(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

exports.grid = [
'.hypergrid-input {',
'	position: absolute;',
'	display: none;',
'	outline: 0;',
'	padding: 0;',
'	border: solid 2px black;',
'	box-sizing: border-box;',
'	box-shadow: white 0 0 1px 1px;',
'	background-color: ivory;',
'	color: black;',
'	font-size: 7pt;',
'	line--height: 0;',
'}',
'div.hypergrid-input > input {',
'	position: absolute;',
'	height: 100%;',
'	right: 20px;',
'	left: 0;',
'	width: 100%;',
'	outline: 0;',
'	padding: 0;',
'',
'	border: 5px solid transparent;',
'	border-right-width: 20px;',
'	border-bottom-width: 0;',
'	border-top-width: 0;',
'	box-sizing: border-box;',
'',
'	font-size: 7pt;',
'	line--height: 0;',
'	color: black;',
'	background-color: transparent;',
'}',
'div.hypergrid-input > span {',
'	position: absolute;',
'	box-sizing: border-box;',
'	width: 20px;',
'	height: 100%;',
'	right: 0;',
'	text-align: center;',
'	font-size: 15px;',
'	line-height: 11px;',
'}',
'div.hypergrid-input span[title] {',
'	color: lightgrey;',
'	cursor: pointer;',
'}',
'div.hypergrid-input span[title]:hover {',
'	color: grey;',
'}',
'div.hypergrid-input span[title]:active, div.hypergrid-input span[title].active {',
'	color: blue;',
'}',
'div.hypergrid-input > span::after {',
'	content: \'\\25BE\';',
'	font-size: 20px;',
'}',
'div.hypergrid-input > div {',
'	position: absolute;',
'	height: 137px;',
'	left: -2px;',
'	right: -2px;',
'	top: 13px;',
'	height: 0;',
'	transition: height .25s;',
'	visibility: hidden;',
'	box-shadow: white 0 0 1px 1px;',
'	box-sizing: border-box;',
'	border: 2px solid black;',
'	background-color: ivory;',
'	-webkit-user-select: none;',
'	-moz-user-select: none;',
'	-ms-user-select: none;',
'}',
'div.hypergrid-input > div > div {',
'	position: absolute;',
'	height: 13px;',
'	width: 100%;',
'	text-align: center;',
'}',
'div.hypergrid-input > div span[title] {',
'	font-weight: bold;',
'	font-size: 10px;',
'	font-family: verdana, geneva, sans-serif;',
'	margin-left: 6px;',
'	margin-right: 6px;',
'}',
'div.hypergrid-input > div span:not([title]) {',
'	font-style: italic;',
'	padding-top: 1px;',
'}',
'div.hypergrid-input > div select {',
'	position: absolute;',
'	border: 0;',
'	outline: 0;',
'	border-top: 2px solid black;',
'	width: 100%;',
'	bottom: 0;',
'	top:14px;',
'	background-color: transparent;',
'}'
].join('\n');

exports['list-dragon-addendum'] = [
'div.dragon-list, li.dragon-pop {',
'	font-family: Roboto, sans-serif;',
'	text-transform: capitalize; }',
'div.dragon-list {',
'	position: absolute;',
'	top: 4%;',
'	left: 4%;',
'	height: 92%;',
'	width: 20%; }',
'div.dragon-list:nth-child(2) { left: 28%; }',
'div.dragon-list:nth-child(3) { left: 52%; }',
'div.dragon-list:nth-child(4) { left: 76%; }',
'div.dragon-list > div, div.dragon-list > ul > li, li.dragon-pop { line-height: 46px; }',
'div.dragon-list > ul { top: 46px; }',
'div.dragon-list > ul > li:not(:last-child)::before, li.dragon-pop::before {',
'	content: \'\\2b24\';',
'	color: #b6b6b6;',
'	font-size: 30px;',
'	margin: 8px 14px 8px 8px; }',
'li.dragon-pop { opacity:.8; }'
].join('\n');

},{}],2:[function(require,module,exports){
'use strict';

exports.CQL = [
'<li>',
'	<label title="${1}">',
'		<a type="button" class="filter-copy"></a>',
'		<div class="filter-tree-remove-button" title="delete conditional"></div>',
'		<strong>%{0}:</strong>',
'		<input name="${1}" class="filter-text-box ${3}" value="%{2}">',
'	</label>',
'	<div class="filter-tree-warn"></div>',
'</li>'
].join('\n');

exports.SQL = [
'<li>',
'	<label title="${1}">',
'		<a type="button" class="filter-copy"></a>',
'		<div class="filter-tree-remove-button" title="delete conditional"></div>',
'		<strong>%{0}:</strong>',
'		<textarea name="${1}" rows="1" class="filter-text-box ${3}">%{2}</textarea>',
'	</label>',
'	<div class="filter-tree-warn"></div>',
'</li>'
].join('\n');

exports.dialog = [
'<div id="hypergrid-dialog">',
'',
'	<style>',
'		#hypergrid-dialog {',
'			position: absolute;',
'			top: 0;',
'			left: 0;',
'			bottom: 0;',
'			right: 0;',
'			background-color: white;',
'			font: 10pt sans-serif;',
'			opacity: 0;',
'			transition: opacity 1s;',
'			box-shadow: rgba(0, 0, 0, 0.298039) 0px 19px 38px, rgba(0, 0, 0, 0.219608) 0px 15px 12px;',
'		}',
'		#hypergrid-dialog.hypergrid-dialog-visible {',
'			opacity: 1;',
'			transition: opacity 1s;',
'		}',
'',
'		#hypergrid-dialog .hypergrid-dialog-control-panel {',
'			position: absolute;',
'			top: 0px;',
'			right: 12px;',
'		}',
'		#hypergrid-dialog .hypergrid-dialog-control-panel a {',
'			color: #999;',
'			font-size: 33px;',
'			transition: text-shadow .35s, color .35s;',
'			text-decoration: none;',
'		}',
'		#hypergrid-dialog .hypergrid-dialog-close:after {',
'			content: \'\\D7\';',
'		}',
'		#hypergrid-dialog .hypergrid-dialog-settings:after {',
'			font-family: Apple Symbols;',
'			content: \'\\2699\';',
'		}',
'		#hypergrid-dialog .hypergrid-dialog-control-panel a:hover {',
'			color: black;',
'			text-shadow: 0 0 6px #337ab7;',
'			transition: text-shadow .35s, color .35s;',
'		}',
'		#hypergrid-dialog .hypergrid-dialog-control-panel a:active {',
'			color: #d00;',
'			transition: color 0s;',
'		}',
'	</style>',
'',
'	<span class="hypergrid-dialog-control-panel">',
'		<a class="hypergrid-dialog-settings" title="(There are no settings for Manage Filters at this time.)"></a>',
'		<a class="hypergrid-dialog-close"></a>',
'	</span>',
'',
'</div>'
].join('\n');

exports.filterTrees = [
'<style>',
'	#hypergrid-dialog > div {',
'		position: absolute;',
'		top: 0;',
'		left: 0;',
'		bottom: 0;',
'		right: 0;',
'	}',
'	#hypergrid-dialog > div:first-of-type {',
'		padding: 1em 1em 1em 0.5em;',
'		margin-left: 50%;',
'	}',
'	#hypergrid-dialog > div:last-of-type {',
'		padding: 1em 0.5em 1em 1em;',
'		margin-right: 50%;',
'	}',
'	#hypergrid-dialog > div > p:first-child {',
'		margin-top: 0;',
'	}',
'	#hypergrid-dialog > div > p > span:first-child {',
'		font-size: larger;',
'		letter-spacing: 2px;',
'		font-weight: bold;',
'		color: #666;',
'		margin-right: 1em;',
'	}',
'	#hypergrid-dialog input, #hypergrid-dialog textarea {',
'		outline: 0;',
'		line-height: initial;',
'	}',
'',
'	.tabz { z-index: 0 }',
'	.tabz > p:first-child, .tabz > section > p:first-child, .tabz > section > div > p:first-child { margin-top: 0 }',
'',
'	#hypergrid-dialog a.more-info { font-size: smaller; }',
'	#hypergrid-dialog a.more-info::after { content: \'(more info)\'; }',
'	#hypergrid-dialog a.more-info.hide-info { color: red; }',
'	#hypergrid-dialog a.more-info.hide-info::after { content: \'(hide info)\'; }',
'	#hypergrid-dialog div.more-info {',
'		border: 1px tan solid;',
'		border-radius: 8px;',
'		padding: 0 8px .2em;',
'		display: none;',
'		background-color: ivory;',
'		box-shadow: 3px 3px 5px #707070;',
'		margin-bottom: 1em;',
'	}',
'	#hypergrid-dialog div.more-info > p { margin: .5em 0; }',
'',
'	#hypergrid-dialog .tabz ul {',
'		padding-left: 1.5em;',
'		list-style-type: circle;',
'		font-weight: bold;',
'	}',
'	#hypergrid-dialog .tabz ul > li > ul {',
'		list-style-type: disc;',
'		font-weight: normal;',
'	}',
'	#hypergrid-dialog .tabz li {',
'		margin: .3em 0;',
'	}',
'	#hypergrid-dialog .tabz li > code {',
'		background: #e0e0e0;',
'		margin: 0 .1em;',
'		padding: 0 5px;',
'		border-radius: 4px;',
'	}',
'',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > div:last-child ol {',
'		padding-left: 1.6em;',
'	}',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > div:last-child ol > li > label {',
'		width: 100%;',
'		font-weight: normal;',
'		display: inline;',
'	}',
'	#hypergrid-dialog .tabz .filter-tree-warn {',
'		color: darkred;',
'		font-size: smaller;',
'		font-style: italic;',
'		line-height: initial;',
'	}',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > textarea,',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > div:last-child textarea,',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > div:last-child input {',
'		display: block;',
'		position: relative;',
'		min-width: 100%;',
'		max-width: 100%;',
'		box-sizing: border-box;',
'		border: 1px solid black;',
'		padding: .4em .7em;',
'		font-family: monospace;',
'		font-size: 9pt;',
'		margin-top: 3px;',
'	}',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > textarea {',
'		height: 96%;',
'	}',
'	#hypergrid-dialog .tabz a.filter-copy {',
'		display: block;',
'		float: right;',
'		font-size: smaller;',
'	}',
'	#hypergrid-dialog .tabz a.filter-copy:before {',
'		content: \'(copy\';',
'	}',
'	#hypergrid-dialog .tabz a.filter-copy:after {',
'		content: \')\';',
'	}',
'	#hypergrid-dialog .tabz a.filter-copy:active {',
'		color: red;',
'	}',
'</style>',
'',
'<div>',
'	<select id="add-column-filter-subexpression" style="float:right; margin-left:1em; margin-right:4em;">',
'		<option value="">New column filter&hellip;</option>',
'	</select>',
'',
'	<p>',
'		<span>Column Filters</span>',
'		<a class="more-info"></a>',
'	</p>',
'	<div class="more-info">',
'		<p>The table filter can be viewed in the Query Builder or as SQL WHERE clause syntax. Both interfaces manipulate the same underlying filter data structure.</p>',
'		<p>All column filters are AND&rsquo;d together. Each grid row is first qualified by the table filter and then successively qualified by each column filter subexpression.</p>',
'	</div>',
'',
'	<div class="tabz" id="columnFiltersPanel">',
'',
'		<header id="columnsQB" class="default-tab">',
'			Query Builder',
'		</header>',
'',
'		<section>',
'		</section>',
'',
'		<header id="columnsSQL" class="tabz-bg2">',
'			SQL',
'		</header>',
'',
'		<section class="filter-expression-syntax tabz-bg2">',
'			<div>',
'				<p>',
'					<span></span>',
'					<a type="button" class="filter-copy" title="The state of the column filters subtree expressed in SQL syntax (all the column filter subexpressions shown below AND&rsquo;d together).">',
'						all</a>',
'				</p>',
'				<ol></ol>',
'			</div>',
'		</section>',
'',
'		<header id="columnsCQL" class="tabz-bg1">',
'			CQL',
'		</header>',
'',
'		<section class="filter-expression-syntax tabz-bg1">',
'			<p>',
'				<em>',
'					<small>Column filter cells accept a simplified, compact, and intuitive syntax, which is however not as flexible or concise as SQL syntax or using the Query Builder.</small>',
'					<a class="more-info"></a>',
'				</em>',
'			</p>',
'			<div class="more-info">',
'				<ul>',
'					<li>',
'						Simple expressions',
'						<ul>',
'							<li>All simple expressions take the form <i>operator literal</i> or <i>operator identifier</i>. The (left side) column is always implied and is the same for all simple expressions in a compound expression. This is because column filters are always tied to a known column.</li>',
'',
'							<li>If the operator is an equals sign (=), it may be omitted.</li>',
'',
'							<li>Besides operators, no other punctuation is permitted, meaning that no quotation marks and no parentheses.</li>',
'',
'							<li>If a literal exactly matches a column name or alias, the operand is not taken literally and instead refers to the value in that column. (There are properties to control what constitutes such a match: Column name, alias, or either; and the case-sensitivity of the match.)</li>',
'',
'							<li>As literals are unquoted, any operator symbol or operator word (including logical operators for compound expressions) terminates a literal.</li>',
'',
'							<li>An important corollary to the above features is that operators may not appear in literals.</li>',
'						</ul>',
'					</li>',
'',
'					<li>',
'						Compound expressions',
'						<ul>',
'							<li>Compound expressions are formed by connecting simple expressions with the logical operators <code>AND</code>, <code>OR</code>, <code>NOR</code>, or <code>NAND</code> ("not and").</li>',
'',
'							<li>However, all logical operators used in a compound column filter expression must be homogeneous. You may not mix the above logical operators in a single column. (If you need to do this, create a table filter expression instead.)</li>',
'						</ul>',
'					</li>',
'',
'					<li>',
'						Hidden logic',
'						<ul>',
'							<li>If the column is also referenced in a table filter expression (on the left side of a simple expression), the column filter is flagged in its grid cell with a special star character. This is just a flag; it is not part of the syntax. <span style="color:red; font-style:italic">Not yet implemented.</span></li>',
'						</ul>',
'					</li>',
'				</ul>',
'			</div>',
'',
'			<div>',
'				<p><span></span></p>',
'				<ol></ol>',
'			</div>',
'		</section>',
'	</div>',
'</div>',
'',
'<div>',
'	<p>',
'		<span>Table Filter</span>',
'		<a class="more-info"></a>',
'	</p>',
'	<div class="more-info">',
'		<p>The table filter can be viewed in the Query Builder or as SQL WHERE clause syntax. Both interfaces manipulate the same underlying filter data structure.</p>',
'		<p>',
'			These filter subexpressions are both required (<code>AND</code>&rsquo;d together), resulting in a subset of <em>qualified rows</em> which have passed through both filters.',
'			It\'s called a <dfn>tree</dfn> because it contains both <dfn>branches</dfn> and <dfn>leaves</dfn>.',
'			The leaves represent <dfn>conditional expressions</dfn> (or simply <dfn>conditionals</dfn>).',
'			The branches, also known as <dfn>subtrees</dfn>, contain leaves and/or other branches and represent subexpressions that group conditionals together.',
'			Grouped conditionals are evaluated together, before conditionals outside the group.',
'		</p>',
'	</div>',
'',
'	<div class="tabz" id="tableFilterPanel">',
'		<header id="tableQB">',
'			Query Builder',
'		</header>',
'',
'		<section>',
'		</section>',
'',
'		<header id="tableSQL" class="tabz-bg2">',
'			SQL',
'		</header>',
'',
'		<section class="filter-expression-syntax tabz-bg2">',
'			<div>',
'				<p>',
'					SQL WHERE clause syntax with certain restrictions.',
'					<a class="more-info"></a>',
'				</p>',
'				<div class="more-info">',
'					<ul>',
'						<li>',
'							Simple expressions',
'							<ul>',
'								<li>All simple expressions must be of the form <i>column operator literal</i> or <i>column operator identifier</i>. That is, the left side must refer to a column (may not be a literal); whereas the right side may be either.</li>',
'',
'								<li>Column names may be quoted with the currently set quote characters (typically double-quotes). If unquoted, they must consist of classic identifier syntax (alphanumerics and underscore, but not beginning with a numeral).</li>',
'',
'								<li>All literals must be quoted strings (using single quotes). (In a future release we expect to support unquoted numeric syntax for columns explicitly typed as numeric.)</li>',
'							</ul>',
'						</li>',
'',
'						<li>',
'							Compound expressions',
'							<ul>',
'								<li>Compound expressions are formed by connecting simple expressions with the logical operators <code>AND</code> or <code>OR</code>.</li>',
'',
'								<li>However, all logical operators at each level in a complex expression (each parenthesized subexpression) must be homogeneous, <i>i.e.,</i> either <code>AND</code> or <code>OR</code> but not a mixture of the two. In other words, there is no implicit operator precedence; grouping of expressions must always be explicitly stated with parentheses.</li>',
'',
'								<li>The unary logical operator <code>NOT</code> is supoorted before parentheses only. While the Query Builder and the Column Filter allow they syntax <code>&hellip; NOT <i>operator</i> &hellip;</code> (where <code><i>operator</i></code> is <code>IN</code>, <code>LIKE</code>, <i>etc.</i>), these must be expressed here with parenthethes: <code>NOT (&hellip; <i>operator</i> &hellip;)</code>.</li>',
'',
'								<li>While the Query Builder and Column Filter syntax support the pseudo-operators <code>NOR</code> and <code>NAND</code>, in SQL these must be expressed as <code>NOT (&hellip; OR &hellip;)</code> and <code>NOT (&hellip; AND &hellip;)</code>, respectively.</li>',
'',
'								<li>The Query Builder and Column Filter syntax also support the pseudo-operators <code>BEGINS abc</code>, <code>ENDS xyz</code>, and <code>CONTAINS def</code>. These are expressed in SQL by <code>LIKE \'abc%\'</code>, <code>LIKE \'%xyz\'</code>, and <code>LIKE \'%def%\'</code>, respectively.</li>',
'							</ul>',
'						</li>',
'					</ul>',
'				</div>',
'			</div>',
'			<div class="filter-tree-warn"></div>',
'			<textarea></textarea>',
'		</section>',
'',
'	</div>',
'</div>'
].join('\n');

},{}],3:[function(require,module,exports){
module.exports = { // This file generated by gulp-imagine-64 at 2:44:56 PM on 6/23/2016
	"Hyperblotter Tabled Reduced Rows": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAtQAAADnCAYAAAA+XMHaAAAMF2lDQ1BJQ0MgUHJvZmlsZQAASImVVwdYU8kWnltSCAktEAEpoTdBepXeBQHpYCMkAUIJIRBU7MiigmsXC1Z0BUTBtQCyVkSxsAjY6wYRFWVdLNhQeZME0HVf+d75vrnz58w5Z/5z7szNDACK9iyBIBNVAiCLnyeMDPRhxickMkligABlQAJugMFi5wq8IyJCAZTR/u/y7ia0hnLNUhLrn+P/VZQ53Fw2AEgExMmcXHYWxEcBwDXZAmEeAIQOqDeYnSeQ4LcQqwohQQCIZAlOlWEtCU6WYWupTXSkL8R+AJCpLJYwFQAFSXxmPjsVxlEQQGzN5/D4EO+C2IOdxuJALIZ4QlZWNsSKVIhNk7+Lk/q3mMljMVms1DEsy0UqZD9eriCTNff/LMf/lqxM0egc+rBR04RBkZKcYd2qMrJDJBhyR07wk8PCIVaB+CKPI7WX4LtpoqCYEft+dq4vrBlgAIACDssvBGJYS5QhyojxHsG2LKHUF9qjYby84OgRnCzMjhyJj+bzM8NCR+IsT+MGj+Id3Fz/qFGbFF5AMMRwpaFHC9Ki42Q80ZZ8XmwYxAoQd+RmRIWM+D4sSPMNG7URiiIlnA0hfpsiDIiU2WDqWbmjeWFWbJZ0LnWIvfLSooNkvlg8Nzc+dJQDh+vnL+OAcbj8mBFuGFxdPpEjvsWCzIgRe2wHNzMwUlZn7FBuftSob1ceXGCyOmCP0lmTI2T8sXeCvIhoGTccB6HAF/gBJhDBlgyyQTrgtfc39MNfspEAwAJCkAq4wHJEM+oRJx3hw2cUKAB/QsQFuWN+PtJRLsiH+i9jWtnTEqRIR/OlHhngCcRZuCbugbvhofDpBZst7oy7jPoxFUdnJfoT/YhBxACi2RgPNmSdCZsQ8P6NLgT2XJidhAt/NIdv8QhPCJ2ER4QbBDHhDogFj6VRRqxm8QqFPzBngilADKMFjGSXDGP2jdrgxpC1A+6Du0P+kDvOwDWBJW4PM/HGPWFuDlD7PUPRGLdvtfxxPgnr7/MZ0SuYKziMsEgeezO+Y1Y/RvH9rkYc2If8aIktx45grdhZ7BJ2AmsATOw01oi1YScleGwlPJauhNHZIqXcMmAc3qiNdY11n/Xnf8zOGmEglL5vkMedkyfZEL7ZgrlCXmpaHtMbfpG5zGA+22oC09baxhEAyfdd9vl4w5B+txHG5W+6nDMAuJRAZeo3HcsAgONPAKC/+6YzeA231xoATnawRcJ8mQ6XPAiAAhThztAAOsAAmMKcbIEj/B/xAv5gMggH0SABzIRVTwNZkPVsMB8sAcWgFKwBG8FWsBPsAVXgIDgMGsAJcBZcAFdAB7gB7sG10QtegAHwDgwhCEJCaAgd0UB0ESPEArFFnBEPxB8JRSKRBCQJSUX4iAiZjyxFSpF1yFZkN1KN/IocR84il5BO5A7SjfQhr5FPKIZSUVVUGzVGJ6LOqDcagkajM9BUNActQIvQVehmtAI9gNajZ9Er6A1UjL5ABzGAyWMMTA+zxJwxXywcS8RSMCG2ECvByrAKrBZrgu/6GibG+rGPOBGn40zcEq7PIDwGZ+M5+EJ8Jb4Vr8Lr8Rb8Gt6ND+BfCTSCFsGC4EoIJsQTUgmzCcWEMsI+wjHCebh3egnviEQig2hCdIJ7M4GYTpxHXEncTqwjniF2EnuIgyQSSYNkQXInhZNYpDxSMWkL6QDpNKmL1Ev6QJYn65JtyQHkRDKfXEguI+8nnyJ3kZ+Sh+SU5IzkXOXC5Thyc+VWy+2Va5K7KtcrN0RRpphQ3CnRlHTKEspmSi3lPOU+5Y28vLy+vIv8VHme/GL5zfKH5C/Kd8t/pKpQzam+1OlUEXUVtZJ6hnqH+oZGoxnTvGiJtDzaKlo17RztIe2DAl3BSiFYgaOwSKFcoV6hS+GlopyikaK34kzFAsUyxSOKVxX7leSUjJV8lVhKC5XKlY4r3VIaVKYr2yiHK2cpr1Ter3xJ+ZkKScVYxV+Fo1KkskflnEoPHaMb0H3pbPpS+l76eXqvKlHVRDVYNV21VPWgarvqgJqKmr1arNoctXK1k2piBsYwZgQzMhmrGYcZNxmfxmmP8x7HHbdiXO24rnHv1cere6lz1UvU69RvqH/SYGr4a2RorNVo0HigiWuaa07VnK25Q/O8Zv941fFu49njS8YfHn9XC9Uy14rUmqe1R6tNa1BbRztQW6C9Rfucdr8OQ8dLJ11ng84pnT5duq6HLk93g+5p3edMNaY3M5O5mdnCHNDT0gvSE+nt1mvXG9I30Y/RL9Sv039gQDFwNkgx2GDQbDBgqGs4xXC+YY3hXSM5I2ejNKNNRq1G741NjOOMlxk3GD8zUTcJNikwqTG5b0oz9TTNMa0wvW5GNHM2yzDbbtZhjpo7mKeZl5tftUAtHC14FtstOicQJrhM4E+omHDLkmrpbZlvWWPZbcWwCrUqtGqwejnRcGLixLUTWyd+tXawzrTea33PRsVmsk2hTZPNa1tzW7Ztue11O5pdgN0iu0a7V/YW9lz7Hfa3HegOUxyWOTQ7fHF0chQ61jr2ORk6JTltc7rlrOoc4bzS+aILwcXHZZHLCZePro6uea6HXf9ys3TLcNvv9mySySTupL2Tetz13Vnuu93FHkyPJI9dHmJPPU+WZ4XnIy8DL47XPq+n3mbe6d4HvF/6WPsIfY75vPd19V3ge8YP8wv0K/Fr91fxj/Hf6v8wQD8gNaAmYCDQIXBe4JkgQlBI0NqgW8Hawezg6uCByU6TF0xuCaGGRIVsDXkUah4qDG2agk6ZPGX9lPthRmH8sIZwEB4cvj78QYRJRE7Eb1OJUyOmlk99EmkTOT+yNYoeNStqf9S7aJ/o1dH3YkxjRDHNsYqx02OrY9/H+cWtixPHT4xfEH8lQTOBl9CYSEqMTdyXODjNf9rGab3THaYXT785w2TGnBmXZmrOzJx5cpbiLNasI0mEpLik/UmfWeGsCtZgcnDytuQBti97E/sFx4uzgdPHdeeu4z5NcU9Zl/Is1T11fWpfmmdaWVo/z5e3lfcqPSh9Z/r7jPCMyozhzLjMuixyVlLWcb4KP4Pfkq2TPSe7U2AhKBaIc1xzNuYMCEOE+3KR3Bm5jXmq8KjTJjIV/STqzvfIL8//MDt29pE5ynP4c9rmms9dMfdpQUDBL/Pweex5zfP15i+Z373Ae8HuhcjC5IXNiwwWFS3qXRy4uGoJZUnGkt8LrQvXFb5dGre0qUi7aHFRz0+BP9UUKxQLi28tc1u2czm+nLe8fYXdii0rvpZwSi6XWpeWlX5eyV55+Webnzf/PLwqZVX7asfVO9YQ1/DX3FzrubZqnfK6gnU966esr9/A3FCy4e3GWRsvldmX7dxE2STaJN4curlxi+GWNVs+b03beqPcp7xum9a2Fdveb+ds79rhtaN2p/bO0p2fdvF23d4duLu+wriibA9xT/6eJ3tj97b+4vxL9T7NfaX7vlTyK8VVkVUt1U7V1fu19q+uQWtENX0Hph/oOOh3sLHWsnZ3HaOu9BA4JDr0/NekX28eDjncfMT5SO1Ro6PbjtGPldQj9XPrBxrSGsSNCY2dxycfb25yazr2m9VvlSf0TpSfVDu5+hTlVNGp4dMFpwfPCM70n00929M8q/neufhz11umtrSfDzl/8ULAhXOt3q2nL7pfPHHJ9dLxy86XG644Xqlvc2g79rvD78faHdvrrzpdbexw6WjqnNR5qsuz6+w1v2sXrgdfv3Ij7EbnzZibt29NvyW+zbn97E7mnVd38+8O3Vt8n3C/5IHSg7KHWg8r/jD7o07sKD7Z7dfd9ijq0b0eds+Lx7mPP/cWPaE9KXuq+7T6me2zE30BfR3Ppz3vfSF4MdRf/Kfyn9temr48+pfXX20D8QO9r4Svhl+vfKPxpvKt/dvmwYjBh++y3g29L/mg8aHqo/PH1k9xn54Ozf5M+rz5i9mXpq8hX+8PZw0PC1hClvQogMGGpqQA8LoSAFoCPDvAexxFQXb/kgoiuzNKEfhPWHZHkwo8uVR6ARCzGIBQeEbZAZsRxFTYS47f0V4AtbMbayOSm2JnK4tFhbcYwofh4TfaAJCaAPgiHB4e2j48/GUvJHsHgDM5snufRIjwjL/LTILa2yjgR/kXHo1sePUmjJ0AAEAASURBVHgB7J0FfFTHE8d/F4cEdw/u0OLu7u4uLdqiLbTQ0qKlFOePtlCgaIEWLVpci7u7BAuSEE/+MxvuuAuX5HK5JHe52Q/h3r23u2/3++69Nzs7M6spXbFFGCQJASEgBISAEBACQkAICAEhYBYBB7NKSSEhIASEgBAQAkJACAgBISAEFAERqOWHIASEgBAQAkJACAgBISAEYkFABOpYwJOiQkAICAEhIASEgBAQAkJABGr5DQgBISAEhIAQEAJCQAgIgVgQEIE6FvCkqBAQAkJACAgBISAEhIAQEIFafgNCQAgIASEgBISAEBACQiAWBJyiK5s5U3o0qFcNGo1GZX367AW27diHwIAgLPttCs6ev4Ip0xZFV40cFwJCQAgIASEgBISAEBACVknAwUGD7FlS48nTN/AnGVebMqZPjoCAYHi/fqfdZfQzWg01C9Tdu7RE8mQeCAsLQ9/e7dGvd0ejlRnbOX7MEPxv5g/qUN48ObB/10qUKlHEWFbZJwSEgBAQAkJACAgBISAE4pWAhoTpYoWyoXCBLChbMjfc3JzV+T2zpkGJYp4oUzIXUqdyj7JN0WqouXRISCg2btmF6zfuIm2aVChpRCBOntwDDetVhbu7O85duILjJ86hQvkSyJ0rO9ySuNKxasifPxecnBxRv25V3L7zAO/e+aFh/epIlSoFfb+PXXsOI18eT6q/KAnvobh77xGOHDsdZQfkoBAQAkJACAgBISAEhIAQMJeAA1lhpEqZVBX3cHdB2RK58eiJN/LmykAWGoCTowNSp/TAS2/fSE8RrYZav2TKlMmRL19O3Lp9X383SfKumPnLaNSrU1Vpsn+e8DXq1KqEd75+8PP3J1V5IN76+OLVq7dKy/3q9VsEh4Rg5Fd90bhRDTg4OGDE8M/RqH41sBZ78BfdULtmJaROndzgPPJFCAgBISAEhIAQEAJCQAhYkgArjk+cvg1//3BTDxaq8+UOF6b5PPcevsTNu0+jPKVJGmoXFycsWThZSemBQcGY/b+lBpUWKZwPnp5Z0avPN7hx8y6Skba6VfN6+Kz/KDx69BSpUqfA/oMn8PjJU3Tr3AJHjp6CI0n7Fcp9itE/TFda6Dykya5WpRz+3XcEb9744IuhY+HrG7W9ikEj5IsQEAJCQAgIASEgBISAEDCDgI9vAI6duoXypfPAxdlRV8P9h964cOUhwkLDdPuMbZikoQ4MDEa33l+hQrW22LZ9H4YO6mlQV9IkbkoLzcI0p4uXrpN2OYVBnohf0qROiSRUbsqkETj072plHuLi6qKyhYSGijAdEZh8FwJCQAgIASEgBISAEIgzAmnTJIczmSbrp1Qp3eFKiuXoUvQ5ItRw4cJV1KhWPsJeKI2zh0dS+Pi8QzIPdwQGfvCQ/Cgz7WAHx6DgYAwaOg5nzl3WZWE7bElCQAgIASEgBISAEBACQiC+CHhmT4dC+TIpaww+ZyjJqWxbrbWpPnbqps4kxFibTNJQawsqM43yJfHihbd2l/q8ffeBCqtXr3ZlckpMiiqVSuHCxevqWEBgIBlzh0v7wSRAh5KzoSN9f/z4GZl2vEWliqVUviqVSqNQwTwG9coXISAEhIAQEAJCQAgIASEQlwScycQjfwSb6QNHrusEaBaqc5HAHVUySaDW2lAf2L0KxYsVxPTZSwzqvH//MebMXY6+n3XEjs2LVVSQhb+tVnn2HTiGQoXy4MfvvsQ9ysdmIZMnfo1MFI5vNpVp3KAGDu9djRHDPkf6dGkM6pUvQkAICAEhIASEgBAQAkIgLgkEBYXg3KX7CCU7aXZAZJtpH19/ZVPNjoqv3rzDjdteUTZBU7pii6itrKMsLgeFgBAQAkJACAgBISAEhIDtE2BLDDb10HdA5Eh0ZKishO2oehhjG+qoKpNjQkAICAEhIASEgBAQAkLAFglw+LyIKZQCZZiSTDL5MKUiySMEhIAQEAJCQAgIASEgBOyRgAjU9njVpc9CQAgIASEgBISAEBACFiMgArXFUEpFQkAICAEhIASEgBAQAvZIQARqe7zq0mchIASEgBAQAkJACAgBixEQgdpiKKUiISAEhIAQEAJCQAgIAXskIAK1PV516bMQEAJCQAgIASEgBISAxQiIQG0xlFKREBACQkAICAEhIASEgD0ScPJ6/Mge+y19FgJCQAgIASEgBISAEBACFiGgcXXLZicrJWoImJ101SI/DalECAgBISAEhIAQEAJCwBQCYvJhCiXJIwSEgBAQAkJACAgBISAEIiEgAnUkYGS3EBACQkAICAEhIASEgBAwhYAI1KZQkjxCQAgIASEgBISAEBACQiASAiJQRwJGdgsBISAEhIAQEAJCQAgIAVMIiEBtCiXJIwSEgBAQAkJACAgBISAEIiEgAnUkYGS3EBACQkAICAEhIASEgBAwhYAI1KZQkjxCQAgIASEgBISAEBACQiASAiJQRwJGdgsBISAEhIAQEAJCQAgIAVMIJKhA7ejsgQzF2pvSTqTKVR1J0uQ1Ka9kEgJCQAgIgYQlkKFwS7gkSZOwjZCzCwELEdA4OCLTJ53g4OBioRrtt5qYyH62RMlsgTpZ5hL4tPsOlOixG3nr/QQHJ7cY99vR1QMZTRWoc1ZD0jR5YnwOKWB/BLKV/wIFmsyhjvPqmECumj8gTb76alv+EwJCIGYEkqTIjuJdtqBEz39RdsBpte1ZdWS0laQjgdoxSepo80mGhCXAws0nXbeZJSjygIkHToktObomQ8HmC+k3v0fJOSzvaOCIDMU7QuMoArWx652+cAslC2qPJc9aCkXbrYZGE/4e1u7nz5jIfvrlrH3bbIHas8oIXN86FKd+q6X6mDZfgwTta+ZPm6Py0B1IXyi8PQnaGDl5ghPgGQ2PDEUSvB3SACFg6wT8Xt/D2aUNcXP7SLy6c1Bt39k30da7Je23AAEeMPHAKbGl7BUH4+2D/3Dq1xq48c/X8Kz2LTQOZotLiQ2P0f68unsIHhk/1Q3MUmavgpc3diEsLMxo/sS408n8ToXByS0VFQ/D/SNz1Kgtf+NZeHbpLzDY4p3+xsU/u6Jwq6UI9PVC0rT58PzKZvBIzyVZRlzd2B8Bbx7ByT2NGsW4pswOfkg/v7yRtIn1kKPScICmWB4enw+vcyujbGbGYg2Qp2Z/0mBnQ766Q0lb7oIn57ZGWUYOJm4Czy79jaxl++Lqpv66jvKUXa5aPyJ55lJ0k4fi6t/9EBLsh6LtVyPw7RMkSeUJrwvrkSpnVTg4J8GltR0RQPtzVB2BlJ5VVT3XN38B3+dXdXXKhhCwVwLGntN8b+VtNB3Bvs/h5JFeoXFJmgb5Gs2EU9K0CHzzEFfo2V+ItH93D/4CP+/b6vl/7o9mCAnys1eUVtdvY89K/zcPkIdmoz3SF0FwwCtc3zIEnlWGqXd7hqJt4XV+tdX1w9wG8e/4Gj3rOfl6XcQLkl2gcSKRxAUFmv5P9fke/X69LqxVs5/ZKw4lgZvklWNzaN+fNIuzGUF0DyRNlw9PTi3Fg+Pz1HtHe2/w++XKxgEIC/FHvobTSWObHD6PT+HGjm8QFhpibrMTtFygz1MEvXtGbPLC99llpMxZGde3DQPPgORrNA1uKT0R5PcC16jf+ql4p424/NdnCAnwQdEOa3FuWVPkbfALnJOkgmuqHPB5dAaOLu5Imr4gHh2bh0enf1fv6BxVv1HX4/HJX/H4zHL9KhNs2+wh1529E5Gzxndqap0FZL+XN/Dixk6kyFERSVPnJmH5IYLfvaQfoYY02UNwYW1npM5bBxfWdMDtPT8gXYEmqtNhQf5K8L6wsg2ylOxJ8N2Rrfwgle/s7w2QqUQ3uLiHP5gjo/Ts8l6cWNgZz67ux/GFncDfJdk3Ad+nFxEaEohkWUrpQPBv6/W9Izi9pB6e0UMvdd7a6lhoUAD93jrh5u7vkTxLCZxd1gjPLrJgXQPu6QrALUU2nKEy9w9NRcYSXXT1yYYQsFcCbOJn7DmdtVw/9bw/t6Ilgny8FB5HMgu4d3gG3UN1SVgIhnva/Hh5czdSZq9As0iF4fP0ggjTVvZDMvasdEuehZQOOXHm93p4dHIxnEjgubN/Ct49v5aohGntpQgJ9leboaGBeHRqMQm/ger7rV2j6X3REemLtFLfWZA+v6IFLv3ZBRmKtgvfRwYi9+k3z8JhWpJ1NA7OyFLmM9zYOgx8b4QEvVP5Mpf+DPcOzcDpxXXg4pGJ7o0Car9t/hcG71t7SflUGa7JMpHo5wD/V3eIU0v4Pb9BfaxNA5MtyFymj0ndY+anF9WEe6ZiuHdwKs4tb460ZFbCLLOW7Y9LJEueW95UmeGYY3JsUiNimMlsDfXbJ2foAVlHwWOt3+1dY/Dm7mFkIhujwOyP8Or2PtUUfoCGBJLmQeNIArY3QkkLEfzuFZxJa8EpJNAXofTDDfJ9Rg/bULA2g3+4ge8fxsHvXtDoLYXKG9l//OMM8A2merjci8iyyX57IkDTTA+PzUX2ysOUlpm7HhLkq2ZIMn3SmTTQ7jQdtUMR4d9fWGiQ+l3yKJu118F+L0mjlgauKXMgedYySuPAmV/fPajKyH9CwJ4JOLmlNPqcdiYttP+re3QPhahnPTMKIa1UzmojAHqRJqEBKr/8vG/9i5w1v1czQbwtyboIGHtW+pOSzPfZJRRpt5YEzF/hSwMht1R5rKvhcdwaVtIE+rJM4kG/4yTqbCyvFG69nLSzz+n3nDR8H2mZA94+fi/7aEi81pDATIpHEjD17w1WPqaoUZ6UPwGqnIbkJFtOL2/tQe5aPxCjZ8o8jLXtSVLnwuv7R1W33j2/rt6npvQxJIBkQxrMhPi9RiCxZQ02zxA4kX17kjS5UajVMrKPCCPGPkp4N6XOuM5jlkDt5JaCjM9/JrONAfAmwTlpmnxInq0MXj84Rp17i7QFm+DapvDpElM7oHF0ph+oKz2kg9TUCY/6+GLwKIc2TK1G8gkBHQE2zQj290aKbOVIM32YtM2FkISmnc6vakcDvw5KYNZljmSDH5beN3fhOtnRSRICQuA9ARqA8jM64nOaFSgODoavlbQFm+HN/eNq2jt/o1mqAv/X9+nl6EbTwlXx+NQSwWplBIw9Kx2c3UjrOpOuryOZfkxR7+V3z29aWcst05xg/1dwS56NFHRPyPQgNZkFkinCH80/qlxpS8sNwOX1PZXSsGCzBR/l0e7gd4ljBIdG3neDfNHeep3VZrPpT9ZIaxxcka5gU5qVmq76wgorJzJx4aRxJLmOBtuxSiQPsjnN+ZWtdJr+WNVnwcKGTz4TKw4JeEPa4HfwrDEaPg9PkADdlKZ+2EmFVP6395OKvw34gWnKaMstZVZkLkFmHTx6875BmuYnNLJ7SNOJX5LGkLTNZDISQHVJEgLmEHhwdB5plzepojyT4ZIiKzLQVB070njf3httlT6PzyqHlAxF2yhzJNZcP738d7TlJIMQSMwEgug+MPac5oFrtgpf4A29F9xSeyoE/L5ISU7rGQPe0uC2DJ6c+UO9VN+QAoZ9agL5OS8pQQmwTW/qvLVII8gzyr7KpyTis9KNTBLy1J+ChycWKHM6bjAr0Jzd05HpTjH4eJ1L0D5Y8uRsbpCD7MMfn16GVJ4V1bsilMxTP0o8ExMcgHSFmtNsZnYSGJ0/yqLdwVrarOUHqHuD7Yw5ed/ZT/fLQHhdXEea29J4eHSOTd8PrAR98+A40hZqAt8nF1QfX17fQbNRYxBCylI2//A6t0rt1/7nT07PGUnBxYNz1vxHl9jiwd/7FnH7kszFLpKZTEEym5miFLDRlY3r445OTinGmHOSlzd2w5kM6flH9OT0UoJ4TFXjxOYZdFO+uneQhGH+FwafJ+dUZ1l97+t1gXeTU8Nbsqu5TrbWD8KnBgnm/SOzqKg/aQR3K1st1ljf2f+TmqpnwdrP+46aijfWXr4YGYvUi8IZ8ePQLcbqkX22T4Cn19iGn51hWUPNjlCsrWY7f//Xd9Vv6+nlDTRF9wL+L++oaSWD3+WL61SDhrQTT/HuxTVysj1I3svF1bTc8yub6LccZPuQpAdCIIYEdM9tuj84GXtOc2QEF/e0SpnCdtL+ZF/79slpNVXLmuvn17aATQd4YOpKvjdsZ/328ekYtkSyW5IAX1eeSncmXyWXpOngSO9dnnmO+Kx88+gk3j29TIOgT2g6fz9eXt+uhG92UOTIaP6v7lqyWQlalz/JGv4vb8MjU3HllPiIHN9YYRhRnvHxOk+zL0fIUbOwMgcMeP2ATGEu0oAxTAmUrIEmgUgNNt7cP6G7N1w8MpAfwR4yjf1XDWKS0hobr+8dovfUtQTttyVOzg7+/N5kx0RObPryjt6/yWjQ9eL6P/Tc2MMode/dtzT4Tkp+FX4vb+IdOYDywIz5+dFzJpgG45xYONdnyc8WNwrnyb/X51c2qne5ypjA/2lc3bJZLKaJR/qiNKobjrsHpsT7aJUF6gxKoN4SCVJ+bFisq5GcQ3YLASEgBIRAdAQ4ikKOysNxY/tXZFeaeASx6Potx+2XQMoclcieODcpZvyR6dPu5MjIzom+9gskEfbcogJ1qpxVVPg8jj1ofUkEauu7JtIiISAE7JEAh9xjJyOe/ZEkBOyBAM+4pyP/Muek6UmruolmAO7ZQ7ftqo8WFaitm5wI1NZ9faR1QkAICAEhIASEgBCwTQJmx6G2ze5Kq4WAEBACQkAICAEhIASEgGUJiEBtWZ5SmxAQAkJACAgBISAEhICdERCB2s4uuHRXCAgBISAEhIAQEAJCwLIERKC2LE+pTQgIASEgBISAEBACQsDOCIhAbWcXXLorBISAEBACQkAICAEhYFkCIlBblqfUJgSEgBAQAkJACAgBIWBnBESgtrMLLt0VAkJACAgBISAEhIAQsCwBTZFmK+1k+UCJQ23Zn47UJgSEgBAQAkJACAgBIcAEnNIVbikkhIAQEAJCQAgIASEgBISAEDCTgJh8mAlOigkBISAEhIAQEAJCQAgIASbgdP/wzHgnERLwBsH0F79JTD7il7ecTQgIASEgBGJEgFVcouYyDVkoZeM/SUIgEgKuybNGciRudmtc3bKJDXXcsJVahYAQEAJCQAiYToCFaUfTs9t1zhDqvQjUdv0TsLbOy1jY2q6ItEcICAEhIASEgBAQAkLApgiIQG1Tl0saKwSEgBAQAkJACAgBIWBtBESgtrYrIu0RAkJACAgBISAEhIAQsCkCIlDb1OWSxgoBISAEhIAQEAJCQAhYGwERqK3tikh7hIAQEAJCQAgIASEgBGyKgAjUNnW5pLFCQAgIASEgBISAEBAC1kZABGpruyLSHiEgBISAEBACQkAICAGbIiACtU1dLmmsEBACQkAICAEhIASEgLUREIHa2q6ItEcICAEhEAMCw4b2x9o1i5A2TeoYlJKsQkAICAEhYEkCjk5OKcZYskLrrYuXHpckBISAEEg8BDw8PLB06UyUKFEM1apVxLNnL3D12k2r6WCO7NkwcsQX8PZ+hcePvaymXVbbEH5NiZrLtMvDazzbyTrPpgGRXAlNQJYeT+grIOcXAkJACJhBoHixQpg1ayKWLFkNHx8f7NlzEMOG9UeFCqUxbtxU7Ni514xaTSvi5uaK1q2a4Ny5izh77pIqlCVLJuTInhU5cvBfNuTO7anakjt3Dnh5PcfFi1dw9+6D93/3cfPmHbXt9fQZuGyN6pWwbdtuPH/x0rRGJMZcLEzL0uOmXVlZetw0TpIr3ghYrUBdr251lCr1CVat/gs3btyOFIgnPbg7dmyFCxcu4e+N2yPNB/DQX4azUQCSQ3ZIILr758H9MySs+aJAwYoJSif8efApNm78B+fOhwtwCdqgBD75wAE9UadOdfTtNxwPHjw2aE3GDOmVYJ0/f278/PMc7D9wxOC4Jb40aVwXa9YsxIsX3rh06RocHR3x8OFjJSTfu/cQd+7cw917D+Dr8w4jRgzE4sWrcJHy5ciRBblzecLTMxuyvxe+M2ZMh1y0L0uWjFi+/E/06j3EEk20zTqsSKB2dXNB21bNcPTYSVy7/vGsR8MGtfBJsSIIDQ3F4SMnsM+E31nqVCnQoX0rpEyRHI8ePcEfq9chwD/Q4Fply5YZbVo1hZurK65cvYF1GzYbHNd9iQeBOixjEBxyBiEsiCSIy0kQ5mvCTDdfw4L+0KQMRegzR2huuAKhulaHbzjTRyE/aNzDEPrYCZo7LjYnngzo3xMpU6aI0LHwr3z/L//jT/XFyckRbds0Q86c2dW7ZNWqv/DE66lBOVe61h07tETmzBnh5+dPsty2KOU+LszvhE8/LQYHB43Ku279ZgQH84/iQ2rZohEKFMgLf/8Ael79jfsPHn44GGGrcaM6KF68CP75Zzf+O3k2wlHTvlqtQH3wwCYSqIuTpmUaxo2fFmlvBn35OSZN+pa0H9dQslStSPOJQB0FGjlktwSiu3+sRaCeNnUs+vbtil69BtODep3dXi+2k164cCoOHz6BadMX0AuE3vSRJBasR5C5BQvWEyfOJKHnPzg5OaiXSyRFTN7NA7FDhzZj5MjxWLpsjcnlIsvYoH5N9O7dWWms+QU8aPB3UfYtsnpsfr8VCNQsSHfp2AbDh/RH9mxZ0KpdD2zeussA7bgxIzB0cF/1W+LBlKOjA0aOnoCZsxca5NP/koWEpV3b/lSCVVBQEJydndVgr3nrbvB956eyflK8MP7ZtAopSOAODgmBs5MTfl28Av2/HKFfVfh2HAvUmk/94FqHBN43YXAgmZiT30pXaLycwr8Y+58EZad2vnDKBIR402RDKiD4ZhiCN3h8EKrdwuDc6R0cU9KuN2Thk0qDoAthCNnqblNCNcto2bNnMaDAv4M09IzatGkHWrfpRc8bR6xZvQgNGtREUFCw+v748VPUrNUSt2/fU2Xd3ZNiw/rFqFKlPN6+9YW7exL4+r5Dw4YdcfzEaYP6tV9mTB+Pzz7rRHUGISQkFEmSuGHDhq3o3KW/TqheRM/JTp1a6c776tVr1KrVmgb2V7XV6D7Tp0uLEye2I0OGdBg0aDTmzf9ddywmG3z7Wl0qVDAfChfOp9rVrFn9KNvXokUDdTxvXk+UJDtCSUJACJhOQO4f01kldE42iVhPL55Jk2bi5ylzohU4WQs0aPAoDBg4El26tIHXk/O4e+ck2O46tqly5XKqHZYQprktW8nUo3mLbqq9V0kruWzpbHr5shpPUnwSyJ8vDy6c2o9Z0yaQYETSoJHEefp+3g3nLlxG7oJlUbBYRTx6/ARDv+yD1KmNl+FqRn8zRJkCDfv6B6RKnxfLV/yJKpXLo1vX9rqzTJsyloSjJGhGQna2XJ/i2IlT6NqlLWrXrKrLEy8bScLgUiUUQafCEDjPHf5z3ZXw61zZP1w3F0kjNEX84JSeBO+lLgha6A6/9U5wyk1a7VwBuhKaUn5wpFvQ71c3BC6gurc4wLkwydKZIh8c6wpb0Ualyo2RPUcJg79Jk2YhLCwMK1asVy1lDXH9+jXwBylBUqXOi+HDfwTPSP00abSuJ40a1gY/T377bSXSpS+Ixo07w8XFBWPGDNfl0d+oXasqevbsQAP64yTQl6ABWimcPHkOTZvWAx/jVKd2NbRv3wLbt+9FxkxF0KPHICRL5oGZM8frV6XbHjiwlxKmdTvM3LBKgZpHKjwFwFqYPHly4hNSwxtLfKxw4fwqn6OjE2rWrGIsm+wTAkLACAG5f4xAsbJdGdKnU4LlpImj6KXQAU2adMax46di1Eq2Ve7VezDZMT8jYdodnTu1jlF5Y5nbtGmKlSs3GDsU632zZv+KtWv/xsoV8ywi/Me6QXZUQUbS0LFNe5sOvbF0ufGZh7JlSpAWMSnmL1yKly+98ZBMN9au24z06dOidMnikdKqWaMKHjx8hN9+/4O0z6GYNnO+mt5v2ayhKpMntyeKFy2EEydPY/uOf8EaxUmTZ8FBo0GLZuGKs0grt/CBsGyB0JBWOvi0W7jWmOThoPMOcMpKwrFr5KajDvlICH8YBs2T8MGg5pYrQllTnTs4vIUkcTnloTy3SC73fm8sf9UNoe9IU53LtgRqY8g7d26tnjP//ntIHW7VqrHSEM+du0RpjufNX0LmGXdQqVJZpEpJKnpKLVs2UnkWL16pvu/ec4AsDq6So3VRpEuXRu3T/69x4zpqRuSXX+bi1es36m/evN/J9MMBhQrlV1lZuKafDQnQC5W2e+WqDTh9+gKZiBRF3jy59KtTMya9e3fEnTv3Dfab88UqBepWrRrh+fOXYEguLs7Ke91Y5/gGTZo0CebPX4onT7zoZVPXWDbZJwSEgBEC5tw/qVOlxG+/Tof3y2vw97uHJ48vUBSHLw1qZ1u4G9ePqeNvXt/E+nWLkS1rZoM8PMV//txe+L27C5+3t/HPtlXKoc0gUxRfWKvB558/bwrVs09tez25gN69OhmU+vqrgXj08Jw6/vrVDSxZPBPcB1tIs8nh8O7dkzh1cieuXbuFTp37qZeHuW0vVrwG2SkXR+vWjc2tQpXLk8dT2ULGpfPgepq+XblynZoKtoRGPVYdtqPCbAddqVpjbNy8PdJef/pJUaWF1LdHvXTpCgkwGmTJbHifaythR1W2m37w4BHevSMtLyWeen9Cg7ycntnV9yyZM5EizY3stUnafJ8uX7lK+d+hUMFwQUm7P64/HVKFAoEaaN6+F3rphKEvaduV5Otkhna6uraQNOWYgr7p+9RSNSGvSADXyoVUhUNyDUJfkLSnTSRHh7HpRzrKbMOpXNmSKFgwLzkW02Do9WvVk6z03Pf19dVFHmIb53PkxJw8eTJlisaZ2JeCr7H+db91644aTOf0zPERkV279uO77yYbmG74+YWbDLH9NSf2yeBt9ufQpv/+O6tMQ9iWWz8NHtRHacTXr9+qv9usbasTqNnbu1ixwjh27BS2/bNHjXa009IRe8ijkJcvX4EB7917RJmJsLmIJCEgBKInYM79M2PGeJpKa44tW3bS9N0P4On50aOH6LSebVo3oQHuFLJrCyH73XFKi1mXnEdWr16oBr/cKraTXLZsjpraZRtcnh7kWalffvkh+kZHyMEakbNnL2Dq1Pn0Qncgn4uRKmIEZ+vXtztNGw7DrVt38dVXP+Kvv7aBNauT9KYbI1RnFV9Z8GCNdI0alRAQEKg4/kZ2pLFNbG/NGp3jx0+rKVFz6+Mp+iVLVppb3ORyLFSPGTOZYmwvBNuDS7IOAmnJFCQ0lEwhAj9oVLUCFCvAokoa0iLqp9ckeLEttX5iTaM23aGoMP7ktOjqSk578Zg0SUMQRn00cCZ8914IdopEQ03CsoYV2h+whLfYTwMH5/dlnEOh4e6+V1hruxTqR8ejMM3W5rPmT9ZG87VbvXqDQTN5oKV/TTm0J+9jKwROKVOSvTwJ2q/p2aRNz569VHnYNjpi2rhpuzJ50xeWa9Wqpuo4r+ewzufgP23idxV/1/+NFi1SkOysW9KM2CZyrr6izWr254dfrtlVWLZgdYqlmjy5h+rg27c+OHr0lDLr4Olp/ZQ5UwZyWixGhuRn8IKmndj7383NTb2Y9fPJthAQAh8TMOf+4amyhg1r4dSp86Qt7Q+emu/ZaxBpAvzQoUMLdRK2RQsODqbIO/0wfcYCfN5nGD1g/6aptiI6+7aGpF3ml+iIEWNVnn79v6KB81MaSBf6uKHR7Nm+fY9qyzffjld2eilSJENxGpBz6tWrIz2k3yrnmJmzFqFrt4G4fPmasuljezprSyxIj/p2CD37flVmbIUKV0aKlHnIvniXRZs6b94ScujpbFadbNdctWp57N5zyKzyMS10iMz+OAQg245bWqjm0H+8IM6ypXPEXjumFyaG+TlcIg/mcpE2OgVpJzlxhIh0abWqW5DpyGMaQPqjGJl9aFPBAvl0A3HtPvm0PgKscW7RoqFSXhw8dEzXQJ6R4BmmYkUL6vZF1BDrDpi5wb+X1q0b4cyZ8zhwMPzcrOFmYTxfvly6WksaMUf69tvBShCf9NNMXb7YbFidQM2jnDdvfHDo8HHVr3Vkm8X2Wjw9rZ8qVSqnpg3Wr9+idh8kkK9evQGbi0gSAkIgagLm3D/8IOSH1NmzF3WVsz0ce0UvXLhMeebnzZtT2aL9d/KMLs8m0iiwZqAsTQlyGj9hOpKnyI0/6d7mxNoJ1sSy+VZM0507D3RFWAPBKRWF5kqZIgWFYMpAodyeGCwowlOF3333k66MNWxoBemNG5eruM6167QGa2HiKt25e19N2efO7RnjU9SpXVXFu44qukiMK42mAAvV3bt/SbMas5E/X+5ockd/mAcFbHK0+LcZ5ABVR5nA1KheMfqCkiNWBHbu3qccv74aNpBMQzJixi/jdLNJXPENsvU/TbNNxUhr+HmvLshFz5t5s38y67kQq4ZK4RgTqFmjMjJlSo9Vq/5Wz3NtBWvWbFT2ziPILJCvOZsH1qplKMtp85rzybLh3LmTaUDspGbytHXwbCRH/xg58ksyN8xCs5Xd0LZtE+1h9Vm+XCmKPlJDherURhwxyGDGF6uaZEhDHsJly5agl2sAundrr7rDRums8eLp6fkLftd1sV27Zir+ZfnypZQNDh9gTRmbi7DZCMdElSQEhIBxAubcPzxVxoIxC7/6adnyteorh1LjEFoc81M/sVmWNrSRdn+Xzm3oYfeFWgREOx3IfhOWSDzLx9OI3BYOq6Sftmzdqf81QbazZs2E5uRkxZEtWLBjzQ7Haa5RsyU96wzbG1cNZP+U3r06Y8TIsTE6BZvYjBw5LkZlLJH56rUbGDDgGwrHtYzst99RCMXh5Jx52uSqWYiuUrksCc9NaMazAHbu3ItRoydhOoUeZE01RxTYQ45U8cXf5IYnoozjJvyCShXKYCjZrPIfOzM+fvKUTEc+PE++GPwttm9ZjRlTw39jF2kankOovaHZaknWS6Bbt7bqvbB58w6DRm74awuZ2jVA8+YNKEb9cWXXfIls5zk29Js3H0w8DArF4MvYH79GyZLF8NNPs3GQon5o085d+8gsbZWKBnL9+hHl9HiBotIUJ3ND/j1x+v774WS77UczrYu0xWL9aVUCNU8lau1pvvqqv65zbBvJ5h08Tf2Ilq9lpyIWvCk6C00tt9TLp6GpZCew2Yg2qLjuoGwIASGgCMT3/cOCOAff1yZ2Wpw3b7LyuuY487xwE9tUm6Oh1tZpS5+9epIgO2IACYg9MX78dNSu0zbeBTn2pB81arASJiMOgCJjyTGwPTySgjXcCZFYqOYZB1aijBo1hGYu3WmABxW7lk0K7tFCMnepbeytz4ve8AqNCxcuV+Gz+EX6778HlaP7WVrdUZs4AgqnjRt3kBKnLRYuWq6+y3+RE2BHQr6f9W1RtREb9O2qI9bwiOIPV67eBA0bhJt8HT32H/bt/kstBqTNy46KJcvWQv16tWjBlwA8ffYcf6/7nZxyb2qzxMtnqA8tyOJAAob+HL77e6fB4A/PMoPGhJDJNfnGKRtp/QNJaX/Q+zJBDgjj8UMEycuB88RevtQ/a7xt58njiYoVy+D8+cu0auqHe4sbwLOP7Tv0oWteSy3awpYE7GPDK7veeh+HmhUuLPdx7HGtHXX69GnULJrWydBYZ9q1bUqma12we/cBjB33y0dZOFwoa6p5ZvW//84oAVo5Kt5/iHJlS1GbSyt58fKlgwZlp08fS7Oun5m1mFmEy2pQb7x/ad26qRpJVK/eHCdPndOdf8jgPpgw4RsKtVIOayicEscsTJ06JX744Rfo276wgfmBA3+T2UdjEah19GRDCBgSMPf+YQ0yPyAzZjR0EONIG97er5W2k82uOM4o29S9efNWnZhXv2LNNtu1cWrZsrHSWH/55ShakSrcNIRXW7NkYqGPV3hk8w/9xFOOBQrkwdCh38doiWsOJ8Y2oKYKn/rnjLgdEhJMz6mjJBROinEIvIh1xeY7h73jEHqmCpHsjLpy5V+xOWWsy7Zu3UtFBzh2/IxuEMIa5hzZs6nZjty5c1K4rWK0SEwnZSrINvTsQKn/PjHWCPYH2LP7T7Jf36ius7E8si+cwBkyy+D7OX/e3GBNIKeCFIWD4w8/fPQoPFMk/7+mZ8KKVevV0e5d25E9dXJs3mY4a+T19DmWLF2l8kz48RsS3h2x9R/L+hFE0rwPu1VED1ohMUUwNE/DxSQV+YMm3/Qjf3woQFv0CAujiB6adCQ8s/zMfogkkHPkj5B773MGUzYKgOGQPhQkf4cnclLUJKPIHzffC93a/Tby2ahhXRpouyvTiciavOX9wkBFaHaoSJECKoa0Vnhmp/FixQqiIGmteVVOTjlz5lBC9+07d41WyT51U2mxryc0w9GbVlbl95KxtGv3frWbrRbKlv2UfGiuqwEcC9ZDhnynfsfacryQIMfrZzOVrVt3a3fH6FN//BWjgpbOzC/gChVKqTAnER9+HMCbp255mppTCwoWzlPIPNrRT+dJpc82lay9ZvMRSUJACHxMwNz7h7VHbEpVmabOC+TPoypuS1EzeJaInQE57dy5TwncHIqIEzuSDRzYU02taWOThoWFKrs6raNxh/YtVQxbVcCC/x0noYsfpJ06tlK15sqVA/37d0dRcpDhkG+8itdntDpfu7bNozwra2B27FhD4eti/1JnHhy9o36DjgkqTHOHV5BArXUmjRLA+4McIWV9ZMtAm1KBBfLwdWOban3TDB7ksPZ6x869mDtvMQ3sxql43T16DFYLxUR8nxhrBtfHi1KwraekqAmwto+nzXt27wiO+MG2sW3JlOYpCcIn3i/ZzIPqIbTQS8XypT+qzIlW0+vQrgUmjh2lFoRZvWbDR3ncyZ9i+JB+GNCvB06fOYe9++PHCVbXkEfOCKMIbE4lWYKmvRSQwrlYKIIfkJQc8F7w5XjUxUklrReXOuSGo1olEVnCTbfCaEEXBxJFQm6+111SkWASnJ09NQhLS9I1pwL+UBrqWyRZ22Di1Qh54LqZIj9FlSrQb4FnIvm5yzGktYlXOGTzvJ49O6pjvDhLkSL5lfM7RwThxM9pXtWXtdhsN/37klnKn6cbOZqz1UJUicM8rlo5nxZ2SabiUnNeXvaeFQkLyPdH+7d//xFVDa9/sipCpJKo6tc/ZjUCdcUKpSmId1oVLk+/gbx98tRZAuClBOUcFLOwSpWyFKf6BU6d/qDF1pbZt++Imj5g8xFJQkAIGBLg6Bbm3j8cdYftZ/mBdurULjx+dI60fzPVctEsjHDiiAw89Tdy5EBame8iTdUeUfZyY8dOxYWL4WGJFixYSgJRMJWdgbdvbpFTyU9K4GbHEu3UsWGrzfv2zbfj6CX/DIsWTVXxss+d/VeF3xo1aqKqsGSJ4ipU36xZ46OMgR0cFK79YE3oQDLTiE1iW90xY342EAhjU19syvK0K68wVqN65Wir4VVo2RnVEhr6aE9mgQwsdK+gONYxSRxNhVfoNcdZMybnsfW8V6/fxOy5v6lB9fVLx3Dp7AE1cP5pyiy10Av3r0HdWpgw9htM+ekHg+7+POl7vHp2A78tmK5iD7ft8Jmyo9bPtHnDcjx9dBljaXnza3Sujl37Ut7w+ML6+eJ0m0LdBe6nFQyLAi59fOHW1xcajzAE7eO4eOFn1hTyh1s9CoNX/EPbwi4kQfATwK1DIJx7+SBJi2AEXacCtMCLNoWdTIIQMu9I0i0ALr2p7ga00AuJMprHtidQVySb+AIFcivlZmR+aw3q16Ln/E1yZl4HT89sarXEvfsOa3FQeOTdYLmtc+dWtGbAeTLT+J1srQMMnMeHDOmDb7/9kt4PKcChWdlummdJVtDiT/funtL9nT71QbNchSwZXnlfx5EjW8h2upCyaFhDM1BxmazG5IPXeZ8wYQYiGrVz51mdzy8hDtbNF2Thwj+UpowNyiMmflnzqCai41TEfPJdCNgjATaBiMn9w/Gd9Z2GODbw1as3Ua9eTaUhYDOQNWv+wkvvVwonawuqkclWazK74qD+fF/v3XvIQBu7fcde1K7dBtVpKW1+KO6jh2vevLmUNpltdL1fhdelf304PN6LF94UBeOy2s0LnYwbN51s407rsrHmjPdp89y8eRdlytRTsad5SWSe5vt74zZls82FeEbrm2/Gq/13yf42ssTmI8WKVyftiTO2bV1B2up9SiMaWf7I9rNQyv3b914TElm++Nw/d94SjBs7khzyDkR52u7d25N2Kdz5NMqMNn6QY6dzDPDWbXrZeE9i33xerZDvuWvXb39U2fc/TsaRo/+hBK08x6Yeh4+cAC8Ko0279uzDmLE/44xeRCA+tnvPfvWsuE/324a/t8LXyDt81dq/cIBCr125eh1btu5Qqypq643Pz7DTSeD3IBgOuQMRRspkzeWk0Pi+105zQ665IcCFZJBLH4RlkGI6eIU7gvP7Q5M6FIHPyBb7Bh3Xt2jz1yBoqTuCOE/yUIQ+doLmDsXZfi+ox2cfY3su1ixPmjSb5LbtkVbFPjKscGFb6b/+3mYQdYkLsRzXtFlX8Gxn9uxZlDCt/5zmPKxsefvWV/lvsMKGn/PGkr5MyHGqJ0+eo0wP+Xd0+3bUvh/83gh/p5wxVrVJ+zSubtls8DKa1LcImfhGsJOuRui5fBUCQsAyBFh7Ofd/P6NBww4x1jLv3LGWYmMPwd17UT/YLdNS02vhWMyDh4ymVeweGy3EmvltW1eieo0WRo8ntp28QiWHY91DTozxnnjO2DHez2qbJ+SJI31B1TZ7Ia2OhkDVKhVoIbE/SHHzN3r0HBRN7oQ97OjklGJMwjYhvs6uN7KMr1PKeYSAEEhUBLxJE88LFXA85v16GrnoOsnOf+yEE5fxpaNrQ2TH31C7WrZoHKkA2aZ1MxVd4yhpJO0h8UqSs2dPpIWC1qvQrPHaZ35NWY0hZrz2POYnY/2Y6Mhizs3GSjRtUhfsb9P7syHKVtuamy8aamu+OtI2ISAErJLAhvVkKkH24qY4vPHCLRs3LkOdum2s1gZ5/76N1L7WRtvH2unOtDImOwTaS2KnWrYxNzUCisW4iIbadJSioTadleSMFwIyFo4XzHISISAEEhOBgV+MpEVBxqo4ztH1a9iw/qTx/NWosBpd2fg6vpbCkbZv9yGmv/a8vFgPh0K0J2Ga+85h9HgRGx4MxUXiMIyShIAQSFwERKBOXNdTeiMEhEA8EGB741mzflUOfVGdjm2u2cM8rr3Lo2qDKcfY4bBLl/Dwgvr5Wai0B2dE/T7zdlyG0RtOA6w7d05i1LdDIp5WvgsBIWDDBESgtuGLJ00XAkIg4QiwkMzLiFetEnmIzik/j6HYxuMSrpEmnpkXrTl79hLKlilhUKJOnWoU33mfwT57+WLpMHoc5WXxbzNoHYUGCiGv7ChJCAiBxENABOrEcy2lJ0JACMQzgQEDRqolbY2ZBtSpXU3F6OYFcWwhzZ27RC2Hrm0rt5/jw+ovoqI9Zi+fvJolh9EzN3GoRY6bu2P7WnTv3gFTpvwP5Ss0hFuS7Fi6bI251Uo5ISAErJCACNRWeFGkSUJACNgGAbYtnjJlDv2NMWgwh5obNWowxc+fbLDfmr/waoO8hDCv5siJzT2W/L7Smpsc5207e+6iisVcg2KmR5dYeC5T+lMVBSZD+nQYPWoI/qXFLHi1zjZtemLAwBGwlcFVdH2V40JACHxMQKJ8fMxE9ggBISAEYkRg+rRxtBLYAV1YPLaTffXqdfxHiYhRqz/O3KRxXZSgFSRnz16klgmu36D9x5nsbA+vqLljx2qsJROfFSvWq97zgCnD+4EHD0LSpEmN/Plzo3XrxvDyekaLC12iBZSWY+u2PTHT8LOKS+JQm/YLkygfpnGSXPFGwCneziQnEgJCQAgkUgKjRk+iaf3VOExLXvOqXg0a1ETtOm1trrc7du6lpeAno2zZT7Fy5Qaba39cNNjJyRHu7klRhWzlHzygdaUpBQQEKMGZt728nuLixau4deuOckCdO3cp5s5bzIckCQEhYEcERENtRxdbuioEhEDcEejQviUWLJhCi6A8Ro8eX+IQCde2lvLny0POiXtIYAxElqyfqFjMttaHuGgvO2s+fPQ40tUkLXZO0VCbjlI01KazkpzxQkA01PGCWU4iBIRAYifw+vVr0k474tKlazYpTPP1YTvqHj0GK7tfXthEUjiBY8dPCQohIASEQJQEREMdJR45KASEgBAwnQBreH3f+ca9JtP0JpmVk22E/f0DzCorhWJBQDTUpsMTDbXprCRnvBAQgTpeMMtJhIAQEAJCQAhEQ0AE6mgA6R0WgVoPhmxaAwGK9MN3sB0kBw0QGmYHHZUuCgEhIASEgE0S4NcxvaokmUCAWYWakE+yCAELEAgJCUNYNDKkU3CQvfwi+SklArUFfldShRAQAkJACAgBISAEhIAeATtRT+v1WDaFgBAQAkJACAgBISAEhIAFCYhAbUGYUpUQEAJCQAgIASEgBISA/REQgdr+rrn0WAgIASEgBISAEBACQsCCBESgtiBMqUoICAEhIASEgBAQAkLA/giIQG1/11x6LASEgA0QyJ3bEwMH9ISHh4cNtFaaKASEgBCwbwKyUqJ9X3/pvRAQAlZKYMrPY1C/fg0lUE+cNMNKWynNEgJCQAgIASYgGmr5HQgBISAEoiBAwfqVprhG9UpR5LL8oYcPH+PAgaNKqLZ87VKjEBACQkAIWJKACNSWpCl1CQEhkOgIlCxRFE2a1MWGDYvBS3LHR0qZIjlKlCiG+g06Yv/+o6hTu1p8nFbOIQSEgBAQAmYSEIHaTHBSTAgIAfsgcPbcRVy9ehMbN+5A716d4qXTAwb0wrx5vyM4OAiLFi3HZ591jpfzykmEgBAQAkLAPAIiUJvHTUoJASFgJwT8/QMwYOBIdO8xCC1aNIxzLTVrpxs0qIkVKzcownfu3kdYWBiyZs1kJ8Slm0JACAgB2yPg6OSUYoztNducFvPS45KEgBAQAuYRCA0NRVhoGCpUKI3jx0+bV4kJpYYN64/duw/g9Jnzuty+Pu/QvHlD7Pn3oG6fPW6w6cvAgT1x9OhJ+AcE2CMC6bMQEAJWSkA01FZ6YaRZQkAIWB8B1hrHpZY6onZaS2Drtl2oWrU82EHSntOoUYPRp09XdO7c2p4xSN/jgACr3PKGhsRBzTGrMhe1wTFmRSS3lRAQgdpKLoQ0QwgkdgK9enYE/9lyYpvmxYtXxZkttb7tdEROGzduR5PGdSPutpvvLZo3wIsX3hg/fjqZxNSym35LR+OHQNewAEx2CEZCz2X3cgjCjwhI8HbED/XEdZZ4FagPH9qCt29uomyZElFS7NSxFfz97mH+vClG8z24fwavvK+jxKfFDI5XrVIBvj53sGzpHIP98kUI2BOBiRO+VfdPv77drarbvcihr2vXdma1adrUsapPnTq2NKu8JQvFlZY6Mu20tu3Llq1F9+7m8dPWYaufLEw3b94Irdv0xthxU/H8+UvkyeMZ6+5079YObVo3iXU9XAEvwDPi6y9QuFB+i9SXUJXUrVMN58/thd+7u/Q+vY39+zYiX97cBs35/LOu6n7k97T+X3T355dffIYnjy+oMrduHkezpvUM6tX/UrxYYXi/vIZnTy/BM0c2/UMW386LEIxwcsTXoU4Ie197BtpaofHHK+dQ3HMKwagwf7hEc2bWLPchwfwiCeY+VO6oQyAahAYalOI6RlBdd6hOrnsjCc/59DTjU+CKJg6OqBGhnEElNvRl6i8/GvxGtL+XRg1rG/SiYoUy2LljLd68voGjR7YZHIv4hctq69H/5PeENuXPlwcsc2p/x/9sW4Uc2bNqD6tPU9tmUCiKL/G2sAs/ZAoWzAtnZ2fUqlUFx46firRZbdqEP+CqV6+IpEmT4N07v4/ycviq4cP7oX2HPh8dkx1CwJ4JNGoU/qBq0aIB/jd3sVWh8PV9Z1XtMacx+lrqWbN/NacKo2W6d++gi+xhLMMTr6d49eo1+EVx9doNY1kS5T6tMN29x5cq6gl3cu3ajWjdqilis+BNxgzpMHfuZMXs4sWruHjpaqz4de7UGmPGDEPfvl2xbNmfFO7wMA4fOQkfH59Y1RufhUt8WhQrVsxT79zvvpuMHDmyqkHc2rWLULlKE7x581Y1J3/+3AgJCcVvv62Al9dzXRPPnbus24640b5dc0yc+A0uXLiCmTP/UZx+/XU67t1rjVOnP/gLaMuNHPklkiRxw9u3ccuPNdKjNcHYHByKaw5J1OlZMJ6PQOTSOKFvQDCyaEIxwsUZbwP8McPBTdvEjz77hAZggqszZgUF4QTV190hDEtdnVCb6jjtEC5ujSRhug/VNTkgCHdpKZB+jhpscCLfjFDgNdX4knTT80JCMNZJg4O0z9Y9BdKmTY3AwEAsWLCcnl9vdMyuXbul2+aZt99/nwX2U/n997X4778zumPGNlKQ4zanNWs2Qr+e//4L921huXHVqvnw9MyGqVPnqcFuz54dqA2/oG69troqTWmbLrMJG/EmUFetWgGuri4KaNOm9TF+wnSjzUuTOhVKl/4UL1++QpYsmZQ2+9+9h4zm5Wk/1nZHJZwbLSg7hUAiJcD3Az9EvL1fo3jxIsiZMztu375nNb198eKF1bQlNg1hLfXOHauxkELacRSQ2CZWEDRpUge163x42Burc968JSSIdMOgwaOMHU50+zq0b0EL29SiCCsfhGnu5I6dezF48OexEqifeD3D06fPsZKu5ZQpY9C4SRedwG4OyJQpk2Pnzn0kpC8BDxyrVClPbexDdQYrJ9Z9+w7j+InT6veSP19uGhTdNOc0cVqmf/+eSojt2nUgNm/Zqc7FQnXNmpVRutQn2L3ngNrHgoi/vz8Jxotw/cYHwSiqxvXr1x1+fv5k/z5ADQivXLmB5cvngM/Zs9cgg6KsreRIN5a4twwqNvIlF2mn6zo5oWYA6abf23sUCA1GDRKMWwUGY4dDuF46c5A/upAWey4JuYY65/BKk9JHP2dHLAoMIAE9CcJo/v8wablPhoWiLWmsT8MJLAZ2oXPNDgzCtPeC+RUSno+7alA+JBD/aMLPtY4+RzuGomJIEPZonI202nZ2pUuXVt0PP/w4xejgiIXfCTSrGkBOxnXrtsXZc5ei7RzPBoWSg/jSpWuwa/f+j/JXpXsvf/486l78dtREddzTMyuqVatIlg1FdQO46Nr2UcXR7Ig3gbply4Z49uwFtm7djfbtm6NY0UI4d/5jcFWrVgQ/mObMWUKxVzuhTp1qMCZQ84PQw8OdtNT90ap1z2i6KYeFgH0QqF27KjQaB9IyrUe/ft3ALyZjAjU/cCrQMQcHDW7cuI116zfTiz9EQWI75+TJk+P06XMqz8aN/+D8hXDNE0+1FaOpWE4XL17B33RMm0qVLI569Wrin392kzBfGJkyZcCjR174Y8U69bDkeMovX3prs6vp3sKFC6gH4wkSNIw9GHWZI2zwFHSbNk1JgNmrBhB58+bC69dv8Mcf6/DS+5Uud9o0qVW+1DRQ5wf2P//s0fVFl8mMDUtrqTm+Ndtmc71RpUOHT2DcuJEqdF98CBtRtSWujw0c0FP9/jp3GfARF+47xwZnswCOE25OKkkL57Bd+tcjxqJvn+5krjEQ48ZPNacqZeZRpUo5A6F83/4jqi4eLFWpXJ6EheoYPXoIMmRIj3z5ctF1nG72+cxqpAmF2IyGtYisRdamQ4eOg58ryZIl0+5C+vTplNaRZ01MSaxRzJs3p3rWaGdXdu7aSzbxL0mBVvyjKr77bqiSF1gxkCNHlo+OW3JHg7BgPAxxIO30B8G1BAnZ/iRdn9UTZv8NdUA3EpjTkiD3SCt56zUkFWlXHUm1vT/MEWHvBfMXlO82mXOke5+PbWx/pQHWX2Eker3P88z2TlWSAABAAElEQVTBAW8RCg8Kjand50Ub/9HzuDVpxvfgQ7v0Tmczm6lSpSCB2s+oMM2d4HdRrlw5aFD7P5OEaS5ToEAemiEhkxmasTOWPvmkqHq3HTx4THd4y5Zd6h7MndtTJ1BH1zZdYRM34kWgZi0Zv4Q5FNTff28jO8o2qFGjklGBunXrxmo0M+d/v5IwXQU8fT3ym/EfdYfNQLZv34t27ZqS0FAa/KKRJATsnUCTJvXAS1b//PMcdOzYgoTJJlj+x58GWH784WsMG9YPQUHhehZXV1fl5NW120CVj22d+YHFwraLiwvu3r2Hy1euYe7/JqvoCiyYcuJy69ZtBpdjYbwUabBGjRqEbt3aKmGa8zg6OpCmrhy6df8Ci379g3ep9L85P6FHj/ZqatmJNDb8x23+fkz4FLw2X2SfLJDwuXr0aIeMGdMrodyJtEdt2zZDterNVHv4Ic02eVmyZFRT1e7uSfHNN1/S82cgNm7aHlnVJu+3lJaaBS6OHBKddlrbsDVrNoHNC1g7HheJXzivSah6TsJOQqWohGltm9jsg7mZK1B3796eBjErVXVz5y3Gpo3LSUAvZPJLXdsOjrwya9ZEMo0w1KJrj7Pwzxp1/uPUpXMb+q1/T1PV1me2U7VaM9VG/f/y0uCV7+/nzz/MLrHSi7XNHdq3RLp0qfH4sRfW/rlJZxKiX563U6VMQc8CR5o5+zDlz6YcT5++oAFGWoPsPGivWLE02OSEB81xnWqQEHyBtMj6WudMmjC8JsH5rVbCpUY8pW1X+kxH2utHesK3tn0PSTAuQII5WXHoEudPSzt2Uv1cFQ/1J2jIZOS9MM0ZC5NA705xPW7qxfYg0RpHSUBvRc80F9Jz6LeNy9hS4t+Kj48vBtBMBG/fu/cQq9f8rRQc3I8SJYqTEgj03nqCYUP7qXfOqVNn8c/2fyPtJs+QBJFZDVs+1KtXQylT2PzD6+kzVSZXruzKJIktHbSJHZo5pSElizZF1zZtPlM/9S69qUVinq9ypXI0unXHn3TDHT7ynxp5NmtW/6OKUqZIoW4kHh2zVo1HFDx9HZkTI9vGBAQEgm2tJAkBeyfwCZl4sKC5d+9hsObo5MlzynyKzai0qWiRQhTHtxfOnr1Imp+SyJa9BC5duobGjeuQk1dObTalAV269E+UK9cAmzfvQvNmDUhAb6Xq5jL8t23bbiXQdOzQSleON1irlDdfOeTOXYaE8Qc0ZV8TmUjo1aZPPylCdbXE4cP/IVPmYihYqBI9TB+p1QAzpDd8uWrLRPbpQM47pUrVQeYsxVR9n1Dd5cqWUtknThhFL+t0ZCIxAukzFEbJkrXVQ/y774ZFVl2M9utrqWNUMEJmU7XT2mIrV66LM0GDF4+5eGE//XZ2YjjFw2bBvQ5pJ1mbyw492rB9PAjgdrMAaulkijDN59xHS7Kzn405iaeMeUr45KlzuuJ9+w3H7NkTY7xwz6hvB5G95gbcvXdfV1dUG0uXrUGGjIWxhgYE1p54lql27SrKTvXosf90zWXNXubMGTFjxlga2A6mGeVJ+JPsrHnQaix5kyaRNYoRhWe2mdVPPCjmQe+DB4/JPjt8sKN/3NLbbA2dmwTZSyQ866dwS2r9PSCNdcxTdXIszExKhXV6mm6uhSkNI1vq8VTrUmcHTCMb4zPvbay1Z7lOau6s9HxLrXOT1B6xnU++nsmSeSgFzZQp36vfyoIFU7CU7KX5GKdChfKqhasmTBiJMWOGK0XJ+vWLMYTMpSJL6ek9waYi48ePVHXyAHX37nXITL9XTm5ufGUNk1YRpN1rStu0eU39jBeBulWrRjSCeItDh46pEeyxY6dQtGhBgxc4N7h8+ZJImzaNmobj77t27VejWp5uMpZYa8bOHzxKYaFdkhCwZwLVqoX7KbCJBideKptH4GxGpU1+/n7kGDSDpp4n4RWZSLCTETtksSY6Pdm6aRPbgE6bPg9nzl6gfK+VAMcvv/Hjp6kyXG7SpFmkuQpWQrW2HH/OnLmATD2eKKH+1Knz9JJNgmzZPkzburi4kvbbgV6wwaoYa9QHDfpOtUlrdqJfX1TbPON16fI11aYtZPPJD0kWojmVKfOJ0tYvXrJCfb9y9QY5ih0jG1FXJQyonbH8L7YRP7Taaa7H1MTX7Sr1hYVcSyeedWDBh53L2KRHQ6qjkiU/QWuKhDFq1BDS4i7Fv3vW48D+jaSVnUBOQYt0QnZs2sKzjCvJGW7c2JF0vuIwZuYRsX4e0PACO2zWFNPUvl0z5dioX46FuFmzfsWY77/S3x3lNit7ChfOjwULl0WZz1YPjvl+OL2TU2PatLlKS63tByu7tm3bQ4PhisiTtxz4Pq9CU/fNyD/KWGJzrOvXbyufDm10rupkz5o/fy6D7O3aNgdP10+fvlA9dwwOxsGXpCSspqaZuNdaGw0LniMl1T2JHAv/JE3qFT3tM5+CLaUrkTNiCxKinUk7e09fZf2+DawRZ8E+pV4EkPeHbObD3d2dFDI7lTI1Z67SJPdVU4MzVuDUIxMoTmnSpFHvA1YEsWKkWPHqyodu6NC+NPuRxmhfWTY8cOAYmYQ1omd5MbqXN6moP6wsMjWZ0jZT69Lmi3OBmoGUKfOp0og9fvJUnffPPzerkWylioYPwpYtG6sXNDtvcGIHjidUhqexI0szZy2kqSc/fPvt4MiyyH4hYBcEePqbp7UOHQo3fzpw4IhyHGIzKm1ie+nJP89WD7CvvxqIUd8OUQIBC04cgUebWHgOeW9TzfuyZs2s7rP79x9psygbVha8tQKs9gAvk61NLHCzTXeSJB90PidPnSFN9yFUrlwOly7uV6HGjh07qUxCXujZWGvriOqTHVO0SRtBhAVmDrPFPhasLddPbdr2QuEiVZTAr7/f3O3Yaqljqp3WtnPhwuXKOVH73VKfLNA2aNCBbIE7YSvNQLA2lSNpjBg5Dr0/G4L6Ddqjeo0WNKPRWb3EWKDt26dLrE/fnpwPm1NovIwZ0ynzoOhsybUn3LBhqyqn/W7qJ5sSGBvEsNaYnZfYrjO6xFruSZNGYfCQ0dFltcnjPXt0UDNJbFq5bLmh2diQod+heYtuNJN8n7TJj9RgmJ8ZTaMIgzdrFg++nOh3s0iZj/FgjCOFaAfRyZMnw9dkx37nzj26NuvihRkLQPwXbihguVOy7vUnis+RhJ6r35H4/OEpFX4ONkRoFuqKQhSm7ztyUJxKUT9KhwYZNODdeyHb9aPSBtms+gsPpD7vMwydOvdXZkHswDqGzPr4fcP+NtoUFBRMip6ZSjHC7yhWjqROnRKlaDBvLP08ZQ6ZyHF0mHPKZ+aHH39WpsJ16lQzlt3oPlPbZrRwJDvjXKCuXKk82CGB7Si18QKXLp2lmtOmTTNds1h9X7VqOdKUOZNAsFnl5fiTPK3E09g8nW0ssWnI8uXrUKlSaWWXbSyP7BMCiZ0Am2uwpoy1SU+enFf3z6lTu5Qgy/aIbE7FiTW4q1bOJ+31UuW0WK1aeZOmuPkBGDGx5lr7Mox4LKrvXKZV614YMuR75cXPocYuXz6Ibl2jjnARVZ0JecxcLbU52mltP9lumKMvcOxqS6UWFOfZiyJfaJ3poqqXTYo6d+lP0TcGKfv7jORoF5vEEZ1++OEX0oJPilE1hw4fR9myJWKkJWfN/t279yMNZzdgwEh8T5pZFpijSuPGjiCN9m/KPCGqfLZ4jMPcsvMrm2z17/91tF24dfuu8oeIOLjWL8iDlaFDxyizKw6dy05obOOqdVRm23J2XOTZrS8G9laDffaP4OhgA8hBlZ2e4yoljfB4e2fkRBS3w8he47u6UCzqVs4u6BUUhsdGtM/aUlzjSrKpfkyDkRoaMpbWSw4xOJ9eMavfvHnzDtk/UyhCuuc5sQKG//RNMnigzu+cNGlSmtSfGzfuqNj0LIRziizUcnSVRWxbdPkjHo9zgbpt2ybKeHzq1PnKyYAdDfjv+vVbZIxeVGdbWb5cKRKeMykvfG0e/ly2bJ164fN0dmRpxowFyuidNRyShIA9EqhZo7Ka9VmxYoPBfbZp0w5lRsXmVJwaNqittEhsKpU7TxnUqt1a2VpHx4wdq9ipiE1DtImd/jhOLD8cY5r44ckxsllb3IUEMzYzYDs4fTvumNapn58jFXCd+lp3Pp6NNO0sLGjt9/TLmLvN2tT167fEaPVEbgNHljAlskdk7Vq8eDU5wnWI7HCM9nM0lGHD+mIUmQLFJHHfx4z5mbRL5ofx44VVrlEIOdaEmxo1Qr+Ne/YcJI2y6SZ/7IzIGv7IEjtjTiEN2PRpP0aWBXy/pU2bCus3bI40j60eSJ0qJf0uZyjl1uefD8UjcjjUTwUL5FXCrr6Sy4Vmt/j5wI6KUaX5C35HocKVlY/Fbgp3xjPYp09fUEV4nQqO3pWPQgpyhC/+Y1tt1mq3bduUFAYFoqrarGMcycOPhLmUerNqXNF9MgFJRWZpyfWEWjYkY3fsZxFsnTm/fvqEnBYnuDhhItlF74/gvJiJ6htHttP6S5yzXtqfzs8OjPqJh8oscL+OYC6in8fat/k3wrOg/JvRJldXNzVD6uvrq3bx4Jad17XCMO9MSU6snPi9EzFlISXrN+Q3F3FhGH7Ws08dJxaMuU5WMGkTR3rixJFlOJnSNpUxBv/FqUDNWrHy5Uvh1q17+Obb8Wqqmaeb+e+PP9Yr+87KFE6IE6vqWQn2v/8tNsg3YeI0JSzzdHZk6e69B8qBgTXZDFGSELA3AhzbnUflkyfPMrh/+H7ixzKbU3FiJyMe+R84cFSnXWbTiOgShx/iWSSOR6tNHLKMTTlOnjyr3WXSZ/9+PWk1rJvk8NZK5V9D9m8cAShp0qTgh6UlEmvPOWQfR/jQtw1fvXohhdpbAw/3qLWPMW0DR9zo3Ll1tNp+1ihP+XmMcvrr3bujUbMDU8/NwhzbIloicZSKkWTWYc4iJLwOAA+Q2A46pol5DBr0Oa1+OC2mRXX5eTDDNt6mJJ4V4JCO0a1dwOYu/DJvQA61ERO3+fvvh5HWdGTEQ4niO2umixQpSP4SM3CQQuZFTOGmGf1J29xPd4jf88z2lJ6Tp+6gkQ221R8x4gslWLFDJ6f+A0Yge44SBn+XL19XU/mVKzfB70tXG6kpdrv8qPhDisCRPYLYcIZiRrPqQN8MoyaFsLtNg/TnUWic2W56kVMoDpB/yEzSPEfUafP3z0kpUV/zwbwjI4Xoy0KDkescuFovcaSR5yRoe5Ngb6spffo05GT6BXpSKFZtqly5rFJosN09p+0UzYN9apqR47s2ceQOFo5ZMI6Y+L5kW2l2htUqRtiPgqPNsLkIpzNnzqtFYmrXrqa+83/8rNSv05S26QqbuOFkYj6zslWoUEppxzZs2PZReX5B89Qv23fyi4GDuPP0z/HjZwzysknH1au31HQ2a6+0wAwy0ZfZc36jcFhtaYogfBQS8bh8FwKJlQB7NvNsz82bd8GOd/rpPxJ2Of47m1OxQHz//kP1oBkxYqASrsuVK0mxOavRlJt+qY+3Fy9ZqcLc/fjjVypMHWuiBgzoQc7Gr2kQ/NvHBaLYc+jQUTVrxcH8OSYvaxZq1qxC7XyO8+cvR1EyZocWLfoDv/wyhmw2f6W/jcoRmqOALCd7UBa4s2fPgn17/yY7a2+yC26pQi/F7AwfcvNDnpcGZ23MpJ9mKcGUI2IUJg92jvddgswM8uQJj/HL2nPl9DltPj0DP7xYP9Rm2hafk6dGa1SvjD3/HjCtkJFcMTH1MFJc7RpFiyewbSyH/otJnyZNGq003OYI8tq2sPkLr9zHAh0ziSq1btWEYrSHC3BR5eNjI0aOx47tqxVj/RCC06ePI/OUKcqpN7o6bO04L8XOYW21JjGf9e6s6wKHzVtPNus8GNlPEVaaN6+PmTPGq4HroEG9leJryZJVKj87nPGKi3/9tQ09eg7S1VGL7nN+5rRs2UitnPzrryuwc9c+3fH43mAji9MkUBciPw+SX3UC8HWKrrE7KACTyUTOIzgQmUiY7kTmqGNoxcPA9/JtRbJ5XkhOhwOCw7CHNNFau+kcji6YQPnKwfDe/o/ycHzptVTvCHrmhQX64yF9/4LqeErh9ra8X0BGy+ATahAv+vLWhjXUPCDjGQiebWB/mnBhuKd6J3HoPE4cTpKdoHv2bK9im3NgiorkX7djx16cPhM+e3Hu7F4l21Wo0JCi6TxQ6yz0798dSxbPovvzFJkl9VCKojkkB3Li8/LCQR06NFPPd55JrV69klIkaVflNKVtqrIY/BenAjVrxVjr/O+/hz5qEhuTe5EdHo9s69WtAU/P7DhCIfX4RRcxbd++hzy/i6pptsgEara74hfo118PiFhcvguBRE2gWrVKarZn9erwB5R+ZznWK4fPq0svODar2rJ1F5lW/I8eQN1JKBhOtsvXSBDapKZUM2fOoF/UYJs1BeyINmfORFpMKVwzxeH2Bg78BtfIfCsm6QyF7OvQoQ9p07/H2LFfK/s5bV36i7LEpE5jedmkhEM2ffllb5rC/15NR/9KsbC1K2clodBKLISxt7cmCq2TsbqN7bt1664yW2FNCD+PuG5mz5qYST/NNNC2sH1udMKfsXNE3Ldw0TIVGcNcgVpr6lGHViiLTWKBkxcTYgdFU5djZ8c/ZqSNzxyb8+/YsY/C+1WLNr54ly5tSInT06RTsZA/fPgYFWO6fYfPVRkefPCASLtioEkV2VCmGmTKwqYbvHbEzJnjDVp+5sxFJVDzzp49B9NAOjyWPOfn9/Lgwd/pngVubkmUyQhrs/VTQ4ox/dlnndXAftiwHzBv/hL9wwmyvZUWbPmNFmxJRYIxL/vNiQXtz0lH/RPZQs8mG25f0jj8Qs6D8/WWHU9KAm9amhFPSkuMc2KTjRqOTiok3jJabjxiKhgQinukiR0GN3gH+2M4CejJSUDaToPqXiEUaURPEe1MhctR3pXktBka3qSI1dnEd5415Wf9/PlT6F3RU2miOapU375fqQhM3AlWLrRr/xl+XzJL5WHnVg7J2q/f17o+sm8dWx9wtDhO333/k/p9daJZTo4i9/jxU3zxxShso4W7OPF527X7nGTCaer5zzbaHBXks8+GquPaPNG1TZfZxA2Nq1u2aHRTJtZk9dn4V2knXbX6ayENFAKJjwCbwGzcuExpqnnFPUsIzKZQ2rB+CQl9i0hLfdCU7AZ5Vq6YD17O3BRHRIOCRr6wRp7D6vECJ9HZQrMgvXPHGtJydrfIAjIc1YXtuLWCr5HmKdt5Xq68V+8hxg5Huu8n0qL7+QXQS36XiurBS5THRqMe6YnkQIIQSEpnPeoYhLFBoVjrwGJxwqciZIe9w0WDMsEaPNBfKSbhmxbvLWCTvXPn9qoFYcqUrRvv54/JCfXGRDEpJnmFgBAQAkJAn4CKvOFZghz7JsabMM3nZzvxrVtXYPCgPmRTyLot0xJrW+/R9KklhGk+Y0wcFIcN7U+OgX9YRJjmc98hxyaOuR5VZI7eZL4QlTMi12Ms8fLkI0YMwJ496+jTPDtzY/XKPusgwBE9ppKWuR+ZXnxwuU64trHqr59DMJZQ/Gp7F6b5KvDKvcmTe5DSYGHCXRQTzywCtYmgJJsQEAJCwBoJ7NlzSJmVcMiyPbv/RJPG0Wtx2NRj4MAeJi/1bmq/TXFQzJ8vj1oRl2NcWzJtJXOmyPrOGnG2Y4/OGdFYe+7SCohstsMDAHPKG6tT9lkXgRUaVzLrIOGNTDwS2sKiWlggypIN9xRqkySoGb/evYd+FAvdGtmIyYc1XhVpkxAQAkLADAIcgYI94DnuP6/6t3HTdqO1LFs6h5bZ/jVOBEQW1qNyUNy5Y62KkHH1mqEDrdGGxmAnx8JeuHCqWpQmYjFeQp2dnXj1T0lCwBiBjGQS2o9C2n2viUnEaWM1xW7fEGrD9jBnXCShWpJtERANtW1dL2mtEBACQiBSArws+dhxU8nxrpeKLrJ/30blrKdfgE092GkyrrSt+g6K+uflbV4ZkuNGW1qY5rrD7bbJUYwE+oipQ4cWpOmyrEY84jnku20TeEK66e8SWJhmglMp3J4I07b5WxINtW1eN2m1EBACQiBaAqy1HTasvworx+GlOG5rFYquwUuIx6XTpDEHxaxZM4GdIDlEYUxC60XbSb0MPWihG44GwHHBtYlNTDhmLa/sKEkICAEhEFcERKCOK7JSrxAQAkLASgiwMHv1ymEVEq1q1WZxpp3W727ZMiXQp083Wp78C7Wbhenp0+fH6bnZKXHtmoVqwKBty6SJo1WEDks5X2rrlU8hIASEgD4BMfnQpyHbQkAICIFESODBg8fo3XsYrYY4Pk4FWn10WgfFviRU8/LiXl7P4vzcHM7Ox8cXPIDgxM6IZct+arFIJvr9k20hIASEgD4BRyenFGP0dyTe7YT23U28ZKVnQkAIWD+B8xcu4+jRk/HaUF4g5JdffkAZ0lZ3oMVR/GmJ8rhOIRQCjc1aDh8+gRbNG6pFH44e/S+uTyv1CwEhYOcERENt5z8A6b4QEAJCIK4InDt3iRZluITx46fH21LdW7ftRIMGNVWXundvL86IcXVxpV4hIAQMCIgNtQEO+SIEhIAQEAK2TmDb1pU4S0vc56AVFKNaPdHW+yntFwJCwHoIfLzgvPW0TVoiBISAEBACQiDGBHgRl+rVK6Jp0y4xLisFhIAQEALmEBAbanOoSRkhIASEgBCwWgJPvZ4jICAQP0+ZY7VtlIYJASGQuAiIyUfiup7SGyEgBISAECACHOEjLmNtC2QhIASEgD4BcUrUpyHbQkAICAEhkCgIiDCdKC6jdEII2AwBWtDKTmRqBwqbFxpmMxdGGioEhIAQEAJCQAgIASGQ8ARCQsIQFo0M6RQcFJrwLY2XFnAcahGo4wW1nEQICAEhIASEgBAQAnZEwE7U03Z0RaWrQkAICAEhIASEgBAQAvFKQATqeMUtJxMCQkAICAEhIASEgBBIbAREoE5sV1T6IwSEgBAQAkJACAgBIRCvBESgjlfccjIhIASEgBCwNQIeHh621mRprxAQAvFMQBZ2iWfgcjohIASEgBCwHQJ58nji6pVDaFC/FoKDQ5A2TWpky5aZljXPCidnJyRP5oGUKZIjbdrUmPrLDwgKDML1G7dtp4PSUiEgBCxCQJYetwhGqUQICAEhIAQSIwFXF1e4urpCo9Gov7JlS8LR0VF1NWvWjLQd/hotWbIYChXKh7JlS2Drtt2JEYX0SQgIgSgIiEAdBRw5JASEgBCwJwK0MAEWLpiCu3cfYMwPP9tT1yPta4MGtTB8+I+YNXtRpHn4AGupO3dujYoVy6BsmRI4dvxUlPnloBAQAomLgCw9nriup/RGCAgBIWA2ATZvuHB+P0JCQrBjxz4sXLjMrrWtbN6xdu0i1K7Tlsw9gkziWrJEMXTv3h4DBo40Kb9kEgJCIHEQEKfExHEdpRdCQAgIgVgTqF+vJpYsWY06ddpg4BcjUaFCGezf9zcGDuipNLCxPoGNVTBq1BBMnDjTZGGau3fy1DkULpwfbm6uNtZbaa4QEAKxISACdWzoSVkhIASEQCIhULxYIbB5w4CB3+DQ4RN48OAxRo2eiDp128DX1w8bNizBtKljkT9f7kTS46i7kTu3p3I83LFzb9QZjRzduHEHmjSua+SI7BICQiCxEhCTj8R6ZaVfQkAICAETCXBYuE0bl6Jzl/5KkI6sWMUKpTFgQC94eCRFGjKH2Lp1N8aNnxpZdpvev3bNIowZ8zMuXroa435kzJAec+dORvMW3WJcVgoIASFgmwREQ22b101aLQSEgBCwGIHp037EtGnzoxSm+WSsuW7f4XMsW7YWJUoUxYgRA9GieQOLtcNaKqpSuTxevPA2S5jmPjzxeqq6kjVrJmvpkrQjGgIaOp43NCSaXHF/OBe1ITyGTNyfS85gWQIiUFuWp9QWBwSGDO6LXj07xkHNUqUQEAJtWjeBj887bNy03WQYa9ZuRN26bVH8k+ro27d7ohOqf/hhuNJOmwzESMbFi1eic6c2Ro7ILmsk0DUsAJMdgsGCdUKmXg5B+BEBCd6OhGRgq+eOd4H69yWz4e93D61aNo6SWaOGteH37i7Wr1tsNN/RI9tUPVyX9u+p10X8PPl7JE+ezGgZ2ZnwBIoVLYRX3tdx5vQekxszZMjn6NWrk8n5rT1j5kwZwL/VmzeOIWnSJAna3H+2rdbdP9r76MXzK5j7v8lqAYsEbZzeydl2l9vXqWNLvb2yGVsCObJnQ58+3TBi5NgYV7Vv/xHcvHmHzBq6o3fvzmBzkMSQOndqjT17Duq0zOb2aeu2Pahfv4a5xeO0XNMm9XDi+Hb0+bzrR+fJny8PDh/aot6/vj638c+2VciRPetH+bJlzYIli2fi2dNL6s8zR7aP8mh3VK1SAb4+dz561mifOcbu6+LFCsP75bVo69aeIzafeRGCEU6O+DrUCWF6FbFwXSc0EJscApHW4IhepgibjSn/GRKKfZxDsZ/KVQ41jA7DdXYMDcBlEt7fUp4dmkB8qpdnClzRxMERNaiexJa2blmhfgPGfnfcV5bdzp/bp/KwDGgsGXtnaX9HVy4f0hUpXeoTnD61W/2O+Xc0aeJoONE11k+tWzXGtatHVB6ft5H/1vXLRLUdr3Gok9GKUlWqlFXtadOmCf5ctynStjVv3vB9EP0SSJ0qJV56v/oob0BAIObMWYxXr16rvM2a1cfAgT2RIUM6dOk64KP8siPhCdSoUUl5v+fKlQOlShbHfyfPJnyj4rkFlSuXUw8ODw93lC9XCrv3HIhxC/ihUrJkUZQuXRd37t6PcXn9AiEhoZg373d4eT2j3RrSPFajsF/tkD17FjRsFLuZAX7JnjixHSdPnke9+m31T2vX24UL5cfVa7diFD3C0sBUzOmFU0nD/BX8/QPMrt7Hxwet2/TGyhXzMGnSDGUWYnZlCVyQI3P07dsNNWq2iHVLOMze8eOnaaBRhpgcj3V9lqiAzXNGjvwSRYsWNFodD/BXrZoPT89smDp1HtnKe6Bnzw5YsOAX1K334f7lgdiePeuQMWM6/PPPvzhw4Bi86T0cWbp+4xYGDRql3tP6ebp2bavaco3uhYiJ25kkiRvevvWJeMii31nAHa0JxubgUFxzCFdw/L+9q4CP6njCkxCk/ZfiToGW4hR3dye4e5EiRYJLgFC0QAst7h7cCykOoVhxdyguxQstEvnPN8m73F3uLneXy+VCdn6Ee7K7b9/3bHb2mxlYGiuzQjuINaTCnA3zZTCr2UERH/aboABaED8Orf8QQMMCgqm1ezAtj+dORbjt+xRivyzFyvO0+HFpwYf3tC/AnTqzjrcirhsVZbYJtJxn/A6eyWErR3q40R98TPufzIj768wSlSqWYf2vmMVDtm7VmLJk+dJimSlT5tK6db8ZlEmXLg316dOZzp27JNvTpk3N4S7nyf0zYcJ0KlWqKN9/HenVq39ozNjJUqZc2RI0b94kevz4KQ0ePIYj82Sn5s3r09Kl06l8hXqSFdXgIFasOFWhLl6soCi7z569oOLFC3EYpkT04mX4hxAPdblyxQnlkiZNTFBANm76PdzpvH//nh/0xTqFAjFTDx7cQrVrVyF8sOxxJgl3ELXBoQhg0IOb+n//+5Qq8gMWGxXqJk3q0r///iej5docCcAehdqRFwUxhxcuXEFnz12UZqdNn0d796ynsmWLU4nihengoaOOPFysbQsKbLasX4nC1qFDC5o8eY5dlmFHAThq5EBWntazYn8t0k1CqW7WvHOMV6p79fxOBpeRGWDogwmuORR0V1CoMbidNWuifFfXrt1KDRrU0O+qLJctU5yyZfuaHSoX0hDvsbItU6b0/D0uSQXyf0MnTp6VbSNHDhBlumdPb5o7b1m4dow33L//kObMXWqwGd//wYN70qVLV+nPoycN9mEQUqNGxUgN9AwatLDyFVunq3p4UMV3rDRDu2ZJHxREK+N7kC8rvccC31HzuPFCdkTwfzu2Ot8KjEPd2cr8lvXnP9iqfYo18QbBH2iKW0gYxU5xgug4K9v9KAGxPk3Hg4PoBP9W+/COVriHlFnrFo+GcrmSgR9ot1vcCI7q+rthGR4+vK8oqR6MtSlBzHcvr+/kmlsKObll645w1fv26SrZS/G8QUBjw2CvX78RnJBpHqVMkZyOHdvOM2ktJEETBmm9e3eWAV6bNt11z2eOHFkob95clD/fN3T02Klwx4log+kzi6iWnfs9PasTlGBf33XUrVs7HjUUod+2hAcHH/E0PC0+deoCHh03o/r1a5lUqI27ASv23r0HqW3bJvTllxmUQm0MUDSvf/31l2KN2LJlJxXjwVWdOtXox/FTwvUKL3XEvw1mq8DOnfsM9tevV4uyZ/+anaJW0Z2792UfRr7F2NK7evVGVg6uy7a63DZGnEFBwXTy5Bn6fdseXTvgY3/++efMGf2d6tapTvHixaPDh4/R7j1/6MpgAR+QSpXKyv4nT57RqlUbDGZKkBmtceM6lDJlCn4JvCU/Tjcc0SAuWdIkkpr4IDt34R6vVKmMKNYBAWHOMOCMv3r1SvehSsXtf/ttc7p8+SqdOHGWWrRoKBak+PHjccSF9oKRdn5ffZWB6njWkAHLc34e1qzZTI8ew/Jsvbx58y+HSPOTa4XnSFOocf3q8DMMq5ExHphtqMYxjA+yJa4QT7Xdu/eAnbqeCX7oJyxeQwZ70bJla3QDYP1rdJQ/qDt3+VvdyaxZMgv2O3bslbazZPmKXr58xe2vNbhGeEnjGiVl3N+9e8fWtN26gYPVB7OyIBzQcI6bmYt8/vxleTFDOcnD4ejwcodcvnxdPipwePP0rEJTp82N0BHQysPbVKxqlXKEtNn2UD3MHUhTqrdvW8kfMp8YZ6lGZI6KFUtT9RrNzZ2izdtPnznPCmpmmZVzlJJucydCK7x48YqV+wG0YeNWasqDelMKdT5WJNzd2TL6xxHdYfC+rlq1PCGMIBTqNKlTcpzycvIuskaZ1jVktFC+fEkxsE2aNNtoD9GwYX3o77+f0vPnLzl0Ybpw+x25oUZwAN0LdGfrdJji+sLdnfJ8CKLbrPR2DX5r1eFYJ6ZCXO8kOxW+pZC2nrOGfjYwgIqwpRqMEajLebnMZjZiBIS2+oAt11cC31Nh9yBaEbrtEdc7xt+ERm5BtDu0rdBdMfIH3w04MYNKVblyWZPn0LlzG0qRIhnt23fQbBmTFXlj06b16MGDx7Rn7wEpAiMsGAz79x+W9cd/PyF//8MEgx6MrYePHKcvvkgv37Ejfx7XNXv69HnKnz83gU1hjzhNocYIpVKl0nT16l80f76vKMqgdZhSqGvVqiIfnZUr17OiVEBoIjjBqJ76sQdAVcd6BEpxSl7MPqxbt5UHVh/4hV4z3EzCd51a81TjCH6pu/M9EEADBnxvME0IxWTYsN50+/ZdWsrKGaRPny6ipK5Zs0mU0yWLp1E9ntqEYghlLk6cODRq1GQaPWaSlAcfOytbCvv378qK5/+kDmgPLVp00Q3coHRPmjRSPi5oB9yurl3bSsILePCDB/377yulHVjcQd+AtaVRow4WLc6YesKsCxTdL7/MKNNURQoX0Cmt6CA444gBrH2sUqZMztO0PWjjxt/5pfE388lbUOLEn3O/PahJkzpi7YZCXY0/ekuWTJO+vH79Rl4KwK969WYRKvoCjIX/wLlcuPBXHlzEpf/+eyvH6NKlNZUvX18UWCjR3t69mH71Svq2d+8hnu4+If1DP1OlSi79xgsVFJXp037kQUKzUEu9h5zLhAnTaLjPeAu9CNuF64fjffttU1ZWU8rACe8YWP/Lla8r7w/QinZsX03p0qXWzYrgGsEiYYsDXthRLS9VqVxeqDKenlVDBlfnr7BifYmWr1gXTmnu5eUt6anHjvGWUHWWW3bsXiiOw4f34/jSYVP4jjoClOr6zKlet25BjFOqvb29OInLL3zvfHAUHNLOunVbqFFDT1qyNMR65tDGbWgMs8GWaJZoCgNyvAsxO6wJBn8QhEmE5M6dgxIlSih0li6d28p2vI9Xrtoog1YpZMV/7fkdi3erscUR3NmSJQvze368DIataCpSRSow5eIcW4n1GcuvuMVXoRQNaxuHDTsJK8J3WHHmHxEswpyRPrQtEEoSubnTPUQTgQbOAsX6KRt+vtAq8TrqHWYreUN+p8Xjovp9410xSjAbjQRJoPVs2rTNpLIMyga+rzt3+tOtW3dNljF30qX5mwojG2ZZ8S2G4LsO4y2+R5qc4xnYhg1rUfLkIfdx/gIVtF26X/QD9TCYs0dCL6k9VW2rU6J4ER4RpBXrzYWLV+jixWsEWoexUxY+ilWqlKUbN25JxqkNG36XUSzoIhEJuNblypWQD/7Nm7cjKq72OxmBxo3ryg2+f/8h2rBhq1htyjKPSRMMmqAA4iVbpkwdSvh5ZhoyZKwoW1oZjDhhDcagC4I6uXNnl/vp0uVrrFRWYMt3dVq7dgulSp2LsmUvKR8HzFroC+67JUvWUpKkWahVq26yq2PHlvKLUbKPTz9+qJ6wlbsMpUyVixXaMcLtwkcAMmRIb4LFtlevYbK/QoUGovhDUbEkjXgqCgrp4cPHQ63vbmKltlRHf9+hw0fpy68K0ZEjJwWn0qU9adjwH0Xhnzx5tAxEEH0hRcqcPL3Vm5LwMzFzpnVKqnYcvADr1asuAxo8R3gmR48eJB/LvPkqUPIUOZh7tlymhsuVK6VVk19YppFlr0vXvtIv9A/XE/1Fv9H//Ply8+ClAVuzj1GatHkoR85SbNG+T506taJUPHiwRdzZeadQoSqUNl0eaS8ft12saCFpAsoq/Cm6dBko16hgwcpyDsOG9bXlEFaXvcz3H+5PT89W1IGxnzR5pqTtxuDIlBzhAQes5s5y5oNlpmiR/JxO/Gf2NRnEkT1em+pWpLdhwAmleuxY7xiTBAaOeLhXjGepIg0GN7B8+XqnKIaO6GuCBAnCNYN7VF9g1HBzc+P3ZiP66ScfCZ04e/ZEWrQw/Gyjfj39ZSQHKl68IL8HT9C1azd1u/CuwaAXz8z8+ct126NqAWebmYPUXWCFNrICZSoB42Is78C/DhW4PIbZwbWtxBbtsDLa1qvBbpSe329JTezTysSE3xbNG4jhCVzm//77z2SXvXp9x7rgpzKgNVnAwsbm3D5k5coNulJv3rxh/SIBzx6HfU8+MK/dkmTOnIlnxgvzjPY5u2cxnaZQY4oI9xUsVJAtTPXAlDfoHfoCax2cobZu3Smb/f0PirUJdBFj0aa8vVm5GTtmCB048JtM/2IUFNHUu3Fbaj1qEcA0IaZ8jrMT4tNnz1n5OSqKLqzUmuT5JofQJ/btO6TjL02fEeJ0qpUBzxezHIUK5RVFD7QMWHy3hvKq7t17yMrwhFBLU6BQD+7cuc8K52diVdbagQV3+oz5cm9tZaoGKBYYnULAn0qWLAn99tsOHT1h/fotMnIGxwpSoUJJdmb4mxYvWSnrmEK6ePGqvDhAMzAlUP5hecFgEso/UhSDW4gBQGQFHs0ZMqTlPu8k/9BpriVL1wjesChBmTInsOBDmcVzNPKHgXTgj9+E7gH6FOgeGO3PnevLg51Ruo/foUN/SnNJkyYyaPaXX+bI8W/eNO8oGS9efFH8A3kqFAIlHAOToUPHyfUwaDCClY0b/QgDdFgm8E7BBxmKEaRIkRDqyYKFvrIOzP39jzBlJT7BacXRgpmPvn1HyHW1tm1v73EyeAO/OqrF338jT6dulHcw7r2oFCjVjdlRcerUsTRq5CCXV6zHjfNmK9q4KIHkCVOf8L6xFAUjSg4cRY3ifQAB7StnztJMHcor1mr4LlVmipw1UrduDTGmLeV3lL40bVKPQDuBf4Ep/yr9so5Y/pSV1aRMcXnJyquryWO2WH/CnUrsArGx7cUGPPm+fbuKs+Cq1WEKr357ObJnFZoukkTZyluGERVc+6tXb7Kx5piuWRg24sb1YEt3OdmGcnCANSf4bkyc4CPfhvHjp5orFuF2p1E+wBfEh/PwkZCThmI9cGAPsTTqcyfB1cJ0/44dIdxZOK399ddtoYvgpPW5puC+QhGAgG8L5WTEiJ/o50kzIzxxVcC5CJTmRAmgKYDqAAHf/ejRU6xgFhG+OyyhsKbiGpuz6Gk9xmALtIiCBfIy1aOgDNSghENOnjrLo8sLVI9f2HD4g7IISgDuKdwvmuB+CQ61SsBBEFxrcIMhKVMmEwvMhQtXtOKiWGfPUVLW0UdQQIJ4Sg58Z03A04XlGwNFfESNBZZIKHuzZi2RXTgueF2NGtU2cPgxrmfNunaOh4wcCMHZLVw4P09zJTPbTJw47rqXDXB5/PgJgX4xYeJ0qQNu8uRfZtE3rJh79eos/Ow8eXLIPmMHkyArXv7HT5yivcx1A5fuwnl/tpguY4V9qUnMzHY6dAeumyawhEOgMEN5AQ3n+vVb2m75bdykg8G6o1ZAo4DlDpxZWwSK5/bt+6gdz6AYO23Z0k5EZWF9AacdUSfgpOMM0c4NzkitWjXka7yMBz07mYcbtcq8tecmUU7Yspo4cSL5NjnCOdPcseEsBYvuyFEfT1bJn3+eoTM4/PrrHImOAA76DiO/F1OYgKoGKsn27Xt0u/FOHTCgu3zvfZev1W2PygVYFPEHWoaryb+hFJD4MdhC3blzWx5wpWFdb6SB7qaPNZJD4TsyMfR7o78vouXy5UuJFRrfVH3dEPQjRHwbMKCbGGhhyAL1D983/XJa+716dhY/gcWLV5Ef+9nYK05RqGE9y5Qpg/AvEetPX0Dv0FeUMZUP5cfPz3C6B5EIQBvxZ7qAJuBUOyJsmNae+o06BKA0QmbOnCB/+kcqXaoY2ULR2bVrP496u7AFMr84EekP1ODNu379Qg4pl4d51vfEoor7y5GSPl1auZdDBnQtDZoGTQTcb1NSq1ZVubd9fPqyVdKQdgDnR82D3lTdiLaZmGmUKlDaIxLw2UuWrGVxmqtf327ipQ26yhV2/MRgwl7BC60hc83bs6MlnJOBBUIewSN74aKV9jYbrfXatWsmkRHs6cSkybNp96417FS7ia1yr+xpwmIdhD5buOAXHmC2dkhED4sHM9q5jmd28CFbv36rDG5bt24sNIFLl64J/c+fw61FFfXEqCvhVhMzD7hZs3pMu3nP9KUw6lm4gg7YsJ0NRFAcXF2hNvW+MI64wDqJCKh3msAIgudam+XTtpv6hdN5VqZ8rFq1ycCBWAuZBofIHt07SlUYCrSZaESkiaqoUJ86wECNN+J/YeN73al/ovdy/sBKsimG/ie8/T8jxdndaF3XYAxZgGGpS5c2MjuTh2OK58yZnR20Qwwx1apVECX6CM/sIjgBOMs1alSSv8KF88kZwpkcg13NV8rUaSOkI5x94V+kLw8ePGLa2bc80zGSneUrEAxNp0+fZzpeNTEs6JeFb9egQd3Zin6R6Uaj9XfZvOwUhRpmd5jf589fIaNPrZdVq5YTZzLNKatggTzMU83EfMsTYsnQyoECAgemKlXKGSjU2n7169oIYLoFYRJv3LgtjgNabxMmTEg9enwrjgKLOWoHFDuMIPECtSTHjp+ihw8fs7NdReY4Z5M4qNqoE4oNlOkffvhZF28SSYAyZ85oqUmDfZo3Pizq+pIjexZ6++4tK/935CN8+/Z9Kliokn4Rs8uwXFeuXIadCh+x4rXIoFz//t0k1OP4CfZPNWl9hpVcX2ARB6YfPph6jeuXNL+MSB/9+3/P02o3+BwaiSUZiRi0F5/5mub3gJcJOg/+GvNg69dfx7BVfDj9ceBPHa3EfO2I98AZBYPwuHENqRRfpE8rswuwRmr3TMStWS4BhQPTjppF33Lp8HvhBDdq1CT+G0TfM7fZkQIr7JLFU3nQMtHpyjTOA4lfenkN1Z2SxlEGBQkft+7dO/C9GUAXLlyWGLUYVCG9uTOkfv2abFVdy45Sv0c6iUtE/cU1hs8AlEkkxHFVwfXCjJXmuIV+au8UzHBAnj4NcdhKnTqVrOM/vN8QHcSUQq4rFLrQrFl9mQFcvnydwS7Q6TA7BmUbf5BEHElJc74+e/aiwxXqt1Bk+f2YGKOESCrV77m/TzhEXkaYvEMVazSJucEHoUGsYd54wsYIKcPLEChhoJ3ACVFf8PVBMy9jaCLyTBkziOEF3ybobxA4tUNKlCgk99jDh4+ErodvfqdOIcYp3EsQRMCKy+EKzSnU8HsoWrSAcJ7PX7gkdfT/w2xh+Qr1dZuOH9vBNKWnQrfUNiK4wKxZP4nu0a5dT4MBnlbGll9cyygXeL3jAzd06Fjhz2oHhNcnSOCgeYCribjEsPpNmTLPwBsZPByEOwFtxJvbUBKzEEBkC3CSZ89eQsZKY7Vq5cXSDEdAWKlhAUXECG3WAlxXYwUbL+39+/+U+wH3C8KUaQIHRVhPEQYPgnaMLSxaWXO/8DKGco9BgCbI8AgOKqhIjRp34Cnih+IRjwxit9jDHYJp/08+TWDS2l6oYD6Z+sIH3BgDvDgKF85LOXNkFT4wjg36AF4sOFcoxaCuGAtmcjSFEfxtYIfR/vgJU0RZhHNhvnycbYzpNfr0FeN2IlrPwOGF0BdYFTUqS+LEiSOqZrBfe5FiY7eu7ZnjPpit0wM48sEaWrV6s/DIwatMx9db30nJoBEbVsC/vH//kVhHMWuBsEmQlSvn8GxZeraWlHEYR7Ne3VoSuSYy0SG279gr8YqhaDrS/2Pc2CHijxLdsc6NLx3OEX9jOREMfA5mzBjPPhZ5aCTzrR2RVMX4eMbreTmUISIB1fZszc+K/YNN43YtrSPUZ79+3VxaoT7FlDm8P2EEWxuaPAPcaFjxoWxDTrGlD5xwOFiDCoaBacmSRWX2DQ7nlgTGFWSPRFQQ49jc3b4fSPjTF80YAufmyCaw0m9XW4aCe48jfGSAEhxJgTp8nLGrGseDPg0kAgEN2RW/4fUJcIhj7RpK95lgnm3Hu5sr4M5Lx3Gws3KZKRybWov8wZspjVswPWFF/zk7JsZE0Rzo9fsOQ8zcuZMkgsvMWSGGpTVrf9MvQsiKC8t2p059TEaB0wpDJ8Q3znhgpu3X/+3EmVwxYFu4cJUuWhx0g8mTR3FYxvTipO2I964DbiP9bodfzsVmfsThxOgSzmj6coT51K9evdZFbIDijQf1+InT+sXkw3fq1DmhjYA+oiRmIQBFCVZSOAoYC+IIwwpRulRxQjatPXsOyLTQiuWzqX8/Dm+2cbHJmJAbNvgJ5xm0H/2YqSc5TioUzREj+tOA/t15Kn2dhNQxPq6ldThGHDp0TEbISMHdreu3QlOBpWReaBIDcH7hnLOR+9ezRycCJQIK9xrOzhQ/fvxwzWPgEEJl2h1uH2Ijf/LJJ2yhKy77wC3HVOcczk4GJ0GEq4PVSF9Ac4GSC+t2Ff744WUAZ9y8eXPSyhVzpc9r18xnpT8jc5SXRkp5vHr1uryEwI8cM3oITZ0ylhWfAfrdMbsMRRbc5ty5s9GggT05hfEX7Dx8WCzmY9iRGAH5sR2DadBl8J5wlICzi/BeyJj1fbf2NGvmRB5g5BbHTSjcmPm6eeMYnTi+Q+5Be4/bqVMLWrAgxPHR3jZQry/Hbh43LsyaG5m2UPfbds1lMBmV3OzI9hH1MUhDRBpEBsHULKb+o1JAgYGzZMdOvZ2mTON88Izi443ju6pghggD5+bN64qj/2QOHQqeKpzINUoaBry+vuvlXbNwwRQazTMrXl6dCM7f8AeAIITns6eXaf68yQanWqVKeeG8ruZBtDXWbIPKUbDCei+dZIU6J4eygzXZFinJGQ8vcCKXCnppwxdz6vK0bG2e7vaOanGmxRmhAe/W6iVnmceJX/KwAv0zx/ZAmvJZboH0hEMV+rkbfjfysUJ9iWfZ/rGlUx9p2TOn99K9u6f5+5FezhDKMGJPw1BrTPfQIMD7Hd9lfAcnTfpBZshHjfpJ2820ok4yMww/IximoHRrfzVrVNaVs2XB8CttS00ry8L6BmcvLbqHfrUHPG1/kT30QfPASxTT95hON8WnhQcorFwYOSuJOQjA0QShDBHXFOFojAXOaVC2mzTxlF0I57Vt216xYgwb5iXeu3hRG8uBg0ckkccJjlagP1CbxZkzkTgIiiWcoTDdBMc/KJ/pebrfWkGsYkT5aNGivnA+wQf7/vtBugQxUFIQ0g+W9x9/9OYp9b7Snx49hkgoNP3j4OGHbwAUy9NnwmNwgD9ioGQ0aFBLqiHZxvHjZ1jBqEk9e3aQAYNG6dDahUMQaC8tWzaUDx62d+8xmKevFjPexaXPUB5Hj/5FR33R6tr6e59pKj17DpH+wxkUVvBFi1bLdcMMkyXBRxMe+5glAIcUfFpYuJpzVj3cE1DMhw71YkfU+8xn5W1sTXeUgE4CqgNS2U6cOJyjTnjKgAiKK+QTDquEfmFg5Gbz51SakFjSp09fcAj3GRbAMzxNiSxfkRVQC2CB7eU1LLJNOaU+uOOItgOOscRZ50F2VMmM6T8KxSYi5+eoOD5C6CEmtasKntemTb+jU6cu8DPfkQc6LeX9A2uhvmCmeNmydTJLiIxzuHcxINJmghIk+ES+13j/60vr1o3kXQeajavI1iB3ysszgEk0noaVHfuUFd7kcdwIkUI0OevuQa3fBYqCvoIzLaZk5brp+7C04yh3gBPIdHr3gcqw5dmXy0AJa8IG7JdaI/wLYkQxNgz5scUblu/YLtD9YFR6+TJkeIFMmniv+zN9SrvnjDH6MlNG0QHgkLho0SqOu9+Y8C3TpEqVckI9ypUrK1MORxv8gYpmj7jFT/BF2N1gTwsxpg7Gn7HkVGPMNVEdVQjEbASW+85ipX2Cw/jJsF5u3bJMXv7GgyhrkcqcORPPbvzMCk5bhyj61h7XUeUqsEUUDkmdu/RzVJO6drpzZlFEvLE2gZCuooMWkF11+fJZnI0xhFPqoGZVM5FA4FOuezjOBxrJmRFXG1mJI9FspKrmDgqg7fHcqEiAG93V54FEqtWYWRmUvTNn9kqQgSJFq7r0SUS5hdqlz151TiGgEFAI2IkAwkHBwu3IcGuIeDFz5mKmwnSzq1dQyOdy4pYuXfrHSGUaJw3Hxc8++1Ss/3aBYKYSnN5BORjJDqDRJbDEI37z119niq4uqOMaIQCu888BQdTVw40su8MbVYyiVZj+ujKVZCHPWsZ2ZRoQI74/8khMmTInihB3XLNKoXYclqolhYBCIBYh0Pm7tsJPd/QpIwZv2bLFhW9uS9thET0cZzG35fiOLIsEOUi24qiEN7AMT2I+MLjaznJCNIcHHJunTxvPyW6+NldEbXcyAr5u8ekNT2B3CH5nJ/nLcR0uF/yeijIdZCL3SQlxRuPV/Nz2EQd2V8dDKdSufoVU/xQCCgGXQwCWaTiRbvXbGSV9QyIEKJTWCCJWtGvblCaz483mzdtdOoqENeeDMkgKs2rVZk4k1MnaKhbLzZgxgR2VJ0Z5eDyLnQjdiWgmZcoUk6gu1pRXZaIeAUTf6BAcl1K7AGM5P/ehdYA7PYt21T7qcbfmCHfu3qNlvmutKRrtZRSHOtovgeqAQkAhENMQ6MjTkLCezpi5IMq6vmTxNHGqRYzqN2/eUCKOi46wgogAg8g4qThMI0IqNm5cW9anTp0vkUKirENObhj4+m315Snf3hya8o7dRwdvGgkiXCWpCizTcPZDeNjInJfdgKiKCgGFQJQgoBTqKIFVNaoQUAh8zAjs2b1OYhhHZZa/1avmSlgnxOs/f/4ye7i/5GgoDyVlM5JrPHz4Nz169DfzgstyPP8iEktVixP+sWAP3nNfDn3VrPl3dp0S6vv49Kd6HIEiuqkedp2AqqQQUAjEGAQ8Di1aEQAAIlVJREFUYkxPVUcVAgoBhYALIFChfGkJaxiVyjROE9FDTpw4S1OmzrOYnhtOkSjzMcpxDouJQYNn7aq0SS+BU0TnOmhgD8m2h4gnjRt3VMp0RICp/QoBhUCkEVAW6khDqBpQCCgEYhMCKzjs2RDvsbrMcbHp3KPjXOFQuGnTEqpRs4XFgYXWtzKlmdvOVBHEf6/JdVwtS6TWT/WrEFAIfFwIKAv1x3U91dkoBBQCUYgALJ5IA6+lYY7CQ6mmQxFAqLmpbIEfOKA7IaGIOYFzJugdT58+l8RBCCGolGlzaKntCgGFgKMRUAq1oxFV7SkEFAIfLQJdOrflONGLPtrzc9UTW7V6E7Vq1Yhy5cwmKbz1+wlFeiCnr0cmUmTBVIMdfXTUskJAIeAsBBTlw1lIq+MoBBQCMRoBWDw3b1pM5SvUj9HnEVM7j9mBqVPGUiPmRIO/jvVxY0NCC3p7j3Nogp2YipHqt0JAIRB9CCgLdfRhr46sEFAIxAAEEHN6wngfQmbEJUvWxIAef5xdhOUZvOiHD86Sn98udjQMJIQUPH3m/Md5wuqsFAIKgRiFgFKoY9TlUp1VCCgEnI1A3jy5KHv2zJST6Qb2hm9zdp8/1uM9efKc3Dg385w5S2n7jr0f62mq81IIKARiIAKK8hEDL5rqskJAIeA8BJBgpGOHFhQYGEiz5yxx3oHVkUwigKgfcFRUohBQCCgEXAkBtwSfZuAM9rFB2KxBseRUY8PlVOeoEFAIKAQUAgoBhYBCwBkIBAcT/7MoHu5xLO5XOxUCCgGFgEJAIaAQUAgoBBQCsRaBoICIjbIegR8iULk/Kvhi07l+VBdOnYxCQCGgEFAIKAQUAgoBl0XA3WV7pjqmEFAIKAQUAgoBhYBCQCGgEIgBCCiFOgZcJNVFhYBCQCGgEFAIKAQUAgoB10VAKdSue21UzxQCCgGFgELADgQQmQWJeJQoBBQCCgFnIaAUamchrY6jEFAIxFgEKpQvJZn5HHECRYsUoFUr51LJEoUd0VysaiNdujRUpXJZTvASN9x5Z8yQnpCGvEzpYnTi+Ha6d/ekw65ZuIOpDQoBhYBCwAgBldjFCBC1qhBQCCgE9BEoWCAv+fj0Z+UsI2XMVIgz9H3Q323zsqdnVfL0rEJff52JSpSsSW/fvrO5jdhYAUr0ct+ZVKRIfvL3PywQuCHLC4dDRTire/ce0tOnz+jFi1eM6XvBdcH8X2jixOm0afO22AiZOmeFgELAiQioxC5OBFsdSiGgEIh5CIA6sHrVHEl7vX37PpowcVqkTmLqlLGi9D169Ddly5aZvu8+KFLtRUdlpGGfPesnSQE+Zeq8KO1C8mRJqV27ZjwIqUrXrv0lA5vu3QdHmHIcKeOhhE+cMJyV67c0cNAoNXiJ0iulGlcIxG4ElEIdu6+/OnuFgELASgSgnPlt9aV23/agu3cfWFnLsFguTl/u49OPGjXuIDugXPv7H6JVqzcZFnTxtUEDe9Lw4X3YIvycrly5zlb7ABkk3Lp1l27dusN/d+n69b9YofVgZbgpLV++no78ecKmsypYIA917tyWoLzPmbNMrMz2zg40buRJHTu2pF69htL5C5dt6kemjF/QkSN+YhXXrptNDajCCgGFQKxAQCnUseIyq5NUCCgEHIEA+M/ff9+eWrXuZldzmzctpV5e3qJsogFYUTdtXEpevM1WRc+uDkSyEtJ+T5zoI5SK3bv96fz5K3T5yjVpFfsysvKZMWN6tiJ/yb/pqESJIpQnTw569OgJK97XZCBy/fqtUKU7RPG+dfsugf9co0YlWr9+K5UpU4w6dGhFN278RTNmLIzQEm3tKWXM8AXNnDme1q3bQnPmLo2wGizjzZrV47/6VKDAN1K+aNHqDutPhB1QBRQCCoEYhYBSqGPU5VKdVQgoBKIbgZkzJtCqVRtp954/bOoKrKR58+aiId5jDepB0Vu48Beq7dmaXr9+bbDPlVbKlC5Oo0YNpHHjfqWtfrus6lrqVCllALJkyWpRvKE4Q+nOlOkLysDLmTNnonTpUut+wYOeOXMRLViwnJ4wH9rRglmGET595djdmWrz4uUrg0Ngf4XyJcWq/tln/2PL+gZat/43SpwoESVLlsRgdsGgolpRCCgEYj0CSqGO9beAAkAhoBCwBQFYLtevX0DlKzS02kERlujdu9ZRlapNTCrNnrXhqFiVOnTsbUtXnFIWHPJRIwdQ6tQpmYLRL5wS6ohOlC1TXOgdo0b97BRLfcUKpWnIEC/azM6KoKgcP36Gvv22GVXg7bt3/yEK/V+83VjmzvmZFi9eTf77DxnvUusKAYVALEdAKdSx/AZQp68QUAjYjkDHDi0pceJEVjso+gzvL1xj3+VrzR5s4gQfOnPmAi1esspsGWfvAMVl7Fhvmjp1vlhqnX38qDwe+OzHj+/gQVEgK9bbRYneveeAxUESZhOmTh3Lswkto7Jrqm2FgEIgBiKgFOoYeNFUlxUCCoHoRcAWB0WNu1u9RjOLnUabW7f4RjufetDAEKfLbNm+5igkX5NXb2+7nTAtnrAL7Bw1cjC9fPnS6oERuoyBz6ZN25SV2gWunyO7kJrDL3YOfkcj3BLwUvSJV9Bb2k5x6bx7nOjrhDqyXQhEi0LdoX0LSpIkMc2ctYj++ceQM1ioYF6qVq2iwcm8evWKrSNb+aV+X7e9ZYuGzMPLoFsP5kCk9+8/oLXscPLq1T+67WELIfFKw9bVkkJAIWANAuCPdurUip48eUbzF/iGq2Lts4jnPnXqVLr6wcFBdJsd0lat3kzv3r3TbTde6O3Vhd6/f09Tp0UuPFutmpVpzZp5EukB757IirUOikuXTKdJk2bS8RNnIjxkdPOpc+XMzlbb7Xw93hNC07mStTxC8JxUALzw1avnUukynk46YvQcJn78+NSkcR06fPg4Xbl63WQncmTPQlWqlKf48ePR7NlLmA700mQ5Uxu/69SGkidPSsuWrSF9eo1Xr870v/99alDlxYuXkX7+DRo0WonH6+vd3tGeoGD6SU+h/iYogKq7BdCrYDda6x6P/iboEdbJ51wsb9AH2u8eloQoU1AgNXczHcf+NWvxM9wTUMWg9zTOw40qBHnQMxuOZ12vHFvKwyMONahfi2Pqf0lBjN3Jk2fo9217DA6CMk0a16Uvv8zAdLc3tGLFBnr46LFBGW0FdLpG7GuCqEDW3ks5smelBg1q0V9/3aalfC8Zi6X72Ja+Gbdrat3pCnXaNKnoxIld9PnnnzFnsDXt3OVv0K/O37WhyZNH0ocPARysP5gQtz9u3LhsRXhFdeq0ocNHjkv53/1WUrlyxflDG3Jzuru7S5zYixevUvXqzUxcMKVQGwCtVhQCViJQo3pFVkTn0/PnLzhiQzl6+uy5QU1rn8XDh/woX75cumc2Thx3ihMnDh09eopq125l9gV6984peRFnz1HS4Ljaiqbw37//0OQLVSvnaIUa7UbkoIgMi41ZKencpZ/WjQh/waeuV6+mhOeLsLCDC2TL+jV/zGbyO3i2UqYtYDt61CAOpXfio0wYAwWkdatG1K9fN3beTEcNG7an37bsCIeGz/B+1KdPF/4+s+LH74TixWsSIrZYI+XLlWSazRL+vrtzdJfmtM//oFRLxJFiLl86IHQq/Xb++usOmXv+9cvZu/wtW6bbxnGjykHxSBvat+VtU+LFpZuBQZTYPUSRrvE+mM65e1g8DBTprsFvqTvj8huHk/yOEujKF2IFe3Sc8PbvLKy//MN28SKBcek9l17Myv0DVlD7s3LvqoJBz8oVc6hSpdL077//yX2AMJkTJ86gocPGSbehsCIrbI0aFUWnw/qDB4+pYqUGdPPmbd2pQZHu2bMT+1G04W3BVLhwVYNBlq6giQXt+7N37yGqVr2JrkRE97G1fdM1aMWC01OPlypVjB+WzwkKcJ061c12sQt/gD5PlJkSfp6Z+vf/gRImTEgjRvQ3KA9lumTJWlIuWfLsPNJdRzlyZKE2bcJANaigVhQCCgGbEajPFgh3/qAkTZqYQ5oVN1nf2mcRM1JQyvFsp0mbh7Zv38svz3xUt241k+1asxHvk379ulLLlo2sKe7QMt4csWPEiH6SQMS4YVA4hg7tTShjiyCrH2bbOnVsZUs1h5RFSLxmzTorZToCNCdMmMYW/PYRlIp5uzGgOnd2H02ZMkaimpg7g/bfNufv8vd06tQ5UaTTpstrtTKNNocP7ysxyo3bT5UyBcWLF0+smAk+yUDaX1Qq07CF9/JwpykBwTplOjFvG8bK35QP79nK7EE5A+LQHbYue8cJtGgzrsvW5YseAdSBFUt3yeJpeIbH2FpdNTiewV8tXr/Hs3WbWXGHMg91e3qgO7VmZT49BRk24EJrbds0E2V60aKVlDJVTsqZszS/tx5Rt27tCP4JEFivq1evwLrZWkqSNAu/p3/gWcoU9OO4obozqcnhMi/xIKpPn85iFNXtsGKhWtUKVKpUkXAlrbmPrelbuIYj2OB0hbpRo9qcAOClxC+tWLGUVQAuWryKaRyvJLSSufPBlPGKFevFql2QaSNKFAIKgcgj8Omnn1DZssX4w3mercT/ytRaRK1a+yyCmrVoUYgDXhF2fouJgtBuiPrg1atTuO536dxaYh7bE/5tuM9EiYGM1NmggThDENbvzJnzurjSzjhmTD0Gwu0h/XmraBjERSVmUHaQwbNx445yX5s6Fix73bq1lzTvTZp2opOnzpoqZnZb3TrVZBB982b4KCpw9IVC/fffT83Wd/SOUsHvKRlbyncxpUOTorwtORv9FgTFFQUXxNTFrPAWj+NBibRCJn5TugWR94dAyhfoQXe4vDUCWkkebndVUBhn+iQr3g+4fgPuh6tKnTpVJQPplCnzxLH3DlNyt/BMBr4ZoIBAGjasLZbpGTMWSpmZsxZKttNSpYpSksQYthClYdbCzp37qXRpT7p82TS1SAoa/Yf7cNiw3vTw4WM5hv5ua+5ja/qm36Y1y05VqJMyb7pEicJM+ThHGzf6yXRS0SIFI+xnAuZnwaKN9LGWBABD3rx5Y6mY2qcQUAhYiUDxYoU4TnAaUQzPn7/EM0KFma6VMMLa1j6LWjnTfg8RHoYm/TxSrBsJE35GoIC9ef0XlS1TQirC8nHl8iF6+99tevTwPDVvXj/iBu0osWDhSuaRlpOMflp1TGGC6jFj5mJtk02/yAj44sUrUaphfY9qQWg8JKwZO25KVB/qo2l/ypS5kn0RMxEfi+zjrJ2lSte2SGXJlzc3K0yZaNeuP9gi+dCmU4eyhXCFSCF/woRPAWabQAW7evWGTe1GpnBN9yA6HRhIz/Vsz5mZbvqM/x7rOQZeCY5DydnqnIot1eZkNlM0FrjF11m6zZXT397MPYDOBAbQBT0qCTSdI3yc6qz3OFVJ0+9YBMuwOvv4/ERQpDV5/PiJLCJyDiR9+rSij13mbKoQbEckI3xDsmXLLNvmzltGTZt1ssrHRCqE/te4UV2O65+bVq7cKIZU/X3W3MfW9E2/TWuWnXqtMCrBtPGmTb/ziMRf+ocPkSWBEj5sWF+5AL6+680WzZolszyoHz58YKvXSrPl1A6FgELAegTwfOIluIeTmGzY4EepUqWgEsULWWzA2mcxb55cNJAjSrx5868kSrHYqJmda9Zs4unjCTLYvnjxGjscetPVazfEAWYOxwxOkSIZT1/Po3nzfHl6soyZViK3GcovaB1jx3jrGho1ahD3azxjF+Ljodthw8LAgaN4inSERNqAwhuVMnBAdw4HN89kjOyoPG5MbhtW6tWcMr5Z07ox+TRs7juS8sRjOgIS3dy7e1oGrBi4VqoY8fPVtEk9ypUrG4EyExQU3oIL3yo3Vlp79+7Mg+Ob9PqfG7Rm9TyCHhAVAhNcfrZOX2DKhT6zOYVbMH1ghVr/6dXSDCVwIA0DfGtPWKfZGh1gdIInuEPZWKGO2iff6KA2rC5avJIm/zJL/Nu0anjHvnz5D506fU7bJNcTBlFNMPuAawyOs70C/vbAgd3ZmHJN9El720E/HNm3sLO0t0c21GvQoLZ8+Px5FPzn0RMSiqlWrSomW5g7d5I8qPfvn6H27ZvTgQN/0vgJhtYTPNRHj26TcmfO7KFChfJyqtrFtHffQZNtqo0KAYWA9QjAelyTI2PAe/rosVM8xX1IptZq1aoarhFrn0VYksGXg9X4yBE/yp79axoz5hc6cfJsuDat2XDg4FG2UGyQfmGqGimlYTWrzpGCMHifOHE69es/ggYPGU2DBo22pkm7yhz584QMDEABKMmzcHjh25pJ0fjASOk9hZVceLy3axt1fiHgG+bNm5OjrWwy7oJajwAB3G9durSVFPIRFNXtzpY1MyfKGWSRwqgr7IILcByEVKhQSqb44cCKaB0LF/5KadOmNttjOA9jtuXcucu0YqVp49jnn4e0jag+EyZMp+vX/6JatSrTTz+NMNtuZHaAP52eFerb4XX7yDRrdd0KzLlOxv4pG9zC6CZa5bvB7pSCFdHEJgYeWhlX+q3NulyhQvnknrh374F0DZHZYAzI800OXVcR7SOy0q5tM5klGTNmsjhE2tNeVPTNsruqPb00Uwcf0tKlizBH5gZduHhFSu3bd0imNBEq79jx0wY1167dQqdPn5dteHDLlStBQ7370HCf8bpygTyqQ5pafEgx0mjduhG/3Fpzpit/2sbOTkoUAgoB+xEoXCg/p4lOT9OnL5BGoPTCM7tKlbLCk4NntybWPosIxzZt2gLxo4BHePv2zWjw4J60f/9hHmSf1JqL9G/+/LkljBMiMWiC90RUyvbt+8jXd7oo1gUKVHbYoZAMZvu2VaJcO6xRvYbgiNi3r4/eFrVoLQJv376jJUvWEBL9YPBjjfj49OcoLtVFCe/bz8eaKi5VBlG3IPPn+1L3HoNlGTjAYliXAw1MnxHyvpAdev916NBC3ictW3aVWS+9XbrFxUtW0o0bfwkt4BlHFcK75/DhrRwlohKl4UydD5gv60iJz3bpBKw7vOA/ZwuO2MojmPyZ7nGXwltr/2UKCsokoUC67bLEjxDUEL0N0dkQjc1nxAQdlKtWbZIB0cCBPelGp96sozWJ9Ewh6HS9enWks2cv0sZNfoSwefZIVPTNaQp18WIFJXUtODbeQ3rL+YNHA8sW0r0aK9R+fjs5BFZIVrFp0+fTSQ6116FDc/r11zm6sF2BzHtauHAFnT13Udrbs2c/U0nW8ij4e6VQ23OHqToKAT0EKlcuK6GQwDXTnllQqtKl+5IKFcxnkNjC2mcRlqfZsxfrQiL9yZbdTZsWs0LXlRo36ah39MgtJkjAyRkwZcvhN50lt27dFmV6wYIVHPHgjsMOC2UFDnA1qleirfxedKQoR8TIowkr9Y7tK2V2BNfKnJQpXZw5p/3oIM+qIPPknDlLzRWNEduPhIawRWf/+OMID2C/JwxkTUnKFMklKgqigiCKjTkBvUx/hvnx308Ihjf4I2Rly76jFWqtH/+C7+FknRoRPMrEiUtd330gNkaHkxfhtrjmBsxkgl6XiuOzd+nSn3ML3NN1dP2GLUwVrMEDyBo82/An/fffW7pw4TLPTGaRQBO6gjYsfMehlTETAiOAxtW2obquaFT0zWkKtadnNeGq5ORwKvjTBB+9unWrM51jqrYp3C84lrCMFWfuJoA0joOrVYAFDWG50qdPo21SvwoBhYCdCNRhb3zwHGvXriJ/WjOIHY1QSP77D2mbwv1a+yxeZ2sULN0ZMqQP10ZM24DELQjfmSBBeGtTZM8F/OYZM8Y7VKHWHBFr1GwR2e7F6vrgyWMQ1avndzTux1/DYSEUD+bUP336nB1jO5vIkRCuiktv0JIwues57CFhB94VGMiaElA74X+Bv9f/3DQosm3bCuaib6ZWrbsZbNdW4JyLsJ2R4dxqbRn/BrAWjSF3CqMdD3g9LlutQ2zxITuThbKs3zrIWlyfI3j8FxzXILqIfjeShB7vg7M1ff1OWLE8cEAPqlixNM8mLKQlS1cb1IDC24zveTiIQ3fDwGvWrIniq3FDLw61QaUIVkABBu95xYrZBiXhlP7q5XUJpawZWQ0KGK1ERd+colBjBAOy+q1bdylX7tIGo4rfNi+VyAE5c2TVUUGMzltWQRnBAwtLmDlJkTyZJIFxplXKXF/UdoVATEagQP5vJPTRpk3bxQNbOxc8h4hTW7NmJRo0eLS2Odyvtc9iQubXgfrh6GcWUQQQLSAZTw86WyxZKe3tCzKLQWlBfNfzbOFxhChHREegGNKGL/Pc/fdtYAriQk5Q9Eo2IqYy4pAjSg6cVh113RzXa/tagnEL3+KyZUvo4pUjAyqeNziJmRJYs3v0GGKwqxUnj0GI219/nUs7duyVfQcPbKEvvkjLekIZXcbjr77KKO8HJI9xtCCaxgtOoJKInRD15SqFRPRIy5E2XoYOHLJwSLwnbAB8pDeQ0K9jyzIU9SaMlx8Pxp7pJX7RbyMJr6B/zx1wPP12HbkMR9T+/btJci4tmYup9rdsDZlZy50rO+XOnV184kAPsUfg7P3JJ2EDt9RMBUJM9KtXbzKdcJ7NkWcc2TcTEw32nKLlOgi9hWnjQ4eOGyjTqLV16y4G5xPmSJc020gb5t18w6T2Gzdum02BitFr377dJAMjHBiVKAQUAvYjUK5cKUknjPCW+oIZoOPHz0gUDaTeNiXWPotw3OvZs6NYdHcZZUw11a65baCR4AOfOnVyXVz7gwf/5MF3kEwzI0IA6GVtjRz7MNBH8hREHogJAis1HOAcIcoR0REohrUBK/XkybNk6rtggTwEq93SpdMl3GS9+m0/GmUaZwxfBwxYPT2rUN48OSkxOyl6eX0nxq79obNWSM/e26uLOOiiDgYTs+csMfhD9kPMUPv57aJdu/ejmCzDwbFr6H1etkxx9r0qKjPU+pEjpLAD/oPCep05yjlDMyFqTZ50i0uP+Z3SidOEQ0lCpI22rAAfYr7zy9BCifi3ZdA7i3GpQ4uG+8nHGRMRe9pXL/a0caGvWYFHMhmOiWG8yyXWYXGGtfn581fUus33Qnez1LESxQuzv8E0eUf/9NMMS0XD7cN7GjNAcIiFFVz/Xlq/fqu8/+EjgxB85hgM4RrV2xCZvuk1Q06xUFflbDb4eIEXbSwYuSLLWv36NQycGWbMmMBTCOOlOHjW+JB7eXkbKOTYfuDAb1IGTolIgXrt2k0aM3ay8WHUukJAIWADAnCaAt8NMUONBWEvkUoWs06IbgGx9lmEhfvMmb1SB9N2eC8gaYzm+Cg7TPwH50hM5+kLPsh58paj+w8e0cWLV6kY+2k8+fsSZ2BtQzt27uPUxtslA+OdOyf5w02SHhkfcE0KFsgr0QMQ3/7QoaM2ZXrT2nDmL7AeN85bFBjNCmrv8ZUjor3Ima8HCg3oUWXKFJOMcNU5pXZkwiaaP1L07gFFq2fPIbRmzTzmg2+RbzKe/1mzljAN7LB0Dk6EY8YMopMnOZNiiRpWd3jatPlMJ6soXHOEzvvss//Je8jLa6jBt9/qBq0ouCcwmJXlOBSPXw3vQ8uDv+zDdIUpnGSmYuAH+pzfVcRW63ZcQOM71+HU5DPix6WEnFRuhrttNK/m7oF0gyOL/MkJXEwJVOiinAr9EM/IvzcgnpgqHT3bhnM443TpUsvM2b69Gww6ce7cJapRs7lsg+/HypWzhD2AbwqyJerz5A0qmlnBvYAwjRs2bDUI02emuNWbHdE3/YM5RaG+efMW/fDDT8Kf0T84lsE7HDZsvEwXIej7MQ7PNWqUoUL8+vVr8ebUz6y0lEcp4OOESbBkzFmzZrNuyi1sn1pSCCgErEUA1txNm7ZJjF1T09S7du3n5/lnDnt5X5q09lmcy85bmBrWBMrtnTv3aO263yxaN37+eZZEFdHqab/IuKpJy1bdqHmz+hLt5xrHoYa0bNWFmjSuK9Z0TC8ePnycI5SUl3cM9oNnN5hpK3jJ37p9F5tcXpBxrF275jRp8ky7+6ocEe2GzmLFrTytDSd58IE1i6vFCi6+c9u23cL7vnIl5HnS7+6evQd4VrmeKL8wZCHp04aNv+uK7Ny1j5XiiTxYNh8Oc/36LUIRuXUrzIEXkT2qVW9KjTjDXpo0qeXZRCQHGMqiSrawNXoIB6TOGhBA5/SSqyzmBC1/vgugGm4B9G+AO63lTIp/61my/TjU3RBWpteZUKZZV6Y5rJA/hH3biAfAh6JLXGAPU03+M9qnnSP404W5L215ls1FDdSE++POnZBvgNZv7ffhw0faoly7cZww6tmzF3yP+NEDNoCYE3wjkiZNIkmt9MuAFvjPP290zuz6+xDoYuzYX+Vbor9dW7Z0H+O+srZvWnuWft3iJ/gizGRjqWSM34cxXyw51Rh/rdQJKAQUAqYQQFY+cHXLlK1rs/UT8bHhFNar13dsPWqhkriYAlhti3UIQDNY5PaOHvAAf4AZPrOzQWnO8am7srmzYlA8m7IuOrufzjgeMt9u2bJMkn99276XMw5p9zHMjI/sbk9VVAgoBBQCCoEoQgAUAlBZPGtXtekIUMS3cSxrX9+ZKiOiTcipwh87AjCz/RDsQZ5sEc7CfOroloTcAS8PNxrK4UfeRXdnXOD4SDqFWQz9+NYu0C2TXVAWapOwqI0KAYWAQsA1EYDD14IFv1D1Gs2s7iCs0/BLuXLlOjVs1N7qeqqgQiC2INCGOdHV2cTYPDi+A5OL247eKI7tgZQu3pzsRc2p245fdNZwCoc6Ok9QHVshoBBQCHxMCCCEHkKQ5s2Ti06fCckma+n8oEwPH96fSpSspWgeloBS+2I1AuBMH2QnwKBonrdfGBSXbnKoPKVMx7zbMZpvnZgHmOqxQkAhoBCIbgTgnAgudESCpCJjx3pzyt9uSpmOCCy1P1YjAAX2qgvEfL7GfYh+4kmsvhXsPnmlUNsNnaqoEFAIKASiBwFYplOnTkGgf5gTKNNICdy4cccYn53P3Dmq7QoBhYBCwFUQiOPhkcjHVToTtf1wzeDoUXvOqnWFgELgY0Xgn1evJQygYfjQkLOFoo0kCh079uGQgGFhyT5WLNR5KQQUAgqB6EZAWaij+wqo4ysEFAIKATsQ2Oq3WxLsJEhgmFQCyvTq1XNEmb58xXQqaDsOp6ooBBQCCgGFgAUElIXaAjhql0JAIaAQcFUEkG49caJE9EX69HSOk9RAkK1v2bLpnCzrRzp56pyrdl31SyGgEFAIfHQIKAv1R3dJ1QkpBBQCsQWBBQt8qVOnFnK6UKbXr1vAmb9+pQMHj8YWCNR5KgQUAgoBl0BAxaF2icugOqEQUAgoBOxDYPWqufT27TtKkCABLV++ltat32pfQ6qWQkAhoBBQCNiNgIpDbTd0qqJCQCGgEIh+BDJnzkQ5c2alrl0HKmU6+i+H6oFCQCEQSxFQFupYeuHVaSsEFAIfBwJFixSgAgXy0IKFy8VS/XGclToLhYBCQCEQsxBQCnXMul6qtwoBhYBCQCGgEFAIKAQUAi6GgEecuLElPnNsOU8Xu8NUdxQCCgGFgEJAIaAQUAjEYASCAoiCgy0nhPcIUjkuY/AlVl1XCCgEFAIKAYWAQkAhoBCIWgQsK9M4tkdwUMSForaTzmw9Np2rM3FVx1IIKAQUAgoBhYBCQCEQexFQcahj77VXZ64QUAgoBBQCCgGFgEJAIeAABJRC7QAQVRMKAYWAQkAhoBBQCCgEFAKxF4H/Awoux9iWM/CZAAAAAElFTkSuQmCC"
	},
	"calendar": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAc0lEQVR4nIXQwQkCMRSE4U9ZLMCT9Xjaq2AfNhfYU5oQLMAOtoN48EWei5iBIRPe/yYQ3qrhf1lFG7iKcEaJxSfukUvMWgdHavt0uWHtg2QwxXnAnJZ2uOLyVZtybzzhgWNmfoFl0/YB87NbzR1cjP9xeQHSDC6mcL1xFQAAAABJRU5ErkJggg=="
	},
	"checked": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAYJJREFUOE+NkstLglEQxf0fahG0iFrUxm2ElFDYLohCqCDaCAkWPaxIRbFFEJEaGEKLDCoMETRFUAMLyaIHBUG6sSKIMtKFqEhLT818ZUgmDhzu3DPn9z0uV1RrmUwmyGQyqNVqfFvViwBxu5RFPZuLSyGMKhz/qlEsRV19K8xm6y+w7bpBPFnAferjj3bdQX6DpHcAUwavAHUN2RGIZxBJZHH2mC/TUeydwwTZvBegLENNgw7sX6Wh1FswNmPEmjPCDyGRRwCtW9E3tMgdAtQw7GZjYcNX+gza2wJ3ZXsSZUuQ0vWCOV8SHfJJ/uluhbHUj1v8PKNMszIoQNRMHCShD6Wh8zyhrbOPwz8w+STKlCCJ7oRNUzQH63kBs5thBghePXxlj2aUoSxDPcuXPNiLAc5EEZ6HIkbmV2DYiXBPHs0o079+K0DTVj/s11mE00A0L+g4VcDp10qKZMAzytBhMaTRaPmYg885DlcSzSij0eoEiIouoUqlqqqaL2rlEok+Ad4vlfzPoVDsAAAAAElFTkSuQmCC"
	},
	"dialog": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAH4AAAAUCAMAAAB8knmGAAAAXVBMVEXn4tfm4dfn4tjn49no5Nrp5dzp5Nvm4dbi3NDg2s3o5Nvl4NTh287k39Pp5dvh3M/j3dHk39Tl4NXg287k3tPi3dHh3NDm4tfj3tLh28/o49ro49ng2s7l4dbl4Nb6VbEyAAAC1ElEQVR4AXVV0YKDKAwE4AAVK6SwC9bt/3/mnYJ2tF7ewMEJyWRgjHMuhFT/nEMb261hxbrqh23hRomYhxLrYfXATTm6DTv060q0vxh9+b+SYj3Muj3c5IORAFMBEtD0rKgoAHIJLWLlfpIG8qAAIk3wk9tJKz2E84GrHUvbVhLbyvw0iA2/6ota/Qbbvv+YbUekbUV6R/Dg3YWN+ZyzT/a8X6KpBLpW3cta2FCOLFMkLuZe97PgFJM7joaG9bUHlVyZWM63tGllZp+yzIwipGFJQwJ5rqgX2e7/w9KrwuYMAtBkgTbS73z0r9JD9IJyy2GJEjSQD9kJwiIeTSNxyC9Dz2VcGiKT6IHplr7VynbA+UpVA+bxQYi/kNPknJtSDn9CfebBNPSrZdK0r+6ImE8p5RzDm4szgFtIQNqme3ZkcBsP1rRvJZBbfr6c4O8Qc04pgfJrY5rs4dJ5hhZ0z9z6+x0vys8Oyj5nKEMTP8oLBw+7OAh9TkCdJ8/5Nno4dt6d506dybUYbhTDmFjtxwxjTvjVDhITiJVNoe5LyoGIQk4Ftd+QEcnlYPF+KY+DWc1WgPSqJeXjXxPpT9uXoBqGx6m7jylyvRvm8hGApuNAyWis98rXYvevZVSguzgfw8kGf3aR4gd2DNUcQX1qXHavvLFrpv6L/nt/d+9RXV8OFDCFEAhHBt+qSr6/FN+37JVS7BC9zwOXj6/JW04JLB7m984v/HIiX77m7iH5kL1198ov8OI0ziX01b32Fo9c3VHzce9xdcs+LC0TeHPKRfmulOLcZfTyW2ICz6Dr5Fl4F41o1q1nYeAts6buhieSy3e+kqzM7PP885AtfB0FJOCoUZnUQSyllAU3kmk4ckAuRqC2OXAh1b3ylaBj9Ka3PidQQxJcBEtGrWRncv2ejrEjVCnSX9tYOuBk07YI4J6MYppcBU0pEgOvDtv+xCCTrtwL5l87wVO3O/g5GQAAAABJRU5ErkJggg=="
	},
	"down-rectangle": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAkAAAAECAYAAABcDxXOAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAABpJREFUGFdjgIL/eDAKIKgABggqgAE0BQwMAPTlD/Fpi0JfAAAAAElFTkSuQmCC"
	},
	"filter-off": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAChSURBVChTzZHBCoUgFET9TqEiskgyWoutQvRLRIr+cR7XQAjiJW/1BgZmMUevXsY5xy9OoDEGMcYiUzeB67qibVuwQjVNA6311V+WBeM4vsLDMEApde/1fY9pmtI453neHEKAlBJd1z0fXtc16PbjODK07zvmeUZVVd8nooc75zJIOX3Gm6i0bVsGKf8xKIRIuyJTLgJJ3nvQzsjW2geIsQ/pr9hMVrSncAAAAABJRU5ErkJggg=="
	},
	"filter-on": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAACoSURBVChTY3BqfP2fHAzWmDbj7f8p294RhVOBasEa02e+/e/VBmQQCTxaX/9PnvYGoj5ywpv/Qd2ENft3vv4f1gfVBAP+nW/+h/a+ATtn1q73KHjytvdgg3070DTBgHvL6/8g22fsQGiaDmSHA21xaybgIpDHixa8hWssnA8NDEIApCh3LkIjiD2INYJCL2X6W3B8gdhEaQQBUOCA4gyE8+e9xaKJgQEA/74BNE3cElkAAAAASUVORK5CYII="
	},
	"unchecked": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAARBJREFUOE+9krtug1AQRPldSio7FQ1tZImOkoKOBomGT0EURC5ino54yTw90WywQhTkIkVWGoF2zuxdrlD+t0zThKZpT0Vmxb8CQRCg6zr0fb8rer7vfwcPxxdcrx+YpgnzPGNZlh9ibxxHlGUJshLSdV0at9tNpg7DIBrX5+OkPM9BVkKGYSBJEtR1jbZrBdiqbVtUVYU0TUFWQq+nE+I4xvvlImGaW7FHjwxZCVmWhbfzGVmWoSgKWXUr9uiRISshx3FkEldomubXauzRI0NWQp7nyUR+NG/rfr/jUXxnjx5vmKyEbNuWox9Xvid6ZMhK6HA4wnVdhGGIKIp2RY8MWQmx+JuoqvpUZFb8L6UonyYL3uOtrFH+AAAAAElFTkSuQmCC"
	},
	"up-down-spin": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAYAAADUFP50AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGJJREFUOE+lkwEKACEIBH2Zb/PnHsoGeaVJDUjGOgRRpKpkiIj+y4MME3eDR7kaKOVNsJyMNjIHzGy9YnW6J7qIcrriQimeCqORNABd0fpRTkt8uVUj7EsxC6vs/q3e/Q6iD2bwnByjPXHNAAAAAElFTkSuQmCC"
	},
	"up-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAYAAADUFP50AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGFJREFUOE+lkkEKQCEIRD2ZJ3Ph3iN4WD9GflpYhj0YYowpGgJmbikd3gjMDFokwbuT1iAiurG5nomgqo5QaPo9ERQRI6Jf7sfGjudy2je23+i0Wl2oQ85TOdlfrJQOazF8br+rqTXQKn0AAAAASUVORK5CYII="
	},
};

},{}],4:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');

var images = require('./images'); // this is the file generated by gulpfile.js (and ignored by git)

_(images).each(function(image, key) {
    var element = new Image();
    element.src = 'data:' + image.type + ';base64,' + image.data;
    images[key] = element;
});

images.checkbox = function(state) {
    return images[state ? 'checked' : 'unchecked'];
};

images.filter = function(state) {
    return images[state ? 'filter-on' : 'filter-off'];
};

module.exports = images;

},{"./images":3,"object-iterators":46}],5:[function(require,module,exports){
/* eslint-env browser */

'use strict';

/** @module automat */

var ENCODERS = /%\{(\d+)\}/g; // double $$ to encode

var REPLACERS = /\$\{(.*?)\}/g; // single $ to replace


/**
 * @summary String formatter.
 *
 * @desc String substitution is performed on numbered _replacer_ patterns like `${n}` or _encoder_ patterns like `%{n}` where n is the zero-based `arguments` index. So `${0}` would be replaced with the first argument following `text`.
 *
 * Encoders are just like replacers except the argument is HTML-encoded before being used.
 *
 * To change the format patterns, assign new `RegExp` patterns to `automat.encoders` and `automat.replacers`.
 *
 * @param {string|function} template - A template to be formatted as described above. Overloads:
 * * A string primitive containing the template.
 * * A function to be called with `this` as the calling context. The template is the value returned from this call.
 *
 * @param {...*} [replacements] - Replacement values for numbered format patterns.
 *
 * @return {string} The formatted text.
 *
 * @memberOf module:automat
 */
function automat(template, replacements/*...*/) {
    var hasReplacements = arguments.length > 1;

    // if `template` is a function, convert it to text
    if (typeof template === 'function') {
        template = template.call(this); // non-template function: call it with context and use return value
    }

    if (hasReplacements) {
        var args = arguments;
        template = template.replace(automat.replacersRegex, function(match, key) {
            key -= -1; // convert to number and increment
            return args.length > key ? args[key] : '';
        });

        template = template.replace(automat.encodersRegex, function(match, key) {
            key -= -1; // convert to number and increment
            if (args.length > key) {
                var htmlEncoderNode = document.createElement('DIV');
                htmlEncoderNode.textContent = args[key];
                return htmlEncoderNode.innerHTML;
            } else {
                return '';
            }
        });
    }

    return template;
}

/**
 * @summary Replace contents of `el` with `Nodes` generated from formatted template.
 *
 * @param {string|function} template - See `template` parameter of {@link automat}.
 *
 * @param {HTMLElement} [el] - Node in which to return markup generated from template. If omitted, a new `<div>...</div>` element will be created and returned.
 *
 * @param {...*} [replacements] - Replacement values for numbered format patterns.
 *
 * @return {HTMLElement} The `el` provided or a new `<div>...</div>` element, its `innerHTML` set to the formatted text.
 *
 * @memberOf module:automat
 */
function replace(template, el, replacements/*...*/) {
    var elOmitted = typeof el !== 'object',
        args = Array.prototype.slice.call(arguments, 1);

    if (elOmitted) {
        el = document.createElement('DIV');
        args.unshift(template);
    } else {
        args[0] = template;
    }

    el.innerHTML = automat.apply(null, args);

    return el;
}

/**
 * @summary Append or insert `Node`s generated from formatted template into given `el`.
 *
 * @param {string|function} template - See `template` parameter of {@link automat}.
 *
 * @param {HTMLElement} el
 *
 * @param {Node} [referenceNode=null] Inserts before this element within `el` or at end of `el` if `null`.
 *
 * @param {...*} [replacements] - Replacement values for numbered format patterns.
 *
 * @returns {Node[]} Array of the generated nodes (this is an actual Array instance; not an Array-like object).
 *
 * @memberOf module:automat
 */
function append(template, el, referenceNode, replacements/*...*/) {
    var replacementsStartAt = 3,
        referenceNodeOmitted = typeof referenceNode !== 'object';  // replacements are never objects

    if (referenceNodeOmitted) {
        referenceNode = null;
        replacementsStartAt = 2;
    }

    replacements = Array.prototype.slice.call(arguments, replacementsStartAt);
    var result = [],
        div = replace.apply(null, [template].concat(replacements));

    while (div.childNodes.length) {
        result.push(div.firstChild);
        el.insertBefore(div.firstChild, referenceNode); // removes child from div
    }

    return result;
}

/**
 * Use this convenience wrapper to return the first child node described in `template`.
 *
 * @param {string|function} template - If a function, extract template from comment within.
 *
 * @returns {HTMLElement} The first `Node` in your template.
 *
 * @memberOf module:automat
 */
function firstChild(template, replacements/*...*/) {
    return replace.apply(null, arguments).firstChild;
}

/**
 * Use this convenience wrapper to return the first child element described in `template`.
 *
 * @param {string|function} template - If a function, extract template from comment within.
 *
 * @returns {HTMLElement} The first `HTMLElement` in your template.
 *
 * @memberOf module:automat
 */
function firstElement(template, replacements/*...*/) {
    return replace.apply(null, arguments).firstElementChild;
}

/**
 * @summary Finds string substitution lexemes that require HTML encoding.
 * @desc Modify to suit.
 * @default %{n}
 * @type {RegExp}
 * @memberOf module:automat
 */
automat.encodersRegex = ENCODERS;

/**
 * @summary Finds string substitution lexemes.
 * @desc Modify to suit.
 * @default ${n}
 * @type {RegExp}
 * @memberOf module:automat
 */
automat.replacersRegex = REPLACERS;

automat.format = automat; // if you find using just `automat()` confusing
automat.replace = replace;
automat.append = append;
automat.firstChild = firstChild;
automat.firstElement = firstElement;

module.exports = automat;

},{}],6:[function(require,module,exports){
'use strict';

/* eslint-env browser */

/** @namespace cssInjector */

/**
 * @summary Insert base stylesheet into DOM
 *
 * @desc Creates a new `<style>...</style>` element from the named text string(s) and inserts it but only if it does not already exist in the specified container as per `referenceElement`.
 *
 * > Caveat: If stylesheet is for use in a shadow DOM, you must specify a local `referenceElement`.
 *
 * @returns A reference to the newly created `<style>...</style>` element.
 *
 * @param {string|string[]} cssRules
 * @param {string} [ID]
 * @param {undefined|null|Element|string} [referenceElement] - Container for insertion. Overloads:
 * * `undefined` type (or omitted): injects stylesheet at top of `<head>...</head>` element
 * * `null` value: injects stylesheet at bottom of `<head>...</head>` element
 * * `Element` type: injects stylesheet immediately before given element, wherever it is found.
 * * `string` type: injects stylesheet immediately before given first element found that matches the given css selector.
 *
 * @memberOf cssInjector
 */
function cssInjector(cssRules, ID, referenceElement) {
    if (typeof referenceElement === 'string') {
        referenceElement = document.querySelector(referenceElement);
        if (!referenceElement) {
            throw 'Cannot find reference element for CSS injection.';
        }
    } else if (referenceElement && !(referenceElement instanceof Element)) {
        throw 'Given value not a reference element.';
    }

    var container = referenceElement && referenceElement.parentNode || document.head || document.getElementsByTagName('head')[0];

    if (ID) {
        ID = cssInjector.idPrefix + ID;

        if (container.querySelector('#' + ID)) {
            return; // stylesheet already in DOM
        }
    }

    var style = document.createElement('style');
    style.type = 'text/css';
    if (ID) {
        style.id = ID;
    }
    if (cssRules instanceof Array) {
        cssRules = cssRules.join('\n');
    }
    cssRules = '\n' + cssRules + '\n';
    if (style.styleSheet) {
        style.styleSheet.cssText = cssRules;
    } else {
        style.appendChild(document.createTextNode(cssRules));
    }

    if (referenceElement === undefined) {
        referenceElement = container.firstChild;
    }

    container.insertBefore(style, referenceElement);

    return style;
}

/**
 * @summary Optional prefix for `<style>` tag IDs.
 * @desc Defaults to `'injected-stylesheet-'`.
 * @type {string}
 * @memberOf cssInjector
 */
cssInjector.idPrefix = 'injected-stylesheet-';

// Interface
module.exports = cssInjector;

},{}],7:[function(require,module,exports){
'use strict';

/** @namespace extend-me **/

/** @summary Extends an existing constructor into a new constructor.
 *
 * @returns {ChildConstructor} A new constructor, extended from the given context, possibly with some prototype additions.
 *
 * @desc Extends "objects" (constructors), with optional additional code, optional prototype additions, and optional prototype member aliases.
 *
 * > CAVEAT: Not to be confused with Underscore-style .extend() which is something else entirely. I've used the name "extend" here because other packages (like Backbone.js) use it this way. You are free to call it whatever you want when you "require" it, such as `var inherits = require('extend')`.
 *
 * Provide a constructor as the context and any prototype additions you require in the first argument.
 *
 * For example, if you wish to be able to extend `BaseConstructor` to a new constructor with prototype overrides and/or additions, basic usage is:
 *
 * ```javascript
 * var Base = require('extend-me').Base;
 * var BaseConstructor = Base.extend(basePrototype); // mixes in .extend
 * var ChildConstructor = BaseConstructor.extend(childPrototypeOverridesAndAdditions);
 * var GrandchildConstructor = ChildConstructor.extend(grandchildPrototypeOverridesAndAdditions);
 * ```
 *
 * This function (`extend()`) is added to the new extended object constructor as a property `.extend`, essentially making the object constructor itself easily "extendable." (Note: This is a property of each constructor and not a method of its prototype!)
 *
 * @param {string} [extendedClassName] - This is simply added to the prototype as $$CLASS_NAME. Useful for debugging because all derived constructors appear to have the same name ("Constructor") in the debugger. This property is ignored unless `extend.debug` is explicitly set to a truthy value.
 *
 * @param {extendedPrototypeAdditionsObject} [prototypeAdditions] - Object with members to copy to new constructor's prototype. Most members will be copied to the prototype. Some members, however, have special meanings as explained in the {@link extendedPrototypeAdditionsObject|type definition} (and may or may not be copied to the prototype).
 *
 * @property {boolean} [debug] - See parameter `extendedClassName` _(above)_.
 *
 * @property {object} Base - A convenient base class from which all other classes can be extended.
 *
 * @memberOf extend-me
 */
function extend(extendedClassName, prototypeAdditions) {
    switch (arguments.length) {
        case 0:
            prototypeAdditions = {};
            break;
        case 1:
            prototypeAdditions = extendedClassName;
            if (typeof prototypeAdditions !== 'object') {
                throw 'Single parameter overload must be object.';
            }
            extendedClassName = undefined;
            break;
        case 2:
            if (typeof extendedClassName !== 'string' || typeof prototypeAdditions !== 'object') {
                throw 'Two parameter overload must be string, object.';
            }
            break;
        default:
            throw 'Too many parameters';
    }

    function Constructor() {
        if (prototypeAdditions.preInitialize) {
            prototypeAdditions.preInitialize.apply(this, arguments);
        }

        initializePrototypeChain.apply(this, arguments);

        if (prototypeAdditions.postInitialize) {
            prototypeAdditions.postInitialize.apply(this, arguments);
        }
    }

    Constructor.extend = extend;

    var prototype = Constructor.prototype = Object.create(this.prototype);
    prototype.constructor = Constructor;

    if (extendedClassName && extend.debug) {
        prototype.$$CLASS_NAME = extendedClassName;
    }

    for (var key in prototypeAdditions) {
        if (prototypeAdditions.hasOwnProperty(key)) {
            var value = prototypeAdditions[key];
            switch (key) {
                case 'initializeOwn':
                    // already called above; not needed in prototype
                    break;
                case 'aliases':
                    for (var alias in value) {
                        if (value.hasOwnProperty(alias)) {
                            makeAlias(value[alias], alias);
                        }
                    }
                    break;
                default:
                    if (typeof value === 'string' && value[0] === '#') {
                        makeAlias(value, key.substr(1));
                    } else {
                        prototype[key] = value;
                    }
            }
        }
    }

    return Constructor;

    function makeAlias(value, key) { // eslint-disable-line no-shadow
        prototype[key] = prototypeAdditions[value];
    }
}

function Base() {}
Base.prototype = {
    constructor: Base.prototype.constructor,
    get super() {
        return Object.getPrototypeOf(Object.getPrototypeOf(this));
    }
};
Base.extend = extend;
extend.Base = Base;

/** @typedef {function} extendedConstructor
 * @property prototype.super - A reference to the prototype this constructor was extended from.
 * @property [extend] - If `prototypeAdditions.extendable` was truthy, this will be a reference to {@link extend.extend|extend}.
 */

/** @typedef {object} extendedPrototypeAdditionsObject
 * @property {function} [initialize] - Additional constructor code for new object. This method is added to the new constructor's prototype. Gets passed new object as context + same args as constructor itself. Called on instantiation after similar function in all ancestors called with same signature.
 * @property {function} [initializeOwn] - Additional constructor code for new object. This method is added to the new constructor's prototype. Gets passed new object as context + same args as constructor itself. Called on instantiation after (all) the `initialize` function(s).
 * @property {object} [aliases] - Hash of aliases for prototype members in form `{ key: 'member', ... }` where `key` is the name of an alieas and `'member'` is the name of an existing member in the prototype. Each such key is added to the prototype as a reference to the named member. (The `aliases` object itself is *not* added to prototype.) Alternatively:
 * @property {string} [keys] - Arbitrary property names defined here with string values starting with a `#` character will alias the actual properties named in the strings (following the `#`). This is an alternative to providing an `aliases` hash, perhaps simpler (though subtler). (Use arbitrary identifiers here; don't use the name `keys`!)
 * @property {*} [arbitraryProperties] - Any additional arbitrary properties defined here will be added to the new constructor's prototype. (Use arbitrary identifiers here; don't use the name `aribitraryProperties`!)
 */

/** @summary Call all `initialize` methods found in prototype chain.
 * @desc This recursive routine is called by the constructor.
 * 1. Walks back the prototype chain to `Object`'s prototype
 * 2. Walks forward to new object, calling any `initialize` methods it finds along the way with the same context and arguments with which the constructor was called.
 * @private
 * @memberOf extend-me
 */
function initializePrototypeChain() {
    var term = this,
        args = arguments;
    recur(term);

    function recur(obj) {
        var proto = Object.getPrototypeOf(obj);
        if (proto.constructor !== Object) {
            recur(proto);
            if (proto.hasOwnProperty('initialize')) {
                proto.initialize.apply(term, args);
            }
        }
    }
}

module.exports = extend;

},{}],8:[function(require,module,exports){
'use strict';

exports['column-CQL-syntax'] = [
'<li>',
'	<button type="button" class="copy"></button>',
'	<div class="filter-tree-remove-button" title="delete conditional"></div>',
'	{1}:',
'	<input name="{2}" class="{4}" value="{3:encode}">',
'</li>'
].join('\n');

exports['column-SQL-syntax'] = [
'<li>',
'	<button type="button" class="copy"></button>',
'	<div class="filter-tree-remove-button" title="delete conditional"></div>',
'	{1}:',
'	<textarea name="{2}" rows="1" class="{4}">{3:encode}</textarea>',
'</li>'
].join('\n');

exports.columnFilter = [
'<span class="filter-tree">',
'	 <strong><span>{2} </span>column filter subexpression:</strong><br>',
'	 Match',
'	 <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-or">any</label>',
'	 <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-and">all</label>',
'	 <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-nor">none</label>',
'	 of the following:',
'	 <select>',
'		 <option value="">New expression&hellip;</option>',
'	 </select>',
'	 <ol></ol>',
' </span>'
].join('\n');

exports.columnFilters = [
'<span class="filter-tree filter-tree-type-column-filters">',
'	 Match <strong>all</strong> of the following column filters:',
'	 <ol></ol>',
' </span>'
].join('\n');

exports.lockedColumn = [
'<span>',
'	 {1:encode}',
'	 <input type="hidden" value="{2}">',
' </span>'
].join('\n');

exports.note = [
'<div class="footnotes">',
'	<div class="footnote"></div>',
'	<p>Select a new value or delete the expression altogether.</p>',
'</div>'
].join('\n');

exports.notes = [
'<div class="footnotes">',
'	<p>Note the following error conditions:</p>',
'	<ul class="footnote"></ul>',
'	<p>Select new values or delete the expression altogether.</p>',
'</div>'
].join('\n');

exports.optionMissing = [
'The requested value of <span class="field-name">{1:encode}</span>',
'(<span class="field-value">{2:encode}</span>) is not valid.'
].join('\n');

exports.removeButton = [
'<div class="filter-tree-remove-button" title="delete conditional"></div>'
].join('\n');

exports.subtree = [
'<span class="filter-tree">',
'	 Match',
'	 <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-or">any</label>',
'	 <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-and">all</label>',
'	 <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-nor">none</label>',
'	 of the following:',
'	 <select>',
'		 <option value="">New expression&hellip;</option>',
'		 <option value="subexp" style="border-bottom:1px solid black">Subexpression</option>',
'	 </select>',
'	 <ol></ol>',
' </span>'
].join('\n');

},{}],9:[function(require,module,exports){
'use strict';

var _ = require('object-iterators');
var popMenu = require('pop-menu');

var FilterTree = require('./js/FilterTree');
FilterTree.Node = require('./js/FilterNode'); // aka: Object.getPrototypeOf(FilterTree.prototype).constructor
FilterTree.Leaf = require('./js/FilterLeaf'); // aka: FilterTree.prototype.editors.Default

// expose some objects for plug-in access

FilterTree.Conditionals = require('./js/Conditionals');

// FOLLOWING PROPERTIES ARE *** TEMPORARY ***,
// FOR THE DEMO TO ACCESS THESE NODE MODULES.

FilterTree._ = _;
FilterTree.popMenu = popMenu;


module.exports = FilterTree;

},{"./js/Conditionals":10,"./js/FilterLeaf":11,"./js/FilterNode":12,"./js/FilterTree":13,"object-iterators":46,"pop-menu":47}],10:[function(require,module,exports){
/** @module conditionals */

'use strict';

var Base = require('extend-me').Base;
var _ = require('object-iterators');
var regExpLIKE = require('regexp-like');

var IN = 'IN',
    NOT_IN = 'NOT ' + IN,
    LIKE = 'LIKE',
    NOT_LIKE = 'NOT ' + LIKE,
    LIKE_WILD_CARD = '%',
    NIL = '';

var toString;

var defaultIdQts = {
    beg: '"',
    end: '"'
};


/**
 * @constructor
 */
var Conditionals = Base.extend({
    /**
     * @param {sqlIdQtsObject} [options.sqlIdQts={beg:'"',end:'"'}]
     * @memberOf Conditionals.prototype
     */
    initialize: function(options) {
        var idQts = options && options.sqlIdQts;
        if (idQts) {
            this.sqlIdQts = idQts; // only override if defined
        }
    },

    sqlIdQts: defaultIdQts,
    /**
     * @param id
     * @returns {string}
     * @memberOf Conditionals.prototype
     */
    makeSqlIdentifier: function(id) {
        return this.sqlIdQts.beg + id + this.sqlIdQts.end;
    },

    /**
     * @param string
     * @returns {string}
     * @memberOf Conditionals.prototype
     */
    makeSqlString: function(string) {
        return '\'' + sqEsc(string) + '\'';
    },

    /**
     * @memberOf Conditionals.prototype
     */
    makeLIKE: function(beg, end, op, originalOp, c) {
        var escaped = c.operand.replace(/([_\[\]%])/g, '[$1]'); // escape all LIKE reserved chars
        return this.makeSqlIdentifier(c.column) +
            ' ' + op +
            ' ' + this.makeSqlString(beg + escaped + end);
    },

    /**
     * @memberOf Conditionals.prototype
     */
    makeIN: function(op, c) {
        return this.makeSqlIdentifier(c.column) +
            ' ' + op +
            ' ' + '(\'' + sqEsc(c.operand).replace(/\s*,\s*/g, '\', \'') + '\')';
    },

    /**
     * @memberOf Conditionals.prototype
     */
    make: function(op, c) {
        return this.makeSqlIdentifier(c.column) +
            ' ' + op +
            ' ' + c.makeSqlOperand();
    }
});

var ops = Conditionals.prototype.ops = {
    undefined: {
        test: function() { return true; },
        make: function() { return ''; }
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    '<': {
        test: function(a, b) { return a < b; },
        make: function(c) { return this.make('<', c); }
    },
    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    '<=': {
        test: function(a, b) { return a <= b; },
        make: function(c) { return this.make('<=', c); }
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    '=': {
        test: function(a, b) { return a === b; },
        make: function(c) { return this.make('=', c); }
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    '>=': {
        test: function(a, b) { return a >= b; },
        make: function(c) { return this.make('>=', c); }
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    '>': {
        test: function(a, b) { return a > b; },
        make: function(c) { return this.make('>', c); }
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    '<>': {
        test: function(a, b) { return a !== b; },
        make: function(c) { return this.make('<>', c); }
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    LIKE: {
        test: function(a, b) { return regExpLIKE.cached(b, true).test(a); },
        make: function(c) { return this.make(LIKE, c); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    'NOT LIKE': {
        test: function(a, b) { return !regExpLIKE.cached(b, true).test(a); },
        make: function(c) { return this.make(NOT_LIKE, c); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    IN: { // TODO: currently forcing string typing; rework calling code to respect column type
        test: function(a, b) { return inOp(a, b) >= 0; },
        make: function(c) { return this.makeIN(IN, c); },
        operandList: true,
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    'NOT IN': { // TODO: currently forcing string typing; rework calling code to respect column type
        test: function(a, b) { return inOp(a, b) < 0; },
        make: function(c) { return this.makeIN(NOT_IN, c); },
        operandList: true,
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    CONTAINS: {
        test: function(a, b) { return containsOp(a, b) >= 0; },
        make: function(c) { return this.makeLIKE(LIKE_WILD_CARD, LIKE_WILD_CARD, LIKE, 'CONTAINS', c); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    'NOT CONTAINS': {
        test: function(a, b) { return containsOp(a, b) < 0; },
        make: function(c) { return this.makeLIKE(LIKE_WILD_CARD, LIKE_WILD_CARD, NOT_LIKE, 'NOT CONTAINS', c); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    BEGINS: {
        test: function(a, b) { b = toString(b); return beginsOp(a, b.length) === b; },
        make: function(c) { return this.makeLIKE(NIL, LIKE_WILD_CARD, LIKE, 'BEGINS', c); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    'NOT BEGINS': {
        test: function(a, b) { b = toString(b); return beginsOp(a, b.length) !== b; },
        make: function(c) { return this.makeLIKE(NIL, LIKE_WILD_CARD, NOT_LIKE, 'NOT BEGINS', c); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    ENDS: {
        test: function(a, b) { b = toString(b); return endsOp(a, b.length) === b; },
        make: function(c) { return this.makeLIKE(LIKE_WILD_CARD, NIL, LIKE, 'ENDS', c); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    'NOT ENDS': {
        test: function(a, b) { b = toString(b); return endsOp(a, b.length) !== b; },
        make: function(c) { return this.makeLIKE(LIKE_WILD_CARD, NIL, NOT_LIKE, 'NOT ENDS', c); },
        type: 'string'
    }
};

// some synonyms
ops['\u2264'] = ops['<='];  // UNICODE 'LESS-THAN OR EQUAL TO'
ops['\u2265'] = ops['>='];  // UNICODE 'GREATER-THAN OR EQUAL TO'
ops['\u2260'] = ops['<>'];  // UNICODE 'NOT EQUAL TO'

function inOp(a, b) {
    return b
        .trim() // remove leading and trailing space chars
        .replace(/\s*,\s*/g, ',') // remove any white-space chars from around commas
        .split(',') // put in an array
        .indexOf((a + '')); // search array whole matches
}

function containsOp(a, b) {
    return toString(a).indexOf(toString(b));
}

function beginsOp(a, length) {
    return toString(a).substr(0, length);
}

function endsOp(a, length) {
    return toString(a).substr(-length, length);
}

function sqEsc(string) {
    return string.replace(/'/g, '\'\'');
}

var groups = {
    equality: {
        label: 'Equality',
        submenu: ['=']
    },
    inequalities: {
        label: 'Inequalities',
        submenu: [
            '<',
            '\u2264', // UNICODE 'LESS-THAN OR EQUAL TO'; on a Mac, type option-comma ()
            '\u2260', // UNICODE 'NOT EQUALS'; on a Mac, type option-equals ()
            '\u2265', // UNICODE 'GREATER-THAN OR EQUAL TO'; on a Mac, type option-period ()
            '>'
        ]
    },
    sets: {
        label: 'Set scans',
        submenu: ['IN', 'NOT IN']
    },
    strings: {
        label: 'String scans',
        submenu: [
            'CONTAINS', 'NOT CONTAINS',
            'BEGINS', 'NOT BEGINS',
            'ENDS', 'NOT ENDS'
        ]
    },
    patterns: {
        label: 'Pattern scans',
        submenu: ['LIKE', 'NOT LIKE']
    }
};

// add a `name` prop to each group
_(groups).each(function(group, key) { group.name = key; });

/**
 * @memberOf Conditionals
 */
Conditionals.groups = groups;

/** Default operator menu when consisting of all of the groups in {@link module:conditionals.groups|groups}. This menu is used when none of the following is otherwise defined:
 * * The `opMenu` property of the column schema.
 * * The entry in the node's `typeOpMap` hash corresponding to the `type` property of the column schema.
 * * The node's `treeOpMenu` object.
 * @type {menuItem[]}
 * @memberOf Conditionals
 */
Conditionals.defaultOpMenu = [ // hierarchical menu of relational operators
    groups.equality,
    groups.inequalities,
    groups.sets,
    groups.strings,
    groups.patterns
];


// Meant to be called by FilterTree.prototype.setSensitivity only
Conditionals.setToString = function(fn) {
    return (toString = fn);
};

module.exports = Conditionals;

},{"extend-me":7,"object-iterators":46,"regexp-like":49}],11:[function(require,module,exports){
/* eslint-env browser */
/* eslint-disable key-spacing */

'use strict';

var popMenu = require('pop-menu');

var FilterNode = require('./FilterNode');
var Conditionals = require('./Conditionals');


var toString; // set by FilterLeaf.setToString() called from ../index.js


/** @typedef {object} converter
 * @property {function} toType - Returns input value converted to type. Fails silently.
 * @property {function} failed - Tests input value against type, returning `false if type or `true` if not type.
 */

/** @type {converter} */
var numberConverter = {
    toType: Number,
    failed: isNaN
};

/** @type {converter} */
var dateConverter = {
    toType: function(s) { return new Date(s); },
    failed: isNaN
};

/**
 * @typedef {object} filterLeafViewObject
 *
 * @property {HTMLElement} column - A drop-down with options from the `FilterLeaf` instance's schema. Value is the name of the column being tested (i.e., the column to which this conditional expression applies).
 *
 * @property operator - A drop-down with options from {@link columnOpMenu}, {@link typeOpMap}, or {@link treeOpMenu}. Value is the string representation of the operator.
 *
 * @property operand - An input element, such as a drop-down or a text box.
 */

/** @constructor
 * @summary An object that represents a conditional expression node in a filter tree.
 * @desc This object represents a conditional expression. It is always a terminal node in the filter tree; it has no child nodes of its own.
 *
 * A conditional expression is a simple dyadic expression with the following syntax in the UI:
 *
 * > _column operator operand_
 *
 * where:
 * * _column_ is the name of a column from the data row object
 * * _operator_ is the name of an operator from the node's operator list
 * * _operand_ is a literal value to compare against the value in the named column
 *
 * **NOTE:** The {@link ColumnLeaf} extension of this object has a different implementation of _operand_ which is: The name of a column from which to fetch the compare value (from the same data row object) to compare against the value in the named column. See *Extending the conditional expression object* in the {@link http://joneit.github.io/filter-tree/index.html|readme}.
 *
 * The values of the terms of the expression above are stored in the first three properties below. Each of these three properties is set either by `setState()` or by the user via a control in `el`. Note that these properties are not dynamically bound to the UI controls; they are updated by the validation function, `invalid()`.
 *
 * **See also the properties of the superclass:** {@link FilterNode}
 *
 * @property {string} column - Name of the member in the data row objects against which `operand` will be compared. Reflects the value of the `view.column` control after validation.
 *
 * @property {string} operator - Operator symbol. This must match a key in the `this.root.conditionals.ops` hash. Reflects the value of the `view.operator` control after validation.
 *
 * @property {string} operand - Value to compare against the the member of data row named by `column`. Reflects the value of the `view.operand` control, after validation.
 *
 * @property {string} name - Used to describe the object in the UI so user can select an expression editor.
 *
 * @property {string} [type='string'] - The data type of the subexpression if neither the operator nor the column schema defines a type.
 *
 * @property {HTMLElement} el - A `<span>...</span>` element that contains the UI controls. This element is automatically appeneded to the parent `FilterTree`'s `el`. Generated by {@link FilterLeaf#createView|createView}.
 *
 * @property {filterLeafViewObject} view - A hash containing direct references to the controls in `el`. Added by {@link FilterLeaf#createView|createView}.
 */
var FilterLeaf = FilterNode.extend('FilterLeaf', {

    name: 'column = value', // display string for drop-down

    destroy: function() {
        if (this.view) {
            for (var key in this.view) {
                this.view[key].removeEventListener('change', this.onChange);
            }
        }
    },

    /** @summary Create a new view.
     * @desc This new "view" is a group of HTML `Element` controls that completely describe the conditional expression this object represents. This method creates the view, setting `this.el` to point to it, and the members of `this.view` to point to the individual controls therein.
     * @memberOf FilterLeaf.prototype
     */
    createView: function(state) {
        var el = this.el = document.createElement('span');

        el.className = 'filter-tree-editor filter-tree-default';

        if (state && state.column) {
            // State includes column:
            // Operator menu is built later in loadState; we don't need to build it now. The call to
            // getOpMenu below with undefined columnName returns [] resulting in an empty drop-down.
        } else {
            // When state does NOT include column, it's because either:
            // a. column is unknown and op menu will be empty until user chooses a column; or
            // b. column is hard-coded when there's only one possible column as inferable from schema:
            var schema = this.schema && this.schema.length === 1 && this.schema[0],
                columnName = schema && schema.name || schema;
        }

        this.view = {
            column: this.makeElement(this.schema, 'column', this.sortColumnMenu),
            operator: this.makeElement(getOpMenu.call(this, columnName), 'operator'),
            operand: this.makeElement()
        };

        el.appendChild(document.createElement('br'));
    },

    loadState: function(state) {
        if (state) {
            var value, el, i, b, selected, notes = [];
            for (var key in state) {
                if (!FilterNode.optionsSchema[key]) {
                    value = this[key] = state[key];
                    el = this.view[key];
                    switch (el.type) {
                        case 'checkbox':
                        case 'radio':
                            el = document.querySelectorAll('input[name=\'' + el.name + '\']');
                            for (i = 0; i < el.length; i++) {
                                el[i].checked = value.indexOf(el[i].value) >= 0;
                            }
                            break;
                        case 'select-multiple':
                            el = el.options;
                            for (i = 0, b = false; i < el.length; i++, b = b || selected) {
                                selected = value.indexOf(el[i].value) >= 0;
                                el[i].selected = selected;
                            }
                            FilterNode.setWarningClass(el, b);
                            break;
                        default:
                            el.value = value;
                            if (FilterNode.setWarningClass(el) !== value) {
                                notes.push({ key: key, value: value });
                            } else if (key === 'column') {
                                makeOpMenu.call(this, value);
                            }
                    }
                }
            }
            if (notes.length) {
                var multiple = notes.length > 1,
                    templates = this.templates,
                    footnotes = templates.get(multiple ? 'notes' : 'note'),
                    inner = footnotes.querySelector('.footnote');
                notes.forEach(function(note) {
                    var footnote = multiple ? document.createElement('li') : inner;
                    note = templates.get('optionMissing', note.key, note.value);
                    while (note.length) { footnote.appendChild(note[0]); }
                    if (multiple) { inner.appendChild(footnote); }
                });
            }
            this.notesEl = footnotes;
        }
    },

    /**
     * @property {converter} number
     * @property {converter} int - synonym of `number`
     * @property {converter} float - synonym of `number`
     * @property {converter} date
     * @property {converter} string
     */
    converters: {
        number: numberConverter,
        int: numberConverter,
        float: numberConverter,
        date: dateConverter
    },

    /**
     * Called by the parent node's {@link FilterTree#invalid|invalid()} method, which catches the error thrown when invalid.
     *
     * Also performs the following compilation actions:
     * * Copies all `this.view`' values from the DOM to similarly named properties of `this`.
     * * Pre-sets `this.op` and `this.converter` for use in `test`'s tree walk.
     *
     * @param {boolean} [options.throw=false] - Throw an error if missing or invalid value.
     * @param {boolean} [options.focus=false] - Move focus to offending control.
     * @returns {undefined} This is the normal return when valid; otherwise throws error when invalid.
     * @memberOf FilterLeaf.prototype
     */
    invalid: function(options) {
        var elementName, type, focused;

        for (elementName in this.view) {
            var el = this.view[elementName],
                value = controlValue(el).trim();

            if (value === '') {
                if (!focused && options && options.focus) {
                    clickIn(el);
                    focused = true;
                }
                if (options && options.throw) {
                    throw new this.Error('Missing or invalid ' + elementName + ' in conditional expression. Complete the expression or remove it.', this);
                }
            } else {
                // Copy each controls's value as a new similarly named property of this object.
                this[elementName] = value;
            }
        }

        this.op = this.root.conditionals.ops[this.operator];

        type = this.getType();

        this.converter = type && type !== 'string' && this.converters[type];
    },

    getType: function() {
        return (
            this.op.type // the expression's operator's type (because some operators only work with strings)
            ||
            (this.schema.lookup(this.column) || {}).type // the expression's column schema type
            ||
            this.type // the expression node's type
        );
    },

    p: function(dataRow) { return dataRow[this.column]; },
    q: function() { return this.operand; },

    test: function(dataRow) {
        var p, q, // untyped versions of args
            P, Q, // typed versions of p and q
            converter;

        // TODO: If a literal (i.e., when this.q is not overridden), q only needs to be fetched & converted ONCE for all rows
        return (
            // TODO: Uncomment following two lines if values can be functions
            //(p = valOrFunc(this.p(dataRow))) === undefined ||
            //(q = valOrFunc(this.q(dataRow))) === undefined
            (p = this.p(dataRow)) === undefined ||
            (q = this.q(dataRow)) === undefined
        )
            ? false // data inaccessible so exclude row
            : (
                (converter = this.converter) &&
                !converter.failed(P = converter.toType(p)) && // attempt to convert data to type
                !converter.failed(Q = converter.toType(q))
            )
                ? this.op.test(P, Q) // both conversions successful: compare as types
                : this.op.test(toString(p), toString(q)); // one or both conversions failed: compare as strings
    },

    toJSON: function() {
        var state = {};
        if (this.editor) {
            state.editor = this.editor;
        }
        for (var key in this.view) {
            state[key] = this[key];
        }
        if (this.schema !== this.parent.schema) {
            state.schema = this.schema;
        }
        return state;
    },

    /**
     * For `'object'` and `'JSON'` note that the subtree's version of `getState` will not call this leaf version of `getState` because the former uses `unstrungify()` and `JSON.stringify()`, respectively, both of which recurse and call `toJSON()` on their own.
     *
     * @param {object} [options='object'] - See the subtree version of {@link FilterTree#getState|getState} for more info.
     *
     * @memberOf FilterLeaf.prototype
     */
    getState: function getState(options) {
        var result = '',
            syntax = options && options.syntax || 'object';

        switch (syntax) {
            case 'object': // see note above
                result = this.toJSON();
                break;
            case 'JSON': // see note above
                result = JSON.stringify(this, null, options && options.space) || '';
                break;
            case 'SQL':
                result = this.getSyntax(this.root.conditionals);
        }

        return result;
    },

    makeSqlOperand: function() {
        return this.root.conditionals.makeSqlString(this.operand); // todo: this should be a number if type is number instead of a string -- but we will have to ensure it is numeric!
    },

    getSyntax: function(conditionals) {
        return this.root.conditionals.ops[this.operator].make.call(conditionals, this);
    },

    /** @summary HTML form controls factory.
     * @desc Creates and appends a text box or a drop-down.
     * > Defined on the FilterTree prototype for access by derived types (alternate filter editors).
     * @returns The new element.
     * @param {menuItem[]} [menu] - Overloads:
     * * If omitted, will create an `<input/>` (text box) element.
     * * If contains only a single option, will create a `<span>...</span>` element containing the string and a `<input type=hidden>` containing the value.
     * * Otherwise, creates a `<select>...</select>` element with these menu items.
     * @param {null|string} [prompt=''] - Adds an initial `<option>...</option>` element to the drop-down with this value, parenthesized, as its `text`; and empty string as its `value`. Omitting creates a blank prompt; `null` suppresses.
     * @param [sort]
     * @memberOf FilterLeaf.prototype
     */
    makeElement: function(menu, prompt, sort) {
        var el, result, options,
            option = menu,
            tagName = menu ? 'SELECT' : 'INPUT';

        // determine if there would be only a single item in the dropdown
        while (option instanceof Array) {
            if (option.length === 1 && !popMenu.isGroupProxy(option[0])) {
                option = option[0];
            } else {
                option = undefined;
            }
        }

        if (option) {
            // hard text when single item
            el = this.templates.get(
                'lockedColumn',
                option.alias || option.name || option,
                option.name || option.alias || option
            );
            result = el.querySelector('input');
        } else {
            options = {
                prompt: prompt,
                sort: sort,
                group: function(groupName) { return Conditionals.groups[groupName]; }
            };

            // make an element
            el = popMenu.build(tagName, menu, options);

            // if it's a textbox, listen for keyup events
            if (el.type === 'text' && this.eventHandler) {
                this.el.addEventListener('keyup', this.eventHandler);
            }

            // handle onchange events
            this.onChange = this.onChange || cleanUpAndMoveOn.bind(this);
            this.el.addEventListener('change', this.onChange);

            FilterNode.setWarningClass(el);
            result = el;
        }

        this.el.appendChild(el);

        return result;
    }
});

//function valOrFunc(vf) {
//var result = (typeof vf)[0] === 'f' ? vf() : vf;
//    return result || result === 0 ? result : '';
//}

/** `change` event handler for all form controls.
 * Rebuilds the operator drop-down as needed.
 * Removes error CSS class from control.
 * Adds warning CSS class from control if blank; removes if not blank.
 * Adds warning CSS class from control if blank; removes if not blank.
 * Moves focus to next non-blank sibling control.
 * @this Bound to this node.
 */
function cleanUpAndMoveOn(evt) {
    var el = evt.target;

    // remove `error` CSS class, which may have been added by `FilterLeaf.prototype.invalid`
    el.classList.remove('filter-tree-error');

    // set or remove 'warning' CSS class, as per el.value
    FilterNode.setWarningClass(el);

    if (el === this.view.column) {
        // rebuild operator list according to selected column name or type, restoring selected item
        makeOpMenu.call(this, el.value);
    }

    if (el.value) {
        // find next sibling control, if any
        if (!el.multiple) {
            while ((el = el.nextElementSibling) && (!('name' in el) || el.value.trim() !== '')); // eslint-disable-line curly
        }

        // and click in it (opens select list)
        if (el && el.value.trim() === '') {
            el.value = ''; // rid of any white space
            FilterNode.clickIn(el);
        }
    }

    // forward the event to the application's event handler
    if (this.eventHandler) {
        this.eventHandler(evt);
    }
}

function getOpMenu(columnName) {
    var column = this.schema.lookup(columnName) || {};
    return (
        column.opMenu
            ||
        this.typeOpMap && this.typeOpMap[column.type || this.type]
            ||
        this.opMenu
    );
}

function makeOpMenu(columnName) {
    var opMenu = getOpMenu.call(this, columnName);

    if (opMenu !== this.renderedOpMenu) {
        var newOpDrop = this.makeElement(opMenu, 'operator');

        newOpDrop.value = this.view.operator.value;
        this.el.replaceChild(newOpDrop, this.view.operator);
        this.view.operator = newOpDrop;

        FilterNode.setWarningClass(newOpDrop);

        this.renderedOpMenu = opMenu;
    }
}

function clickIn(el) {
    setTimeout(function() {
        el.classList.add('filter-tree-error');
        FilterNode.clickIn(el);
    }, 0);
}

function controlValue(el) {
    var value, i;

    switch (el.type) {
        case 'checkbox':
        case 'radio':
            el = document.querySelectorAll('input[name=\'' + el.name + '\']:enabled:checked');
            for (value = [], i = 0; i < el.length; i++) {
                value.push(el[i].value);
            }
            break;

        case 'select-multiple':
            el = el.options;
            for (value = [], i = 0; i < el.length; i++) {
                if (!el.disabled && el.selected) {
                    value.push(el[i].value);
                }
            }
            break;

        default:
            value = el.value;
    }

    return value;
}

// Meant to be called by FilterTree.prototype.setSensitivity only
FilterLeaf.setToString = function(fn) {
    toString = fn;
    return Conditionals.setToString(fn);
};


module.exports = FilterLeaf;

},{"./Conditionals":10,"./FilterNode":12,"pop-menu":47}],12:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');
var extend = require('extend-me'), Base = extend.Base; extend.debug = true;
var popMenu = require('pop-menu');

var cssInjector = require('./stylesheet');
var Templates = require('./Templates');
var Conditionals = require('./Conditionals');
var ParserSQL = require('./parser-SQL');


var CHILDREN_TAG = 'OL',
    CHILD_TAG = 'LI';

// JSON-detector: begins _and_ ends with either [ and ] _or_ { and }
var reJSON = /^\s*((\[[^]*\])|(\{[^]*\}))\s*$/;

function FilterTreeError(message, node) {
    this.message = message;
    this.node = node;
}
FilterTreeError.prototype = Object.create(Error.prototype);
FilterTreeError.prototype.name = 'FilterTreeError';

/** @typedef {object} FilterTreeSetStateOptionsObject
 *
 * @property {boolean} [syntax='auto'] - Specify parser to use on `state`. One of:
 * * `'auto'` - Auto-detect; see {@link FilterNode#parseStateString} for algorithm.
 * * `'object'` - A raw state object such as that produced by the [getState()]{@link FilterTree#getState} method.
 * * `'JSON'` - A JSON string version of a state object such as that produced by the [getState()]{@link FilterTree#getState} method.
 * * `'SQL'` - A SQL [search condition expression]{@link https://msdn.microsoft.com/en-us/library/ms173545.aspx} string.
 *
 * @param {Element} [context] If defined, the provided input string is used as a selector to an `HTMLElement` contained in `context`. The `value` property of this element is fetched from the DOM and is used as the input state string; proceed as above.
 */

/** @typedef {object} FilterTreeOptionsObject
 *
 * @property {menuItem[]} [schema] - A default list of column names for field drop-downs of all descendant terminal nodes. Overrides `options.state.schema` (see). May be defined for any node and pertains to all descendants of that node (including terminal nodes). If omitted (and no `ownSchema`), will use the nearest ancestor `schema` definition. However, descendants with their own definition of `types` will override any ancestor definition.
 *
 * > Typically only used by the caller for the top-level (root) tree.
 *
 * @property {menuItem[]} [ownSchema] - A default list of column names for field drop-downs of immediate descendant terminal nodes _only_. Overrides `options.state.ownSchema` (see).
 *
 * Although both `options.schema` and `options.ownSchema` are notated as optional herein, by the time a terminal node tries to render a schema drop-down, a `schema` list should be defined through (in order of priority):
 *
 * * Terminal node's own `options.schema` (or `options.state.schema`) definition.
 * * Terminal node's parent node's `option.ownSchema` (or `option.state.nodesFields`) definition.
 * * Terminal node's parent (or any ancestor) node's `options.schema` (or `options.state.schema`) definition.
 *
 * @property {FilterTreeStateObject} [state] - A data structure that describes a tree, subtree, or leaf (terminal node). If undefined, loads an empty filter, which is a `FilterTree` node consisting the default `operator` value (`'op-and'`).
 *
 * @property {function} [editor='Default'] - The name of the conditional expression's UI "editor." This name must be registered in the parent node's {@link FilterTree#editors|editors} hash, where it maps to a leaf constructor (`FilterLeaf` or a descendant thereof). (Use {@link FilterTree#addEditor} to register new editors.)
 *
 * @property {FilterTree} [parent] - Used internally to insert element when creating nested subtrees. The only time it may be (and must be) omitted is when creating the root node.
 *
 * @property {string|HTMLElement} [cssStylesheetReferenceElement] - passed to cssInsert
 */

/** @typedef {object|string} FilterTreeStateObject
 *
 * @summary State with which to create a new node or replace an existing node.
 *
 * @desc A string or plain object that describes a filter-tree node. If a string, it is parsed into an object by {@link FilterNode~parseStateString}. (See, for available overloads.)
 *
 * The resulting object may be a flat object that describes a terminal node or a childless root or branch node; or may be a hierarchical object to define an entire tree or subtree.
 *
 * In any case, the resulting object may have any of the following properties:
 *
 * @property {menuItem[]} [schema] - See `schema` property of {@link FilterTreeOptionsObject}.
 *
 * @property {string} [editor='Default'] - See `editor` property of {@link FilterTreeOptionsObject}.
 *
 * @property misc - Other miscellaneous properties will be copied directly to the new `FitlerNode` object. (The name "misc" here is just a stand-in; there is no specific property called "misc".)
 *
 * * May describe a non-terminal node with properties:
 *   * `schema` - Overridden on instantiation by `options.schema`. If both unspecified, uses parent's definition.
 *   * `operator` - One of {@link treeOperators}.
 *   * `children` -  Array containing additional terminal and non-terminal nodes.
 *
 * The constructor auto-detects `state`'s type:
 *  * JSON string to be parsed by `JSON.parse()` into a plain object
 *  * SQL WHERE clause string to be parsed into a plain object
 *  * CSS selector of an Element whose `value` contains one of the above
 *  * plain object
 */

/**
 * @constructor
 *
 * @summary A node in a filter tree.
 *
 * @description A filter tree represents a _complex conditional expression_ and consists of a single instance of a {@link FilterTree} object as the _root_ of an _n_-ary tree.
 *
 * Filter trees are comprised of instances of `FilterNode` objects. However, the `FilterNode` constructor is an "abstract class"; filter node objects are never instantiated directly from this constructor. A filter tree is actually comprised of instances of two "subclasses" of `FilterNode` objects:
 * * {@link FilterTree} (or subclass thereof) objects, instances of which represent the root node and all the branch nodes:
 *   * There is always exactly one root node, containing the whole filter tree, which represents the filter expression in its entirety. The root node is distinguished by having no parent node.
 *   * There are zero or more branch nodes, or subtrees, which are child nodes of the root or other branches higher up in the tree, representing subexpressions within the larger filter expression. Each branch node has exactly one parent node.
 *   * These nodes point to zero or more child nodes which are either nested subtrees, or:
 * * {@link FilterLeaf} (or subclass thereof) objects, each instance of which represents a single simple conditional expression. These are terminal nodes, having exactly one parent node, and no child nodes.
 *
 * The programmer may extend the semantics of filter trees by extending the above objects.
 *
 * @property {FilterNode} [parent] - Undefined means this is the root node.
 *
 * @property {FilterNode} root - Convenience reference to the root node.
 *
 * @property {menuItem[]} schema - Column schema used by descendant leaf nodes (including this node if it is a leaf node) to render a column choice drop-down.
 *
 * @property {string} [editor] - Name of filter editor used by descendant leaf nodes (including this node if it is a leaf node).
 *
 * @property {function} [eventHandler] - Event handler for UI events. See *Events* in the {@link http://joneit.github.io/filter-tree/index.html|readme} for more information.
 *
 * @property {menuItem[]} [treeOpMenu=Conditionals.defaultOpMenu] - Default operator menu for all descendant leaf nodes. Only used if the leaf node has no defined `opMenu` property _and_ there is no menu defined in `typeOpMenus` keyed to the column's `type`.
 *
 * @property {object} [typeOpMap] - A hash of type names. Each member thus defined contains a specific operator menu for all descendant leaf nodes that:
 * 1. do not have their own operator menu (`opMenu` property) of their own; and
 * 2. whose columns resolve to that type.
 *
 * The type is determined by (in priority order):
 * 1. the `type` property of the {@link FilterLeaf}; or
 * 2. the `type` property of the element in the nearest node (including the leaf node itself) that has a defined `ownSchema` or `schema` array property with an element having a matching column name.
 *
 * @property {sqlIdQtsObject} [sqlIdQts={beg:'"',end:'"'}] - Quote characters for SQL identifiers. Used for both parsing and generating SQL. Should be placed on the root node.
 *
 * @property {HTMLElement} el - The DOM element created by the `render` method to represent this node. Contains the `el`s for all child nodes (which are themselves pointed to by those nodes). This is always generated but is only in the page DOM if you put it there.
 */

var FilterNode = Base.extend('FilterNode', {

    /**
     * @summary Create a new node or subtree.
     * @desc Typically used by the application layer to create the entire filter tree; and internally, recursively, to create each node including both subtrees and leaves.
     *
     * **Node properties and options:** Nodes are instantiated with:
     * 1. Certain **required properties** which differ for subtrees and leaves.
     * 2. Arbitrary **non-standard option properties** are defined on the `options` object (so long as their names do not conflict with any standard options) and never persist.
     * 3. Certain **standard options properties** as defined in the {@link FilterNode~optionsSchema|optionsSchema} hash, come from various sources, as prioritized as follows:
     *    1. `options` object; does not persist
     *    2. `state`; object; persists
     *    3. `parent` object; persists
     *    4. `default` object; does not persist
     *
     * Notes:
     * 1. "Persists" means output by {@link FilterTree#getState|getState()}.
     * 2. The `parent` object is generated internally for subtrees. It allows standard options to inherit from the parent node.
     * 3. The `default` object comes from the `default` property, if any, of the {@link FilterNode~optionsSchema|schema object} for the standard option in question. Note that once defined, subtrees will then inherit this value.
     * 4. If not defined by any of the above, the standard option remains undefined on the node.
     *
     * **Query Builder UI support:** If your app wants to make use of the generated UI, you are responsible for inserting the top-level `.el` into the DOM. (Otherwise just ignore it.)
     *
     * @param {FilterTreeOptionsObject} [options] - The node state; or an options object possibly containing `state` among other options. Although you can instantiate a filter without any options, this is generally not useful. See *Instantiating a filter* in the {@link http://joneit.github.io/filter-tree/index.html|readme} for a practical discussion of minimum options.
     *
     * * @memberOf FilterNode.prototype
     */
    initialize: function(options) {
        options = options || {};

        var parent = this.parent = this.parent || options.parent,
            root = parent && parent.root;

        if (!root) {
            root = this;

            this.stylesheet = this.stylesheet ||
                cssInjector(options.cssStylesheetReferenceElement);

            this.conditionals = new Conditionals(options); // .sqlIdQts

            this.ParserSQL = new ParserSQL(options); // .schema, .caseSensitiveColumnNames, .resolveAliases

            var keys = ['name'];
            if (options.resolveAliases) {
                keys.push('alias');
            }

            this.findOptions = {
                caseSensitive: options.caseSensitiveColumnNames,
                keys: keys
            };
        }

        this.root = root;

        this.dontPersist = {}; // hash of truthy values

        this.setState(options.state, options);
    },

    /** Insert each subtree into its parent node along with a "delete" button.
     * > The root tree (which has no parent) is inserted into the DOM by the instantiating code (without a delete button).
     * @memberOf FilterNode.prototype
     */
    render: function() {
        if (this.parent) {
            var newListItem = document.createElement(CHILD_TAG);

            if (this.notesEl) {
                newListItem.appendChild(this.notesEl);
            }

            if (!this.keep) {
                var el = this.templates.get('removeButton');
                el.addEventListener('click', this.remove.bind(this));
                newListItem.appendChild(el);
            }

            newListItem.appendChild(this.el);

            this.parent.el.querySelector(CHILDREN_TAG).appendChild(newListItem);
        }
    },

    /**
     *
     * @param {FilterTreeStateObject} state
     * @param {FilterTreeSetStateOptionsObject} [options]
     * @memberOf FilterNode.prototype
     */
    setState: function(state, options) {
        var oldEl = this.el;

        state = this.parseStateString(state, options);

        this.mixInStandardOptions(state, options);
        this.mixInNonstandardOptions(options);
        this.createView(state);
        this.loadState(state);
        this.render();

        if (oldEl) {
            var newEl = this.el;
            if (this.parent && oldEl.parentElement.tagName === 'LI') {
                oldEl = oldEl.parentNode;
                newEl = newEl.parentNode;
            }
            oldEl.parentNode.replaceChild(newEl, oldEl);
        }
    },

    /**
     * @summary Convert a string to a state object.
     *
     * @desc They string's syntax is inferred as follows:
     * 1. If state is undefined or already an object, return as is.
     * 2. If `options.context` is defined, `state` is assumed to be a CSS selector string (auto-detected) pointing to an HTML form control with a `value` property, such as a {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement HTMLInputElement} or a {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLTextAreaElement HTMLTextAreaElement}. The element is selected and if found, its value is fetched from the DOM and assigned to `state`.
     * 3. If `options.syntax` is `'auto'`, JSON syntax is detected if `state` begins _and_ ends with either `[` and `]` _or_ `{` and `}` (ignoring leading and trailing white space).
     * 4. If JSON syntax, parse the string into an actual `FilterTreeStateObject` using {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse|JSON.parse} and throw an error if unparsable.
     * 5. If not JSON, parse the string as SQL into an actual `FilterTreeStateObject` using parser-SQL's {@link ParserSQL#parser|parser} and throw an error if unparsable.
     *
     * @param {FilterTreeStateObject} [state]
     * @param {FilterTreeSetStateOptionsObject} [options]
     *
     * @returns {FilterTreeStateObject} The unmolested `state` parameter. Throws an error if `state` is unknown or invalid syntax.
     *
     * @memberOf FilterNode
     * @inner
     */
    parseStateString: function(state, options) {
        if (state) {
            if (typeof state === 'string') {
                var context = options && options.context,
                    syntax = options && options.syntax || 'auto'; // default is 'auto'

                if (context) {
                    state = context.querySelector(state).value;
                }

                if (syntax === 'auto') {
                    syntax = reJSON.test(state) ? 'JSON' : 'SQL';
                }

                switch (syntax) {
                    case 'JSON':
                        try {
                            state = JSON.parse(state);
                        } catch (error) {
                            throw new FilterTreeError('JSON parser: ' + error);
                        }
                        break;
                    case 'SQL':
                        try {
                            state = this.root.ParserSQL.parse(state);
                        } catch (error) {
                            throw new FilterTreeError('SQL WHERE clause parser: ' + error);
                        }
                        break;
                }
            }

            if (typeof state !== 'object') {
                throw new FilterTreeError('Unexpected input state.');
            }
        }

        return state;
    },

    /**
     * Create each standard option from when found on the `options` or `state` objects, respectively; or if not an "own" option, on the `parent` object or from the options schema default (if any)
     * @param state
     * @param options
     */
    mixInStandardOptions: function(state, options) {
        var node = this;

        _(FilterNode.optionsSchema).each(function(optionSchema, key) {
            if (!optionSchema.ignore && (this !== this.root || optionSchema.rootBound)) {
                var option;

                node.dontPersist[key] = // truthy if from `options` or `default`
                    (option = options && options[key]) !== undefined ||
                    (option = state && state[key]) === undefined &&
                    !(optionSchema.own || node.hasOwnProperty(key) && option !== null) &&
                    !(option = node.parent && node.parent[key]) &&
                    (option = optionSchema.default);

                if (option === null) {
                    delete node[key];
                    node.dontPersist[key] = false;
                } else if (option) {
                    if (key === 'schema' && !option.walk) {
                        // attach the `walk` and `find` convenience methods to the `schema` array
                        option.walk = popMenu.walk.bind(option);
                        option.lookup = popMenu.lookup.bind(option, node.root.findOptions);
                    }
                    node[key] = option;
                }
            }
        });
    },

    /**
     * @param options
     */
    mixInNonstandardOptions: function(options) {
        var node = this;

        // copy all remaining options directly to the new instance, overriding prototype members of the same name
        _(options).each(function(value, key) {
            if (!FilterNode.optionsSchema[key]) {
                node[key] = value;
            }
        });
    },

    /** Remove both:
     * * `this` filter node from it's `parent`'s `children` collection; and
     * * `this` filter node's `el`'s container (always a `<li>` element) from its parent element.
     * @memberOf FilterNode.prototype
     */
    remove: function() {
        var avert,
            parent = this.parent;

        if (parent) {
            if (this.eventHandler) {
                this.eventHandler.call(parent, {
                    type: 'delete',
                    preventDefault: function() { avert = true; }
                });
            }
            if (!avert) {
                if (
                    parent.keep || // never "prune" (remove if empty) this particular subexpression
                    parent.children.length > 1 // this node has siblings so will not be empty after this remove
                ) {
                    // proceed with remove
                    this.el.parentNode.remove(); // the parent is always the containing <li> tag
                    parent.children.splice(parent.children.indexOf(this), 1);
                } else {
                    // recurse to prune entire subexpression because it's prune-able and would end up empty (childless)
                    parent.remove();
                }
            }
        }
    },

    Error: FilterTreeError,

    templates: new Templates()
});

/** @typedef optionsSchemaObject
 * @summary Standard option schema
 * @desc Standard options are automatically added to nodes. Data sources for standard options include `options`, `state`, `parent` and `default` (in that order). Describes standard options through various properties:
 * @property {boolean} [ignore] - Do not automatically add to nodes (processed elsewhere).
 * @property {boolean} [own] - Do not automatically add from `parent` or `default`.
 * @property {boolean} [rootBound] - Automatically add to root node only.
 * @property {*} [default] - This is the default data source when all other strategies fail.
 */

/**
 * @summary Defines the standard options available to a node.
 * @desc The following properties bear the same names as the node options they define.
 * @type {pbject}
 * @memberOf FilterNode
 */
FilterNode.optionsSchema = {

    state: { ignore: true },

    cssStylesheetReferenceElement: { ignore: true },

    /** @summary Default column schema for column drop-downs of direct descendant leaf nodes only.
     * @desc > This docs entry describes a property in the FilterNode prototype. It does not describe the optionsSchema property (despite it's position in the source code).
     * @type {string[]}
     * @memberOf FilterNode.optionsSchema
     */
    ownSchema: { own: true },

    /** @summary Default column schema for column drop-downs of all descendant leaf nodes.
     * @desc > This docs entry describes a property in the FilterNode prototype. It does not describe the optionsSchema property (despite it's position in the source code).
     * @type {menuItem[]}
     * @memberOf FilterNode.optionsSchema
     */
    schema: {},

    /** @summary Type of filter editor.
     * @desc > This docs entry describes a property in the FilterNode prototype. It does not describe the optionsSchema property (despite it's position in the source code).
     * @type {string}
     * @memberOf FilterNode.optionsSchema
     */
    editor: {},

    /** @summary Event handler for UI events.
     * @desc > This docs entry describes a property in the FilterNode prototype. It does not describe the optionsSchema property (despite it's position in the source code).
     * @type {string}
     * @memberOf FilterNode.optionsSchema
     */
    eventHandler: {},

    type: { own: true },

    keep: { own: true },

    /** @summary Override operator list at any node.
     * @desc > This docs entry describes a property in the FilterNode prototype. It does not describe the optionsSchema property (despite it's position in the source code).
     * @type {string[]}
     * @memberOf FilterNode.optionsSchema
     */
    opMenu: { default: Conditionals.defaultOpMenu },

    typeOpMap: { rootBound: true },

    /** @summary Truthy will sort the column menus.
     * @type {boolean}
     * @memberOf FilterNode.optionsSchema
     */
    sortColumnMenu: {}
};

FilterNode.setWarningClass = function(el, value) {
    if (arguments.length < 2) {
        value = el.value;
    }
    el.classList[value ? 'remove' : 'add']('filter-tree-warning');
    return value;
};

FilterNode.clickIn = function(el) {
    if (el) {
        if (el.tagName === 'SELECT') {
            setTimeout(function() { el.dispatchEvent(new MouseEvent('mousedown')); }, 0);
        } else {
            el.focus();
        }
    }
};

module.exports = FilterNode;

},{"./Conditionals":10,"./Templates":14,"./parser-SQL":16,"./stylesheet":17,"extend-me":7,"object-iterators":46,"pop-menu":47}],13:[function(require,module,exports){
/* eslint-env browser */

// This is the main file, usable as is, such as by /test/index.js.

// For npm: require this file
// For CDN: gulpfile.js browserifies this file with sourcemap to /build/filter-tree.js and uglified without sourcemap to /build/filter-tree.min.js. The CDN is https://joneit.github.io/filter-tree.

'use strict';

var popMenu = require('pop-menu');
var unstrungify = require('unstrungify');

var _ = require('object-iterators');
var FilterNode = require('./FilterNode');
var FilterLeaf = require('./FilterLeaf');
var operators = require('./tree-operators');


var ordinal = 0;

/** @constructor
 * @summary An object that represents the root node or a branch node in a filter tree.
 * @desc A node representing a subexpression in the filter expression. May be thought of as a parenthesized subexpression in algebraic expression syntax. As discussed under {@link FilterNode}, a `FilterTree` instance's child nodes may be either:
 * * Other (nested) `FilterTree` (or subclass thereof) nodes representing subexpressions.
 * * {@link FilterLeaf} (or subclass thereof) terminal nodes representing conditional expressions.
 *
 * The `FilterTree` object also has methods, some of which operate on a specific subtree instance, and some of which recurse through all the subtree's child nodes and all their descendants, _etc._
 *
 * The recursive methods are interesting. They all work similarly, looping through the list of child nodes, recursing when the child node is a nested subtree (which will recurse further when it has its own nested subtrees); and calling the polymorphic method when the child node is a `FilterLeaf` object, which is a terminal node. Such polymorphic methods include `setState()`, `getState()`, `invalid()`, and `test()`.
 *
 * For example, calling `test(dataRow)` on the root tree recurses through any subtrees eventually calling `test(dataRow)` on each of its leaf nodes and concatenating the results together using the subtree's `operator`. The subtree's `test(dataRow)` call then returns the result to it's parent's `test()` call, _etc.,_ eventually bubbling up to the root node's `test(dataRow)` call, which returns the final result to the original caller. This result determines if the given data row passed through the entire filter expression successfully (`true`) and should be displayed, or was blocked somewhere (`false`) and should not be displayed.
 *
 * Note that in practice:
 * 1. `children` may be empty. This represents a an empty subexpression. Normally pointless, empty subexpressions could be pruned. Filter-tree allows them however as harmless placeholders.
 * 1. `operator` may be omitted in which case it defaults to AND.
 * 1. A `false` result from a child node will short-stop an AND operation; a `true` result will short-stop an OR or NOR operation.
 *
 * Additional notes:
 * 1. A `FilterTree` may consist of a single leaf, in which case the concatenation `operator` is not needed and may be left undefined. However, if a second child is added and the operator is still undefined, it will be set to the default (`'op-and'`).
 * 2. The order of the children is undefined as all operators are commutative. For the '`op-or`' operator, evaluation ceases on the first positive result and for efficiency, all simple conditional expressions will be evaluated before any complex subexpressions.
 * 3. A nested `FilterTree` is distinguished (duck-typed) from a leaf node by the presence of a `children` member.
 * 4. Nesting a `FilterTree` containing a single child is valid (albeit pointless).
 *
 * **See also the properties of the superclass:** {@link FilterNode}
 *
 * @property {string} [operator='op-and'] - The operator that concatentates the test results from all the node's `children` (child nodes). Must be one of:
 * * `'op-and'`
 * * `'op-or'`
 * * `'op-nor'`
 *
 * Note that there is only one `operator` per subexpression. If you need to mix operators, create a subordinate subexpression as one of the child nodes.
 *
 * @property {FilterNode[]} children - A list of descendants of this node. As noted, these may be other `FilterTree` (or subclass thereof) nodes; or may be terminal `FilterLeaf` (or subclass thereof) nodes. May be any length including 0 (none; empty).
 *
 * @property {boolean} [keep=false] - Do not automatically prune when last child removed.
 *
 * @property {fieldItem[]} [ownSchema] - Column menu to be used only by leaf nodes that are children (direct descendants) of this node.
 *
 * @property {string} [type='subtree'] - Type of node, for rendering purposes; names the rendering template to use to generate the node's UI representation.
 */
var FilterTree = FilterNode.extend('FilterTree', {

    /**
     * Hash of constructors for objects that extend from {@link FilterLeaf}, which is the `Default` member here.
     *
     * Add additional editors to this object (in the prototype) prior to instantiating a leaf node that refers to it. This object exists in the prototype and additions to it will affect all nodes that don't have their an "own" hash.
     *
     * If you create an "own" hash in your instance be sure to include the default editor, for example: `{ Default: FilterTree.prototype.editors.Default, ... }`. (One way of overriding would be to include such an object in an `editors` member of the options object passed to the constructor on instantiation. This works because all miscellaneous members are simply copied to the new instance. Not to be confused with the standard option `editor` which is a string containing a key from this hash and tells the leaf node what type to use.)
     */
    editors: {
        Default: FilterLeaf
    },

    /**
     * An extension is a hash of prototype overrides (methods, properties) used to extend the default editor.
     * @param {string} [key='Default'] - Nme of the new extension given in `ext` or name of an existing extension in `FilterTree.extensions`. As a constructor, should have an initial capital. If omitted, replaces the default editor (FilterLeaf).
     * @param {object} [ext] An extension hash
     * @param {FilerLeaf} [BaseEditor=this.editors.Default] - Constructor to extend from.
     * @returns {FillterLeaf} A new class extended from `BaseEditor` -- which is initially `FilterLeaf` but may itself have been extended by a call to `.addEditor('Default', extension)`.
     */
    addEditor: function(key, ext, BaseEditor) {
        if (typeof key === 'object') {
            // `key` (string) was omitted
            BaseEditor = ext;
            ext = key;
            key = 'Default';
        }
        BaseEditor = BaseEditor || this.editors.Default;
        ext = ext || FilterTree.extensions[key];
        return (this.editors[key] = BaseEditor.extend(key, ext));
    },

    /**
     * @param {string} key - The name of the existing editor to remove.
     * @memberOf FilterTree.prototype
     */
    removeEditor: function(key) {
        if (key === 'Default') {
            throw 'Cannot remove default editor.';
        }
        delete this.editors[key];
    },

    /**
     *
     * @memberOf FilterTree.prototype
     */
    createView: function() {
        this.el = this.templates.get(
            this.type || 'subtree',
            ++ordinal,
            this.schema[0] && popMenu.formatItem(this.schema[0])
        );

        // Add the expression editors to the "add new" drop-down
        var addNewCtrl = this.el.querySelector(':scope>select');
        if (addNewCtrl) {
            var submenu, optgroup,
                editors = this.editors;

            if (addNewCtrl.length === 1 && this.editors.length === 1) {
                // this editor is the only option besides the null prompt option
                // so make it th eonly item i the drop-down
                submenu = addNewCtrl;
            } else {
                // there are already options and/or multiple editors
                submenu = optgroup = document.createElement('optgroup');
                optgroup.label = 'Conditional Expressions';
            }
            Object.keys(editors).forEach(function(key) {
                var name = editors[key].prototype.name || key;
                submenu.appendChild(new Option(name, key));
            });
            if (optgroup) {
                addNewCtrl.add(optgroup);
            }
            this.el.addEventListener('change', onchange.bind(this));
        }

        this.el.addEventListener('click', onTreeOpClick.bind(this));
    },

    /**
     *
     * @memberOf FilterTree.prototype
     */
    loadState: function(state) {
        this.operator = 'op-and';
        this.children = [];

        if (!state) {
            this.add();
        } else {
            // Validate `state.children` (required)
            if (!(state.children instanceof Array)) {
                throw new this.Error('Expected `children` property to be an array.');
            }

            // Validate `state.operator` (if given)
            if (state.operator) {
                if (!operators[state.operator]) {
                    throw new this.Error('Expected `operator` property to be one of: ' + Object.keys(operators));
                }

                this.operator = state.operator;
            }

            state.children.forEach(this.add.bind(this));
        }
    },

    /**
     *
     * @memberOf FilterTree.prototype
     */
    render: function() {
        var radioButton = this.el.querySelector(':scope > label > input[value=' + this.operator + ']'),
            addFilterLink = this.el.querySelector('.filter-tree-add-conditional');

        if (radioButton) {
            radioButton.checked = true;
            onTreeOpClick.call(this, {
                target: radioButton
            });
        }

        // when multiple filter editors available, simulate click on the new "add conditional" link
        if (addFilterLink && !this.children.length && Object.keys(this.editors).length > 1) {
            this['filter-tree-add-conditional']({
                target: addFilterLink
            });
        }

        // proceed with render
        FilterNode.prototype.render.call(this);
    },

    /**
     * @summary Create a new node as per `state`.
     *
     * @param {object} [options={state:{}}] - May be one of:
     *
     * * an `options` object containing a `state` property
     * * a `state` object (in which case there is no `options` object)
     *
     * In any case, resulting `state` object may be either...
     * * A new subtree (has a `children` property):
     *   Add a new `FilterTree` node.
     * * A new leaf (no `children` property): add a new `FilterLeaf` node:
     *   * If there is an `editor` property:
     *     Add leaf using `this.editors[state.editor]`.
     *   * Otherwise (including the case where `state` is undefined):
     *     Add leaf using `this.editors.Default`.
     *
     * @param {boolean} [options.focus=false] Call invalid() after inserting to focus on first blank control (if any).
     *
     * @returns {FilterNode} The new node.
     *
     * @memberOf FilterTree.prototype
     */
    add: function(options) {
        var Constructor, newNode;

        options = options || {};

        if (!options.state) {
            options = { state: options };
        }

        if (options.state.children) {
            Constructor = this.constructor;
        } else {
            Constructor = this.editors[options.state.editor || 'Default'];
        }

        options.parent = this;
        newNode = new Constructor(options);
        this.children.push(newNode);

        if (options.focus) {
            // focus on blank control a beat after adding it
            setTimeout(function() { newNode.invalid(options); }, 750);
        }

        return newNode;
    },

    /** @typedef {object} FilterTreeValidationOptionsObject
     * @property {boolean} [throw=false] - Throw (do not catch) `FilterTreeError`s.
     * @property {boolean} [alert=false] - Announce error via window.alert() before returning.
     * @property {boolean} [focus=false] - Place the focus on the offending control and give it error color.
     */

    /**
     * @param {FilterTreeValidationOptionsObject} [options]
     * @returns {undefined|FilterTreeError} `undefined` if valid; or the caught `FilterTreeError` if error.
     * @memberOf FilterTree.prototype
     */
    invalid: function(options) {
        var result;

        options = options || {};

        try {
            result = invalid.call(this, options);
        } catch (err) {
            result = err;

            // Throw when unexpected (not a filter tree error)
            if (!(err instanceof this.Error)) {
                throw err;
            }
        }

        // Alter and/or throw when requested
        if (result) {
            if (options.alert) {
                window.alert(result.message || result); // eslint-disable-line no-alert
            }
            if (options.throw) {
                throw result;
            }
        }

        return result;
    },

    /**
     *
     * @param dataRow
     * @returns {boolean}
     * @memberOf FilterTree.prototype
     */
    test: function test(dataRow) {
        var operator = operators[this.operator],
            result = operator.seed,
            noChildrenDefined = true;

        this.children.find(function(child) {
            if (child) {
                noChildrenDefined = false;
                if (child instanceof FilterLeaf) {
                    result = operator.reduce(result, child.test(dataRow));
                } else if (child.children.length) {
                    result = operator.reduce(result, test.call(child, dataRow));
                }
                return result === operator.abort;
            }

            return false;
        });

        return noChildrenDefined || (operator.negate ? !result : result);
    },

    /**
     * @returns {number} Number of filters (terminal nodes) defined in this subtree.
     */
    filterCount: function filterCount() {
        var n = 0;

        this.children.forEach(function(child) {
            n += child instanceof FilterLeaf ? 1 : filterCount.call(child);
        });

        return n;
    },

    /** @typedef {object} FilterTreeGetStateOptionsObject
     *
     * @summary Object containing options for producing a state object.
     *
     * @desc State is commonly used for two purposes:
     * 1. To persist the filter state so that it can be reloaded later.
     * 2. To send a query to a database engine.
     *
     * @property {boolean} [syntax='object'] - A case-sensitive string indicating the expected type and format of a state object to be generated from a filter tree. One of:
     * * `'object'` (default) A raw state object produced by walking the tree using `{@link https://www.npmjs.com/package/unstrungify|unstrungify()}`, respecting `JSON.stringify()`'s "{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior|toJSON() behavior}," and returning a plain object suitable for resubmitting to {@link FilterNode#setState|setState}. This is an "essential" version of the actual node objects in the tree.
     * * `'JSON'` - A stringified state object produced by walking the tree using `{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior|JSON.stringify()}`, returning a JSON string by calling `toJSON` at every node. This is a string representation of the same "essential" object as that produced by the `'object'` option, but "stringified" and therefore suitable for text-based storage media.
     * * `'SQL'` - The subexpression in SQL conditional syntax produced by walking the tree and returning a SQL [search condition expression]{@link https://msdn.microsoft.com/en-us/library/ms173545.aspx}. Suitable for use in the WHERE clause of a SQL `SELECT` statement used to query a database for a filtered result set.
     *
     * @param {number|string} [space] - When `options.syntax === 'JSON'`, forwarded to `JSON.stringify` as the third parameter, `space` (see).
     *
     * NOTE: The SQL syntax result cannot accommodate node meta-data. While meta-data such as `type` typically comes from the column schema, meta-data can be installed directly on a node. Such meta-data will not be part of the resulting SQL expression. For this reason, SQL should not be used to persist filter state but rather its use should be limited to generating a filter query for a remote data server.
     */

    /**
     * @summary Get a representation of filter state.
     * @desc Calling this on the root will get the entire tree's state; calling this on any subtree will get just that subtree's state.
     *
     * Only _essential_ properties will be output:
     *
     * 1. `FilterTree` nodes will output at least 2 properties:
     *    * `operator`
     *    * `children`
     * 2. `FilterLeaf` nodes will output (via {@link FilterLeaf#getState|getState}) at least 3 properties, one property for each item in it's `view`:
     *    * `column`
     *    * `operator`
     *    * `operand`
     * 3. Additional node properties will be output when:
     *    1. When the property was **NOT** externally sourced:
     *       1. Did *not* come from the `options` object on node instantiation.
     *       2. Did *not* come from the options schema `default` object, if any.
     *    2. **AND** at least one of the following is true:
     *       1. When it's an "own" property.
     *       2. When its value differs from it's parent's.
     *       3. When this is the root node.
     *
     * @param {FilterTreeGetStateOptionsObject} [options]
     * @param {object} [options.sqlIdQts] - When `options.syntax === 'SQL'`, forwarded to `conditionals.pushSqlIdQts()`.
     * @returns {object|string} Returns object when `options.syntax === 'object'`; otherwise returns string.
     * @memberOf FilterTree.prototype
     */
    getState: function getState(options) {
        var result = '',
            syntax = options && options.syntax || 'object';

        switch (syntax) {
            case 'object':
                result = unstrungify.call(this);
                break;

            case 'JSON':
                result = JSON.stringify(this, null, options && options.space) || '';
                break;

            case 'SQL':
                var lexeme = operators[this.operator].SQL;

                this.children.forEach(function(child, idx) {
                    var op = idx ? ' ' + lexeme.op + ' ' : '';
                    if (child instanceof FilterLeaf) {
                        result += op + child.getState(options);
                    } else if (child.children.length) {
                        result += op + getState.call(child, options);
                    }
                });

                if (result) {
                    result = lexeme.beg + result + lexeme.end;
                }
                break;

            default:
                throw new this.Error('Unknown syntax option "' + syntax + '"');
        }

        return result;
    },

    toJSON: function toJSON() {
        var self = this,
            state = {
                operator: this.operator,
                children: []
            };

        this.children.forEach(function(child) {
            state.children.push(child instanceof FilterLeaf ? child : toJSON.call(child));
        });

        _(FilterNode.optionsSchema).each(function(optionSchema, key) {
            if (
                self[key] && // there is a standard option on the node which may need to be output
                !self.dontPersist[key] && (
                    optionSchema.own || // output because it's an "own" option (belongs to the node)
                    !self.parent || // output because it's the root node
                    self[key] !== self.parent[key] // output because it differs from its parent's version
                )
            ) {
                state[key] = self[key];
            }
        });

        return state;
    },

    /**
     * @summary Set the case sensitivity of filter tests against data.
     * @desc Case sensitivity pertains to string compares only. This includes untyped columns, columns typed as strings, typed columns containing data that cannot be coerced to type or when the filter expression operand cannot be coerced.
     *
     * NOTE: This is a shared property and affects all filter-tree instances constructed by this code instance.
     * @param {boolean} isSensitive
     * @memberOf Filtertree.prototype.prototype
     */
    setCaseSensitivity: function(isSensitive) {
        var toString = isSensitive ? toStringCaseSensitive : toStringCaseInsensitive;
        FilterLeaf.setToString(toString);
    }

});

function toStringCaseInsensitive(s) { return (s + '').toUpperCase(); }
function toStringCaseSensitive(s) { return s + ''; }

// Some event handlers bound to FilterTree object

function onchange(evt) { // called in context
    var ctrl = evt.target;
    if (ctrl.parentElement === this.el) {
        if (ctrl.value === 'subexp') {
            this.children.push(new FilterTree({
                parent: this
            }));
        } else {
            this.add({
                state: { editor: ctrl.value },
                focus: true
            });
        }
        ctrl.selectedIndex = 0;
    }
}

function onTreeOpClick(evt) { // called in context
    var ctrl = evt.target;

    if (ctrl.className === 'filter-tree-op-choice') {
        this.operator = ctrl.value;

        // display strike-through
        var radioButtons = this.el.querySelectorAll('label>input.filter-tree-op-choice[name=' + ctrl.name + ']');
        Array.prototype.forEach.call(radioButtons, function(ctrl) {
            ctrl.parentElement.style.textDecoration = ctrl.checked ? 'none' : 'line-through';
        });

        // display operator between filters by adding operator string as a CSS class of this tree
        for (var key in operators) {
            this.el.classList.remove(key);
        }
        this.el.classList.add(this.operator);
    }
}

/**
 * Throws error if invalid expression tree.
 * Caught by {@link FilterTree#invalid|FilterTree.prototype.invalid()}.
 * @param {boolean} [options.focus=false] - Move focus to offending control.
 * @returns {undefined} if valid
 * @private
 */
function invalid(options) { // called in context
    //if (this instanceof FilterTree && !this.children.length) {
    //    throw new this.Error('Empty subexpression (no filters).');
    //}

    this.children.forEach(function(child) {
        if (child instanceof FilterLeaf) {
            child.invalid(options);
        } else if (child.children.length) {
            invalid.call(child, options);
        }
    });
}

FilterTree.extensions = {
    Columns: require('./extensions/columns')
};

// module initialization
FilterTree.prototype.setCaseSensitivity(true);  // default is case-sensitive which is more efficient; may be reset at will


module.exports = FilterTree;

},{"./FilterLeaf":11,"./FilterNode":12,"./extensions/columns":15,"./tree-operators":18,"object-iterators":46,"pop-menu":47,"unstrungify":53}],14:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var templex = require('templex');

var templates = require('../html');

var encoders = /\{(\d+)\:encode\}/g;

function Templates() {}
var constructor = Templates.prototype.constructor;
Templates.prototype = templates;
Templates.prototype.constructor = constructor; // restore it
Templates.prototype.get = function(templateName) { // mix it in
    var keys,
        matches = {},
        temp = document.createElement('div'),
        text = this[templateName],
        args = Array.prototype.slice.call(arguments, 1);

    encoders.lastIndex = 0;

    while ((keys = encoders.exec(text))) {
        matches[keys[1]] = true;
    }

    keys = Object.keys(matches);

    if (keys.length) {
        keys.forEach(function(key) {
            temp.textContent = args[key];
            args[key] = temp.innerHTML;
        });
        text = text.replace(encoders, '{$1}');
    }

    temp.innerHTML = templex.apply(this, [text].concat(args));

    // if only one HTMLElement, return it; otherwise entire list of nodes
    return temp.children.length === 1 && temp.childNodes.length === 1
        ? temp.firstChild
        : temp.childNodes;
};

module.exports = Templates;

},{"../html":8,"templex":52}],15:[function(require,module,exports){
'use strict';

var Conditionals = require('../Conditionals');
var FilterLeaf = require('../FilterLeaf');

/**
 * @summary Prototype additions object for extending {@link FilterLeaf}.
 * @desc Resulting object is similar to {@link FilterLeaf} except:
 * 1. The `operand` property names another column rather than contains a literal.
 * 2. Operators are limited to equality, inequalities, and sets (IN/NOT IN). Omitted are the string and pattern scans (BEGINS/NOT BEGINS, ENDS/NOT ENDS, CONTAINS/NOT CONTAINS, and LIKE/NOT LIKE).
 *
 * @extends FilterLeaf
 *
 * @property {string} identifier - Name of column (member of data row object) to compare against this column (member of data row object named by `column`).
 */
var ColumnLeaf = {
    name: 'column = column', // display string for drop-down

    createView: function() {
        // Create the `view` hash and insert the three default elements (`column`, `operator`, `operand`) into `.el`
        FilterLeaf.prototype.createView.call(this);

        // Replace the `operand` element from the `view` hash
        var oldOperand = this.view.operand,
            newOperand = this.view.operand = this.makeElement(this.root.schema, 'column', this.sortColumnMenu);

        // Replace the operand element with the new one. There are no event listeners to worry about.
        this.el.replaceChild(newOperand, oldOperand);
    },

    makeSqlOperand: function() {
        return this.conditionals.makeSqlIdentifier(this.operand);
    },

    opMenu: [
        Conditionals.groups.equality,
        Conditionals.groups.inequalities,
        Conditionals.groups.sets
    ],

    q: function(dataRow) {
        return dataRow[this.operand];
    }
};

module.exports = ColumnLeaf;

},{"../Conditionals":10,"../FilterLeaf":11}],16:[function(require,module,exports){
'use strict';

var reOp = /^((=|>=?|<[>=]?)|(NOT )?(LIKE|IN)\b)/i, // match[1]
    reLit = /^'(\d+)'/,
    reLitAnywhere = /'(\d+)'/,
    reIn = /^\((.*?)\)/,
    reBool = /^(AND|OR)\b/i,
    reGroup = /^(NOT ?)?\(/i;

var SQT = '\'';

var defaultIdQts = {
    beg: '"',
    end: '"'
};

function ParserSqlError(message) {
    this.message = message;
}
ParserSqlError.prototype = Object.create(Error.prototype);
ParserSqlError.prototype.name = 'ParserSqlError';

/** @typedef {object} sqlIdQtsObject
 * @desc On a practical level, the useful characters are:
 * * SQL-92 standard: "double quotes"
 * * SQL Server: "double quotes" or \[square brackets\]
 * * mySQL: \`tick marks\`
 * @property {string} beg - The open quote character.
 * @property {string} end - The close quote character.
 */

/**
 * @constructor
 * @summary Structured Query Language (SQL) parser
 * @author Jonathan Eiten <jonathan@openfin.com>
 * @desc This is a subset of SQL conditional expression syntax.
 *
 * @see {@link https://msdn.microsoft.com/en-us/library/ms173545.aspx SQL Search Condition}
 *
 * @param {menuItem[]} [options.schema] - Column schema for column name validation. Throws an error if name fails validation (but see `resolveAliases`). Omit to skip column name validation.
 * @param {boolean} [options.resolveAliases] - Validate column aliases against schema and use the associated column name in the returned expression state object. Requires `options.schema`. Throws error if no such column found.
 * @param {boolean} [options.caseSensitiveColumnNames] - Ignore case while validating column names and aliases.
 * @param {sqlIdQtsObject} [options.sqlIdQts={beg:'"',end:'"'}]
 */
function ParserSQL(options) {
    options = options || {};

    this.schema = options.schema;

    var idQts = options.sqlIdQts || defaultIdQts;
    this.reName = new RegExp('^(' + idQts.beg + '(.+?)' + idQts.end + '|([A-Z_][A-Z_@\\$#]*)\\b)', 'i'); // match[2] || match[3]
}

ParserSQL.prototype = {

    constructor: ParserSQL.prototype.constructor,

    /**
     * @param {string} sql
     * @returns {*}
     * @memberOf module:sqlSearchCondition
     */
    parse: function(sql) {
        var state;

        // reduce all runs of white space to a single space; then trim
        sql = sql.replace(/\s\s+/g, ' ').trim();

        sql = stripLiterals.call(this, sql);
        state = walk.call(this, sql);

        if (!state.children) {
            state = { children: [ state ] };
        }

        return state;
    }
};

function walk(t) {
    var m, name, op, operand, bool, token, tokens = [];
    var i = 0;

    t = t.trim();

    while (i < t.length) {
        m = t.substr(i).match(reGroup);
        if (m) {
            var not = !!m[1];

            i += m[0].length;
            for (var j = i, v = 1; j < t.length && v; ++j) {
                if (t[j] === '(') {
                    ++v;
                } else if (t[j] === ')') {
                    --v;
                }
            }

            if (v) {
                throw new ParserSqlError('Expected ")"');
            }
            token = walk.call(this, t.substr(i, j - 1 - i));
            if (typeof token !== 'object') {
                return token;
            }

            if (not) {
                if (token.operator !== 'op-or') {
                    throw new ParserSqlError('Expected OR in NOT(...) subexpression but found ' + token.operator.substr(3).toUpperCase() + '.');
                }
                token.operator = 'op-nor';
            }

            i = j;
        } else {
            m = t.substr(i).match(this.reName);
            if (!m) {
                throw new ParserSqlError('Expected identifier or quoted identifier.');
            }
            name = m[2] || m[3];
            if (!/^[A-Z_]/i.test(t[i])) { i += 2; }
            i += name.length;

            if (t[i] === ' ') { ++i; }
            m = t.substr(i).match(reOp);
            if (!m) {
                throw new ParserSqlError('Expected relational operator.');
            }
            op = m[1].toUpperCase();
            i += op.length;

            if (t[i] === ' ') { ++i; }
            if (m[4] && m[4].toUpperCase() === 'IN') {
                m = t.substr(i).match(reIn);
                if (!m) {
                    throw new ParserSqlError('Expected parenthesized list.');
                }
                operand = m[1];
                i += operand.length + 2;
                while ((m = operand.match(reLitAnywhere))) {
                    operand = operand.replace(reLitAnywhere, this.literals[m[1]]);
                }
            } else {
                m = t.substr(i).match(reLit);
                if (!m) {
                    throw new ParserSqlError('Expected string literal.');
                }
                operand = m[1];
                i += operand.length + 2;
                operand = this.literals[operand];
            }

            if (this.schema) {
                var item = this.schema.lookup(name);
                if (item) {
                    name = item.name;
                } else {
                    throw new ParserSqlError(this.resolveAliases
                        ? 'Expected valid column name.'
                        : 'Expected valid column name or alias.'
                    );
                }
            }

            token = {
                column: name,
                operator: op,
                operand: operand
            };
        }

        tokens.push(token);

        if (i < t.length) {
            if (t[i] === ' ') { ++i; }
            m = t.substr(i).match(reBool);
            if (!m) {
                throw new ParserSqlError('Expected boolean opearator.');
            }
            bool = m[1].toLowerCase();
            i += bool.length;
            bool = 'op-' + bool;
            if (tokens.operator && tokens.operator !== bool) {
                throw new ParserSqlError('Expected same boolean operator throughout subexpression.');
            }
            tokens.operator = bool;
        }

        if (t[i] === ' ') { ++i; }
    }

    return (
        tokens.length === 1 ? tokens[0] : {
            operator: tokens.operator,
            children: tokens
        }
    );
}

function stripLiterals(t) {
    var i = 0, j = 0, k;

    this.literals = [];

    while ((j = t.indexOf(SQT, j)) >= 0) {
        k = j;
        do {
            k = t.indexOf(SQT, k + 1);
            if (k < 0) {
                throw new ParserSqlError('Expected ' + SQT + ' (single quote).');
            }
        } while (t[++k] === SQT);
        this.literals.push(t.slice(++j, --k).replace(/''/g, SQT));
        t = t.substr(0, j) + i + t.substr(k);
        j = j + 1 + (i + '').length + 1;
        i++;
    }

    return t;
}

module.exports = ParserSQL;

},{}],17:[function(require,module,exports){
'use strict';

var cssInjector = require('css-injector');

var css; // defined by code inserted by gulpfile between following comments
/* inject:css */
css = '.filter-tree{font-family:sans-serif;font-size:10pt;line-height:1.5em}.filter-tree label{font-weight:400}.filter-tree input[type=checkbox],.filter-tree input[type=radio]{margin-left:3px;margin-right:3px}.filter-tree ol{margin-top:0}.filter-tree>select{float:right;border:1px dotted grey;background-color:transparent;box-shadow:none}.filter-tree-remove-button{display:inline-block;width:15px;height:15px;border-radius:8px;background-color:#e88;font-size:11.5px;color:#fff;text-align:center;line-height:normal;font-style:normal;font-family:sans-serif;margin-right:4px;cursor:pointer}.filter-tree-remove-button:hover{background-color:transparent;color:#e88;font-weight:700;box-shadow:red 0 0 2px inset}.filter-tree-remove-button::before{content:\'\\d7\'}.filter-tree li::after{font-size:70%;font-style:italic;font-weight:700;color:#080}.filter-tree>ol>li:last-child::after{display:none}.op-and>ol,.op-nor>ol,.op-or>ol{padding-left:5px;margin-left:27px}.op-or>ol>li::after{margin-left:2.5em;content:\' OR \'}.op-and>ol>li::after{margin-left:2.5em;content:\' AND \'}.op-nor>ol>li::after{margin-left:2.5em;content:\' NOR \'}.filter-tree-editor>*{font-weight:700}.filter-tree-editor>span{font-size:smaller}.filter-tree-editor>input[type=text]{width:8em;padding:1px 5px 2px}.filter-tree-warning{background-color:#ffc!important;border-color:#edb!important;font-weight:400!important}.filter-tree-error{background-color:#fcc!important;border-color:#c99!important;font-weight:400!important}.filter-tree-default>:enabled{margin:0 .4em;background-color:#ddd;border:1px solid transparent}.filter-tree.filter-tree-type-column-filters>ol>li:not(:last-child){padding-bottom:.75em;border-bottom:3px double #080;margin-bottom:.75em}.filter-tree .footnotes{margin:0 0 6px;font-size:8pt;font-weight:400;line-height:normal;white-space:normal;color:#c00}.filter-tree .footnotes>p{margin:0}.filter-tree .footnotes>ul{margin:-3px 0 0;padding-left:17px;text-index:-6px}.filter-tree .footnotes>ul>li{margin:2px 0}.filter-tree .footnotes .field-name,.filter-tree .footnotes .field-value{font-weight:700;font-style:normal}.filter-tree .footnotes .field-value{font-family:monospace;color:#000;background-color:#ddd;padding:0 5px;margin:0 3px;border-radius:3px}';
/* endinject */

module.exports = cssInjector.bind(this, css, 'filter-tree-base');

},{"css-injector":6}],18:[function(require,module,exports){
'use strict';

/** @typedef {function} operationReducer
 * @param {boolean} p
 * @param {boolean} q
 * @returns {boolean} The result of applying the operator to the two parameters.
 */

/**
 * @private
 * @type {operationReducer}
 */
function AND(p, q) {
    return p && q;
}

/**
 * @private
 * @type {operationReducer}
 */
function OR(p, q) {
    return p || q;
}

/** @typedef {obejct} treeOperator
 * @desc Each `treeOperator` object describes two things:
 *
 * 1. How to take the test results of _n_ child nodes by applying the operator to all the results to "reduce" it down to a single result.
 * 2. How to generate SQL WHERE clause syntax that applies the operator to _n_ child nodes.
 *
 * @property {operationReducer} reduce
 * @property {boolean} seed -
 * @property {boolean} abort -
 * @property {boolean} negate -
 * @property {string} SQL.op -
 * @property {string} SQL.beg -
 * @property {string} SQL.end -
 */

/** A hash of {@link treeOperator} objects.
 * @type {object}
 */
var treeOperators = {
    'op-and': {
        reduce: AND,
        seed: true,
        abort: false,
        negate: false,
        SQL: {
            op: 'AND',
            beg: '(',
            end: ')'
        }
    },
    'op-or': {
        reduce: OR,
        seed: false,
        abort: true,
        negate: false,
        SQL: {
            op: 'OR',
            beg: '(',
            end: ')'
        }
    },
    'op-nor': {
        reduce: OR,
        seed: false,
        abort: true,
        negate: true,
        SQL: {
            op: 'OR',
            beg: 'NOT (',
            end: ')'
        }
    }
};

module.exports = treeOperators;

},{}],19:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

var cssInjector = require('css-injector');

/**
 * @constructor FinBar
 * @summary Create a scrollbar object.
 * @desc Creating a scrollbar is a three-step process:
 *
 * 1. Instantiate the scrollbar object by calling this constructor function. Upon instantiation, the DOM element for the scrollbar (with a single child element for the scrollbar "thumb") is created but is not insert it into the DOM.
 * 2. After instantiation, it is the caller's responsibility to insert the scrollbar, {@link FinBar#bar|this.bar}, into the DOM.
 * 3. After insertion, the caller must call {@link FinBar#resize|resize()} at least once to size and position the scrollbar and its thumb. After that, `resize()` should also be called repeatedly on resize events (as the content element is being resized).
 *
 * Suggested configurations:
 * * _**Unbound**_<br/>
 * The scrollbar serves merely as a simple range (slider) control. Omit both `options.onchange` and `options.content`.
 * * _**Bound to virtual content element**_<br/>
 * Virtual content is projected into the element using a custom event handler supplied by the programmer in `options.onchange`. A typical use case would be to handle scrolling of the virtual content. Other use cases include data transformations, graphics transformations, _etc._
 * * _**Bound to real content**_<br/>
 * Set `options.content` to the "real" content element but omit `options.onchange`. This will cause the scrollbar to use the built-in event handler (`this.scrollRealContent`) which implements smooth scrolling of the content element within the container.
 *
 * @param {finbarOptions} [options={}] - Options object. See the type definition for member details.
 */
function FinBar(options) {

    // make bound versions of all the mouse event handler
    var bound = this._bound = {};
    for (key in handlersToBeBound) {
        bound[key] = handlersToBeBound[key].bind(this);
    }

    /**
     * @name thumb
     * @summary The generated scrollbar thumb element.
     * @desc The thumb element's parent element is always the {@link FinBar#bar|bar} element.
     *
     * This property is typically referenced internally only. The size and position of the thumb element is maintained by `_calcThumb()`.
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var thumb = document.createElement('div');
    thumb.classList.add('thumb');
    thumb.onclick = bound.shortStop;
    thumb.onmouseover = bound.onmouseover;
    this.thumb = thumb;

    /**
     * @name bar
     * @summary The generated scrollbar element.
     * @desc The caller inserts this element into the DOM (typically into the content container) and then calls its {@link FinBar#resize|resize()} method.
     *
     * Thus the node tree is typically:
     * * A **content container** element, which contains:
     *    * The content element(s)
     *    * This **scrollbar element**, which in turn contains:
     *        * The **thumb element**
     *
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var bar = document.createElement('div');

    bar.classList.add('finbar-vertical');

    bar.appendChild(thumb);
    if (this.paging) {
        bar.onclick = bound.onclick;
    }
    this.bar = bar;

    options = options || {};

    // presets
    this.orientation = 'vertical';
    this._min = this._index = 0;
    this._max = 100;

    // options
    for (var key in options) {
        if (options.hasOwnProperty(key)) {
            var option = options[key];
            switch (key) {

            case 'index':
                this._index = option;
                break;

            case 'range':
                validRange(option);
                this._min = option.min;
                this._max = option.max;
                this.contentSize = option.max - option.min + 1;
                break;

            default:
                if (
                    key.charAt(0) !== '_' &&
                    typeof FinBar.prototype[key] !== 'function'
                ) {
                    // override prototype defaults for standard ;
                    // extend with additional properties (for use in onchange event handlers)
                    this[key] = option;
                }
                break;

            }
        }
    }

    cssInjector(cssFinBars, 'finbar-base', options.cssStylesheetReferenceElement);
}

FinBar.prototype = {

    /**
     * @summary The scrollbar orientation.
     * @desc Set by the constructor to either `'vertical'` or `'horizontal'`. See the similarly named property in the {@link finbarOptions} object.
     *
     * Useful values are `'vertical'` (the default) or `'horizontal'`.
     *
     * Setting this property resets `this.oh` and `this.deltaProp` and changes the class names so as to reposition the scrollbar as per the CSS rules for the new orientation.
     * @default 'vertical'
     * @type {string}
     * @memberOf FinBar.prototype
     */
    set orientation(orientation) {
        if (orientation === this._orientation) {
            return;
        }

        this._orientation = orientation;

        /**
         * @readonly
         * @name oh
         * @summary <u>O</u>rientation <u>h</u>ash for this scrollbar.
         * @desc Set by the `orientation` setter to either the vertical or the horizontal orientation hash. The property should always be synchronized with `orientation`; do not update directly!
         *
         * This object is used internally to access scrollbars' DOM element properties in a generalized way without needing to constantly query the scrollbar orientation. For example, instead of explicitly coding `this.bar.top` for a vertical scrollbar and `this.bar.left` for a horizontal scrollbar, simply code `this.bar[this.oh.leading]` instead. See the {@link orientationHashType} definition for details.
         *
         * This object is useful externally for coding generalized {@link finbarOnChange} event handler functions that serve both horizontal and vertical scrollbars.
         * @type {orientationHashType}
         * @memberOf FinBar.prototype
         */
        this.oh = orientationHashes[this._orientation];

        if (!this.oh) {
            error('Invalid value for `options._orientation.');
        }

        /**
         * @name deltaProp
         * @summary The name of the `WheelEvent` property this scrollbar should listen to.
         * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
         *
         * Useful values are `'deltaX'`, `'deltaY'`, or `'deltaZ'`. A value of `null` means to ignore mouse wheel events entirely.
         *
         * The mouse wheel is one-dimensional and only emits events with `deltaY` data. This property is provided so that you can override the default of `'deltaX'` with a value of `'deltaY'` on your horizontal scrollbar primarily to accommodate certain "panoramic" interface designs where the mouse wheel should control horizontal rather than vertical scrolling. Just give `{ deltaProp: 'deltaY' }` in your horizontal scrollbar instantiation.
         *
         * Caveat: Note that a 2-finger drag on an Apple trackpad emits events with _both_ `deltaX ` and `deltaY` data so you might want to delay making the above adjustment until you can determine that you are getting Y data only with no X data at all (which is a sure bet you on a mouse wheel rather than a trackpad).

         * @type {object|null}
         * @memberOf FinBar.prototype
         */
        this.deltaProp = this.oh.delta;

        this.bar.className = this.bar.className.replace(/(vertical|horizontal)/g, orientation);

        if (this.bar.style.cssText || this.thumb.style.cssText) {
            this.bar.removeAttribute('style');
            this.thumb.removeAttribute('style');
            this.resize();
        }
    },
    get orientation() {
        return this._orientation;
    },

    /**
     * @summary Callback for scroll events.
     * @desc Set by the constructor via the similarly named property in the {@link finbarOptions} object. After instantiation, `this.onchange` may be updated directly.
     *
     * This event handler is called whenever the value of the scrollbar is changed through user interaction. The typical use case is when the content is scrolled. It is called with the `FinBar` object as its context and the current value of the scrollbar (its index, rounded) as the only parameter.
     *
     * Set this property to `null` to stop emitting such events.
     * @type {function(number)|null}
     * @memberOf FinBar.prototype
     */
    onchange: null,

    /**
     * @summary Add a CSS class name to the bar element's class list.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * The bar element's class list will always include `finbar-vertical` (or `finbar-horizontal` based on the current orientation). Whenever this property is set to some value, first the old prefix+orientation is removed from the bar element's class list; then the new prefix+orientation is added to the bar element's class list. This property causes _an additional_ class name to be added to the bar element's class list. Therefore, this property will only add at most one additional class name to the list.
     *
     * To remove _classname-orientation_ from the bar element's class list, set this property to a falsy value, such as `null`.
     *
     * > NOTE: You only need to specify an additional class name when you need to have mulltiple different styles of scrollbars on the same page. If this is not a requirement, then you don't need to make a new class; you would just create some additional rules using the same selectors in the built-in stylesheet (../css/finbars.css):
     * *`div.finbar-vertical` (or `div.finbar-horizontal`) for the scrollbar
     * *`div.finbar-vertical > div` (or `div.finbar-horizontal > div`) for the "thumb."
     *
     * Of course, your rules should come after the built-ins.
     * @type {string}
     * @memberOf FinBar.prototype
     */
    set classPrefix(prefix) {
        if (this._classPrefix) {
            this.bar.classList.remove(this._classPrefix + this.orientation);
        }

        this._classPrefix = prefix;

        if (prefix) {
            this.bar.classList.add(prefix + '-' + this.orientation);
        }
    },
    get classPrefix() {
        return this._classPrefix;
    },

    /**
     * @name increment
     * @summary Number of scrollbar index units representing a pageful. Used exclusively for paging up and down and for setting thumb size relative to content size.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * Can also be given as a parameter to the {@link FinBar#resize|resize} method, which is pertinent because content area size changes affect the definition of a "pageful." However, you only need to do this if this value is being used. It not used when:
     * * you define `paging.up` and `paging.down`
     * * your scrollbar is using `scrollRealContent`
     * @type {number}
     * @memberOf FinBar.prototype
     */
    increment: 1,

    /**
     * @name barStyles
     * @summary Scrollbar styles to be applied by {@link FinBar#resize|resize()}.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * This is a value to be assigned to {@link FinBar#styles|styles} on each call to {@link FinBar#resize|resize()}. That is, a hash of values to be copied to the scrollbar element's style object on resize; or `null` for none.
     *
     * @see {@link FinBar#style|style}
     * @type {finbarStyles|null}
     * @memberOf FinBar.prototype
     */
    barStyles: null,

    /**
     * @name style
     * @summary Additional scrollbar styles.
     * @desc See type definition for more details. These styles are applied directly to the scrollbar's `bar` element.
     *
     * Values are adjusted as follows before being applied to the element:
     * 1. Included "pseudo-property" names from the scrollbar's orientation hash, {@link FinBar#oh|oh}, are translated to actual property names before being applied.
     * 2. When there are margins, percentages are translated to absolute pixel values because CSS ignores margins in its percentage calculations.
     * 3. If you give a value without a unit (a raw number), "px" unit is appended.
     *
     * General notes:
     * 1. It is always preferable to specify styles via a stylesheet. Only set this property when you need to specifically override (a) stylesheet value(s).
     * 2. Can be set directly or via calls to the {@link FinBar#resize|resize} method.
     * 3. Should only be set after the scrollbar has been inserted into the DOM.
     * 4. Before applying these new values to the element, _all_ in-line style values are reset (by removing the element's `style` attribute), exposing inherited values (from stylesheets).
     * 5. Empty object has no effect.
     * 6. Falsey value in place of object has no effect.
     *
     * > CAVEAT: Do not attempt to treat the object you assign to this property as if it were `this.bar.style`. Specifically, changing this object after assigning it will have no effect on the scrollbar. You must assign it again if you want it to have an effect.
     *
     * @see {@link FinBar#barStyles|barStyles}
     * @type {finbarStyles}
     * @memberOf FinBar.prototype
     */
    set style(styles) {
        var keys = Object.keys(styles = extend({}, styles, this._auxStyles));

        if (keys.length) {
            var bar = this.bar,
                barRect = bar.getBoundingClientRect(),
                container = this.container || bar.parentElement,
                containerRect = container.getBoundingClientRect(),
                oh = this.oh;

            // Before applying new styles, revert all styles to values inherited from stylesheets
            bar.removeAttribute('style');

            keys.forEach(function (key) {
                var val = styles[key];

                if (key in oh) {
                    key = oh[key];
                }

                if (!isNaN(Number(val))) {
                    val = (val || 0) + 'px';
                } else if (/%$/.test(val)) {
                    // When bar size given as percentage of container, if bar has margins, restate size in pixels less margins.
                    // (If left as percentage, CSS's calculation will not exclude margins.)
                    var oriented = axis[key],
                        margins = barRect[oriented.marginLeading] + barRect[oriented.marginTrailing];
                    if (margins) {
                        val = parseInt(val, 10) / 100 * containerRect[oriented.size] - margins + 'px';
                    }
                }

                bar.style[key] = val;
            });
        }
    },

    /**
     * @readonly
     * @name paging
     * @summary Enable page up/dn clicks.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * If truthy, listen for clicks in page-up and page-down regions of scrollbar.
     *
     * If an object, call `.paging.up()` on page-up clicks and `.paging.down()` will be called on page-down clicks.
     *
     * Changing the truthiness of this value after instantiation currently has no effect.
     * @type {boolean|object}
     * @memberOf FinBar.prototype
     */
    paging: true,

    /**
     * @name range
     * @summary Setter for the minimum and maximum scroll values.
     * @desc Set by the constructor. These values are the limits for {@link FooBar#index|index}.
     *
     * The setter accepts an object with exactly two numeric properties: `.min` which must be less than `.max`. The values are extracted and the object is discarded.
     *
     * The getter returns a new object with `.min` and '.max`.
     *
     * @type {rangeType}
     * @memberOf FinBar.prototype
     */
    set range(range) {
        validRange(range);
        this._min = range.min;
        this._max = range.max;
        this.contentSize = range.max - range.min + 1;
        this.index = this.index; // re-clamp
    },
    get range() {
        return {
            min: this._min,
            max: this._max
        };
    },

    /**
     * @summary Index value of the scrollbar.
     * @desc This is the position of the scroll thumb.
     *
     * Setting this value clamps it to {@link FinBar#min|min}..{@link FinBar#max|max}, scroll the content, and moves thumb.
     *
     * Getting this value returns the current index. The returned value will be in the range `min`..`max`. It is intentionally not rounded.
     *
     * Use this value as an alternative to (or in addition to) using the {@link FinBar#onchange|onchange} callback function.
     *
     * @see {@link FinBar#_setScroll|_setScroll}
     * @type {number}
     * @memberOf FinBar.prototype
     */
    set index(idx) {
        idx = Math.min(this._max, Math.max(this._min, idx)); // clamp it
        this._setScroll(idx);
        // this._setThumbSize();
    },
    get index() {
        return this._index;
    },

    /**
     * @private
     * @summary Move the thumb.
     * @desc Also displays the index value in the test panel and invokes the callback.
     * @param idx - The new scroll index, a value in the range `min`..`max`.
     * @param [scaled=f(idx)] - The new thumb position in pixels and scaled relative to the containing {@link FinBar#bar|bar} element, i.e., a proportional number in the range `0`..`thumbMax`. When omitted, a function of `idx` is used.
     * @memberOf FinBar.prototype
     */
    _setScroll: function (idx, scaled) {
        this._index = idx;

        // Display the index value in the test panel
        if (this.testPanelItem && this.testPanelItem.index instanceof Element) {
            this.testPanelItem.index.innerHTML = Math.round(idx);
        }

        // Call the callback
        if (this.onchange) {
            this.onchange.call(this, Math.round(idx));
        }

        // Move the thumb
        if (scaled === undefined) {
            scaled = (idx - this._min) / (this._max - this._min) * this._thumbMax;
        }
        this.thumb.style[this.oh.leading] = scaled + 'px';
    },

    scrollRealContent: function (idx) {
        var containerRect = this.content.parentElement.getBoundingClientRect(),
            sizeProp = this.oh.size,
            maxScroll = Math.max(0, this.content[sizeProp] - containerRect[sizeProp]),
            //scroll = Math.min(idx, maxScroll);
            scroll = (idx - this._min) / (this._max - this._min) * maxScroll;
        //console.log('scroll: ' + scroll);
        this.content.style[this.oh.leading] = -scroll + 'px';
    },

    /**
     * @summary Recalculate thumb position.
     *
     * @desc This method recalculates the thumb size and position. Call it once after inserting your scrollbar into the DOM, and repeatedly while resizing the scrollbar (which typically happens when the scrollbar's parent is resized by user.
     *
     * > This function shifts args if first arg omitted.
     *
     * @param {number} [increment=this.increment] - Resets {@link FooBar#increment|increment} (see).
     *
     * @param {finbarStyles} [barStyles=this.barStyles] - (See type definition for details.) Scrollbar styles to be applied to the bar element.
     *
     * Only specify a `barStyles` object when you need to override stylesheet values. If provided, becomes the new default (`this.barStyles`), for use as a default on subsequent calls.
     *
     * It is generally the case that the scrollbar's new position is sufficiently described by the current styles. Therefore, it is unusual to need to provide a `barStyles` object on every call to `resize`.
     *
     * @returns {FinBar} Self for chaining.
     * @memberOf FinBar.prototype
     */
    resize: function (increment, barStyles) {
        var bar = this.bar;

        if (!bar.parentNode) {
            return; // not in DOM yet so nothing to do
        }

        var container = this.container || bar.parentElement,
            containerRect = container.getBoundingClientRect();

        // shift args if if 1st arg omitted
        if (typeof increment === 'object') {
            barStyles = increment;
            increment = undefined;
        }

        this.style = this.barStyles = barStyles || this.barStyles;

        // Bound to real content: Content was given but no onchange handler.
        // Set up .onchange, .containerSize, and .increment.
        // Note this only makes sense if your index unit is pixels.
        if (this.content) {
            if (!this.onchange) {
                this.onchange = this.scrollRealContent;
                this.contentSize = this.content[this.oh.size];
                this._min = 0;
                this._max = this.contentSize - 1;
            }
        }
        if (this.onchange === this.scrollRealContent) {
            this.containerSize = containerRect[this.oh.size];
            this.increment = this.containerSize / (this.contentSize - this.containerSize) * (this._max - this._min);
        } else {
            this.containerSize = 1;
            this.increment = increment || this.increment;
        }

        var index = this.index;
        this.testPanelItem = this.testPanelItem || this._addTestPanelItem();
        this._setThumbSize();
        this.index = index;

        if (this.deltaProp !== null) {
            container.addEventListener('wheel', this._bound.onwheel);
        }

        return this;
    },

    /**
     * @summary Shorten trailing end of scrollbar by thickness of some other scrollbar.
     * @desc In the "classical" scenario where vertical scroll bar is on the right and horizontal scrollbar is on the bottom, you want to shorten the "trailing end" (bottom and right ends, respectively) of at least one of them so they don't overlay.
     *
     * This convenience function is an programmatic alternative to hardcoding the correct style with the correct value in your stylesheet; or setting the correct style with the correct value in the {@link FinBar#barStyles|barStyles} object.
     *
     * @see {@link FinBar#foreshortenBy|foreshortenBy}.
     *
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    shortenBy: function (otherFinBar) { return this.shortenEndBy('trailing', otherFinBar); },

    /**
     * @summary Shorten leading end of scrollbar by thickness of some other scrollbar.
     * @desc Supports non-classical scrollbar scenarios where vertical scroll bar may be on left and horizontal scrollbar may be on top, in which case you want to shorten the "leading end" rather than the trailing end.
     * @see {@link FinBar#shortenBy|shortenBy}.
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    foreshortenBy: function (otherFinBar) { return this.shortenEndBy('leading', otherFinBar); },

    /**
     * @summary Generalized shortening function.
     * @see {@link FinBar#shortenBy|shortenBy}.
     * @see {@link FinBar#foreshortenBy|foreshortenBy}.
     * @param {string} whichEnd - a CSS style property name or an orientation hash name that translates to a CSS style property name.
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    shortenEndBy: function (whichEnd, otherFinBar) {
        if (!otherFinBar) {
            delete this._auxStyles;
        } else if (otherFinBar instanceof FinBar && otherFinBar.orientation !== this.orientation) {
            var otherStyle = window.getComputedStyle(otherFinBar.bar),
                ooh = orientationHashes[otherFinBar.orientation];
            this._auxStyles = {};
            this._auxStyles[whichEnd] = otherStyle[ooh.thickness];
        }
        return this; // for chaining
    },

    /**
     * @private
     * @summary Sets the proportional thumb size and hides thumb when 100%.
     * @desc The thumb size has an absolute minimum of 20 (pixels).
     * @memberOf FinBar.prototype
     */
    _setThumbSize: function () {
        var oh = this.oh,
            thumbComp = window.getComputedStyle(this.thumb),
            thumbMarginLeading = parseInt(thumbComp[oh.marginLeading]),
            thumbMarginTrailing = parseInt(thumbComp[oh.marginTrailing]),
            thumbMargins = thumbMarginLeading + thumbMarginTrailing,
            barSize = this.bar.getBoundingClientRect()[oh.size],
            thumbSize = Math.max(20, barSize * this.containerSize / this.contentSize);

        if (this.containerSize < this.contentSize) {
            this.bar.style.visibility = 'visible';
            this.thumb.style[oh.size] = thumbSize + 'px';
        } else {
            this.bar.style.visibility = 'hidden';
        }

        /**
         * @private
         * @name _thumbMax
         * @summary Maximum offset of thumb's leading edge.
         * @desc This is the pixel offset within the scrollbar of the thumb when it is at its maximum position at the extreme end of its range.
         *
         * This value takes into account the newly calculated size of the thumb element (including its margins) and the inner size of the scrollbar (the thumb's containing element, including _its_ margins).
         *
         * NOTE: Scrollbar padding is not taken into account and assumed to be 0 in the current implementation and is assumed to be `0`; use thumb margins in place of scrollbar padding.
         * @type {number}
         * @memberOf FinBar.prototype
         */
        this._thumbMax = barSize - thumbSize - thumbMargins;

        this._thumbMarginLeading = thumbMarginLeading; // used in mousedown
    },

    /**
     * @summary Remove the scrollbar.
     * @desc Unhooks all the event handlers and then removes the element from the DOM. Always call this method prior to disposing of the scrollbar object.
     * @memberOf FinBar.prototype
     */
    remove: function () {
        this._removeEvt('mousedown');
        this._removeEvt('mousemove');
        this._removeEvt('mouseup');

        (this.container || this.bar.parentElement)._removeEvt('wheel', this._bound.onwheel);

        this.bar.onclick =
            this.thumb.onclick =
                this.thumb.onmouseover =
                    this.thumb.transitionend =
                        this.thumb.onmouseout = null;

        this.bar.remove();
    },

    /**
     * @private
     * @function _addTestPanelItem
     * @summary Append a test panel element.
     * @desc If there is a test panel in the DOM (typically an `<ol>...</ol>` element) with class names of both `this.classPrefix` and `'test-panel'` (or, barring that, any element with class name `'test-panel'`), an `<li>...</li>` element will be created and appended to it. This new element will contain a span for each class name given.
     *
     * You should define a CSS selector `.listening` for these spans. This class will be added to the spans to alter their appearance when a listener is added with that class name (prefixed with 'on').
     *
     * (This is an internal function that is called once by the constructor on every instantiation.)
     * @returns {Element|undefined} The appended `<li>...</li>` element or `undefined` if there is no test panel.
     * @memberOf FinBar.prototype
     */
    _addTestPanelItem: function () {
        var testPanelItem,
            testPanelElement = document.querySelector('.' + this._classPrefix + '.test-panel') || document.querySelector('.test-panel');

        if (testPanelElement) {
            var testPanelItemPartNames = [ 'mousedown', 'mousemove', 'mouseup', 'index' ],
                item = document.createElement('li');

            testPanelItemPartNames.forEach(function (partName) {
                item.innerHTML += '<span class="' + partName + '">' + partName.replace('mouse', '') + '</span>';
            });

            testPanelElement.appendChild(item);

            testPanelItem = {};
            testPanelItemPartNames.forEach(function (partName) {
                testPanelItem[partName] = item.getElementsByClassName(partName)[0];
            });
        }

        return testPanelItem;
    },

    _addEvt: function (evtName) {
        var spy = this.testPanelItem && this.testPanelItem[evtName];
        if (spy) { spy.classList.add('listening'); }
        window.addEventListener(evtName, this._bound['on' + evtName]);
    },

    _removeEvt: function (evtName) {
        var spy = this.testPanelItem && this.testPanelItem[evtName];
        if (spy) { spy.classList.remove('listening'); }
        window.removeEventListener(evtName, this._bound['on' + evtName]);
    }
};

function extend(obj) {
    for (var i = 1; i < arguments.length; ++i) {
        var objn = arguments[i];
        if (objn) {
            for (var key in objn) {
                obj[key] = objn[key];
            }
        }
    }
    return obj;
}

function validRange(range) {
    var keys = Object.keys(range),
        valid =  keys.length === 2 &&
            typeof range.min === 'number' &&
            typeof range.max === 'number' &&
            range.min <= range.max;

    if (!valid) {
        error('Invalid .range object.');
    }
}

/**
 * @private
 * @name handlersToBeBound
 * @type {object}
 * @desc The functions defined in this object are all DOM event handlers that are bound by the FinBar constructor to each new instance. In other words, the `this` value of these handlers, once bound, refer to the FinBar object and not to the event emitter. "Do not consume raw."
 */
var handlersToBeBound = {
    shortStop: function (evt) {
        evt.stopPropagation();
    },

    onwheel: function (evt) {
        this.index += evt[this.deltaProp];
        evt.stopPropagation();
        evt.preventDefault();
    },

    onclick: function (evt) {
        var thumbBox = this.thumb.getBoundingClientRect(),
            goingUp = evt[this.oh.coordinate] < thumbBox[this.oh.leading];

        if (typeof this.paging === 'object') {
            this.index = this.paging[goingUp ? 'up' : 'down'](Math.round(this.index));
        } else {
            this.index += goingUp ? -this.increment : this.increment;
        }

        // make the thumb glow momentarily
        this.thumb.classList.add('hover');
        var self = this;
        this.thumb.addEventListener('transitionend', function waitForIt() {
            this.removeEventListener('transitionend', waitForIt);
            self._bound.onmouseup(evt);
        });

        evt.stopPropagation();
    },

    onmouseover: function () {
        this.thumb.classList.add('hover');
        this.thumb.onmouseout = this._bound.onmouseout;
        this._addEvt('mousedown');
    },

    onmouseout: function () {
        this._removeEvt('mousedown');
        this.thumb.onmouseover = this._bound.onmouseover;
        this.thumb.classList.remove('hover');
    },

    onmousedown: function (evt) {
        this._removeEvt('mousedown');
        this.thumb.onmouseover = this.thumb.onmouseout = null;

        var thumbBox = this.thumb.getBoundingClientRect();
        this.pinOffset = evt[this.oh.axis] - thumbBox[this.oh.leading] + this.bar.getBoundingClientRect()[this.oh.leading] + this._thumbMarginLeading;
        document.documentElement.style.cursor = 'default';

        this._addEvt('mousemove');
        this._addEvt('mouseup');

        evt.stopPropagation();
        evt.preventDefault();
    },

    onmousemove: function (evt) {
        var scaled = Math.min(this._thumbMax, Math.max(0, evt[this.oh.axis] - this.pinOffset));
        var idx = scaled / this._thumbMax * (this._max - this._min) + this._min;

        this._setScroll(idx, scaled);

        evt.stopPropagation();
        evt.preventDefault();
    },

    onmouseup: function (evt) {
        this._removeEvt('mousemove');
        this._removeEvt('mouseup');

        document.documentElement.style.cursor = 'auto';

        var thumbBox = this.thumb.getBoundingClientRect();
        if (
            thumbBox.left <= evt.clientX && evt.clientX <= thumbBox.right &&
            thumbBox.top <= evt.clientY && evt.clientY <= thumbBox.bottom
        ) {
            this._bound.onmouseover(evt);
        } else {
            this._bound.onmouseout(evt);
        }

        evt.stopPropagation();
        evt.preventDefault();
    }
};

var orientationHashes = {
    vertical: {
        coordinate:     'clientY',
        axis:           'pageY',
        size:           'height',
        outside:        'right',
        inside:         'left',
        leading:        'top',
        trailing:       'bottom',
        marginLeading:  'marginTop',
        marginTrailing: 'marginBottom',
        thickness:      'width',
        delta:          'deltaY'
    },
    horizontal: {
        coordinate:     'clientX',
        axis:           'pageX',
        size:           'width',
        outside:        'bottom',
        inside:         'top',
        leading:        'left',
        trailing:       'right',
        marginLeading:  'marginLeft',
        marginTrailing: 'marginRight',
        thickness:      'height',
        delta:          'deltaX'
    }
};

var axis = {
    top:    'vertical',
    bottom: 'vertical',
    height: 'vertical',
    left:   'horizontal',
    right:  'horizontal',
    width:  'horizontal'
};

var cssFinBars; // definition inserted by gulpfile between following comments
/* inject:css */
cssFinBars = 'div.finbar-horizontal,div.finbar-vertical{position:absolute;margin:3px}div.finbar-horizontal>.thumb,div.finbar-vertical>.thumb{position:absolute;background-color:#d3d3d3;-webkit-box-shadow:0 0 1px #000;-moz-box-shadow:0 0 1px #000;box-shadow:0 0 1px #000;border-radius:4px;margin:2px;opacity:.4;transition:opacity .5s}div.finbar-horizontal>.thumb.hover,div.finbar-vertical>.thumb.hover{opacity:1;transition:opacity .5s}div.finbar-vertical{top:0;bottom:0;right:0;width:11px}div.finbar-vertical>.thumb{top:0;right:0;width:7px}div.finbar-horizontal{left:0;right:0;bottom:0;height:11px}div.finbar-horizontal>.thumb{left:0;bottom:0;height:7px}';
/* endinject */

function error(msg) {
    throw 'finbars: ' + msg;
}

// Interface
module.exports = FinBar;

},{"css-injector":6}],20:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var rectangular = require('rectangular');

var gestures = require('./js/polymergestures.dev.js');
var GraphicsContext = require('./js/GraphicsContext.js');

var RESIZE_POLLING_INTERVAL = 200,
    paintables = [],
    resizables = [],
    paintLoopRunning = true,
    resizeLoopRunning = true,
    charMap = makeCharMap();

function Canvas(div, component, options) {
    var self = this;

    this.div = div;
    this.component = component;

    options = options || {};
    this.doubleClickDelay = options.doubleClickDelay || 325;

    this.dragEndtime = Date.now();

    this.canvas = document.createElement('canvas');
    this.div.appendChild(this.canvas);

    this.canvas.style.outline = 'none';

    // this.focuser = document.createElement('button');
    // this.focuser.style.position = 'absolute';
    // this.focuser.style.top = '0px';
    // this.focuser.style.left = '0px';
    // this.focuser.style.zIndex = '-1';
    // this.focuser.style.outline = 'none';
    // this.div.appendChild(this.focuser);

    this.canvasCTX = this.canvas.getContext('2d');
    this.gc = new GraphicsContext(this.canvasCTX);

    this.buffer = document.createElement('canvas');
    this.bufferCTX = this.buffer.getContext('2d');
    this.bufferGC = new GraphicsContext(this.bufferCTX);

    this.mouseLocation = new rectangular.Point(-1, -1);
    this.dragstart = new rectangular.Point(-1, -1);
    //this.origin = new rectangular.Point(0, 0);
    this.bounds = new rectangular.Rectangle(0, 0, 0, 0);
    this.hasMouse = false;

    document.addEventListener('mousemove', function(e) {
        if (self.hasMouse || self.isDragging()) {
            self.finmousemove(e);
        }
    });
    document.addEventListener('mouseup', function(e) {
        self.finmouseup(e);
    });
    document.addEventListener('wheel', function(e) {
        self.finwheelmoved(e);
    });
    document.addEventListener('keydown', function(e) {
        self.finkeydown(e);
    });
    document.addEventListener('keyup', function(e) {
        self.finkeyup(e);
    });

    this.canvas.onmouseover = function() {
        self.hasMouse = true;
    };
    this.canvas.addEventListener('focus', function(e) {
        self.finfocusgained(e);
    });
    this.canvas.addEventListener('blur', function(e) {
        self.finfocuslost(e);
    });
    this.canvas.addEventListener('mousedown', function(e) {
        self.finmousedown(e);
    });
    this.canvas.addEventListener('mouseout', function(e) {
        self.hasMouse = false;
        self.finmouseout(e);
    });
    this.canvas.addEventListener('click', function(e) {
        self.finclick(e);
    });
    this.canvas.addEventListener('contextmenu', function(e) {
        self.fincontextmenu(e);
        e.preventDefault();
        return false;
    });

    gestures.addEventListener(this.canvas, 'tap', function(e) {
        self.fintap(e);
    });
    gestures.addEventListener(this.canvas, 'holdpulse', function(e) {
        self.finholdpulse(e);
    });
    gestures.addEventListener(this.canvas, 'flick', function(e) {
        self.finflick(e);
    });
    gestures.addEventListener(this.canvas, 'release', function(e) {
        self.finrelease(e);
    });
    gestures.addEventListener(this.canvas, 'trackstart', function(e) {
        self.fintrackstart(e);
    });
    gestures.addEventListener(this.canvas, 'track', function(e) {
        self.fintrack(e);
    });
    gestures.addEventListener(this.canvas, 'trackend', function(e) {
        self.fintrackend(e);
    });

    this.canvas.setAttribute('tabindex', 0);
    this.canvas.contentEditable = true;

    this.resize();

    this.beginResizing();
    this.beginPainting();
}

Canvas.prototype = {
    constructor: Canvas.prototype.constructor,
    div: null,
    component: null,
    gestures: gestures, // TODO: why do we need this? (was previously at bottom of file)
    canvas: null,
    canvasCTX: null,
    focuser: null,
    buffer: null,
    ctx: null,
    mouseLocation: null,
    holdPulseCount: -1,
    dragstart: null,
    origin: null,
    bounds: null,
    dirty: false,
    size: null,
    mousedown: false,
    dragging: false,
    repeatKeyCount: 0,
    repeatKey: null,
    repeatKeyStartTime: 0,
    currentKeys: [],
    hasMouse: false,
    lastDoubleClickTime: 0,
    dragEndTime: 0,
    lastRepaintTime: 0,

    addEventListener: function(name, callback) {
        this.canvas.addEventListener(name, callback);
    },

    stopPaintLoop: function() {
        paintLoopRunning = false;
    },

    restartPaintLoop: function() {
        if (paintLoopRunning) {
            return; // already running
        }
        paintLoopRunning = true;
        requestAnimationFrame(paintLoopFunction);
    },

    stopResizeLoop: function() {
        resizeLoopRunning = false;
    },

    restartResizeLoop: function() {
        if (resizeLoopRunning) {
            return; // already running
        }
        resizeLoopRunning = true;
        setInterval(resizablesLoopFunction, 200);
    },

    detached: function() {
        this.stopPainting();
        this.stopResizing();
    },

    useHiDPI: function() {
        return this.component.resolveProperty('useHiDPI');
    },

    useBitBlit: function() {
        return this.component.resolveProperty('useBitBlit');
    },

    getFPS: function() {
        var fps = this.component.resolveProperty('repaintIntervalRate');
        return fps ? parseInt(fps) : 0;
    },

    tickPaint: function(now) {
        var fps = this.getFPS();
        if (fps === 0) {
            return;
        }
        var interval = 1000 / fps;

        var elapsed = now - this.lastRepaintTime;
        if (elapsed > interval && this.dirty) {
            this.lastRepaintTime = now - (elapsed % interval);
            this.paintNow();
        }
    },

    beginPainting: function() {
        var self = this;
        this.dirty = true;
        this.tickPainter = function(now) {
            self.tickPaint(now);
        };
        paintables.push(this);
    },

    stopPainting: function() {
        paintables.splice(paintables.indexOf(this), 1);
    },

    beginResizing: function() {
        var self = this;
        this.tickResizer = function() {
            self.checksize();
        };
        resizables.push(this);
    },

    stopResizing: function() {
        resizables.splice(resizables.indexOf(this), 1);
    },

    start: function() {
        this.beginPainting();
        this.beginResizing();
    },

    stop: function() {
        this.stopPainting();
        this.stopResizing();
    },

    checksize: function() {
        //this is expensive lets do it at some modulo
        var sizeNow = this.div.getBoundingClientRect();
        if (sizeNow.width !== this.size.width || sizeNow.height !== this.size.height) {
            this.sizeChangedNotification();
        }
    },

    sizeChangedNotification: function() {
        this.resize();
    },

    resize: function() {
        var box = this.size = this.div.getBoundingClientRect();

        this.canvas.width = this.buffer.width = box.width;
        this.canvas.height = this.buffer.height = box.height;

        //fix ala sir spinka, see
        //http://www.html5rocks.com/en/tutorials/canvas/hidpi/
        //just add 'hdpi' as an attribute to the fin-canvas tag
        var ratio = 1;
        var useBitBlit = this.useBitBlit();
        var isHIDPI = window.devicePixelRatio && this.useHiDPI();
        if (isHIDPI) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = this.canvasCTX.webkitBackingStorePixelRatio ||
                this.canvasCTX.mozBackingStorePixelRatio ||
                this.canvasCTX.msBackingStorePixelRatio ||
                this.canvasCTX.oBackingStorePixelRatio ||
                this.canvasCTX.backingStorePixelRatio || 1;

            ratio = devicePixelRatio / backingStoreRatio;
            //this.canvasCTX.scale(ratio, ratio);
        }
        var width = this.canvas.getAttribute('width');
        var height = this.canvas.getAttribute('height');
        this.canvas.width = this.buffer.width = width * ratio;
        this.canvas.height = this.buffer.height = height * ratio;

        this.canvas.style.width = this.buffer.style.width = width + 'px';
        this.canvas.style.height = this.buffer.style.height = height + 'px';

        this.bufferCTX.scale(ratio, ratio);
        if (isHIDPI && !useBitBlit) {
            this.canvasCTX.scale(ratio, ratio);
        }

        //this.origin = new rectangular.Point(Math.round(this.size.left), Math.round(this.size.top));
        this.bounds = new rectangular.Rectangle(0, 0, box.width, box.height);
        //setTimeout(function() {
        var comp = this.component;
        if (comp) {
            comp.setBounds(this.bounds);
        }
        this.resizeNotification();
        this.paintNow();
        //});
    },

    resizeNotification: function() {
        //to be overridden
    },

    getBounds: function() {
        return this.bounds;
    },

    paintNow: function() {
        var self = this;
        this.safePaintImmediately(function(gc) {
            gc.clearRect(0, 0, self.canvas.width, self.canvas.height);

            var comp = self.component;
            if (comp) {
                comp.paint(gc);
            }

            self.dirty = false;
        });
    },

    safePaintImmediately: function(paintFunction) {
        var useBitBlit = this.useBitBlit(),
            gc = useBitBlit ? this.bufferGC : this.gc;
        try {
            gc.save();
            paintFunction(gc);
        } catch (e) {
            console.error(e);
        } finally {
            gc.restore();
        }
        if (useBitBlit) {
            this.flushBuffer();
        }
    },

    flushBuffer: function() {
        if (this.buffer.width > 0 && this.buffer.height > 0) {
            this.canvasCTX.drawImage(this.buffer, 0, 0);
        }
    },

    dispatchNewEvent: function(event, name, detail) {
        detail = {
            detail: detail || {}
        };
        detail.detail.primitiveEvent = event;
        return this.canvas.dispatchEvent(new CustomEvent(name, detail));
    },

    dispatchNewMouseKeysEvent: function(event, name, detail) {
        detail = detail || {};
        detail.mouse = this.mouseLocation;
        detail.keys = this.currentKeys;
        return this.dispatchNewEvent(event, name, detail);
    },

    finmousemove: function(e) {
        if (!this.isDragging() && this.mousedown) {
            this.beDragging();
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragstart', {
                isRightClick: this.isRightClick(e)
            });
            this.dragstart = new rectangular.Point(this.mouseLocation.x, this.mouseLocation.y);
        }
        this.mouseLocation = this.getLocal(e);
        //console.log(this.mouseLocation);
        if (this.isDragging()) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-drag', {
                dragstart: this.dragstart,
                isRightClick: this.isRightClick(e)
            });
        }
        if (this.bounds.contains(this.mouseLocation)) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousemove');
        }
    },

    finmousedown: function(e) {
        this.mouseLocation = this.mouseDownLocation = this.getLocal(e);
        this.mousedown = true;

        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousedown', {
            isRightClick: this.isRightClick(e)
        });
        this.takeFocus();
    },

    finmouseup: function(e) {
        if (this.isDragging()) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragend', {
                dragstart: this.dragstart,
                isRightClick: this.isRightClick(e)
            });
            this.beNotDragging();
            this.dragEndtime = Date.now();
        }
        this.mousedown = false;
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseup', {
            isRightClick: this.isRightClick(e)
        });
        //this.mouseLocation = new rectangular.Point(-1, -1);
    },

    finmouseout: function(e) {
        if (!this.mousedown) {
            this.mouseLocation = new rectangular.Point(-1, -1);
        }
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseout');
    },

    finwheelmoved: function(e) {
        if (this.isDragging() || !this.hasFocus()) {
            return;
        }
        e.preventDefault();
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-wheelmoved', {
            isRightClick: this.isRightClick(e)
        });
    },

    finclick: function(e) {
        if (this.doubleClickTimer && Date.now() - this.lastClickTime < this.doubleClickDelay) {
            //this is a double click...
            clearTimeout(this.doubleClickTimer); // prevent click event
            this.doubleClickTimer = undefined;
            this.findblclick(e);
        } else {
            this.lastClickTime = Date.now();

            this.doubleClickTimer = setTimeout(function() {
                this.doubleClickTimer = undefined;
                this.mouseLocation = this.getLocal(e);
                this.dispatchNewMouseKeysEvent(e, 'fin-canvas-click', {
                    isRightClick: this.isRightClick(e)
                });
            }.bind(this), this.doubleClickDelay);
        }
    },

    finrelease: function(e) {
        this.holdPulseCount = 0;
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-release');
    },

    finflick: function(e) {
        if (!this.hasFocus()) {
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-flick', {
            isRightClick: this.isRightClick(e)
        });
    },

    fintrackstart: function(e) {
        if (!this.hasFocus()) {
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-trackstart');
    },

    fintrack: function(e) {
        if (!this.hasFocus()) {
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-track');
    },

    fintrackend: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-trackend');
    },

    finhold: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-hold', {
            isRightClick: this.isRightClick(e)
        });
    },

    finholdpulse: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-holdpulse', {
            count: this.holdPulseCount++
        });
    },

    fintap: function(e) {
        //this nonsense is to hold a tap if it's really a double click
        var self = this;
        var now = Date.now();
        var dif = now - this.lastDoubleClickTime;
        if (dif < 300) {
            return;
        }
        //dragend is also causing a tap
        //lets fix this here
        if (now - this.dragEndtime < 100) {
            return;
        }
        setTimeout(function() {
            self._fintap(e);
        }, 180);
    },

    _fintap: function(e) {
        //this nonsense is to hold a tap if it's really a double click
        var now = Date.now();
        var dif = now - this.lastDoubleClickTime;
        if (dif < 300) {
            return;
        }

        if (this.mouseDownLocation) { // maybe no mousedown on a phone?
            this.mouseLocation = this.mouseDownLocation; // mouse may have moved since mousedown
            this.mouseDownLocation = undefined; // consume it (maybe not needed; once a mousedown always a mousedown)
        }

        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-tap', {
            isRightClick: this.isRightClick(e)
        });
    },

    findblclick: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.lastDoubleClickTime = Date.now();
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dblclick', {
            isRightClick: this.isRightClick(e)
        });
        //console.log('dblclick', this.currentKeys);
    },

    getCharMap: function() { //TODO: This is static. Make it a property of the constructor.
        return charMap;
    },

    finkeydown: function(e) {
        if (!this.hasFocus()) {
            return;
        }

        //e.preventDefault();
        var keyChar = e.shiftKey ? charMap[e.keyCode][1] : charMap[e.keyCode][0];
        if (e.repeat) {
            if (this.repeatKey === keyChar) {
                this.repeatKeyCount++;
            } else {
                this.repeatKey = keyChar;
                this.repeatKeyStartTime = Date.now();
            }
        } else {
            this.repeatKey = null;
            this.repeatKeyCount = 0;
            this.repeatKeyStartTime = 0;
        }
        if (this.currentKeys.indexOf(keyChar) === -1) {
            this.currentKeys.push(keyChar);
        }
        //console.log(keyChar, e.keyCode);
        this.dispatchNewEvent(e, 'fin-canvas-keydown', {
            alt: e.altKey,
            ctrl: e.ctrlKey,
            char: keyChar,
            code: e.charCode,
            key: e.keyCode,
            meta: e.metaKey,
            repeatCount: this.repeatKeyCount,
            repeatStartTime: this.repeatKeyStartTime,
            shift: e.shiftKey,
            identifier: e.keyIdentifier,
            currentKeys: this.currentKeys.slice(0)
        });
    },

    finkeyup: function(e) {
        var keyChar = e.shiftKey ? charMap[e.keyCode][1] : charMap[e.keyCode][0];
        this.currentKeys.splice(this.currentKeys.indexOf(keyChar), 1);
        if (!this.hasFocus()) {
            return;
        }
        this.repeatKeyCount = 0;
        this.repeatKey = null;
        this.repeatKeyStartTime = 0;
        this.dispatchNewEvent(e, 'fin-canvas-keyup', {
            alt: e.altKey,
            ctrl: e.ctrlKey,
            char: keyChar,
            code: e.charCode,
            key: e.keyCode,
            meta: e.metaKey,
            repeat: e.repeat,
            shift: e.shiftKey,
            identifier: e.keyIdentifier,
            currentKeys: this.currentKeys.slice(0)
        });
    },

    finfocusgained: function(e) {
        this.dispatchNewEvent(e, 'fin-canvas-focus-gained');
    },

    finfocuslost: function(e) {
        this.dispatchNewEvent(e, 'fin-canvas-focus-lost');
    },

    fincontextmenu: function(e) {
        if (e.ctrlKey && this.currentKeys.indexOf('CTRL') === -1) {
            this.currentKeys.push('CTRL');
        }
        if (this.doubleRightClickTimer && Date.now() - this.lastClickTime < this.doubleClickDelay) {
            //this is a double click...
            clearTimeout(this.doubleRightClickTimer); // prevent context menu event
            this.doubleRightClickTimer = undefined;
            this.findblclick(e);
        } else {
            this.lastClickTime = Date.now();

            this.doubleRightClickTimer = setTimeout(function() {
                this.doubleRightClickTimer = undefined;
                this.dispatchNewMouseKeysEvent(e, 'fin-canvas-context-menu', {
                    isRightClick: this.isRightClick(e)
                });
            }.bind(this), this.doubleClickDelay);
        }
    },

    repaint: function() {
        var fps = this.getFPS();
        this.dirty = true;
        if (!paintLoopRunning || fps === 0) {
            this.paintNow();
        }
    },

    getMouseLocation: function() {
        return this.mouseLocation;
    },

    getOrigin: function() {
        var rect = this.canvas.getBoundingClientRect();
        var p = new rectangular.Point(rect.left, rect.top);
        return p;
    },

    getLocal: function(e) {
        var rect = this.canvas.getBoundingClientRect();
        var p = new rectangular.Point(e.clientX - rect.left, e.clientY - rect.top);
        return p;
    },

    hasFocus: function() {
        return document.activeElement === this.canvas;
    },

    takeFocus: function() {
        var self = this;
        if (!this.hasFocus()) {
            setTimeout(function() {
                self.canvas.focus();
            }, 10);
        }
    },

    beDragging: function() {
        this.dragging = true;
        this.disableDocumentElementSelection();
    },

    beNotDragging: function() {
        this.dragging = false;
        this.enableDocumentElementSelection();
    },

    isDragging: function() {
        return this.dragging;
    },

    disableDocumentElementSelection: function() {
        var style = document.body.style;
        style.cssText = style.cssText + '-webkit-user-select: none';
    },

    enableDocumentElementSelection: function() {
        var style = document.body.style;
        style.cssText = style.cssText.replace('-webkit-user-select: none', '');
    },

    setFocusable: function(truthy) {
        this.focuser.style.display = truthy ? '' : 'none';
    },

    isRightClick: function(e) {
        var isRightMB;
        e = e || window.event;

        if ('which' in e) { // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
            isRightMB = e.which === 3;
        } else if ('button' in e) { // IE, Opera
            isRightMB = e.button === 2;
        }
        return isRightMB;
    },

    dispatchEvent: function(e) {
        return this.canvas.dispatchEvent(e);
    }
};

function paintLoopFunction(now) {
    if (!paintLoopRunning) {
        return;
    }
    for (var i = 0; i < paintables.length; i++) {
        try {
            paintables[i].tickPainter(now);
        } catch (e) {
            console.error(e);
        }
    }
    requestAnimationFrame(paintLoopFunction);
}
requestAnimationFrame(paintLoopFunction);

function resizablesLoopFunction(now) {
    if (!resizeLoopRunning) {
        return;
    }
    for (var i = 0; i < resizables.length; i++) {
        try {
            resizables[i].tickResizer(now);
        } catch (e) {
            console.error(e);
        }
    }
}
setInterval(resizablesLoopFunction, RESIZE_POLLING_INTERVAL);

function makeCharMap() {
    var map = [];

    var empty = ['', ''];

    for (var i = 0; i < 256; i++) {
        map[i] = empty;
    }

    map[27] = ['ESC', 'ESCSHIFT'];
    map[192] = ['`', '~'];
    map[49] = ['1', '!'];
    map[50] = ['2', '@'];
    map[51] = ['3', '#'];
    map[52] = ['4', '$'];
    map[53] = ['5', '%'];
    map[54] = ['6', '^'];
    map[55] = ['7', '&'];
    map[56] = ['8', '*'];
    map[57] = ['9', '('];
    map[48] = ['0', ')'];
    map[189] = ['-', '_'];
    map[187] = ['=', '+'];
    map[8] = ['BACKSPACE', 'BACKSPACESHIFT'];
    map[46] = ['DELETE', 'DELETESHIFT'];
    map[9] = ['TAB', 'TABSHIFT'];
    map[81] = ['q', 'Q'];
    map[87] = ['w', 'W'];
    map[69] = ['e', 'E'];
    map[82] = ['r', 'R'];
    map[84] = ['t', 'T'];
    map[89] = ['y', 'Y'];
    map[85] = ['u', 'U'];
    map[73] = ['i', 'I'];
    map[79] = ['o', 'O'];
    map[80] = ['p', 'P'];
    map[219] = ['[', '{'];
    map[221] = [']', '}'];
    map[220] = ['\\', '|'];
    map[220] = ['CAPSLOCK', 'CAPSLOCKSHIFT'];
    map[65] = ['a', 'A'];
    map[83] = ['s', 'S'];
    map[68] = ['d', 'D'];
    map[70] = ['f', 'F'];
    map[71] = ['g', 'G'];
    map[72] = ['h', 'H'];
    map[74] = ['j', 'J'];
    map[75] = ['k', 'K'];
    map[76] = ['l', 'L'];
    map[186] = [';', ':'];
    map[222] = ['\'', '|'];
    map[13] = ['RETURN', 'RETURNSHIFT'];
    map[16] = ['SHIFT', 'SHIFT'];
    map[90] = ['z', 'Z'];
    map[88] = ['x', 'X'];
    map[67] = ['c', 'C'];
    map[86] = ['v', 'V'];
    map[66] = ['b', 'B'];
    map[78] = ['n', 'N'];
    map[77] = ['m', 'M'];
    map[188] = [',', '<'];
    map[190] = ['.', '>'];
    map[191] = ['/', '?'];
    map[16] = ['SHIFT', 'SHIFT'];
    map[17] = ['CTRL', 'CTRLSHIFT'];
    map[18] = ['ALT', 'ALTSHIFT'];
    map[91] = ['COMMANDLEFT', 'COMMANDLEFTSHIFT'];
    map[32] = ['SPACE', 'SPACESHIFT'];
    map[93] = ['COMMANDRIGHT', 'COMMANDRIGHTSHIFT'];
    map[18] = ['ALT', 'ALTSHIFT'];
    map[38] = ['UP', 'UPSHIFT'];
    map[37] = ['LEFT', 'LEFTSHIFT'];
    map[40] = ['DOWN', 'DOWNSHIFT'];
    map[39] = ['RIGHT', 'RIGHTSHIFT'];

    map[33] = ['PAGEUP', 'PAGEUPSHIFT'];
    map[34] = ['PAGEDOWN', 'PAGEDOWNSHIFT'];
    map[35] = ['PAGERIGHT', 'PAGERIGHTSHIFT']; // END
    map[36] = ['PAGELEFT', 'PAGELEFTSHIFT']; // HOME

    map[112] = ['F1', 'F1SHIFT'];
    map[113] = ['F2', 'F2SHIFT'];
    map[114] = ['F3', 'F3SHIFT'];
    map[115] = ['F4', 'F4SHIFT'];
    map[116] = ['F5', 'F5SHIFT'];
    map[117] = ['F6', 'F6SHIFT'];
    map[118] = ['F7', 'F7SHIFT'];
    map[119] = ['F8', 'F8SHIFT'];
    map[120] = ['F9', 'F9SHIFT'];
    map[121] = ['F10', 'F10SHIFT'];
    map[122] = ['F11', 'F1S1HIFT'];
    map[123] = ['F12', 'F121HIFT'];

    return map;
}

module.exports = Canvas;

},{"./js/GraphicsContext.js":21,"./js/polymergestures.dev.js":23,"rectangular":48}],21:[function(require,module,exports){
'use strict';

var consoleLogger = require('./gc-console-logger');

/**
 * @constructor
 * @param gc - The 2-D graphics context from your canvas
 * @param {boolean|apiLogger} [logger=true]
 * * `true` uses `gc-console-logger` function bound to 'gc.' as prefix
 * * string uses `gc-console-logger` function bound to string
 * * function used as is
 */
function GraphicsContext(gc, logger) {
    this.gc = gc;

    var self = this;
    var reWEBKIT = /^webkit/;

    switch (typeof logger) {

        case 'string':
            logger =  consoleLogger.bind(undefined, logger + '.');
            break;

        case 'boolean':
            if (logger === true) {
                logger = consoleLogger.bind(undefined, 'gc.');
            }
            break;

        case 'function':
            if (logger.length !== 3) {
                throw 'GraphicsContext: User-supplied API logger function does not accept three parameters.';
            }
            break;

        default:
            logger = false;
    }

    // Stub out all the prototype members of the canvas 2D graphics context:
    Object.keys(Object.getPrototypeOf(gc)).forEach(MakeStub);

    // Some older browsers (e.g., Chrome 40) did not have all members of canvas
    // 2D graphics context in the prototype so we make this additional call:
    Object.keys(gc).forEach(MakeStub);

    function MakeStub(key) {
        if (key in GraphicsContext.prototype || reWEBKIT.test(key)) {
            return;
        }
        if (typeof gc[key] === 'function') {
            self[key] = !logger ? gc[key].bind(gc) : function() {
                return logger(key, arguments, gc[key].apply(gc, arguments));
            };
        } else {
            Object.defineProperty(self, key, {
                get: function() {
                    var result = gc[key];
                    return logger ? logger(key, 'getter', result) : result;
                },
                set: function(value) {
                    gc[key] = logger ? logger(key, 'setter', value) : value;
                }
            });
        }
    }
}

module.exports = GraphicsContext;

},{"./gc-console-logger":22}],22:[function(require,module,exports){
'use strict';

var YIELDS = '\u27F9'; // LONG RIGHTWARDS DOUBLE ARROW

function consoleLogger(prefix, name, args, value) {
    var result = value;

    if (typeof value === 'string') {
        result = '"' + result + '"';
    }

    name = prefix + name;

    switch (args) {
        case 'getter':
            console.log(name, '=', result);
            break;

        case 'setter':
            console.log(name, YIELDS, result);
            break;

        default: // method call
            name += '(' + Array.prototype.slice.call(args).join(', ') + ')';
            if (result === undefined) {
                console.log(name);
            } else {
                console.log(name, YIELDS, result);
            }
    }

    return value;
}

module.exports = consoleLogger;

},{}],23:[function(require,module,exports){
/* eslint-disable */

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
//module.exports = {};

(function(scope) {
    var hasFullPath = false;

    // test for full event path support
    var pathTest = document.createElement('meta');
    if (pathTest.createShadowRoot) {
        var sr = pathTest.createShadowRoot();
        var s = document.createElement('span');
        sr.appendChild(s);
        pathTest.addEventListener('testpath', function(ev) {
            if (ev.path) {
                // if the span is in the event path, then path[0] is the real source for all events
                hasFullPath = ev.path[0] === s;
            }
            ev.stopPropagation();
        });
        var ev = new CustomEvent('testpath', {
            bubbles: true
        });
        // must add node to DOM to trigger event listener
        document.head.appendChild(pathTest);
        s.dispatchEvent(ev);
        pathTest.parentNode.removeChild(pathTest);
        sr = s = null;
    }
    pathTest = null;

    var target = {
        shadow: function(inEl) {
            if (inEl) {
                return inEl.shadowRoot || inEl.webkitShadowRoot;
            }
        },
        canTarget: function(shadow) {
            return shadow && Boolean(shadow.elementFromPoint);
        },
        targetingShadow: function(inEl) {
            var s = this.shadow(inEl);
            if (this.canTarget(s)) {
                return s;
            }
        },
        olderShadow: function(shadow) {
            var os = shadow.olderShadowRoot;
            if (!os) {
                var se = shadow.querySelector('shadow');
                if (se) {
                    os = se.olderShadowRoot;
                }
            }
            return os;
        },
        allShadows: function(element) {
            var shadows = [],
                s = this.shadow(element);
            while (s) {
                shadows.push(s);
                s = this.olderShadow(s);
            }
            return shadows;
        },
        searchRoot: function(inRoot, x, y) {
            var t, st, sr, os;
            if (inRoot) {
                t = inRoot.elementFromPoint(x, y);
                if (t) {
                    // found element, check if it has a ShadowRoot
                    sr = this.targetingShadow(t);
                } else if (inRoot !== document) {
                    // check for sibling roots
                    sr = this.olderShadow(inRoot);
                }
                // search other roots, fall back to light dom element
                return this.searchRoot(sr, x, y) || t;
            }
        },
        owner: function(element) {
            if (!element) {
                return document;
            }
            var s = element;
            // walk up until you hit the shadow root or document
            while (s.parentNode) {
                s = s.parentNode;
            }
            // the owner element is expected to be a Document or ShadowRoot
            if (s.nodeType != Node.DOCUMENT_NODE && s.nodeType != Node.DOCUMENT_FRAGMENT_NODE) {
                s = document;
            }
            return s;
        },
        findTarget: function(inEvent) {
            if (hasFullPath && inEvent.path && inEvent.path.length) {
                return inEvent.path[0];
            }
            var x = inEvent.clientX,
                y = inEvent.clientY;
            // if the listener is in the shadow root, it is much faster to start there
            var s = this.owner(inEvent.target);
            // if x, y is not in this root, fall back to document search
            if (!s.elementFromPoint(x, y)) {
                s = document;
            }
            return this.searchRoot(s, x, y);
        },
        findTouchAction: function(inEvent) {
            var n;
            if (hasFullPath && inEvent.path && inEvent.path.length) {
                var path = inEvent.path;
                for (var i = 0; i < path.length; i++) {
                    n = path[i];
                    if (n.nodeType === Node.ELEMENT_NODE && n.hasAttribute('touch-action')) {
                        return n.getAttribute('touch-action');
                    }
                }
            } else {
                n = inEvent.target;
                while (n) {
                    if (n.nodeType === Node.ELEMENT_NODE && n.hasAttribute('touch-action')) {
                        return n.getAttribute('touch-action');
                    }
                    n = n.parentNode || n.host;
                }
            }
            // auto is default
            return "auto";
        },
        LCA: function(a, b) {
            if (a === b) {
                return a;
            }
            if (a && !b) {
                return a;
            }
            if (b && !a) {
                return b;
            }
            if (!b && !a) {
                return document;
            }
            // fast case, a is a direct descendant of b or vice versa
            if (a.contains && a.contains(b)) {
                return a;
            }
            if (b.contains && b.contains(a)) {
                return b;
            }
            var adepth = this.depth(a);
            var bdepth = this.depth(b);
            var d = adepth - bdepth;
            if (d >= 0) {
                a = this.walk(a, d);
            } else {
                b = this.walk(b, -d);
            }
            while (a && b && a !== b) {
                a = a.parentNode || a.host;
                b = b.parentNode || b.host;
            }
            return a;
        },
        walk: function(n, u) {
            for (var i = 0; n && (i < u); i++) {
                n = n.parentNode || n.host;
            }
            return n;
        },
        depth: function(n) {
            var d = 0;
            while (n) {
                d++;
                n = n.parentNode || n.host;
            }
            return d;
        },
        deepContains: function(a, b) {
            var common = this.LCA(a, b);
            // if a is the common ancestor, it must "deeply" contain b
            return common === a;
        },
        insideNode: function(node, x, y) {
            var rect = node.getBoundingClientRect();
            return (rect.left <= x) && (x <= rect.right) && (rect.top <= y) && (y <= rect.bottom);
        },
        path: function(event) {
            var p;
            if (hasFullPath && event.path && event.path.length) {
                p = event.path;
            } else {
                p = [];
                var n = this.findTarget(event);
                while (n) {
                    p.push(n);
                    n = n.parentNode || n.host;
                }
            }
            return p;
        }
    };
    scope.targetFinding = target;
    /**
     * Given an event, finds the "deepest" node that could have been the original target before ShadowDOM retargetting
     *
     * @param {Event} Event An event object with clientX and clientY properties
     * @return {Element} The probable event origninator
     */
    scope.findTarget = target.findTarget.bind(target);
    /**
     * Determines if the "container" node deeply contains the "containee" node, including situations where the "containee" is contained by one or more ShadowDOM
     * roots.
     *
     * @param {Node} container
     * @param {Node} containee
     * @return {Boolean}
     */
    scope.deepContains = target.deepContains.bind(target);

    /**
     * Determines if the x/y position is inside the given node.
     *
     * Example:
     *
     *     function upHandler(event) {
     *       var innode = PolymerGestures.insideNode(event.target, event.clientX, event.clientY);
     *       if (innode) {
     *         // wait for tap?
     *       } else {
     *         // tap will never happen
     *       }
     *     }
     *
     * @param {Node} node
     * @param {Number} x Screen X position
     * @param {Number} y screen Y position
     * @return {Boolean}
     */
    scope.insideNode = target.insideNode;

})(exports);

(function() {
    function shadowSelector(v) {
        return 'html /deep/ ' + selector(v);
    }

    function selector(v) {
        return '[touch-action="' + v + '"]';
    }

    function rule(v) {
        return '{ -ms-touch-action: ' + v + '; touch-action: ' + v + ';}';
    }
    var attrib2css = [
        'none',
        'auto',
        'pan-x',
        'pan-y', {
            rule: 'pan-x pan-y',
            selectors: [
                'pan-x pan-y',
                'pan-y pan-x'
            ]
        },
        'manipulation'
    ];
    var styles = '';
    // only install stylesheet if the browser has touch action support
    var hasTouchAction = typeof document.head.style.touchAction === 'string';
    // only add shadow selectors if shadowdom is supported
    var hasShadowRoot = !window.ShadowDOMPolyfill && document.head.createShadowRoot;

    if (hasTouchAction) {
        attrib2css.forEach(function(r) {
            if (String(r) === r) {
                styles += selector(r) + rule(r) + '\n';
                if (hasShadowRoot) {
                    styles += shadowSelector(r) + rule(r) + '\n';
                }
            } else {
                styles += r.selectors.map(selector) + rule(r.rule) + '\n';
                if (hasShadowRoot) {
                    styles += r.selectors.map(shadowSelector) + rule(r.rule) + '\n';
                }
            }
        });

        var el = document.createElement('style');
        el.textContent = styles;
        document.head.appendChild(el);
    }
})();

/**
 * This is the constructor for new PointerEvents.
 *
 * New Pointer Events must be given a type, and an optional dictionary of
 * initialization properties.
 *
 * Due to certain platform requirements, events returned from the constructor
 * identify as MouseEvents.
 *
 * @constructor
 * @param {String} inType The type of the event to create.
 * @param {Object} [inDict] An optional dictionary of initial event properties.
 * @return {Event} A new PointerEvent of type `inType` and initialized with properties from `inDict`.
 */
(function(scope) {

    var MOUSE_PROPS = [
        'bubbles',
        'cancelable',
        'view',
        'detail',
        'screenX',
        'screenY',
        'clientX',
        'clientY',
        'ctrlKey',
        'altKey',
        'shiftKey',
        'metaKey',
        'button',
        'relatedTarget',
        'pageX',
        'pageY'
    ];

    var MOUSE_DEFAULTS = [
        false,
        false,
        null,
        null,
        0,
        0,
        0,
        0,
        false,
        false,
        false,
        false,
        0,
        null,
        0,
        0
    ];

    var NOP_FACTORY = function() {
        return function() {};
    };

    var eventFactory = {
        // TODO(dfreedm): this is overridden by tap recognizer, needs review
        preventTap: NOP_FACTORY,
        makeBaseEvent: function(inType, inDict) {
            var e = document.createEvent('Event');
            e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);
            e.preventTap = eventFactory.preventTap(e);
            return e;
        },
        makeGestureEvent: function(inType, inDict) {
            inDict = inDict || Object.create(null);

            var e = this.makeBaseEvent(inType, inDict);
            for (var i = 0, keys = Object.keys(inDict), k; i < keys.length; i++) {
                k = keys[i];
                if (k !== 'bubbles' && k !== 'cancelable') {
                    e[k] = inDict[k];
                }
            }
            return e;
        },
        makePointerEvent: function(inType, inDict) {
            inDict = inDict || Object.create(null);

            var e = this.makeBaseEvent(inType, inDict);
            // define inherited MouseEvent properties
            for (var i = 2, p; i < MOUSE_PROPS.length; i++) {
                p = MOUSE_PROPS[i];
                e[p] = inDict[p] || MOUSE_DEFAULTS[i];
            }
            e.buttons = inDict.buttons || 0;

            // Spec requires that pointers without pressure specified use 0.5 for down
            // state and 0 for up state.
            var pressure = 0;
            if (inDict.pressure) {
                pressure = inDict.pressure;
            } else {
                pressure = e.buttons ? 0.5 : 0;
            }

            // add x/y properties aliased to clientX/Y
            e.x = e.clientX;
            e.y = e.clientY;

            // define the properties of the PointerEvent interface
            e.pointerId = inDict.pointerId || 0;
            e.width = inDict.width || 0;
            e.height = inDict.height || 0;
            e.pressure = pressure;
            e.tiltX = inDict.tiltX || 0;
            e.tiltY = inDict.tiltY || 0;
            e.pointerType = inDict.pointerType || '';
            e.hwTimestamp = inDict.hwTimestamp || 0;
            e.isPrimary = inDict.isPrimary || false;
            e._source = inDict._source || '';
            return e;
        }
    };

    scope.eventFactory = eventFactory;
})(exports);

/**
 * This module implements an map of pointer states
 */
(function(scope) {
    var USE_MAP = window.Map && window.Map.prototype.forEach;
    var POINTERS_FN = function() {
        return this.size;
    };

    function PointerMap() {
        if (USE_MAP) {
            var m = new Map();
            m.pointers = POINTERS_FN;
            return m;
        } else {
            this.keys = [];
            this.values = [];
        }
    }

    PointerMap.prototype = {
        set: function(inId, inEvent) {
            var i = this.keys.indexOf(inId);
            if (i > -1) {
                this.values[i] = inEvent;
            } else {
                this.keys.push(inId);
                this.values.push(inEvent);
            }
        },
        has: function(inId) {
            return this.keys.indexOf(inId) > -1;
        },
        'delete': function(inId) {
            var i = this.keys.indexOf(inId);
            if (i > -1) {
                this.keys.splice(i, 1);
                this.values.splice(i, 1);
            }
        },
        get: function(inId) {
            var i = this.keys.indexOf(inId);
            return this.values[i];
        },
        clear: function() {
            this.keys.length = 0;
            this.values.length = 0;
        },
        // return value, key, map
        forEach: function(callback, thisArg) {
            this.values.forEach(function(v, i) {
                callback.call(thisArg, v, this.keys[i], this);
            }, this);
        },
        pointers: function() {
            return this.keys.length;
        }
    };

    scope.PointerMap = PointerMap;
})(exports);

(function(scope) {
    var CLONE_PROPS = [
        // MouseEvent
        'bubbles',
        'cancelable',
        'view',
        'detail',
        'screenX',
        'screenY',
        'clientX',
        'clientY',
        'ctrlKey',
        'altKey',
        'shiftKey',
        'metaKey',
        'button',
        'relatedTarget',
        // DOM Level 3
        'buttons',
        // PointerEvent
        'pointerId',
        'width',
        'height',
        'pressure',
        'tiltX',
        'tiltY',
        'pointerType',
        'hwTimestamp',
        'isPrimary',
        // event instance
        'type',
        'target',
        'currentTarget',
        'which',
        'pageX',
        'pageY',
        'timeStamp',
        // gesture addons
        'preventTap',
        'tapPrevented',
        '_source'
    ];

    var CLONE_DEFAULTS = [
        // MouseEvent
        false,
        false,
        null,
        null,
        0,
        0,
        0,
        0,
        false,
        false,
        false,
        false,
        0,
        null,
        // DOM Level 3
        0,
        // PointerEvent
        0,
        0,
        0,
        0,
        0,
        0,
        '',
        0,
        false,
        // event instance
        '',
        null,
        null,
        0,
        0,
        0,
        0,
        function() {},
        false
    ];

    var HAS_SVG_INSTANCE = (typeof SVGElementInstance !== 'undefined');

    var eventFactory = scope.eventFactory;

    // set of recognizers to run for the currently handled event
    var currentGestures;

    /**
     * This module is for normalizing events. Mouse and Touch events will be
     * collected here, and fire PointerEvents that have the same semantics, no
     * matter the source.
     * Events fired:
     *   - pointerdown: a pointing is added
     *   - pointerup: a pointer is removed
     *   - pointermove: a pointer is moved
     *   - pointerover: a pointer crosses into an element
     *   - pointerout: a pointer leaves an element
     *   - pointercancel: a pointer will no longer generate events
     */
    var dispatcher = {
        IS_IOS: false,
        pointermap: new scope.PointerMap(),
        requiredGestures: new scope.PointerMap(),
        eventMap: Object.create(null),
        // Scope objects for native events.
        // This exists for ease of testing.
        eventSources: Object.create(null),
        eventSourceList: [],
        gestures: [],
        // map gesture event -> {listeners: int, index: gestures[int]}
        dependencyMap: {
            // make sure down and up are in the map to trigger "register"
            down: {
                listeners: 0,
                index: -1
            },
            up: {
                listeners: 0,
                index: -1
            }
        },
        gestureQueue: [],
        /**
         * Add a new event source that will generate pointer events.
         *
         * `inSource` must contain an array of event names named `events`, and
         * functions with the names specified in the `events` array.
         * @param {string} name A name for the event source
         * @param {Object} source A new source of platform events.
         */
        registerSource: function(name, source) {
            var s = source;
            var newEvents = s.events;
            if (newEvents) {
                newEvents.forEach(function(e) {
                    if (s[e]) {
                        this.eventMap[e] = s[e].bind(s);
                    }
                }, this);
                this.eventSources[name] = s;
                this.eventSourceList.push(s);
            }
        },
        registerGesture: function(name, source) {
            var obj = Object.create(null);
            obj.listeners = 0;
            obj.index = this.gestures.length;
            for (var i = 0, g; i < source.exposes.length; i++) {
                g = source.exposes[i].toLowerCase();
                this.dependencyMap[g] = obj;
            }
            this.gestures.push(source);
        },
        register: function(element, initial) {
            var l = this.eventSourceList.length;
            for (var i = 0, es;
                (i < l) && (es = this.eventSourceList[i]); i++) {
                // call eventsource register
                es.register.call(es, element, initial);
            }
        },
        unregister: function(element) {
            var l = this.eventSourceList.length;
            for (var i = 0, es;
                (i < l) && (es = this.eventSourceList[i]); i++) {
                // call eventsource register
                es.unregister.call(es, element);
            }
        },
        // EVENTS
        down: function(inEvent) {
            this.requiredGestures.set(inEvent.pointerId, currentGestures);
            this.fireEvent('down', inEvent);
        },
        move: function(inEvent) {
            // pipe move events into gesture queue directly
            inEvent.type = 'move';
            this.fillGestureQueue(inEvent);
        },
        up: function(inEvent) {
            this.fireEvent('up', inEvent);
            this.requiredGestures.delete(inEvent.pointerId);
        },
        cancel: function(inEvent) {
            inEvent.tapPrevented = true;
            this.fireEvent('up', inEvent);
            this.requiredGestures.delete(inEvent.pointerId);
        },
        addGestureDependency: function(node, currentGestures) {
            var gesturesWanted = node._pgEvents;
            if (gesturesWanted && currentGestures) {
                var gk = Object.keys(gesturesWanted);
                for (var i = 0, r, ri, g; i < gk.length; i++) {
                    // gesture
                    g = gk[i];
                    if (gesturesWanted[g] > 0) {
                        // lookup gesture recognizer
                        r = this.dependencyMap[g];
                        // recognizer index
                        ri = r ? r.index : -1;
                        currentGestures[ri] = true;
                    }
                }
            }
        },
        // LISTENER LOGIC
        eventHandler: function(inEvent) {
            // This is used to prevent multiple dispatch of events from
            // platform events. This can happen when two elements in different scopes
            // are set up to create pointer events, which is relevant to Shadow DOM.

            var type = inEvent.type;

            // only generate the list of desired events on "down"
            if (type === 'touchstart' || type === 'mousedown' || type === 'pointerdown' || type === 'MSPointerDown') {
                if (!inEvent._handledByPG) {
                    currentGestures = {};
                }

                // in IOS mode, there is only a listener on the document, so this is not re-entrant
                if (this.IS_IOS) {
                    var ev = inEvent;
                    if (type === 'touchstart') {
                        var ct = inEvent.changedTouches[0];
                        // set up a fake event to give to the path builder
                        ev = {
                            target: inEvent.target,
                            clientX: ct.clientX,
                            clientY: ct.clientY,
                            path: inEvent.path
                        };
                    }
                    // use event path if available, otherwise build a path from target finding
                    var nodes = inEvent.path || scope.targetFinding.path(ev);
                    for (var i = 0, n; i < nodes.length; i++) {
                        n = nodes[i];
                        this.addGestureDependency(n, currentGestures);
                    }
                } else {
                    this.addGestureDependency(inEvent.currentTarget, currentGestures);
                }
            }

            if (inEvent._handledByPG) {
                return;
            }
            var fn = this.eventMap && this.eventMap[type];
            if (fn) {
                fn(inEvent);
            }
            inEvent._handledByPG = true;
        },
        // set up event listeners
        listen: function(target, events) {
            for (var i = 0, l = events.length, e;
                (i < l) && (e = events[i]); i++) {
                this.addEvent(target, e);
            }
        },
        // remove event listeners
        unlisten: function(target, events) {
            for (var i = 0, l = events.length, e;
                (i < l) && (e = events[i]); i++) {
                this.removeEvent(target, e);
            }
        },
        addEvent: function(target, eventName) {
            target.addEventListener(eventName, this.boundHandler);
        },
        removeEvent: function(target, eventName) {
            target.removeEventListener(eventName, this.boundHandler);
        },
        // EVENT CREATION AND TRACKING
        /**
         * Creates a new Event of type `inType`, based on the information in
         * `inEvent`.
         *
         * @param {string} inType A string representing the type of event to create
         * @param {Event} inEvent A platform event with a target
         * @return {Event} A PointerEvent of type `inType`
         */
        makeEvent: function(inType, inEvent) {
            var e = eventFactory.makePointerEvent(inType, inEvent);
            e.preventDefault = inEvent.preventDefault;
            e.tapPrevented = inEvent.tapPrevented;
            e._target = e._target || inEvent.target;
            return e;
        },
        // make and dispatch an event in one call
        fireEvent: function(inType, inEvent) {
            var e = this.makeEvent(inType, inEvent);
            return this.dispatchEvent(e);
        },
        /**
         * Returns a snapshot of inEvent, with writable properties.
         *
         * @param {Event} inEvent An event that contains properties to copy.
         * @return {Object} An object containing shallow copies of `inEvent`'s
         *    properties.
         */
        cloneEvent: function(inEvent) {
            var eventCopy = Object.create(null),
                p;
            for (var i = 0; i < CLONE_PROPS.length; i++) {
                p = CLONE_PROPS[i];
                eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];
                // Work around SVGInstanceElement shadow tree
                // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
                // This is the behavior implemented by Firefox.
                if (p === 'target' || p === 'relatedTarget') {
                    if (HAS_SVG_INSTANCE && eventCopy[p] instanceof SVGElementInstance) {
                        eventCopy[p] = eventCopy[p].correspondingUseElement;
                    }
                }
            }
            // keep the semantics of preventDefault
            eventCopy.preventDefault = function() {
                inEvent.preventDefault();
            };
            return eventCopy;
        },
        /**
         * Dispatches the event to its target.
         *
         * @param {Event} inEvent The event to be dispatched.
         * @return {Boolean} True if an event handler returns true, false otherwise.
         */
        dispatchEvent: function(inEvent) {
            var t = inEvent._target;
            if (t) {
                t.dispatchEvent(inEvent);
                // clone the event for the gesture system to process
                // clone after dispatch to pick up gesture prevention code
                var clone = this.cloneEvent(inEvent);
                clone.target = t;
                this.fillGestureQueue(clone);
            }
        },
        gestureTrigger: function() {
            // process the gesture queue
            for (var i = 0, e, rg; i < this.gestureQueue.length; i++) {
                e = this.gestureQueue[i];
                rg = e._requiredGestures;
                if (rg) {
                    for (var j = 0, g, fn; j < this.gestures.length; j++) {
                        // only run recognizer if an element in the source event's path is listening for those gestures
                        if (rg[j]) {
                            g = this.gestures[j];
                            fn = g[e.type];
                            if (fn) {
                                fn.call(g, e);
                            }
                        }
                    }
                }
            }
            this.gestureQueue.length = 0;
        },
        fillGestureQueue: function(ev) {
            // only trigger the gesture queue once
            if (!this.gestureQueue.length) {
                requestAnimationFrame(this.boundGestureTrigger);
            }
            ev._requiredGestures = this.requiredGestures.get(ev.pointerId);
            this.gestureQueue.push(ev);
        }
    };
    dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);
    dispatcher.boundGestureTrigger = dispatcher.gestureTrigger.bind(dispatcher);
    scope.dispatcher = dispatcher;

    /**
     * Listen for `gesture` on `node` with the `handler` function
     *
     * If `handler` is the first listener for `gesture`, the underlying gesture recognizer is then enabled.
     *
     * @param {Element} node
     * @param {string} gesture
     * @return Boolean `gesture` is a valid gesture
     */
    scope.activateGesture = function(node, gesture) {
        var g = gesture.toLowerCase();
        var dep = dispatcher.dependencyMap[g];
        if (dep) {
            var recognizer = dispatcher.gestures[dep.index];
            if (!node._pgListeners) {
                dispatcher.register(node);
                node._pgListeners = 0;
            }
            // TODO(dfreedm): re-evaluate bookkeeping to avoid using attributes
            if (recognizer) {
                var touchAction = recognizer.defaultActions && recognizer.defaultActions[g];
                var actionNode;
                switch (node.nodeType) {
                    case Node.ELEMENT_NODE:
                        actionNode = node;
                        break;
                    case Node.DOCUMENT_FRAGMENT_NODE:
                        actionNode = node.host;
                        break;
                    default:
                        actionNode = null;
                        break;
                }
                if (touchAction && actionNode && !actionNode.hasAttribute('touch-action')) {
                    actionNode.setAttribute('touch-action', touchAction);
                }
            }
            if (!node._pgEvents) {
                node._pgEvents = {};
            }
            node._pgEvents[g] = (node._pgEvents[g] || 0) + 1;
            node._pgListeners++;
        }
        return Boolean(dep);
    };

    /**
     *
     * Listen for `gesture` from `node` with `handler` function.
     *
     * @param {Element} node
     * @param {string} gesture
     * @param {Function} handler
     * @param {Boolean} capture
     */
    scope.addEventListener = function(node, gesture, handler, capture) {
        if (handler) {
            scope.activateGesture(node, gesture);
            node.addEventListener(gesture, handler, capture);
        }
    };

    /**
     * Tears down the gesture configuration for `node`
     *
     * If `handler` is the last listener for `gesture`, the underlying gesture recognizer is disabled.
     *
     * @param {Element} node
     * @param {string} gesture
     * @return Boolean `gesture` is a valid gesture
     */
    scope.deactivateGesture = function(node, gesture) {
        var g = gesture.toLowerCase();
        var dep = dispatcher.dependencyMap[g];
        if (dep) {
            if (node._pgListeners > 0) {
                node._pgListeners--;
            }
            if (node._pgListeners === 0) {
                dispatcher.unregister(node);
            }
            if (node._pgEvents) {
                if (node._pgEvents[g] > 0) {
                    node._pgEvents[g]--;
                } else {
                    node._pgEvents[g] = 0;
                }
            }
        }
        return Boolean(dep);
    };

    /**
     * Stop listening for `gesture` from `node` with `handler` function.
     *
     * @param {Element} node
     * @param {string} gesture
     * @param {Function} handler
     * @param {Boolean} capture
     */
    scope.removeEventListener = function(node, gesture, handler, capture) {
        if (handler) {
            scope.deactivateGesture(node, gesture);
            node.removeEventListener(gesture, handler, capture);
        }
    };
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var pointermap = dispatcher.pointermap;
    // radius around touchend that swallows mouse events
    var DEDUP_DIST = 25;

    var WHICH_TO_BUTTONS = [0, 1, 4, 2];

    var currentButtons = 0;

    var FIREFOX_LINUX = /Linux.*Firefox\//i;

    var HAS_BUTTONS = (function() {
        // firefox on linux returns spec-incorrect values for mouseup.buttons
        // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.buttons#See_also
        // https://codereview.chromium.org/727593003/#msg16
        if (FIREFOX_LINUX.test(navigator.userAgent)) {
            return false;
        }
        try {
            return new MouseEvent('test', {
                buttons: 1
            }).buttons === 1;
        } catch (e) {
            return false;
        }
    })();

    // handler block for native mouse events
    var mouseEvents = {
        POINTER_ID: 1,
        POINTER_TYPE: 'mouse',
        events: [
            'mousedown',
            'mousemove',
            'mouseup'
        ],
        exposes: [
            'down',
            'up',
            'move'
        ],
        register: function(target) {
            dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
            if (target.nodeType === Node.DOCUMENT_NODE) {
                return;
            }
            dispatcher.unlisten(target, this.events);
        },
        lastTouches: [],
        // collide with the global mouse listener
        isEventSimulatedFromTouch: function(inEvent) {
            var lts = this.lastTouches;
            var x = inEvent.clientX,
                y = inEvent.clientY;
            for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
                // simulated mouse events will be swallowed near a primary touchend
                var dx = Math.abs(x - t.x),
                    dy = Math.abs(y - t.y);
                if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
                    return true;
                }
            }
        },
        prepareEvent: function(inEvent) {
            var e = dispatcher.cloneEvent(inEvent);
            e.pointerId = this.POINTER_ID;
            e.isPrimary = true;
            e.pointerType = this.POINTER_TYPE;
            e._source = 'mouse';
            if (!HAS_BUTTONS) {
                var type = inEvent.type;
                var bit = WHICH_TO_BUTTONS[inEvent.which] || 0;
                if (type === 'mousedown') {
                    currentButtons |= bit;
                } else if (type === 'mouseup') {
                    currentButtons &= ~bit;
                }
                e.buttons = currentButtons;
            }
            return e;
        },
        mousedown: function(inEvent) {
            if (!this.isEventSimulatedFromTouch(inEvent)) {
                var p = pointermap.has(this.POINTER_ID);
                var e = this.prepareEvent(inEvent);
                e.target = scope.findTarget(inEvent);
                pointermap.set(this.POINTER_ID, e.target);
                dispatcher.down(e);
            }
        },
        mousemove: function(inEvent) {
            if (!this.isEventSimulatedFromTouch(inEvent)) {
                var target = pointermap.get(this.POINTER_ID);
                if (target) {
                    var e = this.prepareEvent(inEvent);
                    e.target = target;
                    // handle case where we missed a mouseup
                    if ((HAS_BUTTONS ? e.buttons : e.which) === 0) {
                        if (!HAS_BUTTONS) {
                            currentButtons = e.buttons = 0;
                        }
                        dispatcher.cancel(e);
                        this.cleanupMouse(e.buttons);
                    } else {
                        dispatcher.move(e);
                    }
                }
            }
        },
        mouseup: function(inEvent) {
            if (!this.isEventSimulatedFromTouch(inEvent)) {
                var e = this.prepareEvent(inEvent);
                e.relatedTarget = scope.findTarget(inEvent);
                e.target = pointermap.get(this.POINTER_ID);
                dispatcher.up(e);
                this.cleanupMouse(e.buttons);
            }
        },
        cleanupMouse: function(buttons) {
            if (buttons === 0) {
                pointermap.delete(this.POINTER_ID);
            }
        }
    };

    scope.mouseEvents = mouseEvents;
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var allShadows = scope.targetFinding.allShadows.bind(scope.targetFinding);
    var pointermap = dispatcher.pointermap;
    var touchMap = Array.prototype.map.call.bind(Array.prototype.map);
    // This should be long enough to ignore compat mouse events made by touch
    var DEDUP_TIMEOUT = 2500;
    var DEDUP_DIST = 25;
    var CLICK_COUNT_TIMEOUT = 200;
    var HYSTERESIS = 20;
    var ATTRIB = 'touch-action';
    // TODO(dfreedm): disable until http://crbug.com/399765 is resolved
    // var HAS_TOUCH_ACTION = ATTRIB in document.head.style;
    var HAS_TOUCH_ACTION = false;

    // handler block for native touch events
    var touchEvents = {
        IS_IOS: false,
        events: [
            'touchstart',
            'touchmove',
            'touchend',
            'touchcancel'
        ],
        exposes: [
            'down',
            'up',
            'move'
        ],
        register: function(target, initial) {
            if (this.IS_IOS ? initial : !initial) {
                dispatcher.listen(target, this.events);
            }
        },
        unregister: function(target) {
            if (!this.IS_IOS) {
                dispatcher.unlisten(target, this.events);
            }
        },
        scrollTypes: {
            EMITTER: 'none',
            XSCROLLER: 'pan-x',
            YSCROLLER: 'pan-y',
        },
        touchActionToScrollType: function(touchAction) {
            var t = touchAction;
            var st = this.scrollTypes;
            if (t === st.EMITTER) {
                return 'none';
            } else if (t === st.XSCROLLER) {
                return 'X';
            } else if (t === st.YSCROLLER) {
                return 'Y';
            } else {
                return 'XY';
            }
        },
        POINTER_TYPE: 'touch',
        firstTouch: null,
        isPrimaryTouch: function(inTouch) {
            return this.firstTouch === inTouch.identifier;
        },
        setPrimaryTouch: function(inTouch) {
            // set primary touch if there no pointers, or the only pointer is the mouse
            if (pointermap.pointers() === 0 || (pointermap.pointers() === 1 && pointermap.has(1))) {
                this.firstTouch = inTouch.identifier;
                this.firstXY = {
                    X: inTouch.clientX,
                    Y: inTouch.clientY
                };
                this.firstTarget = inTouch.target;
                this.scrolling = null;
                this.cancelResetClickCount();
            }
        },
        removePrimaryPointer: function(inPointer) {
            if (inPointer.isPrimary) {
                this.firstTouch = null;
                this.firstXY = null;
                this.resetClickCount();
            }
        },
        clickCount: 0,
        resetId: null,
        resetClickCount: function() {
            var fn = function() {
                this.clickCount = 0;
                this.resetId = null;
            }.bind(this);
            this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
        },
        cancelResetClickCount: function() {
            if (this.resetId) {
                clearTimeout(this.resetId);
            }
        },
        typeToButtons: function(type) {
            var ret = 0;
            if (type === 'touchstart' || type === 'touchmove') {
                ret = 1;
            }
            return ret;
        },
        findTarget: function(touch, id) {
            if (this.currentTouchEvent.type === 'touchstart') {
                if (this.isPrimaryTouch(touch)) {
                    var fastPath = {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        path: this.currentTouchEvent.path,
                        target: this.currentTouchEvent.target
                    };
                    return scope.findTarget(fastPath);
                } else {
                    return scope.findTarget(touch);
                }
            }
            // reuse target we found in touchstart
            return pointermap.get(id);
        },
        touchToPointer: function(inTouch) {
            var cte = this.currentTouchEvent;
            var e = dispatcher.cloneEvent(inTouch);
            // Spec specifies that pointerId 1 is reserved for Mouse.
            // Touch identifiers can start at 0.
            // Add 2 to the touch identifier for compatibility.
            var id = e.pointerId = inTouch.identifier + 2;
            e.target = this.findTarget(inTouch, id);
            e.bubbles = true;
            e.cancelable = true;
            e.detail = this.clickCount;
            e.buttons = this.typeToButtons(cte.type);
            e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;
            e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;
            e.pressure = inTouch.webkitForce || inTouch.force || 0.5;
            e.isPrimary = this.isPrimaryTouch(inTouch);
            e.pointerType = this.POINTER_TYPE;
            e._source = 'touch';
            // forward touch preventDefaults
            var self = this;
            e.preventDefault = function() {
                self.scrolling = false;
                self.firstXY = null;
                cte.preventDefault();
            };
            return e;
        },
        processTouches: function(inEvent, inFunction) {
            var tl = inEvent.changedTouches;
            this.currentTouchEvent = inEvent;
            for (var i = 0, t, p; i < tl.length; i++) {
                t = tl[i];
                p = this.touchToPointer(t);
                if (inEvent.type === 'touchstart') {
                    pointermap.set(p.pointerId, p.target);
                }
                if (pointermap.has(p.pointerId)) {
                    inFunction.call(this, p);
                }
                if (inEvent.type === 'touchend' || inEvent._cancel) {
                    this.cleanUpPointer(p);
                }
            }
        },
        // For single axis scrollers, determines whether the element should emit
        // pointer events or behave as a scroller
        shouldScroll: function(inEvent) {
            if (this.firstXY) {
                var ret;
                var touchAction = scope.targetFinding.findTouchAction(inEvent);
                var scrollAxis = this.touchActionToScrollType(touchAction);
                if (scrollAxis === 'none') {
                    // this element is a touch-action: none, should never scroll
                    ret = false;
                } else if (scrollAxis === 'XY') {
                    // this element should always scroll
                    ret = true;
                } else {
                    var t = inEvent.changedTouches[0];
                    // check the intended scroll axis, and other axis
                    var a = scrollAxis;
                    var oa = scrollAxis === 'Y' ? 'X' : 'Y';
                    var da = Math.abs(t['client' + a] - this.firstXY[a]);
                    var doa = Math.abs(t['client' + oa] - this.firstXY[oa]);
                    // if delta in the scroll axis > delta other axis, scroll instead of
                    // making events
                    ret = da >= doa;
                }
                return ret;
            }
        },
        findTouch: function(inTL, inId) {
            for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
                if (t.identifier === inId) {
                    return true;
                }
            }
        },
        // In some instances, a touchstart can happen without a touchend. This
        // leaves the pointermap in a broken state.
        // Therefore, on every touchstart, we remove the touches that did not fire a
        // touchend event.
        // To keep state globally consistent, we fire a
        // pointercancel for this "abandoned" touch
        vacuumTouches: function(inEvent) {
            var tl = inEvent.touches;
            // pointermap.pointers() should be < tl.length here, as the touchstart has not
            // been processed yet.
            if (pointermap.pointers() >= tl.length) {
                var d = [];
                pointermap.forEach(function(value, key) {
                    // Never remove pointerId == 1, which is mouse.
                    // Touch identifiers are 2 smaller than their pointerId, which is the
                    // index in pointermap.
                    if (key !== 1 && !this.findTouch(tl, key - 2)) {
                        var p = value;
                        d.push(p);
                    }
                }, this);
                d.forEach(function(p) {
                    this.cancel(p);
                    pointermap.delete(p.pointerId);
                }, this);
            }
        },
        touchstart: function(inEvent) {
            this.vacuumTouches(inEvent);
            this.setPrimaryTouch(inEvent.changedTouches[0]);
            this.dedupSynthMouse(inEvent);
            if (!this.scrolling) {
                this.clickCount++;
                this.processTouches(inEvent, this.down);
            }
        },
        down: function(inPointer) {
            dispatcher.down(inPointer);
        },
        touchmove: function(inEvent) {
            if (HAS_TOUCH_ACTION) {
                // touchevent.cancelable == false is sent when the page is scrolling under native Touch Action in Chrome 36
                // https://groups.google.com/a/chromium.org/d/msg/input-dev/wHnyukcYBcA/b9kmtwM1jJQJ
                if (inEvent.cancelable) {
                    this.processTouches(inEvent, this.move);
                }
            } else {
                if (!this.scrolling) {
                    if (this.scrolling === null && this.shouldScroll(inEvent)) {
                        this.scrolling = true;
                    } else {
                        this.scrolling = false;
                        inEvent.preventDefault();
                        this.processTouches(inEvent, this.move);
                    }
                } else if (this.firstXY) {
                    var t = inEvent.changedTouches[0];
                    var dx = t.clientX - this.firstXY.X;
                    var dy = t.clientY - this.firstXY.Y;
                    var dd = Math.sqrt(dx * dx + dy * dy);
                    if (dd >= HYSTERESIS) {
                        this.touchcancel(inEvent);
                        this.scrolling = true;
                        this.firstXY = null;
                    }
                }
            }
        },
        move: function(inPointer) {
            dispatcher.move(inPointer);
        },
        touchend: function(inEvent) {
            this.dedupSynthMouse(inEvent);
            this.processTouches(inEvent, this.up);
        },
        up: function(inPointer) {
            inPointer.relatedTarget = scope.findTarget(inPointer);
            dispatcher.up(inPointer);
        },
        cancel: function(inPointer) {
            dispatcher.cancel(inPointer);
        },
        touchcancel: function(inEvent) {
            inEvent._cancel = true;
            this.processTouches(inEvent, this.cancel);
        },
        cleanUpPointer: function(inPointer) {
            pointermap['delete'](inPointer.pointerId);
            this.removePrimaryPointer(inPointer);
        },
        // prevent synth mouse events from creating pointer events
        dedupSynthMouse: function(inEvent) {
            var lts = scope.mouseEvents.lastTouches;
            var t = inEvent.changedTouches[0];
            // only the primary finger will synth mouse events
            if (this.isPrimaryTouch(t)) {
                // remember x/y of last touch
                var lt = {
                    x: t.clientX,
                    y: t.clientY
                };
                lts.push(lt);
                var fn = (function(lts, lt) {
                    var i = lts.indexOf(lt);
                    if (i > -1) {
                        lts.splice(i, 1);
                    }
                }).bind(null, lts, lt);
                setTimeout(fn, DEDUP_TIMEOUT);
            }
        }
    };

    // prevent "ghost clicks" that come from elements that were removed in a touch handler
    var STOP_PROP_FN = Event.prototype.stopImmediatePropagation || Event.prototype.stopPropagation;
    document.addEventListener('click', function(ev) {
        var x = ev.clientX,
            y = ev.clientY;
        // check if a click is within DEDUP_DIST px radius of the touchstart
        var closeTo = function(touch) {
            var dx = Math.abs(x - touch.x),
                dy = Math.abs(y - touch.y);
            return (dx <= DEDUP_DIST && dy <= DEDUP_DIST);
        };
        // if click coordinates are close to touch coordinates, assume the click came from a touch
        var wasTouched = scope.mouseEvents.lastTouches.some(closeTo);
        // if the click came from touch, and the touchstart target is not in the path of the click event,
        // then the touchstart target was probably removed, and the click should be "busted"
        var path = scope.targetFinding.path(ev);
        if (wasTouched) {
            for (var i = 0; i < path.length; i++) {
                if (path[i] === touchEvents.firstTarget) {
                    return;
                }
            }
            ev.preventDefault();
            STOP_PROP_FN.call(ev);
        }
    }, true);

    scope.touchEvents = touchEvents;
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var pointermap = dispatcher.pointermap;
    var HAS_BITMAP_TYPE = window.MSPointerEvent && typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === 'number';
    var msEvents = {
        events: [
            'MSPointerDown',
            'MSPointerMove',
            'MSPointerUp',
            'MSPointerCancel',
        ],
        register: function(target) {
            dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
            if (target.nodeType === Node.DOCUMENT_NODE) {
                return;
            }
            dispatcher.unlisten(target, this.events);
        },
        POINTER_TYPES: [
            '',
            'unavailable',
            'touch',
            'pen',
            'mouse'
        ],
        prepareEvent: function(inEvent) {
            var e = inEvent;
            e = dispatcher.cloneEvent(inEvent);
            if (HAS_BITMAP_TYPE) {
                e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
            }
            e._source = 'ms';
            return e;
        },
        cleanup: function(id) {
            pointermap['delete'](id);
        },
        MSPointerDown: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.target = scope.findTarget(inEvent);
            pointermap.set(inEvent.pointerId, e.target);
            dispatcher.down(e);
        },
        MSPointerMove: function(inEvent) {
            var target = pointermap.get(inEvent.pointerId);
            if (target) {
                var e = this.prepareEvent(inEvent);
                e.target = target;
                dispatcher.move(e);
            }
        },
        MSPointerUp: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.up(e);
            this.cleanup(inEvent.pointerId);
        },
        MSPointerCancel: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.cancel(e);
            this.cleanup(inEvent.pointerId);
        }
    };

    scope.msEvents = msEvents;
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var pointermap = dispatcher.pointermap;
    var pointerEvents = {
        events: [
            'pointerdown',
            'pointermove',
            'pointerup',
            'pointercancel'
        ],
        prepareEvent: function(inEvent) {
            var e = dispatcher.cloneEvent(inEvent);
            e._source = 'pointer';
            return e;
        },
        register: function(target) {
            dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
            if (target.nodeType === Node.DOCUMENT_NODE) {
                return;
            }
            dispatcher.unlisten(target, this.events);
        },
        cleanup: function(id) {
            pointermap['delete'](id);
        },
        pointerdown: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.target = scope.findTarget(inEvent);
            pointermap.set(e.pointerId, e.target);
            dispatcher.down(e);
        },
        pointermove: function(inEvent) {
            var target = pointermap.get(inEvent.pointerId);
            if (target) {
                var e = this.prepareEvent(inEvent);
                e.target = target;
                dispatcher.move(e);
            }
        },
        pointerup: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.up(e);
            this.cleanup(inEvent.pointerId);
        },
        pointercancel: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.cancel(e);
            this.cleanup(inEvent.pointerId);
        }
    };

    scope.pointerEvents = pointerEvents;
})(exports);

/**
 * This module contains the handlers for native platform events.
 * From here, the dispatcher is called to create unified pointer events.
 * Included are touch events (v1), mouse events, and MSPointerEvents.
 */
(function(scope) {

    var dispatcher = scope.dispatcher;
    var nav = window.navigator;

    if (window.PointerEvent) {
        dispatcher.registerSource('pointer', scope.pointerEvents);
    } else if (nav.msPointerEnabled) {
        dispatcher.registerSource('ms', scope.msEvents);
    } else {
        dispatcher.registerSource('mouse', scope.mouseEvents);
        if (window.ontouchstart !== undefined) {
            dispatcher.registerSource('touch', scope.touchEvents);
        }
    }

    // Work around iOS bugs https://bugs.webkit.org/show_bug.cgi?id=135628 and https://bugs.webkit.org/show_bug.cgi?id=136506
    var ua = navigator.userAgent;
    var IS_IOS = ua.match(/iPad|iPhone|iPod/) && 'ontouchstart' in window;

    dispatcher.IS_IOS = IS_IOS;
    scope.touchEvents.IS_IOS = IS_IOS;

    dispatcher.register(document, true);
})(exports);

/**
 * This event denotes the beginning of a series of tracking events.
 *
 * @module PointerGestures
 * @submodule Events
 * @class trackstart
 */
/**
 * Pixels moved in the x direction since trackstart.
 * @type Number
 * @property dx
 */
/**
 * Pixes moved in the y direction since trackstart.
 * @type Number
 * @property dy
 */
/**
 * Pixels moved in the x direction since the last track.
 * @type Number
 * @property ddx
 */
/**
 * Pixles moved in the y direction since the last track.
 * @type Number
 * @property ddy
 */
/**
 * The clientX position of the track gesture.
 * @type Number
 * @property clientX
 */
/**
 * The clientY position of the track gesture.
 * @type Number
 * @property clientY
 */
/**
 * The pageX position of the track gesture.
 * @type Number
 * @property pageX
 */
/**
 * The pageY position of the track gesture.
 * @type Number
 * @property pageY
 */
/**
 * The screenX position of the track gesture.
 * @type Number
 * @property screenX
 */
/**
 * The screenY position of the track gesture.
 * @type Number
 * @property screenY
 */
/**
 * The last x axis direction of the pointer.
 * @type Number
 * @property xDirection
 */
/**
 * The last y axis direction of the pointer.
 * @type Number
 * @property yDirection
 */
/**
 * A shared object between all tracking events.
 * @type Object
 * @property trackInfo
 */
/**
 * The element currently under the pointer.
 * @type Element
 * @property relatedTarget
 */
/**
 * The type of pointer that make the track gesture.
 * @type String
 * @property pointerType
 */
/**
 *
 * This event fires for all pointer movement being tracked.
 *
 * @class track
 * @extends trackstart
 */
/**
 * This event fires when the pointer is no longer being tracked.
 *
 * @class trackend
 * @extends trackstart
 */

(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var pointermap = new scope.PointerMap();
    var track = {
        events: [
            'down',
            'move',
            'up',
        ],
        exposes: [
            'trackstart',
            'track',
            'trackx',
            'tracky',
            'trackend'
        ],
        defaultActions: {
            'track': 'none',
            'trackx': 'pan-y',
            'tracky': 'pan-x'
        },
        WIGGLE_THRESHOLD: 4,
        clampDir: function(inDelta) {
            return inDelta > 0 ? 1 : -1;
        },
        calcPositionDelta: function(inA, inB) {
            var x = 0,
                y = 0;
            if (inA && inB) {
                x = inB.pageX - inA.pageX;
                y = inB.pageY - inA.pageY;
            }
            return {
                x: x,
                y: y
            };
        },
        fireTrack: function(inType, inEvent, inTrackingData) {
            var t = inTrackingData;
            var d = this.calcPositionDelta(t.downEvent, inEvent);
            var dd = this.calcPositionDelta(t.lastMoveEvent, inEvent);
            if (dd.x) {
                t.xDirection = this.clampDir(dd.x);
            } else if (inType === 'trackx') {
                return;
            }
            if (dd.y) {
                t.yDirection = this.clampDir(dd.y);
            } else if (inType === 'tracky') {
                return;
            }
            var gestureProto = {
                bubbles: true,
                cancelable: true,
                trackInfo: t.trackInfo,
                relatedTarget: inEvent.relatedTarget,
                pointerType: inEvent.pointerType,
                pointerId: inEvent.pointerId,
                _source: 'track'
            };
            if (inType !== 'tracky') {
                gestureProto.x = inEvent.x;
                gestureProto.dx = d.x;
                gestureProto.ddx = dd.x;
                gestureProto.clientX = inEvent.clientX;
                gestureProto.pageX = inEvent.pageX;
                gestureProto.screenX = inEvent.screenX;
                gestureProto.xDirection = t.xDirection;
            }
            if (inType !== 'trackx') {
                gestureProto.dy = d.y;
                gestureProto.ddy = dd.y;
                gestureProto.y = inEvent.y;
                gestureProto.clientY = inEvent.clientY;
                gestureProto.pageY = inEvent.pageY;
                gestureProto.screenY = inEvent.screenY;
                gestureProto.yDirection = t.yDirection;
            }
            var e = eventFactory.makeGestureEvent(inType, gestureProto);
            t.downTarget.dispatchEvent(e);
        },
        down: function(inEvent) {
            if (inEvent.isPrimary && (inEvent.pointerType === 'mouse' ? inEvent.buttons === 1 : true)) {
                var p = {
                    downEvent: inEvent,
                    downTarget: inEvent.target,
                    trackInfo: {},
                    lastMoveEvent: null,
                    xDirection: 0,
                    yDirection: 0,
                    tracking: false
                };
                pointermap.set(inEvent.pointerId, p);
            }
        },
        move: function(inEvent) {
            var p = pointermap.get(inEvent.pointerId);
            if (p) {
                if (!p.tracking) {
                    var d = this.calcPositionDelta(p.downEvent, inEvent);
                    var move = d.x * d.x + d.y * d.y;
                    // start tracking only if finger moves more than WIGGLE_THRESHOLD
                    if (move > this.WIGGLE_THRESHOLD) {
                        p.tracking = true;
                        p.lastMoveEvent = p.downEvent;
                        this.fireTrack('trackstart', inEvent, p);
                    }
                }
                if (p.tracking) {
                    this.fireTrack('track', inEvent, p);
                    this.fireTrack('trackx', inEvent, p);
                    this.fireTrack('tracky', inEvent, p);
                }
                p.lastMoveEvent = inEvent;
            }
        },
        up: function(inEvent) {
            var p = pointermap.get(inEvent.pointerId);
            if (p) {
                if (p.tracking) {
                    this.fireTrack('trackend', inEvent, p);
                }
                pointermap.delete(inEvent.pointerId);
            }
        }
    };
    dispatcher.registerGesture('track', track);
})(exports);

/**
 * This event is fired when a pointer is held down for 200ms.
 *
 * @module PointerGestures
 * @submodule Events
 * @class hold
 */
/**
 * Type of pointer that made the holding event.
 * @type String
 * @property pointerType
 */
/**
 * Screen X axis position of the held pointer
 * @type Number
 * @property clientX
 */
/**
 * Screen Y axis position of the held pointer
 * @type Number
 * @property clientY
 */
/**
 * Type of pointer that made the holding event.
 * @type String
 * @property pointerType
 */
/**
 * This event is fired every 200ms while a pointer is held down.
 *
 * @class holdpulse
 * @extends hold
 */
/**
 * Milliseconds pointer has been held down.
 * @type Number
 * @property holdTime
 */
/**
 * This event is fired when a held pointer is released or moved.
 *
 * @class release
 */

(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var hold = {
        // wait at least HOLD_DELAY ms between hold and pulse events
        HOLD_DELAY: 200,
        // pointer can move WIGGLE_THRESHOLD pixels before not counting as a hold
        WIGGLE_THRESHOLD: 16,
        events: [
            'down',
            'move',
            'up',
        ],
        exposes: [
            'hold',
            'holdpulse',
            'release'
        ],
        heldPointer: null,
        holdJob: null,
        pulse: function() {
            var hold = Date.now() - this.heldPointer.timeStamp;
            var type = this.held ? 'holdpulse' : 'hold';
            this.fireHold(type, hold);
            this.held = true;
        },
        cancel: function() {
            clearInterval(this.holdJob);
            if (this.held) {
                this.fireHold('release');
            }
            this.held = false;
            this.heldPointer = null;
            this.target = null;
            this.holdJob = null;
        },
        down: function(inEvent) {
            if (inEvent.isPrimary && !this.heldPointer) {
                this.heldPointer = inEvent;
                this.target = inEvent.target;
                this.holdJob = setInterval(this.pulse.bind(this), this.HOLD_DELAY);
            }
        },
        up: function(inEvent) {
            if (this.heldPointer && this.heldPointer.pointerId === inEvent.pointerId) {
                this.cancel();
            }
        },
        move: function(inEvent) {
            if (this.heldPointer && this.heldPointer.pointerId === inEvent.pointerId) {
                var x = inEvent.clientX - this.heldPointer.clientX;
                var y = inEvent.clientY - this.heldPointer.clientY;
                if ((x * x + y * y) > this.WIGGLE_THRESHOLD) {
                    this.cancel();
                }
            }
        },
        fireHold: function(inType, inHoldTime) {
            var p = {
                bubbles: true,
                cancelable: true,
                pointerType: this.heldPointer.pointerType,
                pointerId: this.heldPointer.pointerId,
                x: this.heldPointer.clientX,
                y: this.heldPointer.clientY,
                _source: 'hold'
            };
            if (inHoldTime) {
                p.holdTime = inHoldTime;
            }
            var e = eventFactory.makeGestureEvent(inType, p);
            this.target.dispatchEvent(e);
        }
    };
    dispatcher.registerGesture('hold', hold);
})(exports);

/**
 * This event is fired when a pointer quickly goes down and up, and is used to
 * denote activation.
 *
 * Any gesture event can prevent the tap event from being created by calling
 * `event.preventTap`.
 *
 * Any pointer event can prevent the tap by setting the `tapPrevented` property
 * on itself.
 *
 * @module PointerGestures
 * @submodule Events
 * @class tap
 */
/**
 * X axis position of the tap.
 * @property x
 * @type Number
 */
/**
 * Y axis position of the tap.
 * @property y
 * @type Number
 */
/**
 * Type of the pointer that made the tap.
 * @property pointerType
 * @type String
 */
(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var pointermap = new scope.PointerMap();
    var tap = {
        events: [
            'down',
            'up'
        ],
        exposes: [
            'tap'
        ],
        down: function(inEvent) {
            if (inEvent.isPrimary && !inEvent.tapPrevented) {
                pointermap.set(inEvent.pointerId, {
                    target: inEvent.target,
                    buttons: inEvent.buttons,
                    x: inEvent.clientX,
                    y: inEvent.clientY
                });
            }
        },
        shouldTap: function(e, downState) {
            var tap = true;
            if (e.pointerType === 'mouse') {
                // only allow left click to tap for mouse
                tap = (e.buttons ^ 1) && (downState.buttons & 1);
            }
            return tap && !e.tapPrevented;
        },
        up: function(inEvent) {
            var start = pointermap.get(inEvent.pointerId);
            if (start && this.shouldTap(inEvent, start)) {
                // up.relatedTarget is target currently under finger
                var t = scope.targetFinding.LCA(start.target, inEvent.relatedTarget);
                if (t) {
                    var e = eventFactory.makeGestureEvent('tap', {
                        bubbles: true,
                        cancelable: true,
                        x: inEvent.clientX,
                        y: inEvent.clientY,
                        detail: inEvent.detail,
                        pointerType: inEvent.pointerType,
                        pointerId: inEvent.pointerId,
                        altKey: inEvent.altKey,
                        ctrlKey: inEvent.ctrlKey,
                        metaKey: inEvent.metaKey,
                        shiftKey: inEvent.shiftKey,
                        _source: 'tap'
                    });
                    t.dispatchEvent(e);
                }
            }
            pointermap.delete(inEvent.pointerId);
        }
    };
    // patch eventFactory to remove id from tap's pointermap for preventTap calls
    eventFactory.preventTap = function(e) {
        return function() {
            e.tapPrevented = true;
            pointermap.delete(e.pointerId);
        };
    };
    dispatcher.registerGesture('tap', tap);
})(exports);

/*
 * Basic strategy: find the farthest apart points, use as diameter of circle
 * react to size change and rotation of the chord
 */

/**
 * @module pointer-gestures
 * @submodule Events
 * @class pinch
 */
/**
 * Scale of the pinch zoom gesture
 * @property scale
 * @type Number
 */
/**
 * Center X position of pointers causing pinch
 * @property centerX
 * @type Number
 */
/**
 * Center Y position of pointers causing pinch
 * @property centerY
 * @type Number
 */

/**
 * @module pointer-gestures
 * @submodule Events
 * @class rotate
 */
/**
 * Angle (in degrees) of rotation. Measured from starting positions of pointers.
 * @property angle
 * @type Number
 */
/**
 * Center X position of pointers causing rotation
 * @property centerX
 * @type Number
 */
/**
 * Center Y position of pointers causing rotation
 * @property centerY
 * @type Number
 */
(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var pointermap = new scope.PointerMap();
    var RAD_TO_DEG = 180 / Math.PI;
    var pinch = {
        events: [
            'down',
            'up',
            'move',
            'cancel'
        ],
        exposes: [
            'pinchstart',
            'pinch',
            'pinchend',
            'rotate'
        ],
        defaultActions: {
            'pinch': 'none',
            'rotate': 'none'
        },
        reference: {},
        down: function(inEvent) {
            pointermap.set(inEvent.pointerId, inEvent);
            if (pointermap.pointers() == 2) {
                var points = this.calcChord();
                var angle = this.calcAngle(points);
                this.reference = {
                    angle: angle,
                    diameter: points.diameter,
                    target: scope.targetFinding.LCA(points.a.target, points.b.target)
                };

                this.firePinch('pinchstart', points.diameter, points);
            }
        },
        up: function(inEvent) {
            var p = pointermap.get(inEvent.pointerId);
            var num = pointermap.pointers();
            if (p) {
                if (num === 2) {
                    // fire 'pinchend' before deleting pointer
                    var points = this.calcChord();
                    this.firePinch('pinchend', points.diameter, points);
                }
                pointermap.delete(inEvent.pointerId);
            }
        },
        move: function(inEvent) {
            if (pointermap.has(inEvent.pointerId)) {
                pointermap.set(inEvent.pointerId, inEvent);
                if (pointermap.pointers() > 1) {
                    this.calcPinchRotate();
                }
            }
        },
        cancel: function(inEvent) {
            this.up(inEvent);
        },
        firePinch: function(type, diameter, points) {
            var zoom = diameter / this.reference.diameter;
            var e = eventFactory.makeGestureEvent(type, {
                bubbles: true,
                cancelable: true,
                scale: zoom,
                centerX: points.center.x,
                centerY: points.center.y,
                _source: 'pinch'
            });
            this.reference.target.dispatchEvent(e);
        },
        fireRotate: function(angle, points) {
            var diff = Math.round((angle - this.reference.angle) % 360);
            var e = eventFactory.makeGestureEvent('rotate', {
                bubbles: true,
                cancelable: true,
                angle: diff,
                centerX: points.center.x,
                centerY: points.center.y,
                _source: 'pinch'
            });
            this.reference.target.dispatchEvent(e);
        },
        calcPinchRotate: function() {
            var points = this.calcChord();
            var diameter = points.diameter;
            var angle = this.calcAngle(points);
            if (diameter != this.reference.diameter) {
                this.firePinch('pinch', diameter, points);
            }
            if (angle != this.reference.angle) {
                this.fireRotate(angle, points);
            }
        },
        calcChord: function() {
            var pointers = [];
            pointermap.forEach(function(p) {
                pointers.push(p);
            });
            var dist = 0;
            // start with at least two pointers
            var points = {
                a: pointers[0],
                b: pointers[1]
            };
            var x, y, d;
            for (var i = 0; i < pointers.length; i++) {
                var a = pointers[i];
                for (var j = i + 1; j < pointers.length; j++) {
                    var b = pointers[j];
                    x = Math.abs(a.clientX - b.clientX);
                    y = Math.abs(a.clientY - b.clientY);
                    d = x + y;
                    if (d > dist) {
                        dist = d;
                        points = {
                            a: a,
                            b: b
                        };
                    }
                }
            }
            x = Math.abs(points.a.clientX + points.b.clientX) / 2;
            y = Math.abs(points.a.clientY + points.b.clientY) / 2;
            points.center = {
                x: x,
                y: y
            };
            points.diameter = dist;
            return points;
        },
        calcAngle: function(points) {
            var x = points.a.clientX - points.b.clientX;
            var y = points.a.clientY - points.b.clientY;
            return (360 + Math.atan2(y, x) * RAD_TO_DEG) % 360;
        }
    };
    dispatcher.registerGesture('pinch', pinch);
})(exports);
},{}],24:[function(require,module,exports){
'use strict';

module.exports = function(numRows) {

    var firstNames = ['Olivia', 'Sophia', 'Ava', 'Isabella', 'Boy', 'Liam', 'Noah', 'Ethan', 'Mason', 'Logan', 'Moe', 'Larry', 'Curly', 'Shemp', 'Groucho', 'Harpo', 'Chico', 'Zeppo', 'Stanley', 'Hardy'];
    var lastNames = ['Wirts', 'Oneil', 'Smith', 'Barbarosa', 'Soprano', 'Gotti', 'Columbo', 'Luciano', 'Doerre', 'DePena'];
    var months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
    var days = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30'];
    var states = ['Alabama', 'Alaska', 'Arizona', 'Arkansas', 'California', 'Colorado', 'Connecticut', 'Delaware', 'Florida', 'Georgia', 'Hawaii', 'Idaho', 'Illinois', 'Indiana', 'Iowa', 'Kansas', 'Kentucky', 'Louisiana', 'Maine', 'Maryland', 'Massachusetts', 'Michigan', 'Minnesota', 'Mississippi', 'Missouri', 'Montana', 'Nebraska', 'Nevada', 'New Hampshire', 'New Jersey', 'New Mexico', 'New York', 'North Carolina', 'North Dakota', 'Ohio', 'Oklahoma', 'Oregon', 'Pennsylvania', 'Rhode Island', 'South Carolina', 'South Dakota', 'Tennessee', 'Texas', 'Utah', 'Vermont', 'Virginia', 'Washington', 'West Virginia', 'Wisconsin', 'Wyoming'];

    var randomFunc = Math.random;
    //var randomFunc = rnd;
    var randomPerson = function() {
        var firstName = Math.round((firstNames.length - 1) * randomFunc());
        var lastName = Math.round((lastNames.length - 1) * randomFunc());
        var pets = Math.round(10 * randomFunc());
        var birthyear = 1900 + Math.round(randomFunc() * 114);
        var birthmonth = Math.round(randomFunc() * 11);
        var birthday = Math.round(randomFunc() * 29);
        var birthstate = Math.round(randomFunc() * 49);
        var residencestate = Math.round(randomFunc() * 49);
        var travel = randomFunc() * 1000;
        var income = randomFunc() * 100000;
        var employed = Math.round(randomFunc());
        var person = {
            last_name: lastNames[lastName],
            //jshint ignore:line
            first_name: firstNames[firstName],
            //jshint ignore:line
            pets: pets,
            birthDate: birthyear + '-' + months[birthmonth] + '-' + days[birthday],
            birthState: states[birthstate],
            residenceState: states[residencestate],
            employed: employed === 1,
            income: income,
            travel: travel
        };
        return person;
    };

    var data = [];
    for (var i = 0; i < numRows; i++) {
        var person = randomPerson();
        person.order = i;
        data.push(person);
    }

    return data;

};
},{}],25:[function(require,module,exports){
'use strict';

module.exports = {
    JSDataSource: require('./js/DataSource'),
    DataSourceSorter: require('./js/DataSourceSorter'),
    DataSourceSorterComposite: require('./js/DataSourceSorterComposite'),
    DataSourceGlobalFilter: require('./js/DataSourceGlobalFilter'),
    DataSourceAggregator: require('./js/DataSourceAggregator'),
    DataSourceTreeview: require('./js/DataSourceTreeview'),
    DataNodeGroupSorter: require('./js/DataNodeGroupSorter'),
    util: {
        aggregations: require('./js/util/aggregations'),
        Mappy: require('./js/util/Mappy'),
        stableSort: require('./js/util/stableSort'),
        headerify: require('./js/util/headerify'),
        generateSampleData: require('./generateSampleData.js')
    }
};

},{"./generateSampleData.js":24,"./js/DataNodeGroupSorter":29,"./js/DataSource":32,"./js/DataSourceAggregator":33,"./js/DataSourceGlobalFilter":34,"./js/DataSourceSorter":36,"./js/DataSourceSorterComposite":37,"./js/DataSourceTreeview":38,"./js/util/Mappy":39,"./js/util/aggregations":40,"./js/util/headerify":41,"./js/util/stableSort":42}],26:[function(require,module,exports){
'use strict';

function Base() {}
Base.extend = require('extend-me');

Base.prototype.click = function(y) {
    if (this.dataSource) {
        return this.dataSource.click(y);
    }
};

Base.prototype.findRow = function(columnName, value) {
    return this.dataSource.findRow(columnName, value);
};

Base.prototype.replaceIndent = '_';

Base.prototype.fixIndentForTableDisplay = function(string) {
    var count = string.search(/\S/);
    var end = string.substring(count);
    var result = Array(count + 1).join(this.replaceIndent) + end;
    return result;
};

Base.prototype.dump = function(max) {
    max = Math.min(this.getRowCount(), max || Math.max(100, this.getRowCount()));
    var data = [];
    var fields = this.getHeaders();
    var cCount = this.getColumnCount();
    var viewMakesSense = this.viewMakesSense;
    for (var r = 0; r < max; r++) {
        var row = {};
        for (var c = 0; c < cCount; c++) {
            var val = this.getValue(c, r);
            if (c === 0 && viewMakesSense) {
                val = this.fixIndentForTableDisplay(val);
            }
            row[fields[c]] = val;
        }
        data[r] = row;
    }
    console.table(data);
};

module.exports = Base;

},{"extend-me":7}],27:[function(require,module,exports){
'use strict';

var Base = require('./Base');

/**
 * See {@link DataBaseNode#initialize|initialize()} method for parameters.
 * @constructor
 */
var DataNodeBase = Base.extend('DataNodeBase', {

    isNullObject: false,

    INDENT: '   ', // 3 spaces

    /**
     * @memberOf DataNodeBase.prototype
     * @param {string} key
     */
    initialize: function(key) {
        /**
         * @memberOf DataNodeBase.prototype
         * @type {string}
         */

        this.label = key;

        /**
         * @memberOf DataNodeBase.prototype
         * @type {string[]}
         * @default false
         */
        this.data = ['']; // TODO: Why is this first element needed?

        /**
         * @memberOf DataNodeBase.prototype
         * @type {number[]}
         * @default ['']
         */
        this.index = []; // TODO: formerly rowIndex

        /**
         * @memberOf DataNodeBase.prototype
         * @type {boolean}
         * @default false
         */
        this.hasChildren = false; // TODO: Where/how is this used?

        /**
         * @memberOf DataNodeBase.prototype
         * @type {number}
         * @default 0
         */
        this.depth = 0;

        /**
         * @memberOf DataNodeBase.prototype
         * @type {number}
         * @default 1
         */
        this.height = 1;

        /**
         * @memberOf DataNodeBase.prototype
         * @type {boolean}
         * @default false
         */
        this.expanded = false;
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param x
     * @returns {*}
     */
    getValue: function(x) {
        return this.data[x];
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param depth
     */
    toArray: function(depth) {
        this.depth = depth;
        this.data[0] = this.computeDepthString();
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @returns {string}
     */
    computeDepthString: function() {
        return Array(this.depth + 1).join(this.INDENT) + '  ' + this.label;
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @returns {number}
     */
    computeHeight: function() {
        return 1;
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @returns {Array}
     */
    getIndex: function() { // TODO: formerly getAllRowIndexes
        return this.index;
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param aggregator
     */
    computeAggregates: function(aggregator) {
        var index = this.getIndex();

        if (index.length) {
            var groupsOffset = Number(aggregator.hasGroups());

            // redimension the data
            var data = this.data;
            data.length = groupsOffset + aggregator.aggregates.length;

            var sorter = aggregator.sorterInstance;
            sorter.index = index;

            aggregator.aggregates.forEach(function(aggregate, i) {
                data[groupsOffset + i] = aggregate(sorter);
            });
        }
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param aggregator
     */
    buildView: function(aggregator) {
        aggregator.addView(this);
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     */
    toggleExpansionState: function() { /* aggregator */
        //do nothing by default
    },

    sortGroups: function(groupSorter) {
    }
});

//DataNodeBase.prototype.applyAggregates = DataNodeBase.prototype.computeAggregates;

module.exports = DataNodeBase;

},{"./Base":26}],28:[function(require,module,exports){
'use strict';

var Map = require('./util/Mappy');
var DataNodeBase = require('./DataNodeBase');

var expandedMap = {
    true: '\u25bc', // BLACK DOWN-POINTING TRIANGLE aka ''
    false: '\u25b6' // BLACK RIGHT-POINTING TRIANGLE aka ''
};

/**
 * > See {@link DataNodeGroup#initialize|initialize()} method for constructor parameters.
 * @constructor
 * @extends DataNodeBase
 */
var DataNodeGroup = DataNodeBase.extend('DataNodeGroup', {

    extendable: true,

    /**
     * @memberOf DataNodeGroup.prototype
     * @param key
     */
    initialize: function(key) {
        this.children = new Map();
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @param depth
     */
    toArray: function(depth) {
        this.depth = depth;
        this.children = this.children.values;
        this.children.forEach(function(child) {
            child.toArray(depth + 1);
        });
        this.data[0] = this.computeDepthString();
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @returns {string}
     */
    computeDepthString: function() {
        var string = Array(this.depth + 1).join(this.INDENT) +
            expandedMap[this.expanded] + ' ' +
            this.label;
        return string;
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @returns {*}
     */
    getIndex: function() {
        if (this.index.length === 0) {
            this.index = this.computeIndex();
        }
        return this.index;
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @returns {Array}
     */
    computeIndex: function() { // TODO: formerly computeAllRowIndexes
        var result = [];
        result.append = append;
        this.children.forEach(function(child) {
            result.append(child.getIndex());
        });
        return result;
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @param aggregator
     */
    toggleExpansionState: function(aggregator) { /* aggregator */
        this.expanded = !this.expanded;
        this.data[0] = this.computeDepthString();
        if (this.expanded) {
            this.computeAggregates(aggregator);
        }
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @param aggregator
     */
    computeAggregates: function(aggregator) {
        DataNodeBase.prototype.computeAggregates.call(this, aggregator); // call base class's version
        if (this.expanded) {
            this.children.forEach(function(child) {
                child.computeAggregates(aggregator);
            });
        }
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @param aggregator
     */
    buildView: function(aggregator) {
        aggregator.view.push(this);
        if (this.expanded) {
            this.children.forEach(function(child) {
                child.buildView(aggregator);
            });
        }
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @returns {number}
     */
    computeHeight: function() {
        var height = 1;

        if (this.expanded) {
            this.children.forEach(function(child) {
                height = height + child.computeHeight();
            });
        }

        return (this.height = height);
    },

    sortWith: function(sorter) {
        if (this.expanded) {
            sorter.sortGroup(this);
            this.children.forEach(function(child) {
                child.sortWith(sorter);
            });
        }
    },
    clearGroupSorts: function() {
        if (this.originalOrder) {
            for (var i = 0; i < this.originalOrder.length; i++) {
                this.children[i] = this.originalOrder[i];
            }
        }
        this.children.forEach(function(child) {
            child.clearGroupSorts();
        });
    }

});

/**
 * @private
 * @summary Array mixin to append another array to end of `this` one.
 * @desc Appends in place, unlike `this.concat()` which creates a new array.
 * Uses less memory than concat, important when `appendix` is huge.
 * > CAUTION: Mutates `this` array!
 * @param {Array} appendix
 * @returns {Array} Reference to `this` (for convenience)
 */
function append(appendix) {
    this.splice.bind(this, this.length, 0).apply(this, appendix);
    return this;
}

module.exports = DataNodeGroup;

},{"./DataNodeBase":27,"./util/Mappy":39}],29:[function(require,module,exports){
'use strict';

var Base = require('./Base');
var stableSort = require('./util/stableSort').sort;

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataNodeGroupSorter = Base.extend('DataNodeGroupSorter', {

    /**
     * @memberOf DataSourceSorterComposite.prototype
     */
    initialize: function(dataSource) {
        this.dataSource = dataSource;
        this.sorts = [];

    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     * @param {number} y
     * @returns {Object}
     */
    getRow: function(y) {
        return this.last.getRow(y);
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     * @param columnIndex
     * @param direction
     */
    sortOn: function(columnIndex, direction) {
        this.sorts.push([columnIndex, direction]);
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     */
    apply: function() {
        this.dataSource.sortGroups(this);
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     */
    clearSorts: function() {
        this.sorts.length = 0;
        this.dataSource.buildView();
    },

    sortGroup: function(group) {
        if (!group.originalOrder) {
            group.originalOrder = group.children.slice(0);
        }
        var sorts = this.sorts;
        for (var i = 0; i < sorts.length; i++) {
            this.sortGroupOnEach(group, sorts[sorts.length - i - 1]);
        }
    },

    sortGroupOnEach: function(group, sortInfo) {
        // we actually sort the children here....
        var children = group.children.slice(0);
        var colIndex = sortInfo[0];
        var ascDesc = sortInfo[1];
        var indexVector = [];
        var i = 0;

        for (i = 0; i < children.length; i++) {
            indexVector[i] = i;
        }

        stableSort(indexVector, function(rowNumber) {
            var child = children[rowNumber];
            if (colIndex === 0) {
                return child.label;
            }
            return child.data[colIndex];
        }, ascDesc);

        for (i = 0; i < children.length; i++) {
            group.children[i] = children[indexVector[i]];
        }
    }

});

DataNodeGroupSorter.prototype.applySorts = function() {
    (console.warn || console.log).call(console, 'applySorts deprecated; use apply');
    this.apply();
};

module.exports = DataNodeGroupSorter;

},{"./Base":26,"./util/stableSort":42}],30:[function(require,module,exports){
'use strict';

var DataNodeBase = require('./DataNodeBase');

/**
 * @constructor
 * @extends DataNodeBase
 */
var DataNodeLeaf = DataNodeBase.extend('DataNodeLeaf', {

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param depth
     */
    toArray: function(depth) {
        this.depth = depth;
        this.data[0] = this.computeDepthString();
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @returns {numer[]}
     */
    getIndex: function() {
        return this.index;
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param aggregator
     */
    buildView: function(aggregator) {
        aggregator.addView(this);
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @returns {number}
     */
    computeHeight: function() {
        return 1;
    },

    sortWith: function(sorter) {
      // do nothing we have no children to sort
    },

    clearGroupSorts: function() {
      // do nothing we have no children to sort
    }

});

module.exports = DataNodeLeaf;

},{"./DataNodeBase":27}],31:[function(require,module,exports){
'use strict';

var DataNodeGroup = require('./DataNodeGroup');

/**
 * See {@link DataNodeGroup#initialize|initialize()} method for parameters.
 * @constructor
 * @extends DataNodeGroup
 */
var DataNodeTree = DataNodeGroup.extend('DataNodeTree', {

    /**
     * @memberOf DataNodeGroup.prototype
     * @param {string} key
     */
    initialize: function(key) {
        this.height = 0;
        this.expanded = true;
    },

    /**
     * @memberOf DataNodeGroup.prototype
     */
    toArray: function() {
        this.children = this.children.values;
        this.children.forEach(function(child) {
            child.toArray(0);
        });
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @param aggregator
     */
    buildView: function(aggregator) {
        this.children.forEach(function(child) {
            child.buildView(aggregator);
        });
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @returns {number}
     */
    computeHeight: function() {
        var height = 1;

        this.children.forEach(function(child) {
            height = height + child.computeHeight();
        });

        return (this.height = height);
    }

});

module.exports = DataNodeTree;

},{"./DataNodeGroup":28}],32:[function(require,module,exports){
'use strict';

var Base = require('./Base');
var headerify = require('./util/headerify');

/**
 * @constructor
 * @param {object[]} data
 * @param {string[]} fields
 */
var DataSource = Base.extend('DataSource', {
    initialize: function(data, fields) {
        /**
         * @type {string[]}
         */
        this.fields = fields || computeFieldNames(data[0]);

        /**
         * @type {object[]}
         */
        this.data = data;
    },

    isNullObject: false,

    getDataIndex: function(y) {
        return y;
    },

    /**
     * @memberOf DataSource.prototype
     * @param y
     * @returns {object[]}
     */
    getRow: function(y) {
        return this.data[y];
    },

    findRow: function(columnName, value) {
        return this.data.find(function(row) { return row[columnName] === value; });
    },

    /**
     * @memberOf DataSource.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    getValue: function(x, y) {
        var row = this.getRow(y);
        if (!row) {
            return null;
        }
        return row[this.fields[x]];
    },

    /**
     * @memberOf DataSource.prototype
     * @param {number} x
     * @param {number} y
     * @param value
     */
    setValue: function(x, y, value) {
        this.getRow(y)[this.fields[x]] = value;
    },

    /**
     * @memberOf DataSource.prototype
     * @returns {number}
     */
    getRowCount: function() {
        return this.data.length;
    },

    /**
     * @memberOf DataSource.prototype
     * @returns {number}
     */
    getColumnCount: function() {
        return this.getFields().length;
    },

    /**
     * @memberOf DataSource.prototype
     * @returns {number[]}
     */
    getFields: function() {
        return this.fields;
    },

    /**
     * @memberOf DataSource.prototype
     * @returns {string[]}
     */
    getHeaders: function() {
        return (
            this.headers = this.headers || this.getDefaultHeaders().map(function(each) {
                return headerify.transform(each);
            })
        );
    },

    /**
     * @memberOf DataSource.prototype
     * @returns {string[]}
     */
    getDefaultHeaders: function() {
        return this.getFields();
    },

    /**
     * @memberOf DataSource.prototype
     * @param {string[]} fields
     */
    setFields: function(fields) {
        this.fields = fields;
    },

    /**
     * @memberOf DataSource.prototype
     * @param {string[]} headers
     */
    setHeaders: function(headers) {
        if (!(headers instanceof Array)) {
            error('setHeaders', 'param #1 `headers` not array');
        }
        this.headers = headers;
    },

    /**
     * @memberOf DataSource.prototype
     */
    getGrandTotals: function() {
        //nothing here
    },

    /**
     * @memberOf DataSource.prototype
     * @param arrayOfUniformObjects
     */
    setData: function(arrayOfUniformObjects) {
        this.data = arrayOfUniformObjects;
    }
});

function error(methodName, message) {
    throw new Error('DataSource.' + methodName + ': ' + message);
}

/**
 * @private
 * @param {object} object
 * @returns {string[]}
 */
function computeFieldNames(object) {
    if (!object) {
        return [];
    }
    return Object.getOwnPropertyNames(object || []).filter(function(e) {
        return e.substr(0, 2) !== '__';
    });
}

module.exports = DataSource;

},{"./Base":26,"./util/headerify":41}],33:[function(require,module,exports){
'use strict';

var Base = require('./Base');
var DataSourceSorter = require('./DataSourceSorter');
var DataNodeTree = require('./DataNodeTree');
var DataNodeGroup = require('./DataNodeGroup');
var DataNodeLeaf = require('./DataNodeLeaf');
var headerify = require('./util/headerify');

/**
 * @constructor
 * @param {DataSource} dataSource
 */
var DataSourceAggregator = Base.extend('DataSourceAggregator', {
    initialize: function(dataSource) {

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {DataSource}
         */
        this.dataSource = dataSource;

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {DataNodeTree}
         */
        this.tree = new DataNodeTree('Totals');

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {number[]}
         * @default []
         */
        this.index = [];

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {Array}
         * @default []
         */
        this.aggregates = [];

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {Array}
         * @default []
         */
        this.groupBys = [];

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {Array}
         * @default []
         */
        this.view = [];

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {object}
         * @default {}
         */
        this.sorterInstance = {};

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {boolean}
         * @default true
         */
        this.presortGroups = true;

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {object}
         * @default {}
         */
        this.lastAggregate = {};

        this.setAggregates({});
    },

    isNullObject: false,

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param aggregations
     */
    setAggregates: function(aggregations) {
        this.lastAggregate = aggregations;
        this.clearAggregations();

        for (var key in aggregations) {
            this.addAggregate(key, aggregations[key]);
        }

    },

    getFields: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getFields();
        }
        var fields = this.getHeaders().map(function(e) {
            return e.toLowerCase().split(' ').join('_');
        });
        return fields;
    },

    getHeaders: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getHeaders();
        }
        var headers = this.aggregates.map(function(e) {
            return e.header;
        });
        if (this.hasGroups()) {
            headers.unshift('Tree');
        }
        return headers;
    },
    /**
     * @memberOf DataSourceAggregator.prototype
     * @param label
     * @param func
     */
    addAggregate: function(label, func) {
        func.header = headerify.transform(label);
        this.aggregates.push(func);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param columnIndexArray
     */
    setGroupBys: function(columnIndexArray) {
        var groupBys = this.groupBys;
        groupBys.length = 0;
        columnIndexArray.forEach(function(columnIndex) {
            groupBys.push(columnIndex);
        });
        this.setAggregates(this.lastAggregate);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param index
     */
    addGroupBy: function(index) {
        this.groupBys.push(index);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {boolean}
     */
    hasGroups: function() {
        return !!this.groupBys.length;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {boolean}
     */
    hasAggregates: function() {
        return !!this.aggregates.length;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     */
    apply: function() {
        this.buildGroupTree();
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     */
    clearGroups: function() {
        this.groupBys.length = 0;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     */
    clearAggregations: function() {
        this.aggregates.length = 0;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     */
    buildGroupTree: function() {
        var reversedGroupBys = this.groupBys.slice(0).reverse(),
            leafDepth = this.groupBys.length - 1,
            source = this.dataSource,
            rowCount = source.getRowCount(),
            tree = this.tree = new DataNodeTree('Totals');

        // first sort data
        if (this.presortGroups) {
            reversedGroupBys.forEach(function(groupBy) {
                source = new DataSourceSorter(source);
                source.sortOn(groupBy);
            });
        }

        for (var r = 0; r < rowCount; r++) {
            var path = tree;

            this.groupBys.forEach(function(g, c) { // eslint-disable-line no-loop-func
                var key = source.getValue(g, r),
                    factoryDataNode = (c === leafDepth) ? factoryDataNodeLeaf : factoryDataNodeGroup;
                path = path.children.getIfUndefined(key, factoryDataNode);
            });

            path.index.push(r);
        }

        this.sorterInstance = new DataSourceSorter(source);
        tree.toArray();
        tree.computeAggregates(this);
        this.buildView();
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param dataNode
     */
    addView: function(dataNode) {
        this.view.push(dataNode);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     */
    buildView: function() {
        this.view.length = 0;
        this.tree.computeHeight();
        this.tree.buildView(this);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {*|boolean}
     */
    viewMakesSense: function() {
        return this.hasAggregates() && this.hasGroups();
    },

    getDataIndex: function(y) {
        return this.viewMakesSense() ? y : this.dataSource.getDataIndex(y);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    getValue: function(x, y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getValue(x, y);
        }

        var row = this.view[y];

        return row ? row.getValue(x) : null; // TODO: what kind of object is row... ? should it be unfiltred?
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param x
     * @param y
     * @param value
     * @returns {*}
     */
    setValue: function(x, y, value) {
        if (!this.viewMakesSense()) {
            return this.dataSource.setValue(x, y, value);
        }
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {*}
     */
    getColumnCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getColumnCount();
        }
        return this.getHeaders().length;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {*}
     */
    getRowCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRowCount();
        }
        return this.view.length; //header column
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param y
     */
    click: function(y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.click(y);
        }
        var group, expandable;
        if ((group = this.view[y])) {
            group.toggleExpansionState(this);
            if ((expandable = group.children)) {
                this.buildView();
            }
        }

        return !!expandable;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param headers
     */
    setHeaders: function(headers) {
        this.dataSource.setHeaders(headers);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param fields
     * @returns {*}
     */
    setFields: function(fields) {
        return this.dataSource.setFields(fields);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {object[]}
     */
    getGrandTotals: function() {
        var view = this.tree;
        return [view.data];
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param y
     * @returns {*}
     */
    getRow: function(y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRow(y);
        }

        var rollups = this.view[y];

        return rollups ? rollups : this.tree;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param arrayOfUniformObjects
     */
    setData: function(arrayOfUniformObjects) {
        this.dataSource.setData(arrayOfUniformObjects);
        this.apply();
    },

    sortGroups: function(groupSorter) {
        this.tree.clearGroupSorts();
        this.tree.sortWith(groupSorter);
        this.buildView();
    }
});

function factoryDataNodeLeaf(key) {
    return new DataNodeLeaf(key);
}

function factoryDataNodeGroup(key) {
    return new DataNodeGroup(key);
}

module.exports = DataSourceAggregator;

},{"./Base":26,"./DataNodeGroup":28,"./DataNodeLeaf":30,"./DataNodeTree":31,"./DataSourceSorter":36,"./util/headerify":41}],34:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');

/**
 * @typedef {function} filterFunction
 * @param cellValue
 * @param {object} rowObject - Reference to `this.dataSource.data[r]`.
 * @param {number} r - Row number (index within `this.dataSource.data`).
 */

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceGlobalFilter = DataSourceIndexed.extend('DataSourceGlobalFilter', {

    /**
     *
     * @memberOf DataSourceGlobalFilter.prototype
     * @param {object} [filter] - If undefined, deletes filter.
     */
    set: function(filter) {
        if (filter) {
            /**
             * @type {filterFunction}
             * @memberOf DataSourceGlobalFilter.prototype
             */
            this.filter = filter;
        } else {
            delete this.filter;
        }
    },

    get: function(filter) {
        return this.filter;
    },

    /**
     *
     * @memberOf DataSourceGlobalFilter.prototype
     */
    apply: function() {
        if (!this.filter) {
            this.clearIndex();
        } else {
            this.buildIndex(function applyFilter(r, rowObject) {
                return this.filter.test(rowObject);
            });
        }
    },

    /**
     *
     * @memberOf DataSourceGlobalFilter.prototype
     * @returns {number}
     */
    getRowCount: function() {
        return this.filter ? this.index.length : this.dataSource.getRowCount();
    }
});

module.exports = DataSourceGlobalFilter;

},{"./DataSourceIndexed":35}],35:[function(require,module,exports){
'use strict';

var Base = require('./Base');

/**
 * @constructor
 */
var DataSourceIndexed = Base.extend('DataSourceIndexed', {

    /**
     *
     */
    isNullObject: false,

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param dataSource
     */
    initialize: function(dataSource) {
        this.dataSource = dataSource;
        this.index = [];
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param y
     * @returns {*}
     */
    transposeY: function(y) {
        return this.index.length ? this.index[y] : y;
    },

    getDataIndex: function(y) {
        return this.dataSource.getDataIndex(this.transposeY(y));
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param y
     * @returns {object}
     */
    getRow: function(y) {
        return this.dataSource.getRow(this.transposeY(y));
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param x
     * @param y
     * @returns {*|Mixed}
     */
    getValue: function(x, y) {
        return this.dataSource.getValue(x, this.transposeY(y));
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param {number} x
     * @param {number} y
     * @param {*} value
     */
    setValue: function(x, y, value) {
        this.dataSource.setValue(x, this.transposeY(y), value);
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @returns {Number|*}
     */
    getRowCount: function() {
        return this.index.length || this.dataSource.getRowCount();
    },

    /**
     *
     * @returns {*}
     */
    getColumnCount: function() {
        return this.dataSource.getColumnCount();
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @returns {*}
     */
    getFields: function() {
        return this.dataSource.getFields();
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param fields
     * @returns {*}
     */
    setFields: function(fields) {
        return this.dataSource.setFields(fields);
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param {string[]} headers
     * @returns {string[]}
     */
    setHeaders: function(headers) {
        return this.dataSource.setHeaders(headers);
    },

    /**
     *
     * @returns {string[]}
     */
    getHeaders: function() {
        return this.dataSource.getHeaders();
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @returns {*}
     */
    getGrandTotals: function() {
        return this.dataSource.getGrandTotals();
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param {object[]} arrayOfUniformObjects
     * @returns {object[]}
     */
    setData: function(arrayOfUniformObjects) {
        return this.dataSource.setData(arrayOfUniformObjects);
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     */
    clearIndex: function() {
        this.index.length = 0;
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param {filterPredicate} predicate
     * @returns {number[]}
     */
    buildIndex: function(predicate) {
        var rowCount = this.dataSource.getRowCount(),
            index = this.index;

        this.clearIndex();

        for (var r = 0; r < rowCount; r++) {
            if (!predicate || predicate.call(this, r, this.dataSource.getRow(r))) {
                index.push(r);
            }
        }

        return index;
    }
});

/** @typedef {function} filterPredicate
 * @summary Applies filter to given row.
 * @param {nubmer} r - Row index of row data within rows array `this.dataSource.data[]`.
 * @param {object} rowObject - Row data; element of `this.dataSource.data[]`.
 * @returns {boolean} Row qualifies (passes through filter).
 */

module.exports = DataSourceIndexed;

},{"./Base":26}],36:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');
var stableSort = require('./util/stableSort');

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceSorter = DataSourceIndexed.extend('DataSourceSorter', {

    /**
     * @memberOf DataSourceSorter.prototype
     */
    initialize: function() {
        /**
         * @memberOf DataSourceSorter.prototype
         * @type {boolean}
         */
        this.descendingSort = false; // TODO: this does not seem to be in use
    },

    /**
     * @memberOf DataSourceSorter.prototype
     * @param {number} colIdx
     * @param {number} [direction=1]
     */
    sortOn: function(colIdx, direction) {
        switch (direction) {
            case 0:
                this.clearIndex();
                break;

            case undefined:
            case 1:
            case -1:
                var self = this; // for use in getValue
                stableSort.sort(this.buildIndex(), getValue, direction);
                break;
        }

        function getValue(rowIdx) {
            return valOrFuncCall(self.dataSource.getValue(colIdx, rowIdx));
        }
    }
});

/**
 * @private
 * @param {*|function} valOrFunc
 * @returns {*}
 */
function valOrFuncCall(valOrFunc) {
    return typeof valOrFunc === 'function' ? valOrFunc() : valOrFunc;
}

module.exports = DataSourceSorter;

},{"./DataSourceIndexed":35,"./util/stableSort":42}],37:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');
var DataSourceSorter = require('./DataSourceSorter');

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceSorterComposite = DataSourceIndexed.extend('DataSourceSorterComposite', {

    /**
     * @memberOf DataSourceSorterComposite.prototype
     */
    initialize: function() {
        /**
         * Caveats:
         *
         * 1. Columns should be uniquely represented (i.e., no repeats with same columnIndex)
         * 2. Columns should be added low- to high-order (i.e., most grouped columns come last)
         *
         * @type {number[]}
         * @memberOf DataSourceSorterComposite.prototype
         */
        this.sorts = [];

        /**
         * @type {DataSource}
         * @memberOf DataSourceSorterComposite.prototype
         */
        this.last = this.dataSource;
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     * @param {number} y
     * @returns {Object}
     */
    getRow: function(y) {
        return this.last.getRow(y);
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     * @param columnIndex
     * @param direction
     */
    sortOn: function(columnIndex, direction) {
        this.sorts.push([columnIndex, direction]);
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     */
    apply: function() {
        var each = this.dataSource;

        this.sorts.forEach(function(sort) {
            each = new DataSourceSorter(each);
            each.sortOn.apply(each, sort);
        });

        this.last = each;
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     */
    clearSorts: function() {
        this.sorts.length = 0;
        this.last = this.dataSource;
    },

    getDataIndex: function(y) {
        return this.last.getDataIndex(y);
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     * @param {number} x
     * @param {number} y
     * @returns {*}
     */
    getValue: function(x, y) {
        return this.last.getValue(x, y);
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     * @param {number} x
     * @param {number} y
     * @param {*} value
     */
    setValue: function(x, y, value) {
        this.last.setValue(x, y, value);
    }
});

DataSourceSorterComposite.prototype.applySorts = function() {
    (console.warn || console.log).call(console, 'applySorts deprecated; use apply');
    this.apply();
};

module.exports = DataSourceSorterComposite;

},{"./DataSourceIndexed":35,"./DataSourceSorter":36}],38:[function(require,module,exports){
/* eslint-disable no-underscore-dangle */

'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');

var expandedMap = {
    true: '\u25bc ', // BLACK DOWN-POINTING TRIANGLE aka ''
    false: '\u25b6 ', // BLACK RIGHT-POINTING TRIANGLE aka ''
    undefined: '  ' // for leaf rows
};


/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceTreeview = DataSourceIndexed.extend('DataSourceTreeview', {

    /**
     * @summary Turns tree view **on**.
     * @desc Calculates or recalculates nesting depth of each row and marks it as expandable if it has children.
     *
     * If resetting previously set data, the state of expansion of all rows that still have children is retained.
     *
     * All three named columns must exist.
     *
     * @param {boolean|object} [options] - If falsy (or omitted), turns tree view **off**.
     * @param {string} [options.ID='ID'] - Column name of the primary key column.
     * @param {string} [options.parentID='parentID'] - Column name of the foreign key column for grouping.
     * @param {string} [options.drilldown='name'] - Column name of the drilldown column to decorate.
     * @memberOf DataSourceSorter.prototype
     */
    setRelation: function(options) {
        var idColumnName, parentIdColumnName, treeColumnName, fields,
            rowCount, r, parentID, depth, leafRow, row, ID;

        this.treeColumnIndex = undefined;

        if (options) {
            fields = this.getFields();
            idColumnName = options.idColumnName || 'ID';
            parentIdColumnName = options.parentIdColumnName || 'parentID';
            treeColumnName = options.treeColumnName || 'name';

            if ( // all three columns must exist
                fields.indexOf(idColumnName) >= 0 &&
                fields.indexOf(parentIdColumnName) >= 0 &&
                fields.indexOf(treeColumnName) >= 0
            ) {
                this.idColumnName = idColumnName;
                this.parentIdColumnName = parentIdColumnName;
                this.treeColumnIndex = fields.indexOf(treeColumnName);
            }
        }

        if (this.treeColumnIndex !== undefined) {
            // mutate data row with __DEPTH and __EXPANDED
            rowCount = this.getRowCount();
            r = rowCount;
            while (r--) {
                depth = -1;
                leafRow = this.getRow(r);
                row = leafRow;
                ID = row[idColumnName];

                do {
                    parentID = row[parentIdColumnName];
                    row = this.findRow(idColumnName, parentID);
                    ++depth;
                } while (parentID != undefined); // eslint-disable-line eqeqeq

                leafRow.__DEPTH = depth;

                if (!this.findRow(parentIdColumnName, ID)) {
                    delete leafRow.__EXPANDED; // no longer expandable
                } else if (leafRow.__EXPANDED === undefined) { // retain previous setting for old rows
                    leafRow.__EXPANDED = false; // default for new row is unexpanded
                }
            }
        }

        return this.treeColumnIndex;
    },

    apply: function() {
        this.buildIndex(this.treeColumnIndex === undefined ? undefined : collapseRows);
    },

    getValue: function(x, y) {
        var value = DataSourceIndexed.prototype.getValue.call(this, x, y);

        if (x === this.treeColumnIndex) {
            var row = this.getRow(y),
                prefix = Array(row.__DEPTH + 1).join('    ') + expandedMap[row.__EXPANDED];
            value = prefix + value;
        }

        return value;
    },

    click: function(y) {
        var expandable, row = this.getRow(y);
        if ((expandable = row.__EXPANDED !== undefined)) {
            row.__EXPANDED = !row.__EXPANDED;
        }
        return expandable;
    }

});

function collapseRows(r, row) {
    var parentID;
    while ((parentID = row[this.parentIdColumnName]) != undefined) { // eslint-disable-line eqeqeq
        row = this.findRow(this.idColumnName, parentID);
        if (row.__EXPANDED === false) {
            return false;
        }
    }
    return true;
}

module.exports = DataSourceTreeview;

},{"./DataSourceIndexed":35}],39:[function(require,module,exports){
'use strict';

/**
 * @constructor
 */
function Mappy() {
    this.keys = [];
    this.data = {};
    this.values = [];
}

Mappy.prototype = {

    constructor: Mappy.prototype.constructor, // preserve constructor

    /**
     * @memberOf Mappy.prototype
     * @param key
     * @param value
     */
    set: function(key, value) {
        var hashCode = hash(key);
        if (!(hashCode in this.data)) {
            this.keys.push(key);
            this.values.push(value);
        }
        this.data[hashCode] = value;
    },

    /**
     * @memberOf Mappy.prototype
     * @param key
     * @returns {*}
     */
    get: function(key) {
        var hashCode = hash(key);
        return this.data[hashCode];
    },

    /**
     *
     * @memberOf Mappy.prototype
     * @param key
     * @param {function} ifUndefinedFunc - Value getter when value is otherwise undefined.
     * @returns {*}
     */
    getIfUndefined: function(key, ifUndefinedFunc) {
        var value = this.get(key);
        if (value === undefined) {
            value = ifUndefinedFunc(key);
            this.set(key, value);
        }
        return value;
    },

    size: function() {
        return this.keys.length;
    },

    /**
     * @memberOf Mappy.prototype
     */
    clear: function() {
        this.keys.length = 0;
        this.values.length = 0;
        this.data = {};
    },

    /**
     * @memberOf Mappy.prototype
     * @param key
     */
    delete: function(key) {
        var hashCode = hash(key);
        if (this.data[hashCode] !== undefined) {
            var index = betterIndexOf(this.keys, key);
            this.keys.splice(index, 1);
            this.values.splice(index, 1);
            delete this.data[hashCode];
        }
    },

    /**
     * @memberOf Mappy.prototype
     * @param {function} iteratee
     */
    forEach: function(iteratee) {
        if (typeof iteratee === 'function') {
            var keys = this.keys,
                self = this;
            keys.forEach(function(key) {
                var value = self.get(key);
                iteratee(value, key, self);
            });
        }
    },

    /**
     * @memberOf Mappy.prototype
     * @param {function} iteratee
     * @returns {Mappy}
     */
    map: function(iteratee) {
        var keys = this.keys,
            newMap = new Mappy(),
            self = this;

        if (!(typeof iteratee === 'function')) {
            iteratee = reflection;
        }

        keys.forEach(function(key) {
            var value = self.get(key),
                transformed = iteratee(value, key, self);
            newMap.set(key, transformed);
        });
        return newMap;
    },

    /**
     * @memberOf Mappy.prototype
     * @returns {Mappy}
     */
    copy: function() {
        var keys = this.keys,
            newMap = new Mappy(),
            self = this;
        keys.forEach(function(key) {
            var value = self.get(key);
            newMap.set(key, value);
        });
        return newMap;
    }

};

var OID_PREFIX = '.~.#%_'; //this should be something we never will see at the beginning of a string
var counter = 0;

function hash(key) {
    var typeOf = typeof key;

    switch (typeOf) {
        case 'number':
        case 'string':
        case 'boolean':
        case 'symbol':
            return OID_PREFIX + typeOf + '_' + key;

        case 'undefined':
            return 'UNDEFINED';

        case 'object':
            if (key === null) {
                return 'NULL';
            }
            // fall through when not null:
        case 'function':
            return (key.___finhash = key.___finhash || OID_PREFIX + counter++); // eslint-disable-line no-underscore-dangle
    }
}

// Object.is polyfill, courtesy of @WebReflection
var is = Object.is || function(a, b) {
    return a === b ? a !== 0 || 1 / a == 1 / b : a != a && b != b; // eslint-disable-line eqeqeq
};

function reflection(val) {
    return val;
}

// More reliable indexOf, courtesy of @WebReflection
function betterIndexOf(arr, value) {
    if (value != value || value === 0) { // eslint-disable-line eqeqeq
        var i = arr.length;
        while (i-- && !is(arr[i], value)) {
            // eslint-disable-line no-empty
        }
    } else {
        i = [].indexOf.call(arr, value);
    }
    return i;
}

module.exports = Mappy;

},{}],40:[function(require,module,exports){
'use strict';

/**
 * @module aggregations
 */

/**
 * @typedef {function} aggregationFunction
 * @summary A bound function.
 * @desc An aggregation function bound to the `columnIndex` value supplied to one of the above factory functions.
 * @param {object} group
 * @returns {*} Aggregated value.
 */

module.exports = {
    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    count: function(columnIndex) {
        return count;
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    sum: function(columnIndex) {
        return sum.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    min: function(columnIndex) {
        return minmax.bind(this, columnIndex, Math.min, Infinity);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    max: function(columnIndex) {
        return minmax.bind(this, columnIndex, Math.max, -Infinity);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    avg: function(columnIndex) {
        return avg.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    first: function(columnIndex) {
        return first.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    last: function(columnIndex) {
        return last.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    stddev: function(columnIndex) {
        return stddev.bind(this, columnIndex);
    }
};

function count(group) {
    return group.getRowCount();
}

function sum(columnIndex, group) {
    var r = group.getRowCount(),
        n = 0;

    while (r--) {
        n += group.getValue(columnIndex, r);
    }

    return n;
}

function minmax(columnIndex, method, n, group) {
    var r = group.getRowCount();

    while (r--) {
        n = method(n, group.getValue(columnIndex, r));
    }

    return n;
}

function avg(columnIndex, group) {
    return sum(columnIndex, group) / group.getRowCount();
}

function first(columnIndex, group) {
    return group.getValue(columnIndex, 0);
}

function last(columnIndex, group) {
    return group.getValue(columnIndex, group.getRowCount() - 1);
}

function stddev(columnIndex, group) {
    var rows = group.getRowCount(),
        mean = avg(columnIndex, group);

    for (var dev, r = rows, variance = 0; r--; variance += dev * dev) {
        dev = group.getValue(columnIndex, r) - mean;
    }

    return Math.sqrt(variance / rows);
}

},{}],41:[function(require,module,exports){
'use strict';

// NOTE: For backwards compatibility, `capitalize` is still a function, doubling now as the API.

function capitalize(string) {
    return (/[a-z]/.test(string) ? string : string.toLowerCase())
        .replace(/[\s\-_]*([^\s\-_])([^\s\-_]+)/g, replacer)
        .replace(/[A-Z]/g, ' $&')
        .trim();
}

function replacer(a, b, c) {
    return b.toUpperCase() + c;
}

function set(methodName) {
    capitalize.transform = capitalize[methodName];
}

function passthrough(string) {
    return string;
}

capitalize.transform = passthrough;
capitalize.set = set;
capitalize.passthrough = passthrough;
capitalize.capitalize = capitalize;

module.exports = capitalize;

},{}],42:[function(require,module,exports){
'use strict';

/**
 * Note that {@link module:stableSort#sort|sort()} is the only exposed method.
 * @module stableSort
 */

/**
 * @private
 * @instance
 * @param {function} comparator
 * @param {boolean} descending
 * @param {Array} arr1
 * @param {Array} arr2
 * @returns {function}
 */
function stabilize(comparator, descending, arr1, arr2) { // eslint-disable-line no-shadow
    var x = arr1[0];
    var y = arr2[0];

    if (x === y) {
        x = descending ? arr2[1] : arr1[1];
        y = descending ? arr1[1] : arr2[1];
    } else {
        if (y === null) {
            return -1;
        }
        if (x === null) {
            return 1;
        }
    }

    return comparator(x, y);
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function ascendingNumbers(x, y) {
    return x - y;
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function descendingNumbers(x, y) {
    return y - x;
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function ascendingAllOthers(x, y) {
    return x < y ? -1 : 1;
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function descendingAllOthers(x, y) {
    return y < x ? -1 : 1;
}

/**
 * @private
 * @instance
 * @param typeOfData
 * @returns {function(this:ascending)}
 */
function ascending(typeOfData) {
    return stabilize.bind(this, typeOfData === 'number' ? ascendingNumbers : ascendingAllOthers, false);
}

/**
 * @private
 * @instance
 * @param typeOfData
 * @returns {function(this:descending)}
 */
function descending(typeOfData) {
    return stabilize.bind(this, typeOfData === 'number' ? descendingNumbers : descendingAllOthers, true);
}

/**
 * @instance
 * @param {number} index
 * @param {function} getValue
 * @param {number} [direction=1]
 */
function sort(index, getValue, direction) {

    var compare, i;

    // apply defaults
    if (direction === undefined) {
        direction = 1;
    }

    if (index.length) { // something to do
        switch (direction) {
            case 0:
                return; // bail: nothing to sort

            case undefined: // eslint-disable-line no-fallthrough
                direction = 1;
            case 1:  // eslint-disable-line no-fallthrough
                compare = ascending(typeof getValue(0));
                break;

            case -1:
                compare = descending(typeof getValue(0));
                break;
        }

        // set up the sort.....
        var tmp = new Array(index.length);

        // add the index for "stability"
        for (i = 0; i < index.length; i++) {
            tmp[i] = [getValue(i), i];
        }

        // do the actual sort
        tmp.sort(compare);

        // copy the sorted values into our index vector
        for (i = 0; i < index.length; i++) {
            index[i] = tmp[i][1];
        }
    }

}

exports.sort = sort;

},{}],43:[function(require,module,exports){
// list-dragon node module
// https://github.com/joneit/list-dragon

/* eslint-env node, browser */

'use strict';

var cssInjector = require('css-injector');
var format = require('templex');

var REVERT_TO_STYLESHEET_VALUE = null;  // null removes the style

var transform, timer, scrollVelocity, cssListDragon;

/* inject:css */
cssListDragon = 'div.dragon-list{position:relative;background-color:#fff}div.dragon-list>div,div.dragon-list>ul{position:absolute;left:0;right:0}div.dragon-list>div{text-align:center;background-color:#00796b;color:#fff;box-shadow:0 3px 6px rgba(0,0,0,.16),0 3px 6px rgba(0,0,0,.23);overflow:hidden;white-space:nowrap}div.dragon-list>ul{overflow-y:auto;bottom:0;margin:0;padding:0;box-shadow:0 1px 3px rgba(0,0,0,.12),0 1px 2px rgba(0,0,0,.24)}div.dragon-list>ul>li,li.dragon-pop{white-space:nowrap;list-style-type:none;border:0 solid #f4f4f4;border-bottom:1px solid #e0e0e0;cursor:move;transition:border-top-width .2s}div.dragon-list>ul>li:last-child{height:0;border-bottom:none}li.dragon-pop{position:fixed;background-color:#fff;border:1px solid #e0e0e0;left:0;top:0;overflow-x:hidden;box-shadow:rgba(0,0,0,.188235) 0 10px 20px,rgba(0,0,0,.227451) 0 6px 6px}';
/* endinject */

/**
 * @constructor ListDragon
 *
 * @desc This object services a set of item lists that allow dragging and dropping items within and between lists in a set.
 *
 * Two strategies are supported:
 *
 * 1. Supply your own HTML markup and let the API build the item models for you.
 *    To use this strategy, script your HTML and provide one of these:
 *    * an array of all the list item (`<li>`) tags
 *    * a CSS selector that points to all the list item tags
 * 2. Supply your own item models and let the API build the HTML markup for you.
 *    To use this strategy, provide an array of model lists.
 *
 * The new ListDragon object's `modelLists` property references the array of model lists the API constructed for you in strategy #1 or the array of model lists you supplied for strategy #2.
 *
 * After the user performs a successful drag-and-drop operation, the position of the model references within the `modelLists` array is rearranged. (The models themselves are the original objects as supplied in the model lists; they are not rebuilt or altered in any way. Just the references to them are moved around.)
 *
 * @param {string|Element[]|modelListType[]} selectorOrModelLists - You must supply one of the items in **bold** below:
 *
 * 1. _For strategy #1 above (API creates models from supplied elements):_ All the list item (`<li>`) DOM elements of all the lists you want the new object to manage, as either:
 *    1. **A CSS selector;** _or_
 *    2. **An array of DOM elements**
 * 2. _For strategy #2 above (API creates elements from supplied models):_ **An array of model lists,** each of which is in one of the following forms:
 *    1. An array of item models (with various option properties hanging off of it); _and/or_
 *    2. A {@link modelListType} object with those same various option properties including the required `models` property containing that same array of item models.
 *
 * In either case (2.1 or 2.2), each element of such arrays of item models may take the form of:
 * * A string primitive; _or_
 * * A {@link itemModelType} object with a various option properties including the required `label` property containing a string primitive.
 *
 * Regarding these string primitives, each is either:
 * * A string to be displayed in the list item; _or_
 * * A format string with other property values merged in, the result of which is to be displayed in the list item.
 *
 * @param {object} [options={}] - You may supply "global" template variables here, representing the "outer scope," after first searching each model and then each model list.
 * @param {undefined|null|Element|string} [cssStylesheetReferenceElement] - Determines where to insert the stylesheet. (This is the only formal option.) Passed to css-injector, the overloads are (from css-injector docs):
 * * `undefined` type (or omitted): injects stylesheet at top of `<head>...</head>` element
 * * `null` value: injects stylesheet at bottom of `<head>...</head>` element
 * * `Element` type: injects stylesheet immediately before given element, wherever it is found.
 * * `string` type: injects stylesheet immediately before given first element found that matches the given css selector.
 */
function ListDragon(selectorOrModelLists, options) {

    if (!(this instanceof ListDragon)) {
        throw error('Not called with "new" keyword.');
    }

    var self = this, modelLists, items;

    options = options || {};

    if (typeof selectorOrModelLists === 'string') {
        items = toArray(document.querySelectorAll(selectorOrModelLists));
        modelLists = createModelListsFromListElements(items);
    } else if (selectorOrModelLists[0] instanceof Element) {
        items = toArray(selectorOrModelLists);
        modelLists = createModelListsFromListElements(items);
    } else {
        // param is array of model lists
        // build new <ul> element(s) for each list and put in `.modelLists`;
        // fill `.items` array with <li> elements from these new <ul> elements
        items = [];
        modelLists = createListElementsFromModelLists(selectorOrModelLists, options);
        modelLists.forEach(function (list) {
            items = items.concat(toArray(list.element.querySelectorAll('li')));
        });
    }

    // grab wheel events and don't let 'em bubble
    modelLists.forEach(function (modelList) {
        modelList.element.addEventListener('wheel', captureEvent);
    });

    items.forEach(function (itemElement, index) {
        var item = (itemElement !== itemElement.parentElement.lastElementChild)
            ? self.addEvt(itemElement, 'mousedown', itemElement, true)
            : { element: itemElement };

        /* `item.model` not currently needed so commented out here.
         * (Originally used for rebuilding modelLists for final
         * reporting, modelLists are now spliced on every successful
         * drag-and-drop operation so they're always up to date.)

         var origin = this.itemCoordinates(itemElement);
         item.model = this.modelLists[origin.list].models[origin.item];

         */

        items[index] = item;
    });

    transform = 'transform' in items[0].element.style
        ? 'transform' // Chrome 45 and Firefox 40
        : '-webkit-transform'; // Safari 8

    // set up the new object
    this.modelLists = modelLists;
    this.items = items;
    this.bindings = {};
    this.callback = {};

    cssInjector(cssListDragon, 'list-dragon-base', options.cssStylesheetReferenceElement);

}

ListDragon.prototype = {

    addEvt: function (target, type, listener, doNotBind) {
        var binding = {
            handler: handlers[type].bind(target, this),
            element: listener || window
        };

        if (!doNotBind) {
            this.bindings[type] = binding;
        }

        binding.element.addEventListener(type, binding.handler);

        return binding;
    },

    removeEvt: function (type) {
        var binding = this.bindings[type];
        delete this.bindings[type];
        binding.element.removeEventListener(type, binding.handler);
    },

    removeAllEventListeners: function () {
        // remove drag & drop events (mousemove, mouseup, and transitionend)
        for (var type in this.bindings) {
            var binding = this.bindings[type];
            binding.element.removeEventListener(type, binding.handler);
        }
        // remove the mousedown events from all list items
        this.items.forEach(function (item) {
            if (item.handler) {
                item.element.removeEventListener('mousedown', item.handler);
            }
        });
        // wheel events on the list elements
        this.modelLists.forEach(function (modelList) {
            modelList.element.removeEventListener('wheel', captureEvent);
        });
    },

    pointInListRects: function (point) {
        return this.modelLists.find(function (modelList) {
            var rect = modelList.element.getBoundingClientRect();

            rect = {
                left:   window.scrollX + rect.left,
                top:    window.scrollY + rect.top,
                right:  window.scrollX + rect.right,
                bottom: window.scrollY + rect.bottom,
                width:  rect.width,
                height: rect.height
            };

            modelList.rect = rect;

            if (pointInRect(point, rect)) {
                modelList.rect = rect;
                return true; // found
            } else {
                return false;
            }
        });
    },

    pointInItemRects: function (point, except1, except2) {
        return this.items.find(function (item) {
            var element = item.element;
            return (
                element !== except1 &&
                element !== except2 &&
                pointInRect(point, item.rect)
            );
        });
    },

    // get positions of all list items in page coords (normalized for window and list scrolling)
    getAllItemBoundingRects: function () {
        var modelLists = this.modelLists, height;
        this.items.forEach(function (item) {
            var itemElement = item.element,
                listElement = itemElement.parentElement,
                list = modelLists.find(function (list) { return list.element === listElement; });

            if (
                // omitted: default to true
                list.isDropTarget === undefined ||

                // function: use return value
                typeof list.isDropTarget === 'function' && list.isDropTarget() ||

                // otherwise: use truthiness of given value
                list.isDropTarget
            ) {
                var rect = itemElement.getBoundingClientRect(),
                    bottom = rect.bottom;

                if (itemElement === listElement.lastElementChild) {
                    bottom = listElement.getBoundingClientRect().bottom;
                    if (bottom < rect.top) {
                        bottom = rect.top + (height || 50);
                    }
                } else {
                    height = rect.height;
                }

                rect = {
                    left:   window.scrollX + rect.left,
                    right:  window.scrollX + rect.right,
                    top:    window.scrollY + rect.top    + listElement.scrollTop,
                    bottom: window.scrollY + bottom + listElement.scrollTop
                };

                item.rect = rect;
            }
        });
    },

    reinsert: function (target) {
        var style = target.style;
        style.width = style[transform] = style.transition = REVERT_TO_STYLESHEET_VALUE;

        target.classList.remove('dragon-pop');

        this.drop.style.transitionDuration = '0s';
        this.drop.style.borderTopWidth = REVERT_TO_STYLESHEET_VALUE;
        this.drop.parentElement.insertBefore(target, this.drop);

        delete this.drop;
    },

    // return an object { item: <item index within list>, list: <list index within list of lists> }
    itemCoordinates: function (item) {
        var listElement = item.parentElement,
            coords = { item: 0 };

        while ((item = item.previousElementSibling)) {
            ++coords.item;
        }

        this.modelLists.find(function (list, index) {
            coords.list = index;
            return list.element === listElement; // stop when we find the one we belong to
        });

        return coords;
    }

};

var handlers = {
    mousedown: function (dragon, evt) {

        evt.stopPropagation();
        evt.preventDefault();  //prevents user selection of rendered nodes during drag

        if (dragon.drop) {
            return;
        }

        var rect = this.getBoundingClientRect();

        dragon.rect = rect = {
            left:   Math.round(rect.left - 1),
            top:    Math.round(rect.top - 1),
            right:  Math.round(rect.right),
            bottom: Math.round(rect.bottom),
            width:  Math.round(rect.width),
            height: Math.round(rect.height)
        };

        dragon.pin = {
            x: window.scrollX + evt.clientX,
            y: window.scrollY + evt.clientY
        };

        dragon.origin = dragon.itemCoordinates(this);

        if (dragon.callback.grabbed) {
            dragon.callback.grabbed.call(this, dragon);
        }

        dragon.getAllItemBoundingRects();

        dragon.drop = this.nextElementSibling;
        dragon.drop.style.transitionDuration = '0s';
        dragon.drop.style.borderTopWidth = rect.height + 'px';

        this.style.width = rect.width + 'px';
        this.style.transitionDuration = '0s';
        this.style[transform] = translate(
            rect.left - window.scrollX,
            rect.top  - window.scrollY
        );
        this.classList.add('dragon-pop');
        this.style.zIndex = window.getComputedStyle(dragon.modelLists[0].container.parentElement).zIndex;

        if (!dragon.container) {
            // walk back to closest shadow root OR body tag OR root tag
            var container = this;
            while (container.parentNode) {
                container = container.parentNode;
                if (
                    typeof ShadowRoot !== 'undefined' && container instanceof ShadowRoot ||
                    container.tagName === 'BODY'
                ){
                    break;
                }
            }
            dragon.container = container;
        }

        dragon.container.appendChild(this);

        rect.left   += window.scrollX;
        rect.top    += window.scrollY;
        rect.right  += window.scrollX;
        rect.bottom += window.scrollY;

        dragon.addEvt(this, 'mousemove');
        dragon.addEvt(this, 'mouseup');
    },

    mousemove: function (dragon, evt) {
        dragon.drop.style.transition = REVERT_TO_STYLESHEET_VALUE;

        var hoverList = dragon.pointInListRects({ x: evt.clientX, y: evt.clientY }) || dragon.mostRecentHoverList;

        if (hoverList) {
            var dx = evt.clientX - dragon.pin.x,
                dy = evt.clientY - dragon.pin.y;

            dragon.mostRecentHoverList = hoverList;

            var maxScrollY = hoverList.element.scrollHeight - hoverList.rect.height,
                y = evt.clientY + window.scrollY,
                magnitude;

            if (maxScrollY > 0) {
                // list is scrollable (is taller than rect)
                if (hoverList.element.scrollTop > 0 && (magnitude = y - (hoverList.rect.top + 5)) < 0) {
                    // mouse near or above top and list is not scrolled to top yet
                    resetAutoScrollTimer(magnitude, 0, hoverList.element);
                } else if (hoverList.element.scrollTop < maxScrollY && (magnitude = y - (hoverList.rect.bottom - 1 - 5)) > 0) {
                    // mouse near or below bottom and list not scrolled to bottom yet
                    resetAutoScrollTimer(magnitude, maxScrollY, hoverList.element);
                } else {
                    // mouse inside
                    resetAutoScrollTimer();
                }
            }

            var other = dragon.pointInItemRects({
                x: evt.clientX,
                y: dragon.rect.bottom + window.scrollY + dy + hoverList.element.scrollTop
            }, this, dragon.drop);

            this.style[transform] = translate(
                dragon.rect.left - window.scrollX + dx,
                dragon.rect.top - window.scrollY + dy
            );

            if (other) {
                var element = other.element;
                element.style.transition = REVERT_TO_STYLESHEET_VALUE;
                element.style.borderTopWidth = dragon.drop.style.borderTopWidth;
                dragon.drop.style.borderTopWidth = null;
                dragon.drop = element;
            }
        }
    },

    mouseup: function (dragon, evt) {
        resetAutoScrollTimer();
        dragon.removeEvt('mousemove');
        dragon.removeEvt('mouseup');

        evt.stopPropagation();

        var newRect = this.getBoundingClientRect();

        if (
            window.scrollX + newRect.left === dragon.rect.left &&
            window.scrollY + newRect.top === dragon.rect.top
        ) {
            dragon.reinsert(this);
        } else {
            var dropRect = dragon.drop.getBoundingClientRect();

            dragon.addEvt(this, 'transitionend', this);
            this.style.transitionDuration = REVERT_TO_STYLESHEET_VALUE; //reverts to 200ms
            this.style.transitionProperty = transform;
            this.style[transform] = translate(
                dropRect.left - window.scrollX,
                dropRect.top - window.scrollY
            );
        }
    },

    transitionend: function (dragon, evt) {
        if (evt.propertyName === transform) {
            dragon.removeEvt('transitionend');
            dragon.reinsert(this);

            this.style.transitionProperty = REVERT_TO_STYLESHEET_VALUE; //reverts to border-top-width

            var originList = dragon.modelLists[dragon.origin.list];
            var model = originList.splice(dragon.origin.item, 1)[0];
            var destination = dragon.itemCoordinates(this);
            var destinationList = dragon.modelLists[destination.list];
            var interListDrop = originList !== destinationList;
            var listChanged = interListDrop || dragon.origin.item !== destination.item;
            destinationList.splice(destination.item, 0, model);

            if (listChanged) {
                originList.element.dispatchEvent(new CustomEvent('listchanged'));
                if (interListDrop) {
                    destinationList.element.dispatchEvent(new CustomEvent('listchanged'));
                }
            }

            if (dragon.callback.dropped) {
                dragon.callback.dropped.call(this, dragon);
            }
        }
    }
};

function resetAutoScrollTimer(magnitude, limit, element) {
    if (!magnitude) {
        clearInterval(timer);
        scrollVelocity = 0;
    } else {
        var changeDirection =
            scrollVelocity  <  0 && magnitude  >= 0 ||
            scrollVelocity === 0 && magnitude !== 0 ||
            scrollVelocity  >  0 && magnitude  <= 0;
        scrollVelocity = magnitude > 0 ? Math.min(50, magnitude) : Math.max(-50, magnitude);
        if (changeDirection) {
            clearInterval(timer);
            timer = setInterval(function (limit) {
                var scrollTop = element.scrollTop + scrollVelocity;
                if (scrollVelocity < 0 && scrollTop < limit || scrollVelocity > 0 && scrollTop > limit) {
                    element.scrollTop = limit;
                    clearInterval(timer);
                } else {
                    element.scrollTop = scrollTop;
                }
            }, 125);
        }
    }
}

function toArray(arrayLikeObject) {
    return Array.prototype.slice.call(arrayLikeObject);
}

function pointInRect(point, rect) {
    return rect.top <= point.y && point.y <= rect.bottom
        && rect.left <= point.x && point.x <= rect.right;
}

function translate(left, top) {
    return 'translate('
        + Math.floor(left + window.scrollX) + 'px,'
        + Math.floor(top + window.scrollY) + 'px)';
}

function htmlEncode(string) {
    var textNode = document.createTextNode(string);

    return document
        .createElement('a')
        .appendChild(textNode)
        .parentNode
        .innerHTML;
}

/**
 * Creates `<ul>...</ul>` elements and inserts them into an `element` property on each model.
 * @param {object} modelLists
 * @returns `modelLists`
 */
function createListElementsFromModelLists(modelLists, options) {
    var templateLabel = options.label || '{label}';

    modelLists.forEach(function (modelList, listIndex) {
        var listLabel = modelList.label || templateLabel,
            listHtmlEncode = modelList.htmlEncode !== undefined && modelList.htmlEncode || options.htmlEncode,
            container = document.createElement('div'),
            listElement = document.createElement('ul');

        if (modelList.models) {
            Object.keys(modelList).forEach(function (key) {
                if (key !== 'models') {
                    modelList.models[key] = modelList[key];
                }
            });
            modelLists[listIndex] = modelList = modelList.models;
        } else if (modelList instanceof Array) {
            modelList.models = modelList; // point to self
        } else {
            throw error('List [{1}] not an array of models (with or without additional properties) OR ' +
                'an object (with a `models` property containing an array of models).', listIndex);
        }

        modelList.forEach(function (model) {
            var modelLabel = model.label || listLabel,
                modelHtmlEncode = model.htmlEncode !== undefined && model.htmlEncode || listHtmlEncode,
                modelObject = typeof model === 'object' ? model : { label: model},
                label = format.call([modelObject, modelList, options], modelLabel),
                itemElement = document.createElement('li');

            itemElement.innerHTML = modelHtmlEncode ? htmlEncode(label) : label;

            listElement.appendChild(itemElement);
        });

        // append the final "fencepost" item -- drop target at bottom of list after all items
        var itemElement = document.createElement('li');
        itemElement.innerHTML = '&nbsp;';
        listElement.appendChild(itemElement);

        // append header to container
        if (modelList.title) {
            var header = document.createElement('div');
            header.innerHTML = listHtmlEncode ? htmlEncode(modelList.title) : modelList.title;
            container.appendChild(header);
        }

        container.appendChild(listElement);
        container.className = modelList.cssClassNames || options.cssClassNames || 'dragon-list';
        modelList.element = listElement;
        modelList.container = container;
    });

    return modelLists;
}

/**
 * Create a `.modelLists` array with these <li> elements' parent <ul> elements
 * @param {Element[]} listItemElements
 * @returns {Array}
 */
function createModelListsFromListElements(listItemElements) {
    var modelLists = [];

    listItemElements.forEach(function (itemElement) {
        var listElement = itemElement.parentElement,
            container = listElement.parentElement,
            models = [];
        if (!modelLists.find(function (list) { return list.element === listElement; })) {
            toArray(listElement.querySelectorAll('li')).forEach(function (itemElement) {
                if (itemElement !== listElement.lastElementChild) {
                    models.push(itemElement.innerHTML);
                }
            });
            models.element = listElement;
            models.container = container;
            modelLists.push(models);
        }
    });

    return modelLists;
}

function captureEvent(evt) {
    evt.stopPropagation();
}

function error() {
    return 'list-dragon: ' + format.apply(this, Array.prototype.slice.call(arguments));
}

// this interface consists solely of the prototypal object constructor
module.exports = ListDragon;

},{"css-injector":6,"templex":52}],44:[function(require,module,exports){
;(function () { // closure for web browsers

if (typeof module === 'object' && module.exports) {
  module.exports = LRUCache
} else {
  // just set the global for non-node platforms.
  this.LRUCache = LRUCache
}

function hOP (obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key)
}

function naiveLength () { return 1 }

function LRUCache (options) {
  if (!(this instanceof LRUCache))
    return new LRUCache(options)

  if (typeof options === 'number')
    options = { max: options }

  if (!options)
    options = {}

  this._max = options.max
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!this._max || !(typeof this._max === "number") || this._max <= 0 )
    this._max = Infinity

  this._lengthCalculator = options.length || naiveLength
  if (typeof this._lengthCalculator !== "function")
    this._lengthCalculator = naiveLength

  this._allowStale = options.stale || false
  this._maxAge = options.maxAge || null
  this._dispose = options.dispose
  this.reset()
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, "max",
  { set : function (mL) {
      if (!mL || !(typeof mL === "number") || mL <= 0 ) mL = Infinity
      this._max = mL
      if (this._length > this._max) trim(this)
    }
  , get : function () { return this._max }
  , enumerable : true
  })

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, "lengthCalculator",
  { set : function (lC) {
      if (typeof lC !== "function") {
        this._lengthCalculator = naiveLength
        this._length = this._itemCount
        for (var key in this._cache) {
          this._cache[key].length = 1
        }
      } else {
        this._lengthCalculator = lC
        this._length = 0
        for (var key in this._cache) {
          this._cache[key].length = this._lengthCalculator(this._cache[key].value)
          this._length += this._cache[key].length
        }
      }

      if (this._length > this._max) trim(this)
    }
  , get : function () { return this._lengthCalculator }
  , enumerable : true
  })

Object.defineProperty(LRUCache.prototype, "length",
  { get : function () { return this._length }
  , enumerable : true
  })


Object.defineProperty(LRUCache.prototype, "itemCount",
  { get : function () { return this._itemCount }
  , enumerable : true
  })

LRUCache.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  var i = 0
  var itemCount = this._itemCount

  for (var k = this._mru - 1; k >= 0 && i < itemCount; k--) if (this._lruList[k]) {
    i++
    var hit = this._lruList[k]
    if (isStale(this, hit)) {
      del(this, hit)
      if (!this._allowStale) hit = undefined
    }
    if (hit) {
      fn.call(thisp, hit.value, hit.key, this)
    }
  }
}

LRUCache.prototype.keys = function () {
  var keys = new Array(this._itemCount)
  var i = 0
  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    keys[i++] = hit.key
  }
  return keys
}

LRUCache.prototype.values = function () {
  var values = new Array(this._itemCount)
  var i = 0
  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    values[i++] = hit.value
  }
  return values
}

LRUCache.prototype.reset = function () {
  if (this._dispose && this._cache) {
    for (var k in this._cache) {
      this._dispose(k, this._cache[k].value)
    }
  }

  this._cache = Object.create(null) // hash of items by key
  this._lruList = Object.create(null) // list of items in order of use recency
  this._mru = 0 // most recently used
  this._lru = 0 // least recently used
  this._length = 0 // number of items in the list
  this._itemCount = 0
}

LRUCache.prototype.dump = function () {
  var arr = []
  var i = 0

  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    if (!isStale(this, hit)) {
      //Do not store staled hits
      ++i
      arr.push({
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      });
    }
  }
  //arr has the most read first
  return arr
}

LRUCache.prototype.dumpLru = function () {
  return this._lruList
}

LRUCache.prototype.set = function (key, value, maxAge) {
  maxAge = maxAge || this._maxAge
  var now = maxAge ? Date.now() : 0
  var len = this._lengthCalculator(value)

  if (hOP(this._cache, key)) {
    if (len > this._max) {
      del(this, this._cache[key])
      return false
    }
    // dispose of the old one before overwriting
    if (this._dispose)
      this._dispose(key, this._cache[key].value)

    this._cache[key].now = now
    this._cache[key].maxAge = maxAge
    this._cache[key].value = value
    this._length += (len - this._cache[key].length)
    this._cache[key].length = len
    this.get(key)

    if (this._length > this._max)
      trim(this)

    return true
  }

  var hit = new Entry(key, value, this._mru++, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > this._max) {
    if (this._dispose) this._dispose(key, value)
    return false
  }

  this._length += hit.length
  this._lruList[hit.lu] = this._cache[key] = hit
  this._itemCount ++

  if (this._length > this._max)
    trim(this)

  return true
}

LRUCache.prototype.has = function (key) {
  if (!hOP(this._cache, key)) return false
  var hit = this._cache[key]
  if (isStale(this, hit)) {
    return false
  }
  return true
}

LRUCache.prototype.get = function (key) {
  return get(this, key, true)
}

LRUCache.prototype.peek = function (key) {
  return get(this, key, false)
}

LRUCache.prototype.pop = function () {
  var hit = this._lruList[this._lru]
  del(this, hit)
  return hit || null
}

LRUCache.prototype.del = function (key) {
  del(this, this._cache[key])
}

LRUCache.prototype.load = function (arr) {
  //reset the cache
  this.reset();

  var now = Date.now()
  //A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l-- ) {
    var hit = arr[l]
    var expiresAt = hit.e || 0
    if (expiresAt === 0) {
      //the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
    } else {
      var maxAge = expiresAt - now
      //dont add already expired items
      if (maxAge > 0) this.set(hit.k, hit.v, maxAge)
    }
  }
}

function get (self, key, doUse) {
  var hit = self._cache[key]
  if (hit) {
    if (isStale(self, hit)) {
      del(self, hit)
      if (!self._allowStale) hit = undefined
    } else {
      if (doUse) use(self, hit)
    }
    if (hit) hit = hit.value
  }
  return hit
}

function isStale(self, hit) {
  if (!hit || (!hit.maxAge && !self._maxAge)) return false
  var stale = false;
  var diff = Date.now() - hit.now
  if (hit.maxAge) {
    stale = diff > hit.maxAge
  } else {
    stale = self._maxAge && (diff > self._maxAge)
  }
  return stale;
}

function use (self, hit) {
  shiftLU(self, hit)
  hit.lu = self._mru ++
  self._lruList[hit.lu] = hit
}

function trim (self) {
  while (self._lru < self._mru && self._length > self._max)
    del(self, self._lruList[self._lru])
}

function shiftLU (self, hit) {
  delete self._lruList[ hit.lu ]
  while (self._lru < self._mru && !self._lruList[self._lru]) self._lru ++
}

function del (self, hit) {
  if (hit) {
    if (self._dispose) self._dispose(hit.key, hit.value)
    self._length -= hit.length
    self._itemCount --
    delete self._cache[ hit.key ]
    shiftLU(self, hit)
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, lu, length, now, maxAge) {
  this.key = key
  this.value = value
  this.lu = lu
  this.length = length
  this.now = now
  if (maxAge) this.maxAge = maxAge
}

})()

},{}],45:[function(require,module,exports){
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false Mustache: true*/

(function defineMustache (global, factory) {
  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {
    factory(exports); // CommonJS
  } else if (typeof define === 'function' && define.amd) {
    define(['exports'], factory); // AMD
  } else {
    global.Mustache = {};
    factory(Mustache); // script, wsh, asp
  }
}(this, function mustacheFactory (mustache) {

  var objectToString = Object.prototype.toString;
  var isArray = Array.isArray || function isArrayPolyfill (object) {
    return objectToString.call(object) === '[object Array]';
  };

  function isFunction (object) {
    return typeof object === 'function';
  }

  /**
   * More correct typeof string handling array
   * which normally returns typeof 'object'
   */
  function typeStr (obj) {
    return isArray(obj) ? 'array' : typeof obj;
  }

  function escapeRegExp (string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
  }

  /**
   * Null safe way of checking whether or not an object,
   * including its prototype, has a given property
   */
  function hasProperty (obj, propName) {
    return obj != null && typeof obj === 'object' && (propName in obj);
  }

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  var regExpTest = RegExp.prototype.test;
  function testRegExp (re, string) {
    return regExpTest.call(re, string);
  }

  var nonSpaceRe = /\S/;
  function isWhitespace (string) {
    return !testRegExp(nonSpaceRe, string);
  }

  var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;'
  };

  function escapeHtml (string) {
    return String(string).replace(/[&<>"'\/]/g, function fromEntityMap (s) {
      return entityMap[s];
    });
  }

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   */
  function parseTemplate (template, tags) {
    if (!template)
      return [];

    var sections = [];     // Stack to hold section tokens
    var tokens = [];       // Buffer to hold the tokens
    var spaces = [];       // Indices of whitespace tokens on the current line
    var hasTag = false;    // Is there a {{tag}} on the current line?
    var nonSpace = false;  // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace () {
      if (hasTag && !nonSpace) {
        while (spaces.length)
          delete tokens[spaces.pop()];
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags (tagsToCompile) {
      if (typeof tagsToCompile === 'string')
        tagsToCompile = tagsToCompile.split(spaceRe, 2);

      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
        throw new Error('Invalid tags: ' + tagsToCompile);

      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
    }

    compileTags(tags || mustache.tags);

    var scanner = new Scanner(template);

    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;

      // Match any text between tags.
      value = scanner.scanUntil(openingTagRe);

      if (value) {
        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push([ 'text', chr, start, start + 1 ]);
          start += 1;

          // Check for whitespace on the current line.
          if (chr === '\n')
            stripSpace();
        }
      }

      // Match the opening tag.
      if (!scanner.scan(openingTagRe))
        break;

      hasTag = true;

      // Get the tag type.
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);

      // Get the tag value.
      if (type === '=') {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === '{') {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = '&';
      } else {
        value = scanner.scanUntil(closingTagRe);
      }

      // Match the closing tag.
      if (!scanner.scan(closingTagRe))
        throw new Error('Unclosed tag at ' + scanner.pos);

      token = [ type, value, start, scanner.pos ];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        // Check section nesting.
        openSection = sections.pop();

        if (!openSection)
          throw new Error('Unopened section "' + value + '" at ' + start);

        if (openSection[1] !== value)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        // Set the tags for the next time around.
        compileTags(value);
      }
    }

    // Make sure there are no open sections when we're done.
    openSection = sections.pop();

    if (openSection)
      throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

    return nestTokens(squashTokens(tokens));
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens (tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }

    return squashedTokens;
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens (tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];

    var token, section;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      switch (token[0]) {
      case '#':
      case '^':
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case '/':
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
      }
    }

    return nestedTokens;
  }

  /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */
  function Scanner (string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function eos () {
    return this.tail === '';
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function scan (re) {
    var match = this.tail.match(re);

    if (!match || match.index !== 0)
      return '';

    var string = match[0];

    this.tail = this.tail.substring(string.length);
    this.pos += string.length;

    return string;
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function scanUntil (re) {
    var index = this.tail.search(re), match;

    switch (index) {
    case -1:
      match = this.tail;
      this.tail = '';
      break;
    case 0:
      match = '';
      break;
    default:
      match = this.tail.substring(0, index);
      this.tail = this.tail.substring(index);
    }

    this.pos += match.length;

    return match;
  };

  /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */
  function Context (view, parentContext) {
    this.view = view;
    this.cache = { '.': this.view };
    this.parent = parentContext;
  }

  /**
   * Creates a new context using the given view with this context
   * as the parent.
   */
  Context.prototype.push = function push (view) {
    return new Context(view, this);
  };

  /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */
  Context.prototype.lookup = function lookup (name) {
    var cache = this.cache;

    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context = this, names, index, lookupHit = false;

      while (context) {
        if (name.indexOf('.') > 0) {
          value = context.view;
          names = name.split('.');
          index = 0;

          /**
           * Using the dot notion path in `name`, we descend through the
           * nested objects.
           *
           * To be certain that the lookup has been successful, we have to
           * check if the last object in the path actually has the property
           * we are looking for. We store the result in `lookupHit`.
           *
           * This is specially necessary for when the value has been set to
           * `undefined` and we want to avoid looking up parent contexts.
           **/
          while (value != null && index < names.length) {
            if (index === names.length - 1)
              lookupHit = hasProperty(value, names[index]);

            value = value[names[index++]];
          }
        } else {
          value = context.view[name];
          lookupHit = hasProperty(context.view, name);
        }

        if (lookupHit)
          break;

        context = context.parent;
      }

      cache[name] = value;
    }

    if (isFunction(value))
      value = value.call(this.view);

    return value;
  };

  /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */
  function Writer () {
    this.cache = {};
  }

  /**
   * Clears all cached templates in this writer.
   */
  Writer.prototype.clearCache = function clearCache () {
    this.cache = {};
  };

  /**
   * Parses and caches the given `template` and returns the array of tokens
   * that is generated from the parse.
   */
  Writer.prototype.parse = function parse (template, tags) {
    var cache = this.cache;
    var tokens = cache[template];

    if (tokens == null)
      tokens = cache[template] = parseTemplate(template, tags);

    return tokens;
  };

  /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   */
  Writer.prototype.render = function render (template, view, partials) {
    var tokens = this.parse(template);
    var context = (view instanceof Context) ? view : new Context(view);
    return this.renderTokens(tokens, context, partials, template);
  };

  /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */
  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate) {
    var buffer = '';

    var token, symbol, value;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      value = undefined;
      token = tokens[i];
      symbol = token[0];

      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);
      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);
      else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);
      else if (symbol === '&') value = this.unescapedValue(token, context);
      else if (symbol === 'name') value = this.escapedValue(token, context);
      else if (symbol === 'text') value = this.rawValue(token);

      if (value !== undefined)
        buffer += value;
    }

    return buffer;
  };

  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {
    var self = this;
    var buffer = '';
    var value = context.lookup(token[1]);

    // This function is used to render an arbitrary template
    // in the current context by higher-order sections.
    function subRender (template) {
      return self.render(template, context, partials);
    }

    if (!value) return;

    if (isArray(value)) {
      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
      }
    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
    } else if (isFunction(value)) {
      if (typeof originalTemplate !== 'string')
        throw new Error('Cannot use higher-order sections without the original template');

      // Extract the portion of the original template that the section contains.
      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

      if (value != null)
        buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context, partials, originalTemplate);
    }
    return buffer;
  };

  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {
    var value = context.lookup(token[1]);

    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || (isArray(value) && value.length === 0))
      return this.renderTokens(token[4], context, partials, originalTemplate);
  };

  Writer.prototype.renderPartial = function renderPartial (token, context, partials) {
    if (!partials) return;

    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null)
      return this.renderTokens(this.parse(value), context, partials, value);
  };

  Writer.prototype.unescapedValue = function unescapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return value;
  };

  Writer.prototype.escapedValue = function escapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return mustache.escape(value);
  };

  Writer.prototype.rawValue = function rawValue (token) {
    return token[1];
  };

  mustache.name = 'mustache.js';
  mustache.version = '2.2.0';
  mustache.tags = [ '{{', '}}' ];

  // All high-level mustache.* functions use this writer.
  var defaultWriter = new Writer();

  /**
   * Clears all cached templates in the default writer.
   */
  mustache.clearCache = function clearCache () {
    return defaultWriter.clearCache();
  };

  /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */
  mustache.parse = function parse (template, tags) {
    return defaultWriter.parse(template, tags);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer.
   */
  mustache.render = function render (template, view, partials) {
    if (typeof template !== 'string') {
      throw new TypeError('Invalid template! Template should be a "string" ' +
                          'but "' + typeStr(template) + '" was given as the first ' +
                          'argument for mustache#render(template, view, partials)');
    }

    return defaultWriter.render(template, view, partials);
  };

  // This is here for backwards compatibility with 0.4.x.,
  /*eslint-disable */ // eslint wants camel cased function name
  mustache.to_html = function to_html (template, view, partials, send) {
    /*eslint-enable*/

    var result = mustache.render(template, view, partials);

    if (isFunction(send)) {
      send(result);
    } else {
      return result;
    }
  };

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  mustache.escape = escapeHtml;

  // Export these mainly for testing, but also for advanced usage.
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

}));

},{}],46:[function(require,module,exports){
/* object-iterators.js - Mini Underscore library
 * by Jonathan Eiten
 *
 * The methods below operate on objects (but not arrays) similarly
 * to Underscore (http://underscorejs.org/#collections).
 *
 * For more information:
 * https://github.com/joneit/object-iterators
 */

'use strict';

/**
 * @constructor
 * @summary Wrap an object for one method call.
 * @Desc Note that the `new` keyword is not necessary.
 * @param {object|null|undefined} object - `null` or `undefined` is treated as an empty plain object.
 * @return {Wrapper} The wrapped object.
 */
function Wrapper(object) {
    if (object instanceof Wrapper) {
        return object;
    }
    if (!(this instanceof Wrapper)) {
        return new Wrapper(object);
    }
    this.originalValue = object;
    this.o = object || {};
}

/**
 * @name Wrapper.chain
 * @summary Wrap an object for a chain of method calls.
 * @Desc Calls the constructor `Wrapper()` and modifies the wrapper for chaining.
 * @param {object} object
 * @return {Wrapper} The wrapped object.
 */
Wrapper.chain = function (object) {
    var wrapped = Wrapper(object); // eslint-disable-line new-cap
    wrapped.chaining = true;
    return wrapped;
};

Wrapper.prototype = {
    /**
     * Unwrap an object wrapped with {@link Wrapper.chain|Wrapper.chain()}.
     * @return {object|null|undefined} The value originally wrapped by the constructor.
     * @memberOf Wrapper.prototype
     */
    value: function () {
        return this.originalValue;
    },

    /**
     * @desc Mimics Underscore's [each](http://underscorejs.org/#each) method: Iterate over the members of the wrapped object, calling `iteratee()` with each.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function is undefined; an `.each` loop cannot be broken out of (use {@link Wrapper#find|.find} instead).
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `iteratee`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {Wrapper} The wrapped object for chaining.
     * @memberOf Wrapper.prototype
     */
    each: function (iteratee, context) {
        var o = this.o;
        Object.keys(o).forEach(function (key) {
            iteratee.call(this, o[key], key, o);
        }, context || o);
        return this;
    },

    /**
     * @desc Mimics Underscore's [find](http://underscorejs.org/#find) method: Look through each member of the wrapped object, returning the first one that passes a truth test (`predicate`), or `undefined` if no value passes the test. The function returns the value of the first acceptable member, and doesn't necessarily traverse the entire object.
     * @param {function} predicate - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function should be truthy if the member passes the test and falsy otherwise.
     * @param {object} [context] - If given, `predicate` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} The found property's value, or undefined if not found.
     * @memberOf Wrapper.prototype
     */
    find: function (predicate, context) {
        var o = this.o;
        var result;
        if (o) {
            result = Object.keys(o).find(function (key) {
                return predicate.call(this, o[key], key, o);
            }, context || o);
            if (result !== undefined) {
                result = o[result];
            }
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [filter](http://underscorejs.org/#filter) method: Look through each member of the wrapped object, returning the values of all members that pass a truth test (`predicate`), or empty array if no value passes the test. The function always traverses the entire object.
     * @param {function} predicate - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function should be truthy if the member passes the test and falsy otherwise.
     * @param {object} [context] - If given, `predicate` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} An array containing the filtered values.
     * @memberOf Wrapper.prototype
     */
    filter: function (predicate, context) {
        var o = this.o;
        var result = [];
        if (o) {
            Object.keys(o).forEach(function (key) {
                if (predicate.call(this, o[key], key, o)) {
                    result.push(o[key]);
                }
            }, context || o);
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [map](http://underscorejs.org/#map) method: Produces a new array of values by mapping each value in list through a transformation function (`iteratee`). The function always traverses the entire object.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function is concatenated to the end of the new array.
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} An array containing the filtered values.
     * @memberOf Wrapper.prototype
     */
    map: function (iteratee, context) {
        var o = this.o;
        var result = [];
        if (o) {
            Object.keys(o).forEach(function (key) {
                result.push(iteratee.call(this, o[key], key, o));
            }, context || o);
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [reduce](http://underscorejs.org/#reduce) method: Boil down the values of all the members of the wrapped object into a single value. `memo` is the initial state of the reduction, and each successive step of it should be returned by `iteratee()`.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with four arguments: `(memo, value, key, object)`. The return value of this function becomes the new value of `memo` for the next iteration.
     * @param {*} [memo] - If no memo is passed to the initial invocation of reduce, the iteratee is not invoked on the first element of the list. The first element is instead passed as the memo in the invocation of the iteratee on the next element in the list.
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `iteratee`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} The value of `memo` "reduced" as per `iteratee`.
     * @memberOf Wrapper.prototype
     */
    reduce: function (iteratee, memo, context) {
        var o = this.o;
        if (o) {
            Object.keys(o).forEach(function (key, idx) {
                memo = (!idx && memo === undefined) ? o[key] : iteratee(memo, o[key], key, o);
            }, context || o);
        }
        return memo;
    },

    /**
     * @desc Mimics Underscore's [extend](http://underscorejs.org/#extend) method: Copy all of the properties in each of the `source` object parameter(s) over to the (wrapped) destination object (thus mutating it). It's in-order, so the properties of the last `source` object will override properties with the same name in previous arguments or in the destination object.
     * > This method copies own members as well as members inherited from prototype chain.
     * @param {...object|null|undefined} source - Values of `null` or `undefined` are treated as empty plain objects.
     * @return {Wrapper|object} The wrapped destination object if chaining is in effect; otherwise the unwrapped destination object.
     * @memberOf Wrapper.prototype
     */
    extend: function (source) {
        var o = this.o;
        Array.prototype.slice.call(arguments).forEach(function (object) {
            if (object) {
                for (var key in object) {
                    o[key] = object[key];
                }
            }
        });
        return this.chaining ? this : o;
    },

    /**
     * @desc Mimics Underscore's [extendOwn](http://underscorejs.org/#extendOwn) method: Like {@link Wrapper#extend|extend}, but only copies its "own" properties over to the destination object.
     * @param {...object|null|undefined} source - Values of `null` or `undefined` are treated as empty plain objects.
     * @return {Wrapper|object} The wrapped destination object if chaining is in effect; otherwise the unwrapped destination object.
     * @memberOf Wrapper.prototype
     */
    extendOwn: function (source) {
        var o = this.o;
        Array.prototype.slice.call(arguments).forEach(function (object) {
            Wrapper(object).each(function (val, key) { // eslint-disable-line new-cap
                o[key] = val;
            });
        });
        return this.chaining ? this : o;
    }
};

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
if (!Array.prototype.find) {
    Array.prototype.find = function (predicate) { // eslint-disable-line no-extend-native
        if (this === null) {
            throw new TypeError('Array.prototype.find called on null or undefined');
        }
        if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
                return value;
            }
        }
        return undefined;
    };
}

module.exports = Wrapper;

},{}],47:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var REGEXP_INDIRECTION = /^(\w+)\((\w+)\)$/;  // finds complete pattern a(b) where both a and b are regex "words"

/** @typedef {object} valueItem
 * You should supply both `name` and `alias` but you could omit one or the other and whichever you provide will be used for both.
 * > If you only give the `name` property, you might as well just give a string for {@link menuItem} rather than this object.
 * @property {string} [name=alias] - Value of `value` attribute of `<option>...</option>` element.
 * @property {string} [alias=name] - Text of `<option>...</option>` element.
 * @property {string} [type] One of the keys of `this.converters`. If not one of these (including `undefined`), field values will be tested with a string comparison.
 * @property {boolean} [hidden=false]
 */

/** @typedef {object|menuItem[]} submenuItem
 * @summary Hierarchical array of select list items.
 * @desc Data structure representing the list of `<option>...</option>` and `<optgroup>...</optgroup>` elements that make up a `<select>...</select>` element.
 *
 * > Alternate form: Instead of an object with a `menu` property containing an array, may itself be that array. Both forms have the optional `label` property.
 * @property {string} [label] - Defaults to a generated string of the form "Group n[.m]..." where each decimal position represents a level of the optgroup hierarchy.
 * @property {menuItem[]} submenu
 */

/** @typedef {string|valueItem|submenuItem} menuItem
 * May be one of three possible types that specify either an `<option>....</option>` element or an `<optgroup>....</optgroup>` element as follows:
 * * If a `string`, specifies the text of an `<option>....</option>` element with no `value` attribute. (In the absence of a `value` attribute, the `value` property of the element defaults to the text.)
 * * If shaped like a {@link valueItem} object, specifies both the text and value of an `<option....</option>` element.
 * * If shaped like a {@link submenuItem} object (or its alternate array form), specifies an `<optgroup>....</optgroup>` element.
 */

/**
 * @summary Builds a new menu pre-populated with items and groups.
 * @desc This function creates a new pop-up menu (a.k.a. "drop-down"). This is a `<select>...</select>` element, pre-populated with items (`<option>...</option>` elements) and groups (`<optgroup>...</optgroup>` elements).
 * > Bonus: This function also builds `input type=text` elements.
 * > NOTE: This function generates OPTGROUP elements for subtrees. However, note that HTML5 specifies that OPTGROUP elemnents made not nest! This function generates the markup for them but they are not rendered by most browsers, or not completely. Therefore, for now, do not specify more than one level subtrees. Future versions of HTML may support it. I also plan to add here options to avoid OPTGROUPS entirely either by indenting option text, or by creating alternate DOM nodes using `<li>` instead of `<select>`, or both.
 * @memberOf popMenu
 *
 * @param {Element|string} el - Must be one of (case-sensitive):
 * * text box - an `HTMLInputElement` to use an existing element or `'INPUT'` to create a new one
 * * drop-down - an `HTMLSelectElement` to use an existing element or `'SELECT'` to create a new one
 * * submenu - an `HTMLOptGroupElement` to use an existing element or `'OPTGROUP'` to create a new one (meant for internal use only)
 *
 * @param {menuItem[]} [menu] - Hierarchical list of strings to add as `<option>...</option>` or `<optgroup>....</optgroup>` elements. Omitting creates a text box.
 *
 * @param {null|string} [options.prompt=''] - Adds an initial `<option>...</option>` element to the drop-down with this value in parentheses as its `text`; and empty string as its `value`. Default is empty string, which creates a blank prompt; `null` suppresses prompt altogether.
 *
 * @param {boolean} [options.sort] - Whether to alpha sort or not. If truthy, sorts each optgroup on its `label`; and each select option on its text (its `alias` if given; or its `name` if not).
 *
 * @param {string[]} [options.blacklist] - Optional list of menu item names to be ignored.
 *
 * @param {number[]} [options.breadcrumbs] - List of option group section numbers (root is section 0). (For internal use.)
 *
 * @param {boolean} [options.append=false] - When `el` is an existing `<select>` Element, giving truthy value adds the new children without first removing existing children.
 *
 * @returns {Element} Either a `<select>` or `<optgroup>` element.
 */
function build(el, menu, options) {
    options = options || {};

    var prompt = options.prompt,
        blacklist = options.blacklist,
        sort = options.sort,
        breadcrumbs = options.breadcrumbs || [],
        path = breadcrumbs.length ? breadcrumbs.join('.') + '.' : '',
        subtreeName = popMenu.subtree,
        groupIndex = 0,
        tagName;

    if (el instanceof Element) {
        tagName = el.tagName;
        if (!options.append) {
            el.innerHTML = ''; // remove all <option> and <optgroup> elements
        }
    } else {
        tagName = el;
        el = document.createElement(tagName);
    }

    if (menu) {
        var add, newOption;
        if (tagName === 'SELECT') {
            add = el.add;
            if (prompt) {
                newOption = new Option(prompt, '');
                newOption.innerHTML += '&hellip;';
                el.add(newOption);
            } else if (prompt !== null) {
                el.add(new Option());
            }
        } else {
            add = el.appendChild;
            el.label = prompt;
        }

        if (sort) {
            menu = menu.slice().sort(itemComparator); // sorted clone
        }

        menu.forEach(function(item) {
            // if item is of form a(b) and there is an function a in options, then item = options.a(b)
            if (options && typeof item === 'string') {
                var indirection = item.match(REGEXP_INDIRECTION);
                if (indirection) {
                    var a = indirection[1],
                        b = indirection[2],
                        f = options[a];
                    if (typeof f === 'function') {
                        item = f(b);
                    } else {
                        throw 'build: Expected options.' + a + ' to be a function.';
                    }
                }
            }

            var subtree = item[subtreeName] || item;
            if (subtree instanceof Array) {

                var groupOptions = {
                    breadcrumbs: breadcrumbs.concat(++groupIndex),
                    prompt: item.label || 'Group ' + path + groupIndex,
                    options: sort,
                    blacklist: blacklist
                };

                var optgroup = build('OPTGROUP', subtree, groupOptions);

                if (optgroup.childElementCount) {
                    el.appendChild(optgroup);
                }

            } else if (typeof item !== 'object') {

                if (!(blacklist && blacklist.indexOf(item) >= 0)) {
                    add.call(el, new Option(item));
                }

            } else if (!item.hidden) {

                var name = item.name || item.alias;
                if (!(blacklist && blacklist.indexOf(name) >= 0)) {
                    add.call(el, new Option(
                        item.alias || item.name,
                        name
                    ));
                }

            }
        });
    } else {
        el.type = 'text';
    }

    return el;
}

function itemComparator(a, b) {
    a = a.alias || a.name || a.label || a;
    b = b.alias || b.name || b.label || b;
    return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * @summary Recursively searches the context array of `menuItem`s for a named `item`.
 * @memberOf popMenu
 * @this Array
 * @param {object} [options]
 * @param {string} [options.keys=[popMenu.defaultKey]] - Properties to search each menuItem when it is an object.
 * @param {boolean} [options.caseSensitive=false] - Ignore case while searching.
 * @param {string} value - Value to search for.
 * @returns {undefined|menuItem} The found item or `undefined` if not found.
 */
function lookup(options, value) {
    if (arguments.length === 1) {
        value = options;
        options = undefined;
    }

    var shallow, deep, item, prop,
        keys = options && options.keys || [popMenu.defaultKey],
        caseSensitive = options && options.caseSensitive;

    value = toString(value, caseSensitive);

    shallow = this.find(function(item) {
        var subtree = item[popMenu.subtree] || item;

        if (subtree instanceof Array) {
            return (deep = lookup.call(subtree, options, value));
        }

        if (typeof item !== 'object') {
            return toString(item, caseSensitive) === value;
        } else {
            for (var i = 0; i < keys.length; ++i) {
                prop = item[keys[i]];
                if (prop && toString(prop, caseSensitive) === value) {
                    return true;
                }
            }
        }
    });

    item = deep || shallow;

    return item && (item.name ? item : { name: item });
}

function toString(s, caseSensitive) {
    var result = '';
    if (s) {
        result += s; // convert s to string
        if (!caseSensitive) {
            result = result.toUpperCase();
        }
    }
    return result;
}

/**
 * @summary Recursively walks the context array of `menuItem`s and calls `iteratee` on each item therein.
 * @desc `iteratee` is called with each item (terminal node) in the menu tree and a flat 0-based index. Recurses on member with name of `popMenu.subtree`.
 *
 * The node will always be a {@link valueItem} object; when a `string`, it is boxed for you.
 *
 * @memberOf popMenu
 *
 * @this Array
 *
 * @param {function} iteratee - For each item in the menu, `iteratee` is called with:
 * * the `valueItem` (if the item is a primative string, it is wrapped up for you)
 * * a 0-based `ordinal`
 *
 * The `iteratee` return value can be used to replace the item, as follows:
 * * `undefined` - do nothing
 * * `null` - splice out the item; resulting empty submenus are also spliced out (see note)
 * * anything else - replace the item with this value; if value is a subtree (i.e., an array) `iteratee` will then be called to walk it as well (see note)
 *
 * > Note: Returning anything (other than `undefined`) from `iteratee` will (deeply) mutate the original `menu` so you may want to copy it first (deeply, including all levels of array nesting but not the terminal node objects).
 *
 * @returns {number} Number of items (terminal nodes) in the menu tree.
 */
function walk(iteratee) {
    var menu = this,
        ordinal = 0,
        subtreeName = popMenu.subtree,
        i, item, subtree, newVal;

    for (i = menu.length - 1; i >= 0; --i) {
        item = menu[i];
        subtree = item[subtreeName] || item;

        if (!(subtree instanceof Array)) {
            subtree = undefined;
        }

        if (!subtree) {
            newVal = iteratee(item.name ? item : { name: item }, ordinal);
            ordinal += 1;

            if (newVal !== undefined) {
                if (newVal === null) {
                    menu.splice(i, 1);
                    ordinal -= 1;
                } else {
                    menu[i] = item = newVal;
                    subtree = item[subtreeName] || item;
                    if (!(subtree instanceof Array)) {
                        subtree = undefined;
                    }
                }
            }
        }

        if (subtree) {
            ordinal += walk.call(subtree, iteratee);
            if (subtree.length === 0) {
                menu.splice(i, 1);
                ordinal -= 1;
            }
        }
    }

    return ordinal;
}

/**
 * @summary Format item name with it's alias when available.
 * @memberOf popMenu
 * @param {string|valueItem} item
 * @returns {string} The formatted name and alias.
 */
function formatItem(item) {
    var result = item.name || item;
    if (item.alias) {
        result = '"' + item.alias + '" (' + result + ')';
    }
    return result;
}


function isGroupProxy(s) {
    return REGEXP_INDIRECTION.test(s);
}

/**
 * @namespace
 */
var popMenu = {
    build: build,
    walk: walk,
    lookup: lookup,
    formatItem: formatItem,
    isGroupProxy: isGroupProxy,
    subtree: 'submenu',
    defaultKey: 'name'
};

module.exports = popMenu;

},{}],48:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

/**
 * Creates a new read-only property and attaches it to the provided context.
 * @private
 * @param {string} name - Name for new property.
 * @param {*} [value] - Value of new property.
 */
function addReadOnlyProperty(name, value) {
    Object.defineProperty(this, name, {
        value: value,
        writable: false,
        enumerable: true,
        configurable: false
    });
}

/**
 * @constructor Point
 *
 * @desc This object represents a single point in an abstract 2-dimensional matrix.
 *
 * The unit of measure is typically pixels.
 * (If used to model computer graphics, vertical coordinates are typically measured downwards
 * from the top of the window. This convention however is not inherent in this object.)
 *
 * Note: This object should be instantiated with the `new` keyword.
 *
 * @param {number} x - the new point's `x` property
 * @param {number} y - the new point's `y` property
 */
function Point(x, y) {

    /**
     * @name x
     * @type {number}
     * @summary This point's horizontal coordinate.
     * @desc Created upon instantiation by the {@link Point|constructor}.
     * @memberOf Point.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'x', Number(x) || 0);

    /**
     * @name y
     * @type {number}
     * @summary This point's vertical coordinate.
     * @desc Created upon instantiation by the {@link Point|constructor}.
     * @memberOf Point.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'y', Number(y) || 0);

}

Point.prototype = {

    /**
     * @returns {Point} A new point which is this point's position increased by coordinates of given `offset`.
     * @param {Point} offset - Horizontal and vertical values to add to this point's coordinates.
     * @memberOf Point.prototype
     */
    plus: function(offset) {
        return new Point(
            this.x + offset.x,
            this.y + offset.y
        );
    },

    /**
     * @returns {Point} A new point which is this point's position increased by given offsets.
     * @param {number} [offsetX=0] - Value to add to this point's horizontal coordinate.
     * @param {number} [offsetY=0] - Value to add to this point's horizontal coordinate.
     * @memberOf Point.prototype
     */
    plusXY: function(offsetX, offsetY) {
        return new Point(
            this.x + (offsetX || 0),
            this.y + (offsetY || 0)
        );
    },

    /**
     * @returns {Point} A new point which is this point's position decreased by coordinates of given `offset`.
     * @param {Point} offset - Horizontal and vertical values to subtract from this point's coordinates.
     * @memberOf Point.prototype
     */
    minus: function(offset) {
        return new Point(
            this.x - offset.x,
            this.y - offset.y
        );
    },

    /**
     * @returns {Point} A new `Point` positioned to least x and least y of this point and given `offset`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    min: function(point) {
        return new Point(
            Math.min(this.x, point.x),
            Math.min(this.y, point.y)
        );
    },

    /**
     * @returns {Point} A new `Point` positioned to greatest x and greatest y of this point and given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    max: function(point) {
        return new Point(
            Math.max(this.x, point.x),
            Math.max(this.y, point.y)
        );
    },

    /**
     * @returns {number} Distance between given `point` and this point using Pythagorean Theorem formula.
     * @param {Point} point - A point from which to compute the distance to this point.
     * @memberOf Point.prototype
     */
    distance: function(point) {
        var deltaX = point.x - this.x,
            deltaY = point.y - this.y;

        return Math.sqrt(
            deltaX * deltaX +
            deltaY * deltaY
        );
    },

    /**
     * _(Formerly: `equal`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are exactly equal to those of given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    equals: function(point) {
        var result = false;

        if (point) {
            result =
                this.x === point.x &&
                this.y === point.y;
        }

        return result;
    },

    /**
     * @returns {boolean} `true` iff _both_ coordinates of this point are greater than those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    greaterThan: function(point) {
        return (
            this.x > point.x &&
            this.y > point.y
        );
    },

    /**
     * @returns {boolean} `true` iff _both_ coordinates of this point are less than those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    lessThan: function(point) {
        return (
            this.x < point.x &&
            this.y < point.y
        );
    },

    /**
     * _(Formerly `greaterThanEqualTo`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are greater than or equal to those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    greaterThanOrEqualTo: function(point) {
        return (
            this.x >= point.x &&
            this.y >= point.y
        );
    },

    /**
     * _(Formerly `lessThanEqualTo`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are less than or equal to those of given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    lessThanOrEqualTo: function(point) {
        return (
            this.x <= point.x &&
            this.y <= point.y
        );
    },

    /**
     * _(Formerly `isContainedWithinRectangle`.)_
     * @param rect {Rectangle} - Rectangle to test this point against.
     * @returns {boolean} `true` iff this point is within given `rect`.
     * @memberOf Point.prototype
     */
    within: function(rect) {
        var minX = rect.origin.x,
            maxX = minX + rect.extent.x;
        var minY = rect.origin.y,
            maxY = minY + rect.extent.y;

        if (rect.extent.x < 0) {
            minX = maxX;
            maxX = rect.origin.x;
        }

        if (rect.extent.y < 0) {
            minY = maxY;
            maxY = rect.origin.y;
        }

        return (
            minX <= this.x && this.x < maxX &&
            minY <= this.y && this.y < maxY
        );
    }
};

Point.prototype.EQ = Point.prototype.equals;
Point.prototype.GT = Point.prototype.greaterThan;
Point.prototype.LT = Point.prototype.lessThan;
Point.prototype.GE = Point.prototype.greaterThanOrEqualTo;
Point.prototype.LE = Point.prototype.lessThanOrEqualTo;


/**
 * @constructor Rectangle
 *
 * @desc This object represents a rectangular area within an abstract 2-dimensional matrix.
 *
 * The unit of measure is typically pixels.
 * (If used to model computer graphics, vertical coordinates are typically measured downwards
 * from the top of the window. This convention however is not inherent in this object.)
 *
 * Normally, the `x` and `y` parameters to the constructor describe the upper left corner of the rect.
 * However, negative values of `width` and `height` will be added to the given `x` and `y`. That is,
 * a negative value of the `width` parameter will extend the rect to the left of the given `x` and
 * a negative value of the `height` parameter will extend the rect above the given `y`.
 * In any case, after instantiation the following are guaranteed to always be true:
 * * The `extent`, `width`, and `height` properties _always_ give positive values.
 * * The `origin`, `top`, and `left` properties _always_ reflect the upper left corner.
 * * The `corner`, `bottom`, and `right` properties _always_ reflect the lower right corner.
 *
 * Note: This object should be instantiated with the `new` keyword.
 *
 * @param {number} [x=0] - Horizontal coordinate of some corner of the rect.
 * @param {number} [y=0] - Vertical coordinate of some corner of the rect.
 * @param {number} [width=0] - Width of the new rect. May be negative (see above).
 * @param {number} [height=0] - Height of the new rect. May be negative (see above).
 */
function Rectangle(x, y, width, height) {

    x = Number(x) || 0;
    y = Number(y) || 0;
    width = Number(width) || 0;
    height = Number(height) || 0;

    if (width < 0) {
        x += width;
        width = -width;
    }

    if (height < 0) {
        y += height;
        height = -height;
    }

    /**
     * @name origin
     * @type {Point}
     * @summary Upper left corner of this rect.
     * @desc Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'origin', new Point(x, y));

    /**
     * @name extent
     * @type {Point}
     * @summary this rect's width and height.
     * @desc Unlike the other `Point` properties, `extent` is not a global coordinate pair; rather it consists of a _width_ (`x`, always positive) and a _height_ (`y`, always positive).
     *
     * This object might be more legitimately typed as something like `Area` with properties `width` and `height`; however we wanted it to be able to use it efficiently with a point's `plus` and `minus` methods (that is, without those methods having to check and branch on the type of its parameter).
     *
     * Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @see The {@link Rectangle#corner|corner} method.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'extent', new Point(width, height));

    /**
     * @name corner
     * @type {Point}
     * @summary Lower right corner of this rect.
     * @desc This is a calculated value created upon instantiation by the {@linkplain Rectangle|constructor}. It is `origin` offset by `extent`.
     *
     * **Note:** These coordinates actually point to the pixel one below and one to the right of the rect's actual lower right pixel.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'corner', new Point(x + width, y + height));

    /**
     * @name center
     * @type {Point}
     * @summary Center of this rect.
     * @desc Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'center', new Point(x + (width / 2), y + (height / 2)));

}

Rectangle.prototype = {

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Minimum vertical coordinate of this rect.
     * @memberOf Rectangle.prototype
     */
    get top() {
        return this.origin.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Minimum horizontal coordinate of this rect.
     * @memberOf Rectangle.prototype
     */
    get left() {
        return this.origin.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Maximum vertical coordinate of this rect + 1.
     * @memberOf Rectangle.prototype
     */
    get bottom() {
        return this.corner.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Maximum horizontal coordinate of this rect + 1.
     * @memberOf Rectangle.prototype
     */
    get right() {
        return this.corner.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Width of this rect (always positive).
     * @memberOf Rectangle.prototype
     */
    get width() {
        return this.extent.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Height of this rect (always positive).
     * @memberOf Rectangle.prototype
     */
    get height() {
        return this.extent.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Area of this rect.
     * @memberOf Rectangle.prototype
     */
    get area() {
        return this.width * this.height;
    },

    /**
     * @returns {Rectangle} A copy of this rect but with horizontal position reset to given `x` and no width.
     * @param {number} x - Horizontal coordinate of the new rect.
     * @memberOf Rectangle.prototype
     */
    flattenXAt: function(x) {
        return new Rectangle(x, this.origin.y, 0, this.extent.y);
    },

    /**
     * @returns {Rectangle} A copy of this rect but with vertical position reset to given `y` and no height.
     * @param {number} y - Vertical coordinate of the new rect.
     * @memberOf Rectangle.prototype
     */
    flattenYAt: function(y) {
        return new Rectangle(this.origin.x, y, this.extent.x, 0);
    },

    /**
     * @returns {boolean} `true` iff given `point` entirely contained within this rect.
     * @param {Point} pointOrRect - The point or rect to test for containment.
     * @memberOf Rectangle.prototype
     */
    contains: function(pointOrRect) {
        return pointOrRect.within(this);
    },

    /**
     * _(Formerly `isContainedWithinRectangle`.)_
     * @returns {boolean} `true` iff `this` rect is entirely contained within given `rect`.
     * @param {Rectangle} rect - Rectangle to test against this rect.
     * @memberOf Rectangle.prototype
     */
    within: function(rect) {
        return (
            rect.origin.lessThanOrEqualTo(this.origin) &&
            rect.corner.greaterThanOrEqualTo(this.corner)
        );
    },

    /**
     * _(Formerly: `insetBy`.)_
     * @returns {Rectangle} That is enlarged/shrunk by given `padding`.
     * @param {number} padding - Amount by which to increase (+) or decrease (-) this rect
     * @see The {@link Rectangle#shrinkBy|shrinkBy} method.
     * @memberOf Rectangle.prototype
     */
    growBy: function(padding) {
        return new Rectangle(
            this.origin.x + padding,
            this.origin.y + padding,
            this.extent.x - padding - padding,
            this.extent.y - padding - padding);
    },

    /**
     * @returns {Rectangle} That is enlarged/shrunk by given `padding`.
     * @param {number} padding - Amount by which to decrease (+) or increase (-) this rect.
     * @see The {@link Rectangle#growBy|growBy} method.
     * @memberOf Rectangle.prototype
     */
    shrinkBy: function(padding) {
        return this.growBy(-padding);
    },

    /**
     * @returns {Rectangle} Bounding rect that contains both this rect and the given `rect`.
     * @param {Rectangle} rect - The rectangle to union with this rect.
     * @memberOf Rectangle.prototype
     */
    union: function(rect) {
        var origin = this.origin.min(rect.origin),
            corner = this.corner.max(rect.corner),
            extent = corner.minus(origin);

        return new Rectangle(
            origin.x, origin.y,
            extent.x, extent.y
        );
    },

    /**
     * iterate over all points within this rect, invoking `iteratee` for each.
     * @param {function(number,number)} iteratee - Function to call for each point.
     * Bound to `context` when given; otherwise it is bound to this rect.
     * Each invocation of `iteratee` is called with two arguments:
     * the horizontal and vertical coordinates of the point.
     * @param {object} [context=this] - Context to bind to `iteratee` (when not `this`).
     * @memberOf Rectangle.prototype
     */
    forEach: function(iteratee, context) {
        context = context || this;
        for (var x = this.origin.x, x2 = this.corner.x; x < x2; x++) {
            for (var y = this.origin.y, y2 = this.corner.y; y < y2; y++) {
                iteratee.call(context, x, y);
            }
        }
    },

    /**
     * @returns {Rectangle} One of:
     * * _If this rect intersects with the given `rect`:_
     *      a new rect representing that intersection.
     * * _If it doesn't intersect and `ifNoneAction` defined:_
     *      result of calling `ifNoneAction`.
     * * _If it doesn't intersect and `ifNoneAction` undefined:_
     *      `null`.
     * @param {Rectangle} rect - The rectangle to intersect with this rect.
     * @param {function(Rectangle)} [ifNoneAction] - When no intersection, invoke and return result.
     * Bound to `context` when given; otherwise bound to this rect.
     * Invoked with `rect` as sole parameter.
     * @param {object} [context=this] - Context to bind to `ifNoneAction` (when not `this`).
     * @memberOf Rectangle.prototype
     */
    intersect: function(rect, ifNoneAction, context) {
        var result = null,
            origin = this.origin.max(rect.origin),
            corner = this.corner.min(rect.corner),
            extent = corner.minus(origin);

        if (extent.x > 0 && extent.y > 0) {
            result = new Rectangle(
                origin.x, origin.y,
                extent.x, extent.y
            );
        } else if (typeof ifNoneAction === 'function') {
            result = ifNoneAction.call(context || this, rect);
        }

        return result;
    },

    /**
     * @returns {boolean} `true` iff this rect overlaps with given `rect`.
     * @param {Rectangle} rect - The rectangle to intersect with this rect.
     * @memberOf Rectangle.prototype
     */
    intersects: function(rect) {
        return (
            rect.corner.x > this.origin.x &&
            rect.corner.y > this.origin.y &&
            rect.origin.x < this.corner.x &&
            rect.origin.y < this.corner.y
        );
    }
};

// Interface
exports.Point = Point;
exports.Rectangle = Rectangle;

},{}],49:[function(require,module,exports){
'use strict';

var // a regex search pattern that matches all the reserved chars of a regex search pattern
    reserved = /([\.\\\+\*\?\^\$\(\)\{\}\=\!\<\>\|\:\[\]])/g,

    // regex wildcard search patterns
    REGEXP_WILDCARD = '.*',
    REGEXP_WILDCHAR = '.',
    REGEXP_WILDCARD_MATCHER = '(' + REGEXP_WILDCARD + ')',

    // LIKE search patterns
    LIKE_WILDCHAR = '_',
    LIKE_WILDCARD = '%',

    // regex search patterns that match LIKE search patterns
    REGEXP_LIKE_PATTERN_MATCHER = new RegExp('(' + [
        LIKE_WILDCHAR,
        LIKE_WILDCARD,
        '\\[\\^?[^-\\]]+]', // matches a LIKE set (same syntax as a RegExp set)
        '\\[\\^?[^-\\]]\\-[^\\]]]' // matches a LIKE range (same syntax as a RegExp range)
    ].join('|') + ')', 'g');

function regExpLIKE(pattern, ignoreCase) {
    var i, parts;

    // Find all LIKE patterns
    parts = pattern.match(REGEXP_LIKE_PATTERN_MATCHER);

    if (parts) {
        // Translate found LIKE patterns to regex patterns, escaped intervening non-patterns, and interleave the two

        for (i = 0; i < parts.length; ++i) {
            // Escape left brackets (unpaired right brackets are OK)
            if (parts[i][0] === '[') {
                parts[i] = regExpLIKE.reserve(parts[i]);
            }

            // Make each found pattern matchable by enclosing in parentheses
            parts[i] = '(' + parts[i] + ')';
        }

        // Match these precise patterns again with their intervening non-patterns (i.e., text)
        parts = pattern.match(new RegExp(
            REGEXP_WILDCARD_MATCHER +
            parts.join(REGEXP_WILDCARD_MATCHER)  +
            REGEXP_WILDCARD_MATCHER
        ));

        // Discard first match of non-global search (which is the whole string)
        parts.shift();

        // For each re-found pattern part, translate % and _ to regex equivalent
        for (i = 1; i < parts.length; i += 2) {
            var part = parts[i];
            switch (part) {
                case LIKE_WILDCARD: part = REGEXP_WILDCARD; break;
                case LIKE_WILDCHAR: part = REGEXP_WILDCHAR; break;
                default:
                    var j = part[1] === '^' ? 2 : 1;
                    part = '[' + regExpLIKE.reserve(part.substr(j, part.length - (j + 1))) + ']';
            }
            parts[i] = part;
        }
    } else {
        parts = [pattern];
    }

    // For each surrounding text part, escape reserved regex chars
    for (i = 0; i < parts.length; i += 2) {
        parts[i] = regExpLIKE.reserve(parts[i]);
    }

    // Join all the interleaved parts
    parts = parts.join('');

    // Optimize or anchor the pattern at each end as needed
    if (parts.substr(0, 2) === REGEXP_WILDCARD) { parts = parts.substr(2); } else { parts = '^' + parts; }
    if (parts.substr(-2, 2) === REGEXP_WILDCARD) { parts = parts.substr(0, parts.length - 2); } else { parts += '$'; }

    // Return the new regex
    return new RegExp(parts, ignoreCase ? 'i' : undefined);
}

regExpLIKE.reserve = function (s) {
    return s.replace(reserved, '\\$1');
};

var cache, size;

/**
 * @summary Delete a pattern from the cache; or clear the whole cache.
 * @param {string} [pattern] - The LIKE pattern to remove from the cache. Fails silently if not found in the cache. If pattern omitted, clears whole cache.
 */
(regExpLIKE.clearCache = function (pattern) {
    if (!pattern) {
        cache = {};
        size = 0;
    } else if (cache[pattern]) {
        delete cache[pattern];
        size--;
    }
    return size;
})(); // init the cache

regExpLIKE.getCacheSize = function () { return size; };

/**
 * @summary Cached version of `regExpLIKE()`.
 * @desc Cached entries are subject to garbage collection if `keep` is `undefined` or `false` on insertion or `false` on most recent reference. Garbage collection will occur iff `regExpLIKE.cacheMax` is defined and it equals the number of cached patterns. The garbage collector sorts the patterns based on most recent reference; the oldest 10% of the entries are deleted. Alternatively, you can manage the cache yourself to a limited extent (see {@link regeExpLIKE.clearCache|clearCache}).
 * @param pattern - the LIKE pattern (to be) converted to a RegExp
 * @param [keep] - If given, changes the keep status for this pattern as follows:
 * * `true` permanently caches the pattern (not subject to garbage collection) until `false` is given on a subsequent call
 * * `false` allows garbage collection on the cached pattern
 * * `undefined` no change to keep status
 * @returns {RegExp}
 */
regExpLIKE.cached = function (keep, pattern, ignoreCase) {
    if (typeof keep === 'string') {
        ignoreCase = pattern;
        pattern = keep;
        keep = false;
    }
    var patternAndCase = pattern + (ignoreCase ? 'i' : 'c'),
        item = cache[patternAndCase];
    if (item) {
        item.when = new Date().getTime();
        if (keep !== undefined) {
            item.keep = keep;
        }
    } else {
        if (size === regExpLIKE.cacheMax) {
            var age = [], ages = 0, key, i;
            for (key in cache) {
                item = cache[key];
                if (!item.keep) {
                    for (i = 0; i < ages; ++i) {
                        if (item.when < age[i].item.when) {
                            break;
                        }
                    }
                    age.splice(i, 0, { key: key, item: item });
                    ages++;
                }
            }
            if (!age.length) {
                return regExpLIKE(pattern, ignoreCase); // cache is full!
            }
            i = Math.ceil(age.length / 10); // will always be at least 1
            size -= i;
            while (i--) {
                delete cache[age[i].key];
            }
        }
        item = cache[patternAndCase] = {
            regex: regExpLIKE(pattern, ignoreCase),
            keep: keep,
            when: new Date().getTime()
        };
        size++;
    }
    return item.regex;
};

module.exports = regExpLIKE;

},{}],50:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

(function (module) {  // eslint-disable-line no-unused-expressions

    // This closure supports NodeJS-less client side includes with <script> tags. See https://github.com/joneit/mnm.

    /**
     * @constructor RangeSelectionModel
     *
     * @desc This object models selection of "cells" within an abstract single-dimensional matrix.
     *
     * Disjoint selections can be built with calls to the following methods:
     * * {@link RangeSelectionModel#select|select(start, stop)} - Add a range to the matrix.
     * * {@link RangeSelectionModel#deselect|deselect(start, stop)} - Remove a range from the matrix.
     *
     * Two more methods are available:
     * * Test a cell to see if it {@link RangeSelectionModel#isSelected|isSelected(cell)}
     * * {@link RangeSelectionModel#clear|clear()} the matrix
     *
     * Internally, the selection is run-length-encoded. It is therefore a "sparse" matrix
     * with undefined bounds. A single data property called `selection` is an array that
     * contains all the "runs" (ranges) of selected cells albeit in no particular order.
     * This property should not normally need to be accessed directly.
     *
     * Note: This object should be instantiated with the `new` keyword.
     *
     * @returns {RangeSelectionModel} Self (i.e., `this` object).
     */
    function RangeSelectionModel() {
        /**
         * @name selection
         * @type {Array.Array.number}
         * @summary Unordered list of runs.
         * @desc A "run" is defined as an Array(2) where:
         * * element [0] is the beginning of the run
         * * element [1] is the end of the run (inclusive) and is always >= element [0]
         * The order of the runs within is undefined.
         * @memberOf RangeSelectionModel.prototype
         * @abstract
         */
        this.selection = [];

        //we need to be able to go back in time
        //the states field
        this.states = [];

        //clone and store my current state
        //so we can unwind changes if need be
        this.storeState = function () {
            var sels = this.selection;
            var state = [];
            var copy;
            for (var i = 0; i < sels.length; i++) {
                copy = [].concat(sels[i]);
                state.push(copy);
            }
            this.states.push(state);
        };
    }

    RangeSelectionModel.prototype = {

        /**
         * @summary Add a contiguous run of points to the selection.
         * @desc Insert a new run into `this.selection`.
         * The new run will be merged with overlapping and adjacent runs.
         *
         * The two parameters may be given in either order.
         * The start and stop elements in the resulting run will however always be ordered.
         * (However, note that the order of the runs within `this.selection` is itself always unordered.)
         *
         * Note that `this.selection` is updated in place, preserving validity of any external references.
         * @param {number} start - Start of run. May be greater than `stop`.
         * @param {number} [stop=stop] - End of run (inclusive). May be less than `start`.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        select: function (start, stop) {
            this.storeState();
            var run = makeRun(start, stop);
            var splicer = [0, 1];
            this.selection.forEach(function (each) {
                if (overlaps(each, run) || abuts(each, run)) {
                    run = merge(each, run);
                } else {
                    splicer.push(each);
                }
            });
            splicer.push(run);
            splicer[1] = this.selection.length;
            this.selection.splice.apply(this.selection, splicer); // update in place to preserve external references
            return this;
        },

        /**
         * @summary Remove a contiguous run of points from the selection.
         * @desc Truncate and/or remove run(s) from `this.selection`.
         * Removing part of existing runs will (correctly) shorten them or break them into two fragments.
         *
         * The two parameters may be given in either order.
         *
         * Note that `this.selection` is updated in place, preserving validity of any external references.
         * @param {number} start - Start of run. May be greater than `stop`.
         * @param {number} [stop=stop] - End of run (inclusive). May be less than `start`.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        deselect: function (start, stop) {
            var run = makeRun(start, stop);
            var splicer = [0, 0];
            this.selection.forEach(function (each) {
                if (overlaps(each, run)) {
                    var pieces = subtract(each, run);
                    splicer = splicer.concat(pieces);
                } else {
                    splicer.push(each);
                }
            });
            splicer[1] = this.selection.length;
            this.selection.splice.apply(this.selection, splicer); // update in place to preserve external references
            return this;
        },

        /**
         * @summary Empties `this.selection`, effectively removing all runs.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        clear: function () {
            this.states.length = 0;
            this.selection.length = 0;
            return this;
        },

        clearMostRecentSelection: function () {
            if (this.states.length === 0) {
                return;
            }
            this.selection = this.states.pop();
        },

        /**
         * @summary Determines if the given `cell` is selected.
         * @returns {boolean} `true` iff given `cell` is within any of the runs in `this.selection`.
         * @param {number} cell - The cell to test for inclusion in the selection.
         * @memberOf RangeSelectionModel.prototype
         */
        isSelected: function (cell) {
            return this.selection.some(function (each) {
                return each[0] <= cell && cell <= each[1];
            });
        },

        isEmpty: function (){
            return this.selection.length === 0;
        },

        /**
         * @summary Return the indexes that are selected.
         * @desc Return the indexes that are selected.
         * @returns {Array.Array.number}
         * @memberOf RangeSelectionModel.prototype
         */
        getSelections: function (){
            var result = [];
            this.selection.forEach(function (each) {
                for (var i = each[0]; i <= each[1]; i++) {
                    result.push(i);
                }
            });
            result.sort(function (a, b){
                return a - b;
            });
            return result;
        }

    };

    /**
     * @private
     * @summary Preps `start` and `stop` params into order array
     * @function makeRun
     * @desc Utility function called by both `select()` and `deselect()`.
     * @param {number|number[]} start - Start of run. if array, `start` and `stop` are taken from first two elements.
     * @param {number} [stop=start] - End of run (inclusive).
     */
    function makeRun(start, stop) {
        return (
            start instanceof Array
                ? makeRun.apply(this, start) // extract params from given array
                : stop === undefined
                ? [ start, start ] // single param is a run that stops where it starts
                : start <= stop
                ? [ start, stop ]
                : [ stop, start ] // reverse descending params into ascending order
        );
    }

    /**
     * @private
     * @function overlaps
     * @returns {boolean} `true` iff `run1` overlaps `run2`
     * @summary Comparison operator that determines if given runs overlap with one another.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * Overlap is defined to include the case where one run completely contains the other.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - first run
     * @param {number[]} run2 - second run
     */
    function overlaps(run1, run2) {
        return (
            run1[0] <= run2[0] && run2[0] <= run1[1] || // run2's start is within run1 OR...
            run1[0] <= run2[1] && run2[1] <= run1[1] || // run2's stop is within run1 OR...
            run2[0] <  run1[0] && run1[1] <  run2[1]    // run2 completely contains run1
        );
    }

    /**
     * @private
     * @function abuts
     * @summary Comparison operator that determines if given runs are consecutive with one another.
     * @returns {boolean} `true` iff `run1` is consecutive with `run2`
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - first run
     * @param {number[]} run2 - second run
     */
    function abuts(run1, run2) {
        return (
            run1[1] === run2[0] - 1 || // run1's top immediately precedes run2's start OR...
            run2[1] === run1[0] - 1    // run2's top immediately precedes run1's start
        );
    }

    /**
     * @private
     * @function subtract
     * @summary Operator that subtracts one run from another.
     * @returns {Array.Array.number} The remaining pieces of `minuend` after removing `subtrahend`.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * This function _does not assumes_ that `overlap()` has already been called with the same runs and has returned `true`.
     *
     * Returned array contains 0, 1, or 2 runs which are the portion(s) of `minuend` that do _not_ include `subtrahend`.
     *
     * Caveat: This operator is *not* commutative.
     * @param {number[]} minuend - a run from which to "subtract" `subtrahend`
     * @param {number[]} subtrahend - a run to "subtracted" from `minuend`
     */
    function subtract(minuend, subtrahend) {
        var m0 = minuend[0];
        var m1 = minuend[1];
        var s0 = subtrahend[0];
        var s1 = subtrahend[1];
        var result = [];

        if (s0 <= m0 && s1 < m1) {
            //subtrahend extends before minuend: return remaining piece of `minuend`
            result.push([s1 + 1, m1]);
        } else if (s0 > m0 && s1 >= m1) {
            //subtrahend extends after minuend: return remaining piece of `minuend`
            result.push([m0, s0 - 1]);
        } else if (m0 < s0 && s1 < m1) {
            //completely inside: return 2 smaller pieces resulting from the hole
            result.push([m0, s0 - 1]);
            result.push([s1 + 1, m1]);
        } else if (s1 < m0 || s0 > m1) {
            // completely outside: return `minuend` untouched
            result.push(minuend);
        }

        //else subtrahend must completely overlap minuend so return no pieces

        return result;
    }


    // Local utility functions

    /**
     * @private
     * @function merge
     * @summary Operator that merges given runs.
     * @returns {number[]} A single merged run.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * The runs are assumed to be overlapping or adjacent to one another.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - a run to merge with `run2`
     * @param {number[]} run2 - a run to merge with `run1`
     */
    function merge(run1, run2) {
        var min = Math.min(Math.min.apply(Math, run1), Math.min.apply(Math, run2));
        var max = Math.max(Math.max.apply(Math, run1), Math.max.apply(Math, run2));
        return [min, max];
    }

    // Interface
    module.exports = RangeSelectionModel;
})(
    typeof module === 'object' && module || (window.RangeSelectionModel = {}),
    typeof module === 'object' && module.exports || (window.RangeSelectionModel.exports = {})
) || (
    typeof module === 'object' || (window.RangeSelectionModel = window.RangeSelectionModel.exports)
);

/* About the above IIFE:
 * This file is a "modified node module." It functions as usual in Node.js *and* is also usable directly in the browser.
 * 1. Node.js: The IIFE is superfluous but innocuous.
 * 2. In the browser: The IIFE closure serves to keep internal declarations private.
 * 2.a. In the browser as a global: The logic in the actual parameter expressions + the post-invocation expression
 * will put your API in `window.RangeSelectionModel`.
 * 2.b. In the browser as a module: If you predefine a `window.module` object, the results will be in `module.exports`.
 * The bower component `mnm` makes this easy and also provides a global `require()` function for referencing your module
 * from other closures. In either case, this works with both NodeJs-style export mechanisms -- a single API assignment,
 * `module.exports = yourAPI` *or* a series of individual property assignments, `module.exports.property = property`.
 *
 * Before the IIFE runs, the actual parameter expressions are executed:
 * 1. If `window` object undefined, we're in NodeJs so assume there is a `module` object with an `exports` property
 * 2. If `window` object defined, we're in browser
 * 2.a. If `module` object predefined, use it
 * 2.b. If `module` object undefined, create a `RangeSelectionModel` object
 *
 * After the IIFE returns:
 * Because it always returns undefined, the expression after the || will execute:
 * 1. If `window` object undefined, then we're in NodeJs so we're done
 * 2. If `window` object defined, then we're in browser
 * 2.a. If `module` object predefined, we're done; results are in `moudule.exports`
 * 2.b. If `module` object undefined, redefine`RangeSelectionModel` to be the `RangeSelectionModel.exports` object
 */

},{}],51:[function(require,module,exports){
// tabz node module
// https://github.com/joneit/tabz

/* eslint-env node, browser */

'use strict';

var cssInjector = require('css-injector');

/**
 * Register/deregister click handler on all tab collections.
 * @param {Element} [options.root=document] - Where to look for tab panels (`.tabz` elements) containing tabs and folders.
 * @param {boolean} [options.unhook=false] - Remove event listener from tab panels (`.tabz` elements).
 * @param {Element} [options.referenceElement] - Passed to cssInjector's insertBefore() call.
 * @param {string} [options.defaultTabSelector='.default-tab'] - .classname or #id of the tab to select by default
 * @param {object} [options.onEnable] - Handler implementation. See {@link Tabz#onEnable|onEnable}.
 * @param {object} [options.onDisable] - Handler implementation. See {@link Tabz#onDisable|onEnable}.
 * @param {object} [options.onEnabled] - Handler implementation. See {@link Tabz#onEnabled|onEnable}.
 * @param {object} [options.onDisabled] - Handler implementation. See {@link Tabz#onDisabled|onEnable}.
 * @constructor
 */
function Tabz(options) {
    var i, el;

    options = options || {};
    var root = options.root || document,
        unhook = options.unhook,
        referenceElement = options.referenceElement,
        defaultTabSelector = options.defaultTabSelector || '.default-tab';

    if (!unhook) {
        var css;
        /* inject:css */
        css = '.tabz{position:relative;visibility:hidden;height:100%}.tabz>header{position:relative;display:inline-block;background-color:#fff;margin-left:1em;padding:5px .6em;border:1px solid #666;border-bottom-color:transparent;border-radius:6px 6px 0 0;cursor:default;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.tabz>header+section{position:absolute;display:none;background-color:#fff;margin-top:-1px;padding:8px;border:1px solid #666;border-radius:6px;left:0;right:0;bottom:0;top:0;z-index:0}.tabz>header+section.tabz-enable{z-index:1}.tabz>header.tabz-enable{z-index:2}.tabz-bg0{background-color:#eee!important}.tabz-bg1{background-color:#eef!important}.tabz-bg2{background-color:#efe!important}.tabz-bg3{background-color:#eff!important}.tabz-bg4{background-color:#fee!important}.tabz-bg5{background-color:#fef!important}.tabz-bg6{background-color:#ffe!important}';
        /* endinject */

        if (!referenceElement) {
            // find first <link> or <style> in <head>
            var headStuff = document.querySelector('head').children;
            for (i = 0; !referenceElement && i < headStuff.length; ++i) {
                el = headStuff[i];
                if (el.tagName === 'STYLE' || el.tagName === 'LINK' && el.rel === 'stylesheet') {
                    referenceElement = el;
                }
            }
        }
        cssInjector(css, 'tabz-css-base', referenceElement);

        for (var key in options) {
            if (this[key] === noop) {
                this[key] = options[key];
            }
        }

        /**
         * @summary The context of this tab object.
         * @desc The context may encompass any number of tab panels (`.tabz` elements).
         * @type {HTMLDocumen|HTMLElement}
         */
        this.root = root;

        // enable first tab on each tab panel (`.tabz` element)
        forEachEl('.tabz>header:first-of-type,.tabz>section:first-of-type', function(el) {
            el.classList.add('tabz-enable');
        }, root);

        // enable default tab and all its parents (must be a tab)
        this.tabTo(root.querySelector('.tabz > header' + defaultTabSelector));

        setTimeout(function() {
            forEachEl('.tabz > section', function(el) {

                // Step 1: A bug in older versions of Chrome (like v40) that inserted a break at mark-up location of an absolute positioned block. The work-around is to hide those blocks until after first render; then show them. I don't know why this works but it does. Seems to be durable.
                el.style.display = 'block';

                // Step 2: Adjust absolute top of each rendered folder to the bottom of its tab
                el.style.top = el.previousElementSibling.getBoundingClientRect().bottom - el.parentElement.getBoundingClientRect().top + 'px';

            }, root);
        }, 0);
    }

    var method = unhook ? 'removeEventListener' : 'addEventListener';
    var boundClickHandler = onclick.bind(this);
    forEachEl('.tabz', function(tabBar) {
        tabBar.style.visibility = 'visible';
        tabBar[method]('click', boundClickHandler);
    }, root);
}

function onclick(evt) {
    click.call(this, evt.currentTarget, evt.target);
}

/**
 * @summary Selects the given tab.
 * @desc If it is a nested tab, also reveals all its ancestor tabs.
 * @param {string|HTMLElement} [el] - May be one of:
 * * `HTMLElement`
 *   * `<header>` - tab element
 *   * `<section>` - folder element
 * * `string` - CSS selector to one of the above
 * * falsy - fails silently
 * @memberOf Tabz.prototype
 */
Tabz.prototype.tabTo = function(el) {
    while ((el = this.tab(el))) {
        click.call(this, el.parentElement, el);
        el = el.parentElement.parentElement; // loop to click on each containing tab...
    }
};

/**
 * Current selected tab.
 * @param {HTMLElement|number} el - An element that is (or is within) the tab panel (`.tabz` element) to look in.
 * @returns {undefined|HTMLElement} Returns tab (`<header>`) element.  Returns `undefined` if `el` is neither of the above or an out of range index.
 */
Tabz.prototype.enabledTab = function(el) {
    el = this.panel(el);
    return el && el.querySelector(':scope>header.tabz-enable');
};

/**
 * @summary Get tab element.
 * @desc Get tab element if given tab or folder element; or an element within such; or find tab.
 * @param {string|Element} [el] - May be one of:
 * * a tab (a `<header>` element)
 * * a folder (a `<section>` element)
 * * an element within one of the above
 * * `string` - CSS selector to one of the above, searching within the root or document
 * @returns {null|Element} tab (`<header>...</header>`) element or `null` if not found
 * @memberOf Tabz.prototype
 */
Tabz.prototype.tab = function(el) {
    el = lookForEl.call(this, el);
    return !(el instanceof HTMLElement) ? null : el.tagName === 'HEADER' ? el : el.tagName === 'SECTION' ? el.previousElementSibling : null;
};

/**
 * @summary Get folder element.
 * @desc Get folder element if given tab or folder element; or an element within such; or find folder.
 * @param {string|Element} [el] - May be one of:
 * * a tab (a `<header>` element)
 * * a folder (a `<section>` element)
 * * an element within one of the above
 * * `string` - CSS selector to one of the above, searching within the root or document
 * @returns {null|Element} tab (`<header>...</header>`) element or `null` if not found
 * @memberOf Tabz.prototype
 */
Tabz.prototype.folder = function(el) {
    el = lookForEl.call(this, el);
    return !(el instanceof HTMLElement) ? null : el.tagName === 'SECTION' ? el : el.tagName === 'HEADER' ? el.nextElementSibling : null;
};

/**
 * @summary Get tab panel element.
 * @desc Get panel element if given tab panel element; or an element within a tab panel; or find tab panel.
 * @param {string|Element} [el] - May be one of:
 * * a tab panel (an `HTMLElement` with class `tabz`)
 * * an element within a tab panel
 * * `string` - CSS selector to one a tab panel, searching within the root or document
 * @returns {null|Element} tab panel element or `null` if not found
 * @memberOf Tabz.prototype
 */
Tabz.prototype.panel = function(el) {
    while (el && !el.classList.contains('tabz')) {
        el = el.parentElement;
    }
    return !(el instanceof HTMLElement) ? null : el.classList.contains('tabz') ? el : null;
};

function lookForEl(el) {
    if (el instanceof Element) {
        while (el && el.tagName !== 'HEADER' && el.tagName !== 'SECTION') {
            el = el.parentElement;
        }
    } else {
        el = this.root.querySelector(el);
    }
    return el;
}

/** Enables the tab/folder pair of the clicked tab.
 * Disables all the other pairs in this scope which will include the previously enabled pair.
 * @private
 * @this Tabz
 * @param {Element} div - The tab panel (`.tabz` element) that's handling the click event.
 * @param {Element} target - The element that received the click.
 * @returns {undefined|Element} The `<header>` element (tab) the was clicked; or `undefined` when click was not within a tab.
 */
function click(div, target) {
    var newTab, oldTab;

    forEachEl(':scope>header:not(.tabz-enable)', function(tab) { // todo: use a .find() polyfill here
        if (tab.contains(target)) {
            newTab = tab;
        }
    }, div);

    if (newTab) {
        oldTab = this.enabledTab(div);
        toggleTab.call(this, oldTab, false);
        toggleTab.call(this, newTab, true);
    }

    return newTab;
}

/**
 * @private
 * @this Tabz
 * @param {Element} tab - The `<header>` element of the tab to enable or disable.
 * @param {boolean} enable - Enable (vs. disable) the tab.
 */
function toggleTab(tab, enable) {
    if (tab) {
        var folder = this.folder(tab),
            method = enable ? 'onEnable' : 'onDisable';

        this[method].call(this, tab, folder);

        tab.classList.toggle('tabz-enable', enable);
        folder.classList.toggle('tabz-enable', enable);

        method += 'd';
        this[method].call(this, tab, folder);
    }
}

/**
 * @typedef tabEvent
 * @type {function}
 * @param {tabEventObject}
 */

/**
 * @typedef tabEventObject
 * @property {Tabz} tabz - The tab object issuing the callback.
 * @property {Element} target - The tab (`<header>` element).
 */

/**
 * Called before a previously disabled tab is enabled.
 * @type {tabEvent}
 * @abstract
 * @memberOf Tabz.prototype
 */
Tabz.prototype.onEnable = noop;

/**
 * Called before a previously enabled tab is disabled by another tab being enabled.
 * @type {tabEvent}
 * @abstract
 * @memberOf Tabz.prototype
 */
Tabz.prototype.onDisable = noop;

/**
 * Called after a previously disabled tab is enabled.
 * @type {tabEvent}
 * @abstract
 * @memberOf Tabz.prototype
 */
Tabz.prototype.onEnabled = noop;

/**
 * Called after a previously enabled tab is disabled by another tab being enabled.
 * @type {tabEvent}
 * @abstract
 * @memberOf Tabz.prototype
 */
Tabz.prototype.onDisabled = noop;

function noop() {} // null pattern

function forEachEl(selector, iteratee, context) {
    return Array.prototype.forEach.call((context || document).querySelectorAll(selector), iteratee);
}


module.exports = Tabz;

},{"css-injector":6}],52:[function(require,module,exports){
// templex node module
// https://github.com/joneit/templex

/* eslint-env node */

/**
 * Merges values of execution context properties named in template by {prop1},
 * {prop2}, etc., or any javascript expression incorporating such prop names.
 * The context always includes the global object. In addition you can specify a single
 * context or an array of contexts to search (in the order given) before finally
 * searching the global context.
 *
 * Merge expressions consisting of simple numeric terms, such as {0}, {1}, etc., deref
 * the first context given, which is assumed to be an array. As a convenience feature,
 * if additional args are given after `template`, `arguments` is unshifted onto the context
 * array, thus making first additional arg available as {1}, second as {2}, etc., as in
 * `templex('Hello, {1}!', 'World')`. ({0} is the template so consider this to be 1-based.)
 *
 * If you prefer something other than braces, redefine `templex.regexp`.
 *
 * See tests for examples.
 *
 * @param {string} template
 * @param {...string} [args]
 */
function templex(template) {
    var contexts = this instanceof Array ? this : [this];
    if (arguments.length > 1) { contexts.unshift(arguments); }
    return template.replace(templex.regexp, templex.merger.bind(contexts));
}

templex.regexp = /\{(.*?)\}/g;

templex.with = function (i, s) {
    return 'with(this[' + i + ']){' + s + '}';
};

templex.cache = [];

templex.deref = function (key) {
    if (!(this.length in templex.cache)) {
        var code = 'return eval(expr)';

        for (var i = 0; i < this.length; ++i) {
            code = templex.with(i, code);
        }

        templex.cache[this.length] = eval('(function(expr){' + code + '})'); // eslint-disable-line no-eval
    }
    return templex.cache[this.length].call(this, key);
};

templex.merger = function (match, key) {
    // Advanced features: Context can be a list of contexts which are searched in order.
    var replacement;

    try {
        replacement = isNaN(key) ? templex.deref.call(this, key) : this[0][key];
    } catch (e) {
        replacement = '{' + key + '}';
    }

    return replacement;
};

// this interface consists solely of the templex function (and it's properties)
module.exports = templex;

},{}],53:[function(require,module,exports){
// Created by Jonathan Eiten on 1/7/16.

'use strict';

/**
 * Very fast array test.
 * For cross-frame scripting; use `crossFramesIsArray` instead.
 * @param {*} arr - The object to test.
 * @returns {boolean}
 */
unstrungify.isArray = function(arr) { return arr.constructor === Array; };

/**
 * @summary Walk a hierarchical object as JSON.stringify does but without serializing.
 *
 * @desc Usage:
 * * var myDistilledObject = unstrungify.call(myObject);
 * * var myDistilledObject = myApi.getState(); // where myApi.prototype.getState = unstrungify
 *
 * Result equivalent to `JSON.parse(JSON.stringify(this))`.
 *
 * > Do not use this function to get a JSON string; use `JSON.stringify(this)` instead.
 *
 * @this {*|object|*[]} - Object to walk; typically an object or array.
 *
 * @param {boolean} [options.nullElements==false] - Preserve undefined array elements as `null`s.
 * Use this when precise index matters (not merely the order of the elements).
 *
 * @param {boolean} [options.nullProperties==false] - Preserve undefined object properties as `null`s.
 *
 * @returns {object} - Distilled object.
 */
function unstrungify(options) {
    var clone, preserve,
        object = (typeof this.toJSON === 'function') ? this.toJSON() : this;

    if (unstrungify.isArray(object)) {
        clone = [];
        preserve = options && options.nullElements;
        object.forEach(function(obj) {
            var value = unstrungify.call(obj);
            if (value !== undefined) {
                clone.push(value);
            } else if (preserve) {
                clone.push(null); // undefined not a valid JSON value
            }
        });
    } else  if (typeof object === 'object') {
        clone = {};
        preserve = options && options.nullProperties;
        Object.keys(object).forEach(function(key) {
            var value = object[key];
            if (value !== undefined) {
                value = unstrungify.call(object[key]);
            }
            if (value !== undefined) {
                clone[key] = value;
            } else if (preserve) {
                clone[key] = null; // undefined not a valid JSON value
            }
        });
    } else {
        clone = object;
    }

    return clone;
}

/**
 * Very slow array test. Suitable for cross-frame scripting.
 *
 * Suggestion: If you need this and have jQuery loaded, use `jQuery.isArray` instead which is reasonably fast.
 *
 * @param {*} arr - The object to test.
 * @returns {boolean}
 */
unstrungify.crossFramesIsArray = function(arr) { return toString.call(arr) === arrString; }; // eslint-disable-line no-unused-vars

var toString = Object.prototype.toString, arrString = '[object Array]';

module.exports = unstrungify;

},{}],54:[function(require,module,exports){
/* eslint-env browser */

'use strict';

require('./lib/polyfills'); // Installs misc. polyfills into global objects, as needed

var extend = require('extend-me');
extend.debug = true;

var FinBar = require('finbars');
var Canvas = require('fincanvas');
var Point = require('rectangular').Point;
var Rectangle = require('rectangular').Rectangle;
var _ = require('object-iterators'); // fyi: installs the Array.prototype.find polyfill, as needed

var deprecated = require('./lib/deprecated');
var defaults = require('./defaults');
var Renderer = require('./lib/Renderer');
var SelectionModel = require('./lib/SelectionModel');
var stylesheet = require('./lib/stylesheet');
var Localization = require('./lib/Localization');
var behaviors = require('./behaviors');
var CellRenderers = require('./cellRenderers');
var CellEditors = require('./cellEditors');

var themeInitialized = false,
    polymerTheme = Object.create(defaults),
    globalProperties = Object.create(polymerTheme);

/**s
 * @constructor
 * @param {string|Element} div - CSS selector or Element
 * @param {object} [options]
 * @param {function} [options.Behavior=behaviors.JSON] - A behavior constructor.
 * @param {function|object[]} [options.data] - Passed to behavior constructor. May be:
 * * An array of congruent raw data objects
 * * A function returning same
 * @param {function|menuItem[]} [options.schema=derivedSchema] - Passed to behavior constructor. May be:
 * * A schema array
 * * A function returning a schema array. Called at filter reset time with behavior as context.
 * * Omit to generate a basic schema from `this.behavior.columns`.
 * @param {Behavior} [options.Behavior=JSON] - A grid behavior (descendant of Behavior "class"). Will be used if `getBehavior` omitted, in which case `options.data` (which has no default) *must* also be provided.
 * @param {string} [options.localization=Hypergrid.localization]
 * @param {string|string[]} [options.localization.locale=Hypergrid.localization.locale] - The default locale to use when an explicit `locale` is omitted from localizer constructor calls. Passed to Intl.NumberFomrat` and `Intl.DateFomrat`. See {@ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation|Locale identification and negotiation} for more information.
 * @param {string} [options.localization.numberOptions=Hypergrid.localization.numberOptions] - Options passed to `Intl.NumberFomrat` for creating the basic "number" localizer.
 * @param {string} [options.localization.dateOptions=Hypergrid.localization.dateOptions] - Options passed to `Intl.DateFomrat` for creating the basic "date" localizer.
 * @param {object} [options.margin] - optional canvas margins
 * @param {string} [options.margin.top=0]
 * @param {string} [options.margin.right='-200px']
 * @param {string} [options.margin.bottom=0]
 * @param {string} [options.margin.left=0]
 */
function Hypergrid(div, options) {
    var self = this;

    this.div = (typeof div === 'string') ? document.querySelector(div) : div;

    stylesheet.inject('grid');

    this.lastEdgeSelection = [0, 0];

    this.lnfProperties = Object.create(globalProperties);

    this.isWebkit = navigator.userAgent.toLowerCase().indexOf('webkit') > -1;
    this.selectionModel = new SelectionModel(this);
    this.renderOverridesCache = {};

    options = options || {};
    var data = typeof options.data === 'function' ? options.data() : options.data;
    var Behavior = options.Behavior || behaviors.JSON;
    this.behavior = new Behavior(this, options.schema, data);

    var loc = options.localization || {};
    this.localization = new Localization(
        loc.locale || Hypergrid.localization.locale,
        loc.numberOptions || Hypergrid.localization.numberOptions,
        loc.dateOptions || Hypergrid.localization.dateOptions
    );

    //prevent the default context menu for appearing
    this.div.oncontextmenu = function(event) {
        event.preventDefault();
        return false;
    };

    this.clearMouseDown();
    this.dragExtent = new Point(0, 0);
    this.numRows = 0;
    this.numColumns = 0;

    //install any plugins
    this.pluginsDo(function(each) {
        if (each.installOn) {
            each.installOn(self);
        }
    });

    var margin = options.margin || {};
    margin.top = margin.top || 0;
    margin.right = margin.right || '-200px';
    margin.bottom = margin.bottom || 0;
    margin.left = margin.left || 0;

    /**
     * @type {CellRenderers}
     * @memberOf Hypergrid.prototype
     */
    this.cellRenderers = new CellRenderers();

    /**
     * @type {CellEditors}
     * @memberOf Hypergrid.prototype
     */
    this.cellEditors = new CellEditors(this);

    this.allowEventHandlers = true;

    //initialize our various pieces
    if (!themeInitialized) {
        themeInitialized = true;
        buildPolymerTheme();
    }
    this.initRenderer();
    this.initCanvas(margin);
    this.initScrollbars();

    //Register a listener for the copy event so we can copy our selected region to the pastebuffer if conditions are right.
    document.body.addEventListener('copy', function(evt) {
        self.checkClipboardCopy(evt);
    });
    this.getCanvas().resize();
}

Hypergrid.prototype = {
    constructor: Hypergrid.prototype.constructor,

    deprecated: deprecated,
    registerCellEditor: function(Constructor, name) {
        this.deprecated('registerCellEditor(Constructor, name)', 'cellEditors.add(name, Constructor)', '1.0.6', arguments);
    },
    createCellEditor: function(name) {
        this.deprecated('createCellEditor(name)', 'cellEditors.create(name)', '1.0.6', arguments);
    },
    getCellProvider: function(name) {
        this.deprecated('getCellProvider()', 'cellRenderers', '1.0.6', arguments);
    },
    registerLocalizer: function(name, localizer, baseClassName, newClassName) {
        this.deprecated('registerLocalizer(name, localizer, baseClassName, newClassName)', 'localization.add(name, localizer)', '1.0.6', arguments,
            'STRUCTURAL CHANGE: No longer supports deriving and registering a new cell editor class. Use .cellEditors.get(baseClassName).extend(newClassName || name, {...}) for that.');
    },

    /**
     *
     * A null object behavior serves as a place holder.
     * @type {object}
     * @memberOf Hypergrid.prototype
     */
    behavior: null,

    /**
     * Cached resulan}
     * @memberOf Hypergrid.prototype
     */
    isWebkit: true,

    /**
     * The pixel location of an initial mousedown click, either for editing a cell or for dragging a selection.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */
    mouseDown: [],

    /**
     * The extent from the mousedown point during a drag operation.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */

    dragExtent: null,

    /**
     * A float value between 0.0 - 1.0 of the vertical scroll position.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    vScrollValue: 0,

    /**
     * A float value between 0.0 - 1.0 of the horizontal scroll position.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    hScrollValue: 0,

    /**
     * @property {fin-hypergrid-selection-model} selectionModel - A [fin-hypergrid-selection-model](module-._selection-model.html) instance.
     * @memberOf Hypergrid.prototype
     */
    selectionModel: null,

    /**
     * @property {fin-hypergrid-cell-editor} cellEditor - The current instance of [fin-hypergrid-cell-editor](module-cell-editors_base.html).
     * @memberOf Hypergrid.prototype
     */
    cellEditor: null,

    /**
     * @property {fin-vampire-bar} sbHScroller - An instance of {@link https://github.com/openfin/finbars|FinBar}.
     * @memberOf Hypergrid.prototype
     */
    sbHScroller: null,

    /**
     * @property {fin-vampire-bar} sbVScroller - An instance of {@link https://github.com/openfin/finbars|FinBar}.
     * @memberOf Hypergrid.prototype
     */
    sbVScroller: null,

    /**
     * The previous value of sbVScrollVal.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    sbPrevVScrollValue: null,

    /**
     * The previous value of sbHScrollValue.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    sbPrevHScrollValue: null,

    /**
     * is the short term memory of what column I might be dragging around
     * @type {object}
     * @memberOf Hypergrid.prototype
     */

    renderOverridesCache: {},

    /**
     * The pixel location of the current hovered cell.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */
    hoverCell: null,

    scrollingNow: false,

    lastEdgeSelection: null,

    /**
     * @memberOf Hypergrid.prototype
    clear out the LRU cache of text widths
     */
    setAttribute: function(attribute, value) {
        this.div.setAttribute(attribute, value);
    },

    /**
     * @memberOf Hypergrid.prototype
    clear out all state and data of the grid
     */
    reset: function() {
        this.lastEdgeSelection = [0, 0];
        this.lnfProperties = Object.create(globalProperties);
        this.selectionModel = new SelectionModel(this);
        this.renderOverridesCache = {};
        this.clearMouseDown();
        this.dragExtent = new Point(0, 0);

        this.numRows = 0;
        this.numColumns = 0;

        this.vScrollValue = 0;
        this.hScrollValue = 0;

        this.cellEditor = null;

        this.sbPrevVScrollValue = null;
        this.sbPrevHScrollValue = null;

        this.hoverCell = null;
        this.scrollingNow = false;
        this.lastEdgeSelection = [0, 0];

        this.behavior.reset();
        this.getRenderer().reset();
        this.getCanvas().resize();
        this.behaviorChanged();
    },

    //resetTextWidthCache: function() {
    //    textWidthCache = new LRUCache(2000);
    //},

    getProperties: function() {
        return this.getPrivateState();
    },

    _getProperties: function() {
        return this.lnfProperties;
    },

    computeCellsBounds: function() {
        var renderer = this.getRenderer();
        if (renderer) {
            renderer.computeCellsBounds();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The pointer is over the given cell.
     * @param {number} x - The x cell coordinate.
     * @param {number} y - The y cell coordinate.
     */
    isHovered: function(x, y) {
        var p = this.getHoverCell();
        return p && p.x === x && p.y === y;
    },

    getFormatter: function(localizerName) {
        return this.localization.get(localizerName).format;
    },

    formatValue: function(localizerName, value) {
        var formatter = this.getFormatter(localizerName);
        return formatter(value);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns boolean} The pointer is hovering over the given column.
     * @param {number} x - The horizontal cell coordinate.
     */
    isColumnHovered: function(x) {
        var p = this.getHoverCell();
        return p && p.x === x;
    },

    isRowResizeable: function() {
        return this.resolveProperty('rowResize');
    },

    isCheckboxOnlyRowSelections: function() {
        return this.resolveProperty('checkboxOnlyRowSelections');
    },

    /**
     *
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The pointer is hovering over the row `y`.
     * @param {number} y - The vertical cell coordinate.
     */
    isRowHovered: function(y) {
        var p = this.getHoverCell();
        return p && p.y === y;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Point} The cell over which the cursor is hovering.
     */
    getHoverCell: function() {
        return this.hoverCell;
    },


    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the cell under the cursor.
     * @param {Point} point
     */
    setHoverCell: function(point) {
        var me = this.hoverCell;
        var newPoint = new Point(point.x, point.y);
        if (me && me.equals(newPoint)) {
            return;
        }
        this.hoverCell = newPoint;
        this.fireSyntheticOnCellEnterEvent(newPoint);
        this.repaint();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Ammend properties for all hypergrids in this process.
     * @param {object} properties - A simple properties hash.
     */
    addGlobalProperties: function(properties) {
        //we check for existence to avoid race condition in initialization
        if (!globalProperties) {
            var self = this;
            setTimeout(function() {
                self.addGlobalProperties(properties);
            }, 10);
        } else {
            this._addGlobalProperties(properties);
        }

    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Ammend properties for all hypergrids in this process.
     * @param {object} properties - A simple properties hash.
     * @private
     */
    _addGlobalProperties: function(properties) {
        _(properties).each(function(property, key) {
            globalProperties[key] = property;
        });
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Utility function to push out properties if we change them.
     * @param {object} properties - An object of various key value pairs.
     */

    refreshProperties: function() {
        // this.canvas = this.shadowRoot.querySelector('fin-canvas');
        //this.canvas = new Canvas(this.divCanvas, this.renderer); //TODO: Do we really need to be recreating it here?
        this.renderer.computeCellsBounds();
        this.checkScrollbarVisibility();
        this.behavior.defaultRowHeight = null;
        if (this.isColumnAutosizing()) {
            this.behavior.autosizeAllColumns();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Ammend properties for this hypergrid only.
     * @param {object} moreProperties - A simple properties hash.
     */
    addProperties: function(moreProperties) {
        var properties = this.getProperties();
        addDeepProperties(properties, moreProperties);
        this.refreshProperties();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} The state object for remembering our state.
     * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
     */
    getPrivateState: function() {
        return this.behavior.getPrivateState();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the state object to return to the given user configuration.
     * @param {object} state - A memento object.
     * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
     */
    setState: function(state) {
        var self = this;
        this.behavior.setState(state);
        setTimeout(function() {
            self.behaviorChanged();
            self.synchronizeScrollingBoundries();
        }, 100);
    },

    getState: function() {
        return this.behavior.getState();
    },
    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} The initial mouse position on a mouse down event for cell editing or a drag operation.
     * @memberOf Hypergrid.prototype
     */
    getMouseDown: function() {
        var last = this.mouseDown.length - 1;
        if (last < 0) {
            return null;
        }
        return this.mouseDown[last];
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Remove the last item from the mouse down stack.
     */
    popMouseDown: function() {
        if (this.mouseDown.length !== 0) {
            this.mouseDown.length = this.mouseDown.length - 1;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Empty out the mouse down stack.
     */
    clearMouseDown: function() {
        this.mouseDown = [new Point(-1, -1)];
        this.dragExtent = null;
    },

    /**
     * Set the mouse point that initiated a cell edit or drag operation.
     * @param {Point} point
     * @memberOf Hypergrid.prototype
     */
    setMouseDown: function(point) {
        this.mouseDown.push(point);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Point} The extent point of the current drag selection rectangle.
     */
    getDragExtent: function() {
        return this.dragExtent;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set the extent point of the current drag selection operation.
     * @param {Point} point
     */
    setDragExtent: function(point) {
        this.dragExtent = point;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Iterate over the plugins invoking the given function with each.
     * @todo We need a new plugin mechanism!
     * @param {function} func - The function to invoke on all the plugins.
     */
    pluginsDo: function(func) {
        //TODO: We need a new plugin mechanism!
        //var userPlugins = this.children.array();
        //var pluginsTag = this.shadowRoot.querySelector('fin-plugins');
        //
        //var plugins = userPlugins;
        //if (pluginsTag) {
        //    var systemPlugins = pluginsTag.children.array();
        //    plugins = systemPlugins.concat(plugins);
        //}
        //
        //plugins.forEach(function(plugin) {
        //    func(plugin);
        //});
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc This function is a callback from the HypergridRenderer sub-component. It is called after each paint of the canvas.
     */
    gridRenderedNotification: function() {
        this.updateRenderedSizes();
        if (this.cellEditor) {
            this.cellEditor.gridRenderedNotification();
        }
        this.checkColumnAutosizing();
        this.fireSyntheticGridRenderedEvent();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The grid has just been rendered, make sure the column widths are optimal.
     */
    checkColumnAutosizing: function() {
        var behavior = this.behavior;
        behavior.autoSizeRowNumberColumn();
        if (this.isColumnAutosizing()) {
            behavior.checkColumnAutosizing(false);
        }
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Notify the GridBehavior how many rows and columns we just rendered.
     */
    updateRenderedSizes: function() {
        //add one to each of these values as we want also to include
        //the columns and rows that are partially visible
        this.behavior.setRenderedColumnCount(this.getVisibleColumns() + 1);
        this.behavior.setRenderedRowCount(this.getVisibleRows() + 1);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Conditionally copy to clipboard.
     * @desc If we have focus, copy our current selection data to the system clipboard.
     * @param {event} event - The copy system event.
     */
    checkClipboardCopy: function(event) {
        if (this.hasFocus()) {
            event.preventDefault();
            var csvData = this.getSelectionAsTSV();
            event.clipboardData.setData('text/plain', csvData);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} We have any selections.
     */
    hasSelections: function() {
        if (!this.getSelectionModel) {
            return; // were not fully initialized yet
        }
        return this.selectionModel.hasSelections();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {string} Tab separated value string from the selection and our data.
     */
    getSelectionAsTSV: function() {
        var sm = this.selectionModel;
        if (sm.hasSelections()) {
            var selections = this.getSelectionMatrix();
            selections = selections[selections.length - 1];
            return this.getMatrixSelectionAsTSV(selections);
        } else if (sm.hasRowSelections()) {
            return this.getMatrixSelectionAsTSV(this.getRowSelectionMatrix());
        } else if (sm.hasColumnSelections()) {
            return this.getMatrixSelectionAsTSV(this.getColumnSelectionMatrix());
        }
    },

    getMatrixSelectionAsTSV: function(selections) {
        var result = '';

        //only use the data from the last selection
        if (selections.length) {
            var width = selections.length,
                height = selections[0].length,
                area = width * height,
                lastCol = width - 1,
                //Whitespace will only be added on non-singular rows, selections
                whiteSpaceDelimiterForRow = (height > 1 ? '\n' : '');

            //disallow if selection is too big
            if (area > 20000) {
                alert('selection size is too big to copy to the paste buffer'); // eslint-disable-line no-alert
                return '';
            }

            for (var h = 0; h < height; h++) {
                for (var w = 0; w < width; w++) {
                    result += selections[w][h] + (w < lastCol ? '\t' : whiteSpaceDelimiterForRow);
                }
            }
        }

        return result;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} We have focus.
     */
    hasFocus: function() {
        return this.getCanvas().hasFocus();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear all the selections.
     */
    clearSelections: function() {
        var dontClearRows = this.isCheckboxOnlyRowSelections();
        this.selectionModel.clear(dontClearRows);
        this.clearMouseDown();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent selection.
     */
    clearMostRecentSelection: function() {
        var dontClearRows = this.isCheckboxOnlyRowSelections();
        this.selectionModel.clearMostRecentSelection(dontClearRows);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent column selection.
     */
    clearMostRecentColumnSelection: function() {
        this.selectionModel.clearMostRecentColumnSelection();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent row selection.
     */
    clearMostRecentRowSelection: function() {
        //this.selectionModel.clearMostRecentRowSelection(); // commented off as per GRID-112
    },

    clearRowSelection: function() {
        this.selectionModel.clearRowSelection();
        this.behavior.dataModel.clearSelectedData();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Select given region.
     * @param {number} ox - origin x
     * @param {number} oy - origin y
     * @param {number} ex - extent x
     * @param {number} ex - extent y
     */
    select: function(ox, oy, ex, ey) {
        if (ox < 0 || oy < 0) {
            //we don't select negative area
            //also this means there is no origin mouse down for a selection rect
            return;
        }
        this.selectionModel.select(ox, oy, ex, ey);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} Given point is selected.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     */
    isSelected: function(x, y) {
        return this.selectionModel.isSelected(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given column is selected anywhere in the entire table.
     * @param {number} col - The column index.
     */
    isCellSelectedInRow: function(col) {
        var selectionModel = this.selectionModel;
        var isSelected = selectionModel.isCellSelectedInRow(col);
        return isSelected;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given row is selected anywhere in the entire table.
     * @param {number} row - The row index.
     */
    isCellSelectedInColumn: function(row) {
        var selectionModel = this.selectionModel;
        var isSelected = selectionModel.isCellSelectedInColumn(row);
        return isSelected;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set the Behavior (model) object for this grid control.
     * @desc This can be done dynamically.
     * @param {Behavior} behavior - The behavior (model).
     */
    setBehavior: function(behavior) {
        behavior.changed = this.behaviorChanged.bind(this);
        behavior.shapeChanged = this.behaviorShapeChanged.bind(this);
        behavior.stateChanged = this.behaviorStateChanged.bind(this);
        this.behavior = behavior;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc I've been notified that the behavior has changed.
     */
    behaviorChanged: function() {
        if (this.numColumns !== this.getColumnCount() || this.numRows !== this.getRowCount()) {
            this.numColumns = this.getColumnCount();
            this.numRows = this.getRowCount();
            this.behaviorShapeChanged();
        }
        this.computeCellsBounds();
        this.repaint();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Rectangle} My bounds.
     */
    getBounds: function() {
        var renderer = this.getRenderer();
        return renderer && renderer.getBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {string} The value of a lnf property.
     * @param {string} key - A look-and-feel key.
     */
    resolveProperty: function(key) {
        var keys = key.split('.');
        var prop = this.getProperties();
        while (keys.length) { prop = prop[keys.shift()]; }
        return prop;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    behaviorShapeChanged: function() {
        this.synchronizeScrollingBoundries();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    behaviorStateChanged: function() {
        this.getRenderer().computeCellsBounds();
        this.repaint();
    },

    repaint: function() {
        var now = this.resolveProperty('repaintImmediately');
        var canvas = this.getCanvas();
        if (canvas) {
            if (now === true) {
                canvas.paintNow();
            } else {
                canvas.repaint();
            }
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Paint immediately in this microtask.
     */
    paintNow: function() {
        var canvas = this.getCanvas();
        canvas.paintNow();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} In HiDPI mode (has an attribute as such).
     */
    useHiDPI: function() {
        return this.resolveProperty('useHiDPI') !== false;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Initialize drawing surface.
     * @private
     */
    initCanvas: function(margin) {

        var self = this;

        var divCanvas = this.divCanvas = document.createElement('div');
        this.div.appendChild(divCanvas);
        this.canvas = new Canvas(divCanvas, this.renderer);
        this.canvas.canvas.classList.add('hypergrid');

        var style = divCanvas.style;
        style.position = 'absolute';
        style.top = margin.top;
        style.right = margin.right;
        style.bottom = margin.bottom;
        style.left = margin.left;

        this.canvas.resizeNotification = function() {
            self.resized();
        };

        this.addEventListener('fin-canvas-mousemove', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.delegateMouseMove(mouseEvent);
        });

        this.addEventListener('fin-canvas-mousedown', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            //self.stopEditing();
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.keys = e.detail.keys;
            mouseEvent.primitiveEvent = e;
            self.mouseDownState = mouseEvent;
            self.delegateMouseDown(mouseEvent);
            self.fireSyntheticMouseDownEvent(mouseEvent);
            self.repaint();
        });

        this.addEventListener('fin-canvas-click', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            //self.stopEditing();
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            mouseEvent.keys = e.detail.keys; // todo: this was in fin-tap but wasn't here
            self.fireSyntheticClickEvent(mouseEvent);
            self.delegateClick(mouseEvent);
        });

        this.addEventListener('fin-canvas-mouseup', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.dragging = false;
            if (self.isScrollingNow()) {
                self.setScrollingNow(false);
            }
            if (self.columnDragAutoScrolling) {
                self.columnDragAutoScrolling = false;
            }
            //self.stopEditing();
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.delegateMouseUp(mouseEvent);
            if (self.mouseDownState) {
                self.fireSyntheticButtonPressedEvent(self.mouseDownState);
            }
            self.mouseDownState = null;
            self.fireSyntheticMouseUpEvent(mouseEvent);
        });

        this.addEventListener('fin-canvas-dblclick', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.fireSyntheticDoubleClickEvent(mouseEvent, e);
            self.delegateDoubleClick(mouseEvent);
        });

        this.addEventListener('fin-canvas-drag', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.dragging = true;
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.delegateMouseDrag(mouseEvent);
        });

        this.addEventListener('fin-canvas-keydown', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.fireSyntheticKeydownEvent(e);
            self.delegateKeyDown(e);
        });

        this.addEventListener('fin-canvas-keyup', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.fireSyntheticKeyupEvent(e);
            self.delegateKeyUp(e);
        });

        this.addEventListener('fin-canvas-wheelmoved', function(e) {
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e.detail.primitiveEvent;
            self.delegateWheelMoved(mouseEvent);
        });

        this.addEventListener('fin-canvas-mouseout', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e.detail.primitiveEvent;
            self.delegateMouseExit(mouseEvent);
        });

        this.addEventListener('fin-canvas-context-menu', function(e) {
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e.detail.primitiveEvent;
            self.delegateContextMenu(mouseEvent);
        });

        this.div.removeAttribute('tabindex');

    },

    convertViewPointToDataPoint: function(viewPoint) {
        return this.behavior.convertViewPointToDataPoint(viewPoint);
    },

    convertDataPointToViewPoint: function(dataPoint) {
        return this.behavior.convertDataPointToViewPoint(dataPoint);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Add an event listener to me.
     * @param {string} eventName - The type of event we are interested in.
     * @param {function} callback - The event handler.
     */
    addEventListener: function(eventName, callback) {
        var self = this;
        var decorator = function(e) {
            if (self.allowEventHandlers){
                callback(e);
            }
        };
        this.canvas.addEventListener(eventName, decorator);
    },

    allowEvents: function(allow){
        if ((this.allowEventHandlers = !!allow)){
            this.behavior.featureChain.attachChain();
        } else {
            this.behavior.featureChain.detachChain();
        }

        this.behavior.changed();
    },

    addFinEventListener: function(eventName, callback) {
        console.warn('.addFinEventListener() method is deprecated as of v0.2. Use .addEventListener() instead. (Will be removed in a future release.)');
        this.addEventListener(eventName, callback);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set for `scrollingNow` field.
     * @param {boolean} isItNow - The type of event we are interested in.
     */
    setScrollingNow: function(isItNow) {
        this.scrollingNow = isItNow;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The `scrollingNow` field.
     */
    isScrollingNow: function() {
        return this.scrollingNow;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The index of the column divider under the mouse coordinates.
     * @param {MouseEvent} mouseEvent - The event to interogate.
     */
    overColumnDivider: function(mouseEvent) {
        var x = mouseEvent.primitiveEvent.detail.mouse.x;
        var whichCol = this.getRenderer().overColumnDivider(x);
        return whichCol;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The index of the row divider under the mouse coordinates.
     * @param {MouseEvent} mouseEvent - The event to interogate.
     */
    overRowDivider: function(mouseEvent) {
        var y = mouseEvent.primitiveEvent.detail.mouse.y;
        var which = this.getRenderer().overRowDivider(y);
        return which;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Switch the cursor for the grid.
     * @param {string} cursorName - A well know cursor name.
     * @see [cursor names](http://www.javascripter.net/faq/stylesc.htm)
     */
    beCursor: function(cursorName) {
        if (!cursorName) {
            cursorName = 'default';
        }
        this.div.style.cursor = cursorName;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate the wheel moved event to the behavior.
     * @param {Event} event - The pertinent event.
     */
    delegateWheelMoved: function(event) {
        this.behavior.onWheelMoved(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseExit to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateMouseExit: function(event) {
        this.behavior.handleMouseExit(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseExit to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateContextMenu: function(event) {
       this. behavior.onContextMenu(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseMove to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseMove: function(mouseDetails) {
        this.behavior.onMouseMove(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mousedown to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseDown: function(mouseDetails) {
        this.behavior.handleMouseDown(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mouseup to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseUp: function(mouseDetails) {
        this.behavior.onMouseUp(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate click to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateClick: function(mouseDetails) {
        this.behavior.onClick(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mouseDrag to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseDrag: function(mouseDetails) {
        this.behavior.onMouseDrag(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc We've been doubleclicked on. Delegate through the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateDoubleClick: function(mouseDetails) {
        this.behavior.onDoubleClick(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateKeyDown: function(event) {
        this.behavior.onKeyDown(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateKeyUp: function(event) {
        this.behavior.onKeyUp(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Shut down the current cell editor and save the edited value.
     * @returns {boolean} `true` if we were editing; `false` if we were not.
     */
    stopEditing: function() {
        var wasEditing = !!this.cellEditor;
        if (wasEditing) {
            this.cellEditor.stopEditing();
        }
        return wasEditing;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Shut down the current cell editor without saving the edited value.
     * @returns {boolean} `true` if we were editing; `false` if we were not.
     */
    cancelEditing: function() {
        var wasEditing = !!this.cellEditor;
        if (wasEditing) {
            this.cellEditor.cancelEditing();
        }
        return wasEditing;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Rectangle} The pixel coordinates of just the center 'main" data area.
     */
    getDataBounds: function() {
        var colDNDHackWidth = 200; //this was a hack to help with column dnd, need to factor this into a shared variable
        var b = this.canvas.bounds;

        //var x = this.getRowNumbersWidth();
        // var y = behavior.getFixedRowsHeight() + 2;

        var result = new Rectangle(0, 0, b.origin.x + b.extent.x - colDNDHackWidth, b.origin.y + b.extent.y);
        return result;
    },

    getRowNumbersWidth: function() {
        if (this.isShowRowNumbers()) {
            return this.getRenderer().getRowNumbersWidth();
        } else {
            return 0;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Canvas} Our fin-canvas instance.
     */
    getCanvas: function() {
        return this.canvas;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Open the cell-editor at the provided model coordinates.
     * @param {Point} editPoint - The model coordinates of the cell to edit. This is the grid coordinates regardless of scroll position.
     * @return {undefined|CellEditor} The cellEditor determined from the cell's render properties, which may be modified by logic added by overriding {@link DataModel#getCellEditorAt|getCellEditorAt}.
     */
    editAt: function(editPoint) {
        var cellEditor;

        if (arguments.length === 2) {
            return this.deprecated('editAt(cellEditor, editPoint)', 'editAt(editPoint)', '1.0.6', arguments);
        }

        this.stopEditing(); //other editor is open, close it first

        if (editPoint.x >= 0 && editPoint.y >= 0) {
            if (this.isEditable() || this.isFilterRow(editPoint.y)) {
                this.setMouseDown(editPoint);
                this.setDragExtent(new Point(0, 0));
                cellEditor = this.getCellEditorAt(editPoint);
                if (cellEditor) {
                    cellEditor.beginEditing();
                }
            }
        }

        return cellEditor;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given column is fully visible.
     * @param {number} columnIndex - The column index in question.
     * @return {boolan} Visible.
     */
    isColumnVisible: function(columnIndex) {
        return this.getRenderer().isColumnVisible(columnIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given row is fully visible.
     * @param {number} rowIndex - The row index in question.
     * @return {boolan} Visible.
     */
    isDataRowVisible: function(rowIndex) {
        return this.getRenderer().isRowVisible(rowIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given cell is fully is visible.
     * @param {number} columnIndex - The column index in question.
     * @param {number} rowIndex - The row index in question.
     * @return {boolean} Data is visible.
     */
    isDataVisible: function(columnIndex, rowIndex) {
        return this.isDataRowVisible(rowIndex) && this.isColumnVisible(columnIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll in the `offsetX` direction if column index `colIndex` is not visible.
     * @param {number} colIndex - The column index in question.
     * @param {number} offsetX - The direction and magnitude to scroll if we need to.
     * @return {boolean} Column is visible.
     */
    insureModelColIsVisible: function(colIndex, offsetX) {
        var maxCols = this.getColumnCount() - 1, // -1 excludes partially visible columns
            indexToCheck = colIndex + (offsetX > 0),
            visible = !this.isColumnVisible(indexToCheck) || colIndex === maxCols;

        if (visible) {
            //the scroll position is the leftmost column
            this.scrollBy(offsetX, 0);
        }

        return visible;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll in the `offsetY` direction if column index c is not visible.
     * @param {number} rowIndex - The column index in question.
     * @param {number} offsetX - The direction and magnitude to scroll if we need to.
     * @return {boolean} Row is visible.
     */
    insureModelRowIsVisible: function(rowIndex, offsetY) {
        var maxRows = this.getRowCount() - 1, // -1 excludes partially visible rows
            indexToCheck = rowIndex + (offsetY > 0),
            visible = !this.isDataRowVisible(indexToCheck) || rowIndex === maxRows;

        if (visible) {
            //the scroll position is the topmost row
            this.scrollBy(0, offsetY);
        }

        return visible;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll horizontal and vertically by the provided offsets.
     * @param {number} offsetX - Scroll in the x direction this much.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollBy: function(offsetX, offsetY) {
        this.scrollHBy(offsetX);
        this.scrollVBy(offsetY);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll vertically by the provided offset.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollVBy: function(offsetY) {
        var max = this.sbVScroller.range.max;
        var oldValue = this.getVScrollValue();
        var newValue = Math.min(max, Math.max(0, oldValue + offsetY));
        if (newValue !== oldValue) {
            this.setVScrollValue(newValue);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll horizontally by the provided offset.
     * @param {number} offsetX - Scroll in the x direction this much.
     */
    scrollHBy: function(offsetX) {
        var max = this.sbHScroller.range.max;
        var oldValue = this.getHScrollValue();
        var newValue = Math.min(max, Math.max(0, oldValue + offsetX));
        if (newValue !== oldValue) {
            this.setHScrollValue(newValue);
        }
    },

    scrollToMakeVisible: function(c, r) {
        var leftColumn = this.renderer.getScrollLeft(),
            topRow = this.renderer.getScrollTop(),
            delta,
            numOfGridCtrlCols = 2, //TODO: Get rid of ALL magic and hardcoded numbers.
            numofGridCtrlRows = 3,
            adjustmentForPartiallyVisCols = -1;

        if (
            // target is off to left; negative delta scrolls left
            (delta = c - (leftColumn + this.renderer.getFixedColumnCount())) < 0 ||

            // target is off to right; positive delta scrolls right
            (delta = c - (leftColumn + this.getVisibleColumnsCount() - numOfGridCtrlCols + adjustmentForPartiallyVisCols)) > 0
        ) {
            this.sbHScroller.index += delta;
        }

        if (
            // target is above top; negative delta scrolls up
            (delta = r - (topRow + this.renderer.getFixedRowCount())) < 0 ||

            // target is below bottom; positive delta scrolls down
            (delta = r - (topRow + this.renderer.rowEdges.length - numofGridCtrlRows)) > 0
        ) {
            this.sbVScroller.index += delta;
        }
    },

    selectCellAndScrollToMakeVisible: function(c, r) {
        this.selectCell(c, r, true);
        this.scrollToMakeVisible(c, r);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Answer which data cell is under a pixel value mouse point.
     * @param {mousePoint} mouse - The mouse point to interrogate.
     */

    getGridCellFromMousePoint: function(mouse) {
        var cell = this.getRenderer().getGridCellFromMousePoint(mouse);
        return cell;
    },

    /**
     * @returns {Rectangle} The pixel based bounds rectangle given a data cell point.
     * @param {Point} cell - The pixel location of the mouse.
     * @memberOf Hypergrid.prototype
     */
    getBoundsOfCell: function(cell) {
        var b = this.getRenderer().getBoundsOfCell(cell);

        //we need to convert this to a proper rectangle
        var newBounds = new Rectangle(b.x, b.y, b.width, b.height);
        return newBounds;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc This is called by the fin-canvas when a resize occurs.
     */
    resized: function() {
        this.synchronizeScrollingBoundries();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A click event occured.
     * @desc Determine the cell and delegate to the behavior (model).
     * @param {MouseEvent} event - The mouse event to interrogate.
     */
    cellClicked: function(event) {
        var cell = event.gridCell;

        //click occurred in background area
        if (
            cell.x <= this.getColumnCount() &&
            cell.y <= this.getRowCount()
        ) {
            var hovered = this.getHoverCell(),
                x = hovered.x,
                y = hovered.y;

            // if (x >= 0) {
            //     x = behavior.translateColumnIndex(x + this.getHScrollValue());
            // }

            if (y >= 0) {
                y += this.getVScrollValue();
            }

            this.behavior.cellClicked(new Point(x, y), event);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @param {number} x - column index
     * @param {number} y - totals row index local to the totals area
     * @param value
     * @param {string[]} [areas=['top', 'bottom']] - may include `'top'` and/or `'bottom'`
     */
    setTotalsValueNotification: function(x, y, value, areas) {
        this.fireSyntheticSetTotalsValue(x, y, value, areas);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @param {number} x - column index
     * @param {number} y - totals row index local to the totals area
     * @param value
     * @param {string[]} [areas=['top', 'bottom']] - may include `'top'` and/or `'bottom'`
     */
    fireSyntheticSetTotalsValue: function(x, y, value, areas) {
        var clickEvent = new CustomEvent('fin-set-totals-value', {
            detail: {
                x: x,
                y: y,
                value: value,
                areas: areas
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyUpEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-keyup', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent,
                char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyDownEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-keydown', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent,
                char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyPressEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-keypress', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent,
                char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorDataChangeEvent: function(inputControl, oldValue, newValue) {
        var clickEvent = new CustomEvent('fin-editor-data-change', {
            detail: {
                input: inputControl,
                oldValue: oldValue,
                newValue: newValue
            },
            cancelable: true
        });
        return this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-row-selection-changed` event.
     */
    fireSyntheticRowSelectionChangedEvent: function() {
        var selectionEvent = new CustomEvent('fin-row-selection-changed', {
            detail: {
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections(),
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },

    fireSyntheticColumnSelectionChangedEvent: function() {
        var selectionEvent = new CustomEvent('fin-column-selection-changed', {
            detail: {
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections()
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and dispatch a `fin-selection-changed` event.
     */
    selectionChanged: function() {
        var selectedRows = this.getSelectedRows();
        var selectionEvent = new CustomEvent('fin-selection-changed', {
            detail: {
                rows: selectedRows,
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections(),
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },


    getRowSelection: function(includeHiddenColumns) {
        var c, column, columnValues, getColumn,
            selectedRowIndexes = this.selectionModel.getSelectedRows(),
            numColumns = this.getColumnCount(),
            result = {};

        if (includeHiddenColumns) {
            numColumns += this.getHiddenColumns().length;
            getColumn = this.behavior.getColumn;
        } else {
            getColumn = this.behavior.getActiveColumn;
        }
        getColumn = getColumn.bind(this.behavior);

        for (c = 0; c < numColumns; c++) {
            column = getColumn(c);
            columnValues = new Array(selectedRowIndexes.length);
            selectedRowIndexes.forEach(setColumnValue);
            result[column.name] = columnValues;
        }

        function setColumnValue(selectedRowIndex, j) {
            columnValues[j] = valOrFunc(column.getValue(selectedRowIndex));
        }

        return result;
    },

    getHiddenColumns: function(){
        //A non in-memory behavior will be more troublesome
      return this.behavior.getHiddenColumns();
    },

    getRowSelectionMatrix: function() {
        var c, self = this,
            selectedRowIndexes = this.selectionModel.getSelectedRows(),
            numCols = this.getColumnCount(),
            result = new Array(numCols);

        function getValue(selectedRowIndex, r) {
            result[c][r] = valOrFunc(self.getValue(c, selectedRowIndex));
        }

        for (c = 0; c < numCols; c++) {
            result[c] = new Array(selectedRowIndexes.length);
            selectedRowIndexes.forEach(getValue);
        }

        return result;
    },

    getColumnSelectionMatrix: function() {
        var selectedColumnIndexes = this.getSelectedColumns();
        var numRows = this.getRowCount();
        var result = new Array(selectedColumnIndexes.length);
        var self = this;
        selectedColumnIndexes.forEach(function(selectedColumnIndex, c) {
            result[c] = new Array(numRows);
            for (var r = 0; r < numRows; r++) {
                result[c][r] = valOrFunc(self.getValue(selectedColumnIndex, r));
            }
        });
        return result;
    },

    getColumnSelection: function() {
        var selectedColumnIndexes = this.getSelectedColumns();
        var result = {};
        var rowCount = this.getRowCount();
        var self = this;
        selectedColumnIndexes.forEach(function(selectedColumnIndex) {
            var column = new Array(rowCount);
            result[self.behavior.getActiveColumn(selectedColumnIndex).name] = column;
            for (var r = 0; r < rowCount; r++) {
                column[r] = valOrFunc(self.getValue(selectedColumnIndex, r));
            }
        });
        return result;
    },

    getSelection: function() {
        var self = this;
        var selections = this.getSelections();
        var result = new Array(selections.length);
        selections.forEach(function(selectionRect, i) {
            result[i] = self._getSelection(selectionRect);
        });
        return result;
    },

    _getSelection: function(rect) {
        rect = normalizeRect(rect);
        var colCount = rect.extent.x + 1;
        var rowCount = rect.extent.y + 1;
        var ox = rect.origin.x;
        var oy = rect.origin.y;
        var result = {};
        var r;
        for (var c = 0; c < colCount; c++) {
            var column = new Array(rowCount);
            result[this.behavior.getActiveColumn(c + ox).name] = column;
            for (r = 0; r < rowCount; r++) {
                column[r] = valOrFunc(this.getValue(ox + c, oy + r));
            }
        }
        return result;
    },

    getSelectionMatrix: function() {
        var self = this;
        var selections = this.getSelections();
        var result = new Array(selections.length);
        selections.forEach(function(selectionRect, i) {
            result[i] = self._getSelectionMatrix(selectionRect);
        });
        return result;
    },

    _getSelectionMatrix: function(rect) {
        rect = normalizeRect(rect);
        var colCount = rect.extent.x + 1;
        var rowCount = rect.extent.y + 1;
        var ox = rect.origin.x;
        var oy = rect.origin.y;
        var result = [];
        for (var c = 0; c < colCount; c++) {
            var column = new Array(rowCount);
            result[c] = column;
            for (var r = 0; r < rowCount; r++) {
                column[r] = valOrFunc(this.getValue(ox + c, oy + r));
            }
        }
        return result;
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-context-menu` event
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticContextMenuEvent: function(e) {
        e.gridCell = this.convertViewPointToDataPoint(e.gridCell);
        var event = new CustomEvent('fin-context-menu', {
            detail: {
                gridCell: e.gridCell,
                mousePoint: e.mousePoint,
                viewPoint: e.viewPoint,
                primitiveEvent: e.primitiveEvent,
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections()
            }
        });
        this.canvas.dispatchEvent(event);
    },

    fireSyntheticMouseUpEvent: function(e) {
        var event = new CustomEvent('fin-mouseup', {
            detail: {
                gridCell: e.gridCell,
                mousePoint: e.mousePoint,
                viewPoint: e.viewPoint,
                primitiveEvent: e.primitiveEvent,
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections()
            }
        });
        this.canvas.dispatchEvent(event);
    },

    fireSyntheticMouseDownEvent: function(e) {
        this.stopEditing();
        var event = new CustomEvent('fin-mousedown', {
            detail: {
                gridCell: e.gridCell,
                mousePoint: e.mousePoint,
                viewPoint: e.viewPoint,
                primitiveEvent: e.primitiveEvent,
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections()
            }
        });
        this.canvas.dispatchEvent(event);
    },

    isViewableButton: function(c, r) {
        return this.getRenderer().isViewableButton(c, r);
    },

    fireSyntheticButtonPressedEvent: function(evt) {
        var dataCell = evt.dataCell;
        var gridCell = evt.gridCell;
        if (this.isViewableButton(dataCell.x, dataCell.y)) {
            var event = new CustomEvent('fin-button-pressed', {
                detail: {
                    gridCell: gridCell
                }
            });
            this.canvas.dispatchEvent(event);
        }
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-column-drag-start` event.
     */
    fireSyntheticOnColumnsChangedEvent: function() {
        var detail = {
            time: Date.now(),
            grid: this
        };
        var cEvent = new CustomEvent('fin-column-changed-event', {
            detail: detail
        });
        console.log('column changed');
        this.canvas.dispatchEvent(cEvent);
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-keydown` event.
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticKeydownEvent: function(keyEvent) {
        var clickEvent = new CustomEvent('fin-keydown', {
            detail: keyEvent.detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-keyup` event.
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticKeyupEvent: function(keyEvent) {
        var clickEvent = new CustomEvent('fin-keyup', {
            detail: keyEvent.detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticFilterAppliedEvent: function() {
        var filterEvent = new CustomEvent('fin-filter-applied');
        this.canvas.dispatchEvent(filterEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-enter` event
     * @param {Point} cell - The pixel location of the cell in which the click event occurred.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticOnCellEnterEvent: function(cell) {
        var detail = {
            gridCell: cell,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-cell-enter', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticGroupsChangedEvent: function(groups) {
        var detail = {
            groups: groups,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-groups-changed', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-exit` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticOnCellExitEvent: function(cell) {
        var detail = {
            gridCell: cell,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-cell-exit', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-click` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticClickEvent: function(mouseEvent) {
        var cell = mouseEvent.gridCell;
        var detail = {
            gridCell: cell,
            mousePoint: mouseEvent.mousePoint,
            keys: mouseEvent.keys,
            primitiveEvent: mouseEvent,
            time: Date.now(),
            grid: this
        };
        this.behavior.enhanceDoubleClickEvent(detail);
        var clickEvent = new CustomEvent('fin-click', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-double-click` event.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticDoubleClickEvent: function(mouseEvent) {
        this.stopEditing();
        var cell = mouseEvent.gridCell;
        var detail = {
            gridCell: cell,
            mousePoint: mouseEvent.mousePoint,
            time: Date.now(),
            grid: this
        };
        this.behavior.enhanceDoubleClickEvent(mouseEvent);
        var clickEvent = new CustomEvent('fin-double-click', {
            detail: detail
        });
        this.behavior.cellDoubleClicked(cell, mouseEvent);
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a rendered event.
     */
    fireSyntheticGridRenderedEvent: function() {
        var event = new CustomEvent('fin-grid-rendered', {
            detail: {
                source: this,
                time: Date.now()
            }
        });
        if (this.canvas) {
            this.canvas.dispatchEvent(event);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a scroll event.
     * @param {string} type - Should be either `fin-scroll-x` or `fin-scroll-y`.
     * @param {number} oldValue - The old scroll value.
     * @param {number} newValue - The new scroll value.
     */
    fireScrollEvent: function(type, oldValue, newValue) {
        var event = new CustomEvent(type, {
            detail: {
                oldValue: oldValue,
                value: newValue,
                time: Date.now()
            }
        });
        this.canvas.dispatchEvent(event);

    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the vertical scroll value.
     * @param {number} newValue - The new scroll value.
     */
    setVScrollValue: function(y) {
        var self = this;
        y = Math.min(this.sbVScroller.range.max, Math.max(0, Math.round(y)));
        if (y !== this.vScrollValue) {
            this.behavior._setScrollPositionY(y);
            var oldY = this.vScrollValue;
            this.vScrollValue = y;
            this.scrollValueChangedNotification();
            setTimeout(function() {
                // self.sbVRangeAdapter.subjectChanged();
                self.fireScrollEvent('fin-scroll-y', oldY, y);
            });
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @return {number} The vertical scroll value.
     */
    getVScrollValue: function() {
        return this.vScrollValue;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the horizontal scroll value.
     * @param {number} newValue - The new scroll value.
     */
    setHScrollValue: function(x) {
        var self = this;
        x = Math.min(this.sbHScroller.range.max, Math.max(0, Math.round(x)));
        if (x !== this.hScrollValue) {
            this.behavior._setScrollPositionX(x);
            var oldX = this.hScrollValue;
            this.hScrollValue = x;
            this.scrollValueChangedNotification();
            setTimeout(function() {
                //self.sbHRangeAdapter.subjectChanged();
                self.fireScrollEvent('fin-scroll-x', oldX, x);
                //self.synchronizeScrollingBoundries(); // todo: Commented off to prevent the grid from bouncing back, but there may be repurcussions...
            });
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns The vertical scroll value.
     */
    getHScrollValue: function() {
        return this.hScrollValue;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Request input focus.
     */
    takeFocus: function() {
        if (!this.stopEditing()) {
            this.getCanvas().takeFocus();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Request focus for our cell editor.
     */
    editorTakeFocus: function() {
        if (this.cellEditor) {
            return this.cellEditor.takeFocus();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Initialize the scroll bars.
     */
    initScrollbars: function() {

        var self = this;

        var horzBar = new FinBar({
            orientation: 'horizontal',
            onchange: self.setHScrollValue.bind(self),
            cssStylesheetReferenceElement: this.div
        });

        var vertBar = new FinBar({
            orientation: 'vertical',
            onchange: self.setVScrollValue.bind(self),
            paging: {
                up: self.pageUp.bind(self),
                down: self.pageDown.bind(self)
            }
        });

        this.sbHScroller = horzBar;
        this.sbVScroller = vertBar;

        var hPrefix = this.resolveProperty('hScrollbarClassPrefix');
        var vPrefix = this.resolveProperty('vScrollbarClassPrefix');

        if (hPrefix && hPrefix !== '') {
            this.sbHScroller.classPrefix = hPrefix;
        }

        if (vPrefix && vPrefix !== '') {
            this.sbVScroller.classPrefix = vPrefix;
        }

        this.div.appendChild(horzBar.bar);
        this.div.appendChild(vertBar.bar);

        this.resizeScrollbars();

    },

    resizeScrollbars: function() {
        this.sbHScroller.shortenBy(this.sbVScroller).resize();
        //this.sbVScroller.shortenBy(this.sbHScroller);
        this.sbVScroller.resize();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll values have changed, we've been notified.
     */
    setVScrollbarValues: function(max) {
        this.sbVScroller.range = {
            min: 0,
            max: max
        };
    },

    setHScrollbarValues: function(max) {
        this.sbHScroller.range = {
            min: 0,
            max: max
        };
    },

    scrollValueChangedNotification: function() {

        if (this.hScrollValue === this.sbPrevHScrollValue && this.vScrollValue === this.sbPrevVScrollValue) {
            return;
        }

        this.sbPrevHScrollValue = this.hScrollValue;
        this.sbPrevVScrollValue = this.vScrollValue;

        if (this.cellEditor) {
            this.cellEditor.scrollValueChangedNotification();
        }

        this.computeCellsBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Get data value at given cell.
     * @desc Delegates to the behavior.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     * @param {*} value
     */
    getValue: function(x, y) {
        return this.behavior.getValue(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set a data value into the behavior (model) at the given point
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     */
    setValue: function(x, y, value) {
        this.behavior.setValue(x, y, value);
    },

    getColumnAlignment: function(c) {
        return this.behavior.getColumnAlignment(c);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The data dimensions have changed, or our pixel boundries have changed.
     * Adjust the scrollbar properties as necessary.
     */
    synchronizeScrollingBoundries: function() {
        var numFixedColumns = this.getFixedColumnCount();
        var numFixedRows = this.getFixedRowCount();

        var numColumns = this.getColumnCount();
        var numRows = this.getRowCount();

        var bounds = this.getBounds();
        if (!bounds) {
            return;
        }
        var scrollableHeight = bounds.height - this.behavior.getFixedRowsMaxHeight() - 15; //5px padding at bottom and right side
        var scrollableWidth = (bounds.width - 200) - this.behavior.getFixedColumnsMaxWidth() - 15;

        var lastPageColumnCount = 0;
        var columnsWidth = 0;
        for (; lastPageColumnCount < numColumns; lastPageColumnCount++) {
            var eachWidth = this.getColumnWidth(numColumns - lastPageColumnCount - 1);
            columnsWidth += eachWidth;
            if (columnsWidth > scrollableWidth) {
                break;
            }
        }

        var lastPageRowCount = 0;
        var rowsHeight = 0;
        for (; lastPageRowCount < numRows; lastPageRowCount++) {
            var eachHeight = this.getRowHeight(numRows - lastPageRowCount - 1);
            rowsHeight += eachHeight;
            if (rowsHeight > scrollableHeight) {
                break;
            }
        }

        var hMax = Math.max(0, numColumns - numFixedColumns - lastPageColumnCount);
        this.setHScrollbarValues(hMax);

        var vMax = 1 + Math.max(0, numRows - numFixedRows - lastPageRowCount);
        this.setVScrollbarValues(vMax);

        this.setHScrollValue(Math.min(this.getHScrollValue(), hMax));
        this.setVScrollValue(Math.min(this.getVScrollValue(), vMax));

        //this.getCanvas().resize();
        this.computeCellsBounds();
        this.repaint();

        this.resizeScrollbars();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Note that "viewable rows" includes any partially viewable rows.
     * @returns {number} The number of viewable rows.
     */
    getVisibleRows: function() {
        return this.getRenderer().getVisibleRows();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Note that "viewable columns" includes any partially viewable columns.
     * @returns {number} The number of viewable columns.
     */
    getVisibleColumns: function() {
        return this.getRenderer().getVisibleColumns();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Initialize the renderer sub-component.
     */
    initRenderer: function() {
        this.renderer = new Renderer(this);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Renderer} sub-component
     */
    getRenderer: function() {
        return this.renderer;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The width of the given column.
     * @param {number} columnIndex - The untranslated column index.
     */
    getColumnWidth: function(columnIndex) {
        return this.behavior.getColumnWidth(columnIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the width of the given column.
     * @param {number} columnIndex - The untranslated column index.
     * @param {number} columnWidth - The width in pixels.
     */
    setColumnWidth: function(columnIndex, columnWidth) {
        this.stopEditing();
        this.behavior.setColumnWidth(columnIndex, columnWidth);
    },

    getColumnEdge: function(c) {
        return this.behavior.getColumnEdge(c, this.getRenderer());
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The total width of all the fixed columns.
     */
    getFixedColumnsWidth: function() {
        return this.behavior.getFixedColumnsWidth();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The height of the given row
     * @param {number} rowIndex - The untranslated fixed column index.
     */
    getRowHeight: function(rowIndex) {
        return this.behavior.getRowHeight(rowIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the height of the given row.
     * @param {number} rowIndex - The row index.
     * @param {number} rowHeight - The width in pixels.
     */
    setRowHeight: function(rowIndex, rowHeight) {
        this.stopEditing();
        this.behavior.setRowHeight(rowIndex, rowHeight);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The total fixed rows height
     */
    getFixedRowsHeight: function() {
        return this.behavior.getFixedRowsHeight();
    },

    /**
     * Number of _visible_ columns.
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of columns.
     */
    getColumnCount: function() {
        return this.behavior.getActiveColumnCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of fixed rows.
     */
    getRowCount: function() {
        return this.behavior.getRowCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of unfiltered rows.
     */
    getUnfilteredRowCount: function() {
        return this.behavior.getUnfilteredRowCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.behavior.getFixedColumnCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns The number of fixed rows.
     */
    getFixedRowCount: function() {
        return this.behavior.getFixedRowCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary The top left area has been clicked on
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    topLeftClicked: function(mouse) {
        this.behavior.topLeftClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A fixed row has been clicked.
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    rowHeaderClicked: function(mouse) {
        this.behavior.rowHeaderClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A fixed column has been clicked.
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    columnHeaderClicked: function(mouse) {
        this.behavior.columnHeaderClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc An edit event has occurred. Activate the editor at the given coordinates.
     * @param {number} event.gridCell.x - The horizontal coordinate.
     * @param {number} event.gridCell.y - The vertical coordinate.
     * @param {boolean} [event.primitiveEvent.type]
     * @returns {undefined|CellEditor} The editor object or `undefined` if no editor or editor already open.
     */
    onEditorActivate: function(event) {
        var point = event.gridCell;
        return this.editAt(point);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Get the cell editor.
     * @desc Delegates to the behavior.
     * @returns The cell editor at the given coordinates.
     * @param {Point} editPoint - The grid cell coordinates.
     */
    getCellEditorAt: function(editPoint) {
        return this.behavior.getCellEditorAt(editPoint);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Toggle HiDPI support.
     * @desc HiDPI support is now *on* by default.
     * > There used to be a bug in Chrome that caused severe slow down on bit blit of large images, so this HiDPI needed to be optional.
     */
    toggleHiDPI: function() {
        if (this.useHiDPI()) {
            this.removeAttribute('hidpi');
        } else {
            this.setAttribute('hidpi', null);
        }
        this.canvas.resize();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} Te HiDPI ratio.
     */
    getHiDPI: function(ctx) {
        if (window.devicePixelRatio && this.useHiDPI()) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
                ctx.mozBackingStorePixelRatio ||
                ctx.msBackingStorePixelRatio ||
                ctx.oBackingStorePixelRatio ||
                ctx.backingStorePixelRatio || 1;

            var ratio = devicePixelRatio / backingStoreRatio;
            return ratio;
        } else {
            return 1;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The width of the given (recently rendered) column.
     * @param {number} colIndex - The column index.
     */
    getRenderedWidth: function(colIndex) {
        return this.renderer.getRenderedWidth(colIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The height of the given (recently rendered) row.
     * @param {number} rowIndex - Tthe row index.
     */
    getRenderedHeight: function(rowIndex) {
        return this.renderer.getRenderedHeight(rowIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Update the cursor under the hover cell.
     */
    updateCursor: function() {
        var cursor = this.behavior.getCursorAt(-1, -1);
        var hoverCell = this.getHoverCell();
        if (
            hoverCell &&
            hoverCell.x > -1 &&
            hoverCell.y > -1
        ) {
            var x = hoverCell.x + this.getHScrollValue();
            cursor = this.behavior.getCursorAt(x, hoverCell.y + this.getVScrollValue());
        }
        this.beCursor(cursor);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Repaint the given cell.
     * @param {x} x - The horizontal coordinate.
     * @param {y} y - The vertical coordinate.
     */
    repaintCell: function(x, y) {
        this.getRenderer().repaintCell(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The user is currently dragging a column to reorder it.
     */
    isDraggingColumn: function() {
        return !!this.renderOverridesCache.dragger;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll up one full page.
     * @returns {number}
     */
    pageUp: function() {
        var rowNum = this.getRenderer().getPageUpRow();
        this.setVScrollValue(rowNum);
        return rowNum;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll down one full page.
     * @returns {number}
     */
    pageDown: function() {
        var rowNum = this.getRenderer().getPageDownRow();
        this.setVScrollValue(rowNum);
        return rowNum;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Not yet implemented.
     */
    pageLeft: function() {
        console.log('page left');
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Not yet implemented.
     */
    pageRight: function() {
        console.log('page right');
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object[]} Objects with the values that were just rendered.
     */
    getRenderedData: function() {
        // assumes one row of headers
        var behavior = this.behavior,
            renderer = this.getRenderer(),
            colCount = this.getColumnCount(),
            rowCount = renderer.getVisibleRows(),
            headers = new Array(colCount),
            results = new Array(rowCount),
            row;

        headers.forEach(function(header, c) {
            headers[c] = behavior.getActiveColumn(c).header;
        });

        results.forEach(function(result, r) {
            row = results[r] = {
                hierarchy: behavior.getFixedColumnValue(0, r)
            };
            headers.forEach(function(field, c) {
                row[field] = behavior.getValue(c, r);
            });
        });

        return results;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} An object that represents the currently selection row.
     */
    getSelectedRow: function() {
        var sels = this.selectionModel.getSelections();
        if (sels.length) {
            var behavior = this.behavior,
                colCount = this.getColumnCount(),
                topRow = sels[0].origin.y,
                row = {
                    //hierarchy: behavior.getFixedColumnValue(0, topRow)
                };

            for (var c = 0; c < colCount; c++) {
                row[behavior.getActiveColumn(c).header] = behavior.getValue(c, topRow);
            }

            return row;
        }
    },

    fireRequestCellEdit: function(cell, value) {
        var clickEvent = new CustomEvent('fin-request-cell-edit', {
            cancelable: true,
            detail: {
                value: value,
                gridCell: cell,
                time: Date.now()
            }
        });
        return this.canvas.dispatchEvent(clickEvent); //I wasn't cancelled
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a fin-before-cell-edit event.
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} value - The current value.
     */
    fireBeforeCellEdit: function(cell, oldValue, newValue, control) {
        var clickEvent = new CustomEvent('fin-before-cell-edit', {
            cancelable: true,
            detail: {
                oldValue: oldValue,
                newValue: newValue,
                gridCell: cell,
                time: Date.now(),
                input: control,
                row: this.getRow(cell.y)
            }
        });
        var proceed = this.canvas.dispatchEvent(clickEvent);
        return proceed; //I wasn't cancelled
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Renderer} sub-component
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} oldValue - The old value.
     * @param {Object} newValue - The new value.
     */
    fireAfterCellEdit: function(cell, oldValue, newValue, control) {
        var clickEvent = new CustomEvent('fin-after-cell-edit', {
            detail: {
                newValue: newValue,
                oldValue: oldValue,
                gridCell: cell,
                time: Date.now(),
                input: control,
                row: this.getRow(cell.y)
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Autosize the column at colIndex for best fit.
     * @param {number} colIndex - The column index to modify at
     */
    autosizeColumn: function(activeColumnIndex) {
        var column = this.behavior.getActiveColumn(activeColumnIndex);
        column.checkColumnAutosizing(true);
        this.computeCellsBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Enable/disable if this component can receive the focus.
     * @param {boolean} - canReceiveFocus
     */
    setFocusable: function(canReceiveFocus) {
        this.getCanvas().setFocusable(canReceiveFocus);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of columns that were just rendered
     */
    getVisibleColumnsCount: function() {
        return this.getRenderer().getVisibleColumnsCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of rows that were just rendered
     */
    getVisibleRowsCount: function() {
        return this.getRenderer().getVisibleRowsCount();
    },

    /**
     * @memberOf Hypergrid.prototype
    update the size of the grid
     *
     * #### returns: integer
     */
    updateSize: function() {
        this.canvas.checksize();
    },


    /**
     * @memberOf Hypergrid.prototype
     * @desc Stop the global repainting flag thread.
     */
    stopPaintThread: function() {
        this.canvas.stopPaintThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Stop the global resize check flag thread.
     */
    stopResizeThread: function() {
        this.canvas.stopResizeThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Restart the global resize check flag thread.
     */
    restartResizeThread: function() {
        this.canvas.restartResizeThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Restart the global repainting check flag thread.
     */
    restartPaintThread: function() {
        this.canvas.restartPaintThread();
    },

    swapColumns: function(source, target) {
        //Turns out this is called during dragged 'i.e' when the floater column is reshuffled
        //by the currently dragged column. The column positions are constantly reshuffled
        this.behavior.swapColumns(source, target);
    },

    endDragColumnNotification: function() {
        this.behavior.endDragColumnNotification();
    },

    getFixedColumnsMaxWidth: function() {
        return this.behavior.getFixedColumnsMaxWidth();
    },

    isMouseDownInHeaderArea: function() {
        var numHeaderColumns = this.getHeaderColumnCount();
        var numHeaderRows = this.getHeaderRowCount();
        var mouseDown = this.getMouseDown();
        return mouseDown.x < numHeaderColumns || mouseDown.y < numHeaderRows;
    },

    isHeaderWrapping: function() {
        return this.resolveProperty('headerTextWrapping');
    },

    _getBoundsOfCell: function(x, y) {
        return this.getRenderer()._getBoundsOfCell(x, y);
    },

    getColumnProperties: function(columnIndex) {
        return this.behavior.getColumnProperties(columnIndex);
    },

    setColumnProperties: function(columnIndex, properties) {
        this.behavior.setColumnProperties(columnIndex, properties);
    },

    moveSingleSelect: function(x, y) {
        this.behavior.moveSingleSelect(this, x, y);
    },

    selectCell: function(x, y, silent) {
        var dontClearRows = this.isCheckboxOnlyRowSelections();
        this.selectionModel.clear(dontClearRows);
        this.selectionModel.select(x, y, 0, 0, silent);
    },

    getHeaderColumnCount: function() {
        return this.behavior.getHeaderColumnCount();
    },

    toggleSort: function(x, keys) {
        this.stopEditing();
        var behavior = this.behavior;
        var self = this;
        behavior.toggleSort(x, keys);

        setTimeout(function() {
            self.synchronizeScrollingBoundries();
            //self.behaviorChanged();
            if (self.isColumnAutosizing()) {
                behavior.autosizeAllColumns();
            }
            self.repaint();
        }, 10);
    },

    toggleSelectColumn: function(x, keys) {
        keys = keys || [];
        var model = this.selectionModel;
        var alreadySelected = model.isColumnSelected(x);
        var hasCTRL = keys.indexOf('CTRL') > -1;
        var hasSHIFT = keys.indexOf('SHIFT') > -1;
        if (!hasCTRL && !hasSHIFT) {
            model.clear();
            if (!alreadySelected) {
                model.selectColumn(x);
            }
        } else {
            if (hasCTRL) {
                if (alreadySelected) {
                    model.deselectColumn(x);
                } else {
                    model.selectColumn(x);
                }
            }
            if (hasSHIFT) {
                model.clear();
                model.selectColumn(this.lastEdgeSelection[0], x);
            }
        }
        if (!alreadySelected && !hasSHIFT) {
            this.lastEdgeSelection[0] = x;
        }
        this.repaint();
        this.fireSyntheticColumnSelectionChangedEvent();
    },

    toggleSelectRow: function(y, keys) {
        //we can select the totals rows if they exist, but not rows above that
        if (y > this.getFilterRowIndex()) {
            keys = keys || [];

            var sm = this.selectionModel;
            var alreadySelected = sm.isRowSelected(y);
            var hasSHIFT = keys.indexOf('SHIFT') >= 0;

            if (alreadySelected) {
                sm.deselectRow(y);
            } else {
                this.singleSelect();
                sm.selectRow(y);
            }

            if (hasSHIFT) {
                sm.clear();
                sm.selectRow(this.lastEdgeSelection[1], y);
            }

            if (!alreadySelected && !hasSHIFT) {
                this.lastEdgeSelection[1] = y;
            }
            this.repaint();
        }
    },

    singleSelect: function() {
        var isCheckboxOnlyRowSelections = this.isCheckboxOnlyRowSelections(),
            isSingleRowSelectionMode = this.isSingleRowSelectionMode(),
            hasCTRL = false,
            result;

        if (this.mouseDownState){
            //triggered programmatically
            hasCTRL = this.mouseDownState.primitiveEvent.detail.primitiveEvent.ctrlKey;
        }

        result = (
            isCheckboxOnlyRowSelections && isSingleRowSelectionMode ||
            !isCheckboxOnlyRowSelections && (!hasCTRL || isSingleRowSelectionMode)
        );

        if (result) {
            this.selectionModel.clearRowSelection();
        }

        return result;
    },

    selectViewportCell: function(x, y) {
        var headerRowCount = this.getHeaderRowCount();
        var renderer = this.getRenderer();
        var realX = renderer.getVisibleColumns()[x];
        var realY = renderer.getVisibleRows()[y];
        this.clearSelections();
        this.select(realX, realY + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(realX, realY + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToViewportCell: function(x, y) {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var headerRowCount = this.getHeaderRowCount();
            var renderer = this.getRenderer();
            var realX = renderer.getVisibleColumns()[x];
            var realY = renderer.getVisibleRows()[y] + headerRowCount;
            var selection = selections[0];
            var origin = selection.origin;
            this.setDragExtent(this.newPoint(realX - origin.x, realY - origin.y));
            this.select(origin.x, origin.y, realX - origin.x, realY - origin.y);
            this.repaint();
        }
    },

    selectFinalCellOfCurrentRow: function() {
        var x = this.getColumnCount() - 1;
        var y = this.getSelectedRows()[0];
        var headerRowCount = this.getHeaderRowCount();
        this.clearSelections();
        this.scrollBy(this.getColumnCount(), 0);
        this.select(x, y + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(x, y + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToFinalCellOfCurrentRow: function() {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0];
            var origin = selection.origin;
            var extent = selection.extent;
            var columnCount = this.getColumnCount();
            this.scrollBy(columnCount, 0);

            this.clearSelections();
            this.select(origin.x, origin.y, columnCount - origin.x - 1, extent.y);

            this.repaint();
        }
    },

    selectFirstCellOfCurrentRow: function() {
        var x = 0;
        var y = this.getSelectedRows()[0];
        var headerRowCount = this.getHeaderRowCount();
        this.clearSelections();
        this.setHScrollValue(0);
        this.select(x, y + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(x, y + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToFirstCellOfCurrentRow: function() {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0];
            var origin = selection.origin;
            var extent = selection.extent;
            this.clearSelections();
            this.select(origin.x, origin.y, -origin.x, extent.y);
            this.setHScrollValue(0);
            this.repaint();
        }
    },

    selectFinalCell: function() {
        this.selectCell(this.getColumnCount() - 1, this.getRowCount() - 1);
        this.scrollBy(this.getColumnCount(), this.getRowCount());
        this.repaint();
    },

    selectToFinalCell: function() {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0];
            var origin = selection.origin;
            var columnCount = this.getColumnCount();
            var rowCount = this.getRowCount();

            this.clearSelections();
            this.select(origin.x, origin.y, columnCount - origin.x - 1, rowCount - origin.y - 1);
            this.scrollBy(columnCount, rowCount);
            this.repaint();
        }
    },

    isShowRowNumbers: function() {
        return this.resolveProperty('showRowNumbers');
    },
    isEditable: function() {
        return this.resolveProperty('editable') === true;
    },
    isShowFilterRow: function() {
        return this.resolveProperty('showFilterRow');
    },
    isShowHeaderRow: function() {
        return this.resolveProperty('showHeaderRow');
    },
    getHeaderRowCount: function() {
        return this.behavior.getHeaderRowCount();
    },
    isFilterRow: function(y) {
        return y === this.getFilterRowIndex();
    },
    getFilterRowIndex: function() {
        return !this.isShowFilterRow() ? -1 : this.isShowHeaderRow() ? 1 : 0;
    },
    setGroups: function(arrayOfColumnIndexes) {
        this.behavior.setGroups(arrayOfColumnIndexes);
    },
    hasHierarchyColumn: function() {
        return this.behavior.hasHierarchyColumn();
    },
    isHierarchyColumn: function(x) {
        return this.hasHierarchyColumn() && x === 0;
    },
    checkScrollbarVisibility: function() {
        // var hoverClassOver = this.resolveProperty('scrollbarHoverOver');
        // var hoverClassOff = this.resolveProperty('scrollbarHoverOff');

        // if (hoverClassOff === 'visible') {
        //     this.sbHScroller.classList.remove(hoverClassOver);
        //     this.sbVScroller.classList.remove(hoverClassOff);
        //     this.sbHScroller.classList.add('visible');
        //     this.sbVScroller.classList.add('visible');
        // }
    },
    isColumnOrRowSelected: function() {
        return this.selectionModel.isColumnOrRowSelected();
    },
    selectColumn: function(x1, x2) {
        this.selectionModel.selectColumn(x1, x2);
    },
    selectRow: function(y1, y2) {
        var sm = this.selectionModel;
        var selectionEdge = this.getFilterRowIndex() + 1;

        if (this.singleSelect()) {
            y1 = y2;
        } else {
            // multiple row selection
            y2 = y2 || y1;
        }
        var min = Math.min(y1, y2);
        if (min >= selectionEdge) {
            var max = Math.max(y1, y2);
            sm.selectRow(min, max);
        }
    },
    isRowNumberAutosizing: function() {
        return this.resolveProperty('rowNumberAutosizing');
    },
    isRowSelected: function(r) {
        return this.selectionModel.isRowSelected(r);
    },
    isColumnSelected: function(c) {
        return this.selectionModel.isColumnSelected(c);
    },
    lookupFeature: function(key) {
        return this.behavior.lookupFeature(key);
    },
    getRow: function(y) {
        return this.behavior.getRow(y);
    },
    isCellSelection: function() {
        return this.resolveProperty('cellSelection') === true;
    },
    isRowSelection: function() {
        return this.resolveProperty('rowSelection') === true;
    },
    isColumnSelection: function() {
        return this.resolveProperty('columnSelection') === true;
    },
    getComputedRow: function(y) {
        return this.behavior.getComputedRow(y);
    },
    isColumnAutosizing: function() {
        return this.resolveProperty('columnAutosizing') === true;
    },

    /**
     * @summary Get a reference to the filter attached to the Hypergrid.
     * @returns {FilterTree}
     * @memberOf Hypergrid.prototype
     */
    getGlobalFilter: function() {
        return this.behavior.getGlobalFilter();
    },

    /**
     * @summary Attach/detach a filter to a Hypergrid.
     * @param {FilterTree} [filter] - The filter object. If undefined, any attached filter is removed.
     * @memberOf Hypergrid.prototype
     */
    setGlobalFilter: function(filter) {
        this.behavior.setGlobalFilter(filter);
        this.behaviorChanged();
    },

    /**
     * @summary Set the case sensitivity of filter tests against data.
     * @desc Case sensitivity pertains to string compares only. This includes untyped columns, columns typed as strings, typed columns containing data that cannot be coerced to type or when the filter expression operand cannot be coerced.
     *
     * NOTE: This is a shared property and affects all grid managed by this instance of the app.
     * @param {boolean} isSensitive
     * @memberOf Hypergrid.prototype
     */
    setGlobalFilterCaseSensitivity: function(isSensitive) {
        // this setting affects all grids
        this.behavior.setGlobalFilterCaseSensitivity(isSensitive);
        this.computeCellsBounds();
        this.behaviorChanged();
    },

    /**
     * @param {number|string} columnIndexOrName - The _column filter_ to set.
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @param {boolean} [options.syntax='CQL'] - The syntax to use to describe the filter state. Note that `getFilter`'s default syntax, `'CQL'`, differs from the other get state methods.
     * @returns {FilterTreeStateObject}
     * @memberOf Hypergrid.prototype
     */
    getFilter: function(columnIndexOrName, options) {
        return this.behavior.getFilter(columnIndexOrName, options);
    },

    /**
     * @summary Set a particular column filter's state.
     * @desc After setting the new filter state:
     * * Reapplies the filter to the data source.
     * * Calls `behaviorChanged()` to update the grid canvas.
     * @param {number|string} columnIndexOrName - The _column filter_ to set.
     * @param {string|object} [state] - A filter tree object or a JSON, SQL, or CQL subexpression string that describes the a new state for the named column filter. The existing column filter subexpression is replaced with a new node based on this state. If it does not exist, the new subexpression is added to the column filters subtree (`filter.columnFilters`).
     *
     * If undefined, removes the entire column filter subexpression from the column filters subtree.
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @param {string} [options.syntax='CQL'] - The syntax to use to describe the filter state. Note that `setFilter`'s default syntax, `'CQL'`, differs from the other get state methods.
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf Hypergrid.prototype
     */
    setFilter: function(columnIndexOrName, state, options) {
        if (this.cellEditor) {
            this.cellEditor.hideEditor();
        }
        this.behavior.setFilter(columnIndexOrName, state, options);
        this.behaviorChanged();
    },

    /**
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @returns {FilterTreeStateObject}
     * @memberOf Hypergrid.prototype
     */
    getFilters: function(options) {
        return this.behavior.getFilters(options);
    },

    /**
     * @param {FilterTreeStateObject} state
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf Hypergrid.prototype
     */
    setFilters: function(state, options) {
        if (this.cellEditor) {
            this.cellEditor.hideEditor();
        }
        this.behavior.setFilters(state, options);
        this.behaviorChanged();
    },

    /**
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @returns {FilterTreeStateObject}
     * @memberOf Hypergrid.prototype
     */
    getTableFilter: function(options) {
        return this.behavior.getTableFilter(options);
    },

    /**
     * @param {FilterTreeStateObject} state
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf Hypergrid.prototype
     */
    setTableFilter: function(state, options) {
        this.behavior.setTableFilter(state, options);
        this.behaviorChanged();
    },

    selectRowsFromCells: function() {
        if (!this.isCheckboxOnlyRowSelections()) {
            var last,
                hasCTRL = this.mouseDownState.primitiveEvent.detail.primitiveEvent.ctrlKey;

            if (hasCTRL && !this.isSingleRowSelectionMode()) {
                this.selectionModel.selectRowsFromCells(0, hasCTRL);
            } else if ((last = this.selectionModel.getLastSelection())) {
                this.selectRow(null, last.corner.y);
            } else {
                this.clearRowSelection();
            }
        }
    },
    selectColumnsFromCells: function() {
        this.selectionModel.selectColumnsFromCells();
    },
    getSelectedRows: function() {
        return this.behavior.getSelectedRows();
    },
    getSelectedColumns: function() {
        return this.behavior.getSelectedColumns();
    },
    getSelections: function() {
        return this.behavior.getSelections();
    },
    getLastSelectionType: function() {
        return this.selectionModel.getLastSelectionType();
    },
    isCellSelected: function(x, y) {
        return this.selectionModel.isCellSelected(x, y);
    },
    isInCurrentSelectionRectangle: function(x, y) {
        return this.selectionModel.isInCurrentSelectionRectangle(x, y);
    },
    selectAllRows: function() {
        this.selectionModel.selectAllRows();
    },
    areAllRowsSelected: function() {
        return this.selectionModel.areAllRowsSelected();
    },
    toggleSelectAllRows: function() {
        if (this.areAllRowsSelected()) {
            this.selectionModel.clear();
        } else {
            this.selectAllRows();
        }
        this.repaint();
    },
    isSingleRowSelectionMode: function() {
        return this.resolveProperty('singleRowSelectionMode');
    },
    newPoint: function(x, y) {
        return new Point(x, y);
    },
    newRectangle: function(x, y, width, height) {
        return new Rectangle(x, y, width, height);
    },
    getFormattedValue: function(x, y) {
        return this.formatValue(
            this.getColumnProperties(x).format,
            this.getValue(x, y + this.getHeaderRowCount())
        );
    },

    /**
     * @summary Sticky hash of dialog options objects.
     * @desc Each key is a dialog name; the value is the options object for that dialog.
     * The default dialog options object has the key `'undefined'`, which is undefined by default; it is set by calling `setDialogOptions` with no `dialogName` parameter.
     * @private
     */
    dialogOptions: {},

    /**
     * @summary Set and/or return a specific dialog options object *or* a default dialog options object.
     *
     * @desc If `options` defined:
     * * If `dialogName` defined: Save the specific dialog's options object.
     * * If `dialogName` undefined: Save the default dialog options object.
     *
     * If `options` is _not_ defined, no new dialog options object will be saved; but a previously saved preset will be returned (after mixing in the default preset if there is one).
     *
     * The default dialog options object is used in two ways:
     * * when a dialog has no options object
     * * as a mix-in base when a dialog does have an options object
     *
     * @param {string} [dialogName] If undefined, `options` defines the default dialog options object.
     *
     * @param {object} [options] If defined, preset the named dialog options object or the default dialog options object if name is undefined.
     *
     * @returns {object} One of:
     * * When `options` undefined, first of:
     *   * previous preset
     *   * default preset
     *   * empty object
     * * When `options` defined, first of:
     *   * mix-in: default preset members + `options` members
     *   * `options` verbatim when default preset undefined
     */
    setDialogOptions: function(dialogName, options) {
        if (typeof dialogName === 'object') {
            options = dialogName;
            dialogName = undefined;
        }
        var defaultOptions = this.dialogOptions.undefined;
        options = options || dialogName && this.dialogOptions[dialogName];
        if (options) {
            this.dialogOptions[dialogName] = options;
            if (defaultOptions) {
                options = _({}).extend(defaultOptions, options); // make a mix-in
            }
        } else {
            options = defaultOptions || {};
        }
        return options;
    },

    /**
     * Options objects are remembered for subsequent use. Alternatively, they can be preset by calling {@link Hypergrid#setDialogOptions|setDialogOptions}.
     * @param {string} dialogName
     * @param {object} [options] - If omitted, use the options object previously given here (or to {@link Hypergrid#setDialogOptions|setDialogOptions}), if any. In any case, the resultant options object, if any, is mixed into the default options object, if there is one.
     */
    openDialog: function(dialogName, options) {
        this.stopEditing();
        options = this.setDialogOptions(dialogName, options);
        options.terminate = function() { // when about-to-be-opened dialog is eventually closed
            delete this.dialog;
        }.bind(this);
        this.dialog = this.behavior.openDialog(dialogName, options);
    },

    // although you can have multiple dialogs open at the same time, the following enforces one at a time (for now)
    toggleDialog: function(newDialogName, options) {
        var dialog = this.dialog,
            oldDialogName = dialog && dialog.$$CLASS_NAME;
        if (!dialog || !this.dialog.close() && oldDialogName !== newDialogName) {
            if (!dialog) {
                // open new dialog now
                this.openDialog(newDialogName, options);
            } else {
                // open new dialog when already-opened dialog finishes closing due to .closeDialog() above
                dialog.terminate = this.openDialog.bind(this, newDialogName, options);
            }
        }
    },

    /**
     * @returns {string} One of:
     * * `'active'` - There is at least one defined filter (leaf node) in the filter tree.
     * * `'inactive'` - There are no defined filters (no leaf nodes) in the filter tree.
     * * `'error'` - There is at least one partially defined filter.
     */
    getFilterStatus: function() {
        var filter = this.getGlobalFilter(),
            result;

        if (filter.invalid()) {
            result = 'error';
        } else if (filter.filterCount()) {
            result = 'active';
        } else {
            result = 'inactive';
        }

        return result;
    }
};

/**
 * @summary Update deep properties with new values.
 * @desc This function is a recursive property setter which updates a deep property in a destination object with the value of a congruent property in a source object.
 *
 * > Terminology: A deep property is a "terminal node" (primitive value) nested at some depth (i.e., depth > 1) inside a complex object (an object containing nested objects). A congruent property is a property in another object with the same name and at the same level of nesting.
 *
 * This function is simple and elegant. I recommend you study the code, which nonetheless implies all of the following:
 *
 * * If the deep property is _not_ found in `destination`, it will be created.
 * * If the deep property is found in `destination` _and_ is a primitive type, it will be modified (overwritten with the value from `source`).
 * * If the deep property is found in `destination` _but_ is not a primitive type (i.e., is a nested object), it will _also_ be overwritten with the (primitive) value from `source`.
 * * If the nested object the deep property inhabits in `source` is not found in `destination`, it will be created.
 * * If the nested object the deep property inhabits in `source` is found in `destination` but is not in fact an object (i.e., it is a primitive value), it will be overwritten with a reference to that object.
 * * If the primitive value is `undefined`, the destination property is deleted.
 * * `source` may contain multiple properties to update.
 *
 * That one rule is simply this: If both the source _and_ the destination properties are objects, then recurse; else overwrite the destination property with the source property.
 *
 * > Caveat: This is _not_ equivalent to a deep extend function. While both a deep extend and this function will recurse over a complex object, they are fundamentally different: A deep extend clones the nested objects as it finds them; this function merely updates them (or creates them where they don't exist).
 *
 * @param {object} destination - An object to update with new or modified property values
 * @param {object} source - A congruent object continaly (only) the new or modified property values.
 * @returns {object} Always returns `destination`.
 */
function addDeepProperties(destination, source) {
    _(source).each(function(property, key) {
        if (typeof destination[key] === 'object' && typeof property === 'object') {
            addDeepProperties(destination[key], property);
        } else if (property === undefined) {
            delete destination[key];
        } else {
            destination[key] = property;
        }
    });
    return destination;
}

function normalizeRect(rect) {
    var o = rect.origin;
    var c = rect.corner;

    var ox = Math.min(o.x, c.x);
    var oy = Math.min(o.y, c.y);

    var cx = Math.max(o.x, c.x);
    var cy = Math.max(o.y, c.y);

    var result = new Rectangle(ox, oy, cx - ox, cy - oy);

    return result;
}

function buildPolymerTheme() {
    clearObjectProperties(polymerTheme);
    var pb = document.createElement('paper-button');

    pb.style.display = 'none';
    pb.setAttribute('disabled', true);
    document.body.appendChild(pb);
    var p = window.getComputedStyle(pb);

    var section = document.createElement('section');
    section.style.display = 'none';
    section.setAttribute('hero', true);
    document.body.appendChild(section);

    var h = window.getComputedStyle(document.querySelector('html'));
    var hb = window.getComputedStyle(document.querySelector('html, body'));
    var s = window.getComputedStyle(section);

    polymerTheme.columnHeaderBackgroundColor = p.color;
    polymerTheme.rowHeaderBackgroundColor = p.color;
    polymerTheme.topLeftBackgroundColor = p.color;
    polymerTheme.lineColor = p.backgroundColor;

    polymerTheme.backgroundColor2 = hb.backgroundColor;

    polymerTheme.color = h.color;
    polymerTheme.fontFamily = h.fontFamily;
    polymerTheme.backgroundColor = s.backgroundColor;

    pb.setAttribute('disabled', false);
    pb.setAttribute('secondary', true);
    pb.setAttribute('raised', true);
    p = window.getComputedStyle(pb);

    polymerTheme.columnHeaderColor = p.color;
    polymerTheme.rowHeaderColor = p.color;
    polymerTheme.topLeftColor = p.color;


    polymerTheme.backgroundSelectionColor = p.backgroundColor;
    polymerTheme.foregroundSelectionColor = p.color;

    pb.setAttribute('secondary', false);
    pb.setAttribute('warning', true);

    polymerTheme.columnHeaderForegroundSelectionColor = p.color;
    polymerTheme.columnHeaderBackgroundSelectionColor = p.backgroundColor;
    polymerTheme.rowHeaderForegroundSelectionColor = p.color;
    polymerTheme.fixedColumnBackgroundSelectionColor = p.backgroundColor;

    //check if there is actually a theme loaded if not, clear out all bogus values
    //from my cache
    if (polymerTheme.columnHeaderBackgroundSelectionColor === 'rgba(0, 0, 0, 0)' ||
        polymerTheme.lineColor === 'transparent') {
        clearObjectProperties(polymerTheme);
    }

    document.body.removeChild(pb);
    document.body.removeChild(section);
}

function clearObjectProperties(obj) {
    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            delete obj[prop];
        }
    }
}

function valOrFunc(vf) {
    var result = (typeof vf)[0] === 'f' ? vf() : vf;
    return result || result === 0 ? result : '';
}

/**
 * @summary Shared localization defaults for all grid instances.
 * @desc These property values are overridden by those supplied in the `Hypergrid` constructor's `options.localization`.
 * @property {string|string[]} [options.localization.defaultLocale] - The default locale to use when an explicit `locale` is omitted from localizer constructor calls. Passed to Intl.NumberFomrat` and `Intl.DateFomrat`. See {@ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation|Locale identification and negotiation} for more information. Omitting will use the runtime's local language and region.
 * @property {object} [options.localization.numberOptions] - Options passed to `Intl.NumberFomrat` for creating the basic "number" localizer.
 * @property {object} [options.localization.dateOptions] - Options passed to `Intl.DateFomrat` for creating the basic "date" localizer.
 */

Hypergrid.localization = {
    locale: 'en-US',
    numberOptions: { maximumFractionDigits: 0 }
};

module.exports = Hypergrid;

},{"./behaviors":61,"./cellEditors":71,"./cellRenderers":81,"./defaults":84,"./lib/Localization":111,"./lib/Renderer":112,"./lib/SelectionModel":113,"./lib/deprecated":115,"./lib/polyfills":119,"./lib/stylesheet":121,"extend-me":7,"finbars":19,"fincanvas":20,"object-iterators":46,"rectangular":48}],55:[function(require,module,exports){
/* eslint-env browser */

'use strict';

// Only 1 choice from each block below should be exposed (uncommented):

module.exports = {

	analytics: require('hyper-analytics'), // npm
    //analytics: require('../../hyper-analytics/src'), // developers

    FilterTree: require('filter-tree'), // npm
    //FilterTree: require('../../filter-tree'), // developers

};

},{"filter-tree":9,"hyper-analytics":25}],56:[function(require,module,exports){
/* eslint-env browser */
'use strict';

var _ = require('object-iterators');
var Base = require('../lib/Base');

var Column = require('./Column');
var dialogs = require('../dialogs');
var DefaultFilter = require('../filter/DefaultFilter');

var noExportProperties = [
    'columnHeader',
    'columnHeaderColumnSelection',
    'filterProperties',
    'rowHeader',
    'rowHeaderRowSelection',
    'rowNumbersProperties',
    'treeColumnProperties',
    'treeColumnPropertiesColumnSelection',
];

var isNull = {
    isNull: true
};

/**
 * @constructor
 * @abstract
 * @desc A sort of "model++." It contains all code/data that's necessary for easily implementing a virtual data source and its manipulation/analytics.
 *
 */
var Behavior = Base.extend('Behavior', {

    /**
     * @desc this is the callback for the plugin pattern of nested tags
     * @param {Hypergrid} grid
     * @param {function|menuItem[]} [schema=derivedSchema] - Passed to behavior constructor. May be:
     * * A schema array
     * * A function returning a schema array. Called at filter reset time with behavior as context.
     * * Omit to generate a basic schema from `this.columns`.
     * @memberOf Behavior.prototype
     */
    initialize: function(grid, schema, dataRows) {
        /**
         * @type {Hypergrid}
         * @memberOf Behavior.prototype
         */
        this.grid = grid;

        /**
         * @type {DataModel}
         * @memberOf Behavior.prototype
         */
        this.dataModel = this.getNewDataModel();

        grid.setBehavior(this);

        this.reset();

        this.initializeFeatureChain(grid);
    },

    /**
     * @desc create the feature chain - this is the [chain of responsibility](http://c2.com/cgi/wiki?ChainOfResponsibilityPattern) pattern.
     * @param {Hypergrid} grid
     * @memberOf Behavior.prototype
     */
    initializeFeatureChain: function(grid) {
        var self = this;

        /**
         * @summary Hash of feature class names.
         * @desc Built here but otherwise not in use.
         * @type {object}
         * @memberOf Behavior.prototype
         */
        this.featureMap = {};

        this.features.forEach(function(FeatureConstructor) {
            var newFeature = new FeatureConstructor;
            self.featureMap[newFeature.$$CLASS_NAME] = newFeature;
            if (self.featureChain) {
                self.featureChain.setNext(newFeature);
            } else {
                /**
                 * @summary Controller chain of command.
                 * @desc Each feature is linked to the next feature.
                 * @type {Feature}
                 * @memberOf Behavior.prototype
                 */
                self.featureChain = newFeature;
            }
        });
        if (this.featureChain) {
            this.featureChain.initializeOn(grid);
        }
    },

    features: [], // override in implementing class unless no features

    reset: function() {
        this.renderedColumnCount = 30;
        this.renderedRowCount = 60;
        this.dataUpdates = {}; //for overriding with edit values;
        this.scrollPositionX = this.scrollPositionY = 0;
        this.clearColumns();
        this.clearState();
        this.dataModel.reset();
        this.createColumns();
    },

    clearColumns: function() {
        /**
         * @type {Column[]}
         * @memberOf Behavior.prototype
         */
        this.columns = [];

        /**
         * @type {Column[]}
         * @memberOf Behavior.prototype
         */
        this.allColumns = [];

        this.allColumns[-1] = this.columns[-1] = this.newColumn(-1);
        this.allColumns[-2] = this.columns[-2] = this.newColumn(-2);

        this.columnEnum = {};
    },

    getActiveColumn: function(x) {
        return this.columns[x];
    },
    getVisibleColumn: function() {
        this.deprecated('getVisibleColumn(x)', 'getActiveColumn(x)', '1.0.6', arguments);
    },
    getVisibleColumnName: function() {
        this.deprecated('getVisibleColumnName(x)', 'getActiveColumn(x).name', '1.0.6', arguments);
    },
    getColumnId: function() {
        this.deprecated('getColumnId(x)', 'getActiveColumn(x).header', '1.0.6', arguments);
    },
    getHeader: function() {
        this.deprecated('getHeader(x)', 'getActiveColumn(x).header', '1.0.6', arguments);
    },

    getColumn: function(x) {
        return this.allColumns[x];
    },

    newColumn: function(options) {
        var column = new Column(this, options);
        this.getPrivateState().columnProperties[column.index] = this.createColumnProperties();
        return column;
    },

    addColumn: function(options) {
        var column = this.newColumn(options);
        this.columns.push(column);
        this.allColumns.push(column);
        return column;
    },

    createColumns: function() {
        //concrete implementation here
    },

    createColumnProperties: function() {
        var tableState = this.getPrivateState();
        var properties = Object.create(tableState);

        properties.rowNumbersProperties = Object.create(properties, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundSelectionColor = value;
                }
            }
        });

        properties.rowHeader = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.rowHeaderFont;
                },
                set: function(value) {
                    this.rowHeaderFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.rowHeaderColor;
                },
                set: function(value) {
                    this.rowHeaderColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderBackgroundColor;
                },
                set: function(value) {
                    this.rowHeaderBackgroundColor = value;
                }
            },
            foregroundSelectionFont: {
                configurable: true,
                get: function() {
                    return this.rowHeaderForegroundSelectionFont;
                },
                set: function(value) {
                    this.rowHeaderForegroundSelectionFont = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderForegroundSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderBackgroundSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderBackgroundSelectionColor = value;
                }
            }
        });

        properties.columnHeader = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.columnHeaderFont;
                },
                set: function(value) {
                    this.columnHeaderFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.columnHeaderColor;
                },
                set: function(value) {
                    this.columnHeaderColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundColor = value;
                }
            },
            foregroundSelectionFont: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundSelectionFont;
                },
                set: function(value) {
                    this.columnHeaderForegroundSelectionFont = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundSelectionColor = value;
                }
            }
        });

        properties.columnHeaderColumnSelection = Object.create(properties.columnHeader, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundColumnSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderForegroundColumnSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundColumnSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundColumnSelectionColor = value;
                }
            }
        });

        properties.rowHeaderRowSelection = Object.create(properties.rowHeader, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderForegroundRowSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderForegroundRowSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderBackgroundRowSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderBackgroundRowSelectionColor = value;
                }
            }
        });

        properties.filterProperties = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.filterFont;
                },
                set: function(value) {
                    this.filterFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.filterColor;
                },
                set: function(value) {
                    this.filterColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.filterBackgroundColor;
                },
                set: function(value) {
                    this.filterBackgroundColor = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.filterForegroundSelectionColor;
                },
                set: function(value) {
                    this.filterForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.filterBackgroundSelectionColor;
                },
                set: function(value) {
                    this.filterBackgroundSelectionColor = value;
                }
            },
            cellBorderStyle: {
                configurable: true,
                get: function() {
                    return this.filterCellBorderStyle;
                },
                set: function(value) {
                    this.filterCellBorderStyle = value;
                }
            },
            cellBorderThickness: {
                configurable: true,
                get: function() {
                    return this.filterCellBorderThickness;
                },
                set: function(value) {
                    this.filterCellBorderThickness = value;
                }
            }
        });

        properties.treeColumnProperties = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.treeColumnFont;
                },
                set: function(value) {
                    this.treeColumnFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.treeColumnColor;
                },
                set: function(value) {
                    this.treeColumnColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnBackgroundColor;
                },
                set: function(value) {
                    this.treeColumnBackgroundColor = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnForegroundSelectionColor;
                },
                set: function(value) {
                    this.treeColumnForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnBackgroundSelectionColor;
                },
                set: function(value) {
                    this.treeColumnBackgroundSelectionColor = value;
                }
            }
        });

        properties.treeColumnPropertiesColumnSelection = Object.create(properties.treeColumnProperties, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnForegroundColumnSelectionColor;
                },
                set: function(value) {
                    this.treeColumnForegroundColumnSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnBackgroundColumnSelectionColor;
                },
                set: function(value) {
                    this.treeColumnBackgroundColumnSelectionColor = value;
                }
            }
        });

        return properties;
    },

    getColumnWidth: function(x) {
        var column = this.getActiveColumn(x);
        if (!column) {
            return this.resolveProperty('defaultColumnWidth');
        }
        var width = column.getWidth();
        return width;
    },

    setColumnWidth: function(x, width) {
        this.getActiveColumn(x).setWidth(width);
        this.stateChanged();
    },

    getCellRenderer: function(config, x, y) {
        return this.getActiveColumn(x).getCellRenderer(config, y);
    },
    getCellProvider: function(name) {
        this.deprecated('getCellProvider()', 'grid.cellRenderers', '1.0.6', arguments);
    },
    createCellProvider: function(name) {
        console.error('getCellProvider() is deprecated as of v1.0.6. No replacement; do not call. Previously called by `Behavior` constructor; `new CellRenderers()` is now called by `Hypergrid` constructor instead.', arguments);
    },

    applyAnalytics: function() {
        this.dataModel.applyAnalytics();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc utility function to empty an object of its members
     * @param {object} obj - the object to empty
     * @param {boolean} [exportProps]
     * * `undefined` (omitted) - delete *all* properties
     * * **falsy** - delete *only* the export properties
     * * **truthy** - delete all properties *except* the export properties
     */
    clearObjectProperties: function(obj, exportProps) {
        for (var key in obj) {
            if (
                obj.hasOwnProperty(key) && (
                    exportProps === undefined ||
                    !exportProps && noExportProperties.indexOf(key) >= 0 ||
                    exportProps && noExportProperties.indexOf(key) < 0
                )
            ) {
                delete obj[key];
            }
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc getter for a [Memento](http://c2.com/cgi/wiki?MementoPattern) Object
     * @returns {object}
     */
    getPrivateState: function() {
        if (!this.tableState) {
            this.tableState = this.getDefaultState();
        }
        return this.tableState;
    },

    //this is effectively a clone, with certain things removed....
    getState: function() {
        var copy = JSON.parse(JSON.stringify(this.getPrivateState()));
        this.clearObjectProperties(copy.columnProperties, false);
        return copy;
    },
    /**
     * @memberOf Behavior.prototype
     * @desc clear all table state
     */
    clearState: function() {
        /**
         * memento for the user configured visual properties of the table
         * @type {object}
         * @memberOf Behavior.prototype
         */
        this.tableState = null;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {object} Newly created default empty tablestate.
     */
    getDefaultState: function() {
        var tableProperties = this.grid._getProperties();
        var state = Object.create(tableProperties);

        _(state).extendOwn({
            rowHeights: {},
            columnProperties: []
        });

        return state;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Restore this table to a previous state.
     * See the [memento pattern](http://c2.com/cgi/wiki?MementoPattern).
     * @param {Object} memento - an encapsulated representation of table state
     */
    setState: function(memento) {

        //we don't want to clobber the column properties completely
        if (!memento.columnIndexes) {
            var fields = this.dataModel.getFields();
            memento.columnIndexes = [];
            for (var i = 0; i < fields.length; i++) {
                memento.columnIndexes[i] = i;
            }
        }
        var colProperties = memento.columnProperties;
        delete memento.columnProperties;
        this.tableState = null;
        var state = this.getPrivateState();
        this.createColumns();
        this._setColumnOrder(memento.columnIndexes);
        _(state).extendOwn(memento);
        this.setAllColumnProperties(colProperties);
        memento.columnProperties = colProperties;

        //just to be close/ it's easier on the eyes
        this.setColumnWidth(-1, 24.193359375);
        this.dataModel.applyState();
    },

    setAllColumnProperties: function(properties) {
        properties = properties || [];
        for (var i = 0; i < properties.length; i++) {
            var current = this.getPrivateState().columnProperties[i];
            this.clearObjectProperties(current, false);
            _(current).extendOwn(properties[i]);
        }
    },

    _setColumnOrder: function(indexes) {
        if (!Array.isArray(indexes)){
            return;
        }
        if (!indexes) {
            this.columns.length = 0;
            return;
        }
        this.columns.length = indexes.length;
        for (var i = 0; i < indexes.length; i++) {
            this.columns[i] = this.allColumns[indexes[i]];
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc fetch the value for a property key
     * @returns {*} The value of the given property.
     * @param {string} key - a property name
     */
    resolveProperty: function(key) {
        return this.grid.resolveProperty(key);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc A specific cell was clicked; you've been notified.
     * @param {Point} cell - point of cell coordinates
     * @param {Object} event - all event information
     */
    cellClicked: function(cell, event) {
        this.dataModel.cellClicked(cell, event);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc A specific cell was le double-clicked; you've been notified.
     * @param {Point} cell - point of cell coordinates
     * @param {Object} event - all event information
     */
    cellDoubleClicked: function(cell, event) {

    },

    lookupFeature: function(key) {
        return this.featureMap[key];
    },

    /**
     * @memberOf Behavior.prototype
     * @desc setter for the hypergrid
     * @param {Hypergrid} grid
     */
    setGrid: function(grid) {
    },

    /**
     * @memberOf Behavior.prototype
     * @desc First check to see if something was overridden.
     * @return {*} The value at `x,y` for the top left section of the hypergrid.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     */
    getValue: function(x, y) {
        var column = this.getActiveColumn(x);
        return column && column.getValue(y);
    },

    getUnfilteredValue: function(x, y) {
        var column = this.getActiveColumn(x);
        return column && column.getUnfilteredValue(y);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc update the data at point x, y with value
     * @return The data.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     * @param {Object} value - the value to use
     */
    setValue: function(x, y, value) {
        var column = this.getActiveColumn(x);
        return column && column.setValue(y, value);
    },

    getDataValue: function(x, y) {
        return this.dataModel.getValue(x, y);
    },

    setDataValue: function(x, y, value) {
        this.dataModel.setValue(x, y, value);
    },
    /**
     * @memberOf Behavior.prototype
     * @desc First checks to see if something was overridden.
     * @return {*} The value at x,y for the top left section of the hypergrid.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     */
    getCellProperties: function(x, y) {
        var column = this.allColumns[x];
        return column && column.getCellProperties(y);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc update the data at point x, y with value
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     * @param {Object} value - the value to use
     */
    setCellProperties: function(x, y, value) {
        var column = this.allColumns[x];
        if (column) {
            column.setCellProperties(y, value);
        }
    },
    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of rows in the hypergrid.
     */
    getRowCount: function() {
        return this.dataModel.getRowCount();
    },

    getUnfilteredRowCount: function() {
        return this.dataModel.getUnfilteredRowCount();
    },
    /**
     * @memberOf Behavior.prototype
     * @return {number} The height in pixels of the fixed rows area  of the hypergrid.
     */
    getFixedRowsHeight: function() {
        var count = this.getFixedRowCount();
        var total = 0;
        for (var i = 0; i < count; i++) {
            total = total + this.getRowHeight(i);
        }
        //var footerHeight = this.getDefaultRowHeight();
        //total = total + (footerHeight * this.getFooterRowCount());
        return total;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The height in pixels of a specific row in the hypergrid.
     * @param {number} rowNum - row index of interest
     */
    getRowHeight: function(rowNum) {
        var rowHeights = this.getPrivateState().rowHeights;
        return rowHeights && rowHeights[rowNum] || this.getDefaultRowHeight();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc The value is lazily initialized and comes from the properties mechanism for '`defaultRowHeight`', which should be ~20px.
     * @returns {number} The row height in pixels.
     */
    getDefaultRowHeight: function() {
        if (!this.defaultRowHeight) {
            this.defaultRowHeight = this.resolveProperty('defaultRowHeight');
        }
        return this.defaultRowHeight;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the pixel height of a specific row
     * @param {number} rowNum - the row index of interest
     * @param {number} height - pixel height
     */
    setRowHeight: function(rowNum, height) {
        var tableState = this.getPrivateState();
        tableState.rowHeights[rowNum] = Math.max(5, height);
        this.stateChanged();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc This will allow 'floating' fixed rows.
     * @return {number} The maximum height of the fixed rows area in the hypergrid.
     */
    getFixedRowsMaxHeight: function() {
        return this.getFixedRowsHeight();
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The width of the fixed column area in the hypergrid.
     */
    getFixedColumnsWidth: function() {
        var count = this.getFixedColumnCount();
        var total = 0;
        if (this.grid.isShowRowNumbers()) {
            total = this.getColumnWidth(-1);
        }
        for (var i = 0; i < count; i++) {
            total = total + this.getColumnWidth(i);
        }
        return total;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc This exists to support "floating" columns.
     * @return {number} The total width of the fixed columns area.
     */
    getFixedColumnsMaxWidth: function() {
        return this.getFixedColumnsWidth();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the scroll position in vertical dimension and notify listeners.
     * @param {number} y - the new y value
     */
    _setScrollPositionY: function(y) {
        this.setScrollPositionY(y);
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the scroll position in horizontal dimension and notify listeners.
     * @param {number} x - the new x value
     */
    _setScrollPositionX: function(x) {
        this.setScrollPositionX(x);
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the number of columns just rendered, including partially rendered columns.
     * @param {number} count - how many columns were just rendered
     */
    setRenderedColumnCount: function(count) {
        this.renderedColumnCount = count;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the number of rows just rendered, including partially rendered rows.
     * @param {number} count - how many rows were just rendered
     */
    setRenderedRowCount: function(count) {
        this.renderedRowCount = count;
    },


    /**
     * @memberOf Behavior.prototype
     * @desc The fixed row area has been clicked, massage the details and call the real function.
     * @param {Hypergrid} grid
     * @param {Object} mouse - event details
     */
    _fixedRowClicked: function(grid, mouse) {
        var x = this.translateColumnIndex(this.getScrollPositionX() + mouse.gridCell.x - this.getFixedColumnCount());
        var translatedPoint = this.grid.newPoint(x, mouse.gridCell.y);
        mouse.gridCell = translatedPoint;
        this.fixedRowClicked(grid, mouse);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc The fixed column area has been clicked, massage the details and call the real function.
     * @param {Hypergrid} grid
     * @param {Object} mouse - event details
     */
    _fixedColumnClicked: function(grid, mouse) {
        var translatedPoint = this.grid.newPoint(mouse.gridCell.x, this.getScrollPositionY() + mouse.gridCell.y - this.getFixedRowCount());
        mouse.gridCell = translatedPoint;
        this.fixedColumnClicked(grid, mouse);
    },

    moveSingleSelect: function(grid, x, y) {
        if (this.featureChain) {
            this.featureChain.moveSingleSelect(grid, x, y);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate setting the cursor up the feature chain of responsibility
     * @param {Hypergrid} grid
     */
    setCursor: function(grid) {
        grid.updateCursor();
        this.featureChain.setCursor(grid);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse move to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseMove: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseMove(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onClick: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleClick(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onContextMenu: function(grid, event) {
        var proceed = grid.fireSyntheticContextMenuEvent(event);
        if (proceed && this.featureChain) {
            this.featureChain.handleContextMenu(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling wheel moved to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onWheelMoved: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleWheelMoved(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse up to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseUp: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseUp(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse drag to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseDrag: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseDrag(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling key down to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onKeyDown: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleKeyDown(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling key up to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onKeyUp: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleKeyUp(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling double click to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onDoubleClick: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleDoubleClick(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling double click to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {string[]} [options] - Forwarded to dialog constructor.
     */
    openDialog: function(dialogName, options) {
        return new dialogs[dialogName](this.grid, options);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse down to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseDown(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse exit to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseExit: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseExit(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is replaced by the grid on initialization and serves as the callback
     */
    changed: function() {},

    /**
     * @memberOf Behavior.prototype
     * @desc this function is replaced by the grid on initialization and serves as the callback
     */
    shapeChanged: function() {},

    /**
     * @memberOf Behavior.prototype
     * @return {boolean} Can re-order columns.
     */
    isColumnReorderable: function() {
        return true;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {Object} The properties for a specific column. These are used if no cell properties are specified.
     * @param {index} columnIndex - the column index of interest
     */
    getColumnProperties: function(columnIndex) {
        var column = this.columns[columnIndex];
        if (!column) {
            return isNull;
        }
        var properties = column.getProperties(); //TODO: returns `null` on Hypergrid.prototype.reset();
        if (!properties) {
            return isNull;
        }
        return properties;
    },

    setColumnProperties: function(columnIndex, properties) {
        var column = this.allColumns[columnIndex];
        var columnProperties = column.getProperties();
        _(columnProperties).extendOwn(properties);
        this.changed();
    },

    /**
     * Clears all cell properties of given column or of all columns.
     * @param {number} [columnIndex] - Omit for all columns.
     */
    clearAllCellProperties: function(columnIndex) {
        if (columnIndex === undefined) {
            for (var i = this.allColumns.length - 1; i >= 0; --i) {
                this.allColumns[i].clearAllCellProperties();
            }
        } else {
            var column = this.allColumns[i];
            if (column) {
                column.clearAllCellProperties();
            }
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Rebuild the column order indexes
     * @param {Array} columnIndexes - list of column indexes
     * @param {Boolean} [silent=false] - whether to trigger column changed event
     */
    setColumnIndexes: function(columnIndexes, silent) {
        var tableState = this.getPrivateState();
        this._setColumnOrder(columnIndexes);
        tableState.columnIndexes = columnIndexes;
        this.changed();
        if (!silent) {
            this.grid.fireSyntheticOnColumnsChangedEvent();
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @return {string[]} All the currently hidden column header labels.
     */
    getHiddenColumnDescriptors: function() {
        var tableState = this.getPrivateState();
        var indexes = tableState.columnIndexes;
        var labels = [];
        var columnCount = this.getActiveColumnCount();
        for (var i = 0; i < columnCount; i++) {
            if (indexes.indexOf(i) === -1) {
                var column = this.getActiveColumn(i);
                labels.push({
                    id: i,
                    header: column.header,
                    field: column.name
                });
            }
        }
        return labels;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc hide columns that are specified by their indexes
     * @param {Array} arrayOfIndexes - an array of column indexes to hide
     */
    hideColumns: function(arrayOfIndexes) {
        var tableState = this.getPrivateState();
        var order = tableState.columnIndexes;
        for (var i = 0; i < arrayOfIndexes.length; i++) {
            var each = arrayOfIndexes[i];
            if (order.indexOf(each) !== -1) {
                order.splice(order.indexOf(each), 1);
            }
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @return {integer} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.getPrivateState().fixedColumnCount || 0;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the number of fixed columns
     * @param {number} n - the integer count of how many columns to be fixed
     */
    setFixedColumnCount: function(n) {
        this.getPrivateState().fixedColumnCount = n;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {integer} The number of fixed rows.
     */
    getFixedRowCount: function() {
        if (!this.tableState) {
            return 0;
        }
        var headers = this.grid.getHeaderRowCount();
        var usersSize = this.tableState.fixedRowCount || 0;
        return headers + usersSize;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the number of fixed rows, which includes (top to bottom order):
     * 1. The header rows
     *    1. The header labels row (optional)
     *    2. The filter row (optional)
     *    3. The top total rows (0 or more)
     * 2. The non-scrolling rows (externally called "the fixed rows")
     *
     * @returns {number} Sum of the above or 0 if none of the above are in use.
     *
     * @param {number} n - The number of rows.
     */
    setFixedRowCount: function(n) {
        this.tableState.fixedRowCount = n;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of header rows.
     * A portion of the number returned by {@link Behavior#getFixedRowCount()|getFixedRowCount()}.
     * (The remaining _fixed rows_ are the _top totals_ rows.)
     */
    getHeaderRowCount: function() {
        var header = this.grid.isShowHeaderRow() ? 1 : 0;
        var filter = this.grid.isShowFilterRow() ? 1 : 0;
        var totals = this.getTopTotals().length;
        return header + filter + totals;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of footer rows, consisting entirely of 0 or more _bottom totals_ rows.
     */
    getFooterRowCount: function() {
        return this.getBottomTotals().length;
    },

    getTopTotals: function() {
        return this.dataModel.getTopTotals();
    },
    /**
     * @memberOf Behavior.prototype
     * @summary Set the number of header rows.
     * @param {number} n - The number of _fixed rows_ to reserve as header rows.
     * (The remaining _fixed rows_ are the _top totals_ rows.)
     */
    setHeaderRowCount: function(n) {
        this.tableState.headerRowCount = n;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of fixed rows.
     */
    getHeaderColumnCount: function() {
        return this.grid.resolveProperty('headerColumnCount');
    },

    /**
     * @memberOf Behavior.prototype
     * @param {number} The number of fixed rows.
     */
    setHeaderColumnCount: function(numberOfHeaderColumns) {
        this.tableState.headerColumnCount = numberOfHeaderColumns;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc a dnd column has just been dropped, we've been notified
     */
    endDragColumnNotification: function() {},

    /**
     * @memberOf Behavior.prototype
     * @return {null} the cursor at a specific x,y coordinate
     * @param {number} x - the x coordinate
     * @param {number} y - the y coordinate
     */
    getCursorAt: function(x, y) {
        return null;
    },

    /**
     * Number of _visible_ columns.
     * @memberOf Behavior.prototype
     * @return {number} The total number of columns.
     */
    getActiveColumnCount: function() {
        return this.columns.length;
    },
    getColumnCount: function() {
        this.deprecated('getColumnCount()', 'getActiveColumnCount()', '1.0.6', arguments);
    },

    /**
     * @memberOf Behavior.prototype
     * @return {string} The column alignment at column `x`: `'left'`, `'center'` , or `'right'`
     * @param {number} x - The column index of interest.
     */
    getColumnAlignment: function(x) {
        return 'center';
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Quietly set the horizontal scroll position.
     * @param {number} x - The new position in pixels.
     */
    setScrollPositionX: function(x) {
        /**
         * @memberOf Behavior.prototype
         * @type {number}
         */
        this.scrollPositionX = x;
    },

    getScrollPositionX: function() {
        return this.scrollPositionX;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Quietly set the vertical scroll position.
     * @param {number} y - The new position in pixels.
     */
    setScrollPositionY: function(y) {
        /**
         * @memberOf Behavior.prototype
         * @type {number}
         */
        this.scrollPositionY = y;
    },

    getScrollPositionY: function() {
        return this.scrollPositionY;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {cellEditor} The cell editor for the cell at the given coordinates.
     * @param {Point} editPoint - The grid cell coordinates.
     */
    getCellEditorAt: function(editPoint) {
        var cellEditor, options,
            column = this.getActiveColumn(editPoint.x);

        if (column) {
            options = {
                column: column,
                editPoint: editPoint
            };

            cellEditor = this.grid.isFilterRow(editPoint.y)
                ? this.grid.cellEditors.create('filterbox', options)
                : column.getCellEditorAt(editPoint.y, options);
        }

        return cellEditor;
    },

    /**
     * @memberOf Behavior.prototype
     * @param {number} x - The column index.
     * @param {string[]} keys
     */
    toggleSort: function(x, keys) {
        this.getActiveColumn(x).toggleSort(keys);
    },

    /**
     * @memberOf Behavior.prototype
     * @return {boolean} `true` if we should highlight on hover
     * @param {boolean} isColumnHovered - the column is hovered or not
     * @param {boolean} isRowHovered - the row is hovered or not
     */
    highlightCellOnHover: function(isColumnHovered, isRowHovered) {
        return isColumnHovered && isRowHovered;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellPropertiesPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a fixed row cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellFixedRowPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a fixed column cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellFixedColumnPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a top left cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellTopLeftPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function enhance the double click event just before it's broadcast to listeners
     * @param {Object} event - event to enhance
     */
    enhanceDoubleClickEvent: function(event) {},

    /**
     * @memberOf Behavior.prototype
     * @desc swap src and tar columns
     * @param {number} src - column index
     * @param {number} tar - column index
     */
    swapColumns: function(source, target) {
        var columns = this.columns;
        var tmp = columns[source];
        columns[source] = columns[target];
        columns[target] = tmp;
        this.changed();
    },

    getColumnEdge: function(c, renderer) {
        return this.dataModel.getColumnEdge(c, renderer);
    },

    /**
     * @memberOf Behavior.prototype
     * @param {number} x - column index
     * @param {number} y - totals row index local to the totals area
     * @param value
     * @param {string[]} [areas=['top', 'bottom']] - may include `'top'` and/or `'bottom'`
     */
    setTotalsValue: function(x, y, value, areas) {
        this.grid.setTotalsValueNotification(x, y, value, areas);
    },

    /**
     * @memberOf Behavior.prototype
     * @return {object} The object at y index.
     * @param {number} y - the row index of interest
     */
    getRow: function(y) {
        return this.dataModel.getRow(y);
    },

    convertViewPointToDataPoint: function(viewPoint) {
        var newX = this.getActiveColumn(viewPoint.x).index;
        var newPoint = this.grid.newPoint(newX, viewPoint.y);
        return newPoint;
    },

    setGroups: function(arrayOfColumnIndexes) {
        this.dataModel.setGroups(arrayOfColumnIndexes);
        this.createColumns();
        this.changed();
    },

    setAggregates: function(mapOfKeysToFunctions) {
        var self = this;
        this.dataModel.setAggregates(mapOfKeysToFunctions);
        this.createColumns();
        setTimeout(function() {
            self.changed();
        }, 100);
    },

    hasHierarchyColumn: function() {
        return false;
    },

    setRelation: function(options) {
        this.dataModel.setRelation(options);
        this.shapeChanged();
    },

    getRowContextFunction: function(selectedRows) {
        return function() {
            return null;
        };
    },

    getSelectionMatrixFunction: function(selectedRows) {
        return function() {
            return null;
        };
    },

    getComputedRow: function(y) {
        return this.dataModel.getComputedRow(y);
    },

    autosizeAllColumns: function() {
        this.checkColumnAutosizing(true);
        this.changed();
    },

    checkColumnAutosizing: function(force) {
        force = force === true;
        this.autoSizeRowNumberColumn();
        this.allColumns[-2].checkColumnAutosizing(force);
        this.allColumns.forEach(function(column) {
            column.checkColumnAutosizing(force);
        });
    },

    autoSizeRowNumberColumn: function() {
        if (this.grid.isRowNumberAutosizing()) {
            this.allColumns[-1].checkColumnAutosizing(true);
        }
    },

    getNewFilter: function() {
        var newFilter = new DefaultFilter({
            schema: typeof this.schema === 'function' ? this.schema(this.columns) : this.schema,
            caseSensitiveColumnNames: this.grid.resolveProperty('filterCaseSensitiveColumnNames'),
            resolveAliases: this.grid.resolveProperty('filterResolveAliases'),
            defaultColumnFilterOperator: this.grid.resolveProperty('filterDefaultColumnFilterOperator')
        });
        newFilter.loadColumnPropertiesFromSchema(this.columns);
        return newFilter;
    },

    /**
     * @summary Get a reference to the filter attached to the Hypergrid.
     * @returns {FilterTree}
     * @memberOf Behavior.prototype
     */
    getGlobalFilter: function() {
        return this.dataModel.getGlobalFilter();
    },

    /**
     * @summary Attach/detach a filter to a Hypergrid.
     * @param {FilterTree} [filter] - The filter object. If undefined, any attached filter is removed, turning filtering OFF.
     * @memberOf Behavior.prototype
     */
    setGlobalFilter: function(filter) {
        this.dataModel.setGlobalFilter(filter);
    },

    /**
     * @summary Set the case sensitivity of filter tests against data.
     * @desc Case sensitivity pertains to string compares only. This includes untyped columns, columns typed as strings, typed columns containing data that cannot be coerced to type or when the filter expression operand cannot be coerced.
     *
     * NOTE: This is a shared property and affects all grid managed by this instance of the app.
     * @param {boolean} isSensitive
     * @memberOf Behavior.prototype
     */
    setGlobalFilterCaseSensitivity: function(isSensitive) {
        this.dataModel.setGlobalFilterCaseSensitivity(isSensitive);
    },

    /**
     * @param {number|string} columnIndexOrName - The _column filter_ to set.
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @param {boolean} [options.syntax='CQL'] - The syntax to use to describe the filter state. Note that `getFilter`'s default syntax, `'CQL'`, differs from the other get state methods.
     * @returns {FilterTreeStateObject}
     * @memberOf Behavior.prototype
     */
    getFilter: function(columnIndexOrName, options) {
        return this.dataModel.getFilter(columnIndexOrName, options);
    },

    /**
     * @summary Set a particular column filter's state.
     * @desc After setting the new filter state, reapplies the filter to the data source.
     * @param {number|string} columnIndexOrName - The _column filter_ to set.
     * @param {string|object} [state] - A filter tree object or a JSON, SQL, or CQL subexpression string that describes the a new state for the named column filter. The existing column filter subexpression is replaced with a new node based on this state. If it does not exist, the new subexpression is added to the column filters subtree (`filter.columnFilters`).
     *
     * If undefined, removes the entire column filter subexpression from the column filters subtree.
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @param {string} [options.syntax='CQL'] - The syntax to use to describe the filter state. Note that `setFilter`'s default syntax, `'CQL'`, differs from the other get state methods.
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf Behavior.prototype
     */
    setFilter: function(columnIndexOrName, state, options) {
        this.dataModel.setFilter(columnIndexOrName, state, options);
    },

    /**
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @returns {FilterTreeStateObject}
     * @memberOf Behavior.prototype
     */
    getFilters: function(options) {
        return this.dataModel.getFilters(options);
    },

    /**
     * @param {FilterTreeStateObject} state
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf Behavior.prototype
     */
    setFilters: function(state, options) {
        this.dataModel.setFilters(state, options);
    },

    /**
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @returns {FilterTreeStateObject}
     * @memberOf Behavior.prototype
     */
    getTableFilter: function(options) {
        return this.dataModel.getTableFilter(options);
    },

    /**
     * @param {FilterTreeStateObject} state
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf Behavior.prototype
     */
    setTableFilter: function(state, options) {
        this.dataModel.setTableFilter(state, options);
    },

    getSelectedRows: function() {
        return this.grid.selectionModel.getSelectedRows();
    },

    getSelectedColumns: function() {
        return this.grid.selectionModel.getSelectedColumns();
    },

    getSelections: function() {
        return this.grid.selectionModel.getSelections();
    },

    getData: function() {
        return this.dataModel.getData();
    },

    getFilteredData: function() {
        return this.dataModel.getFilteredData();
    },
});

module.exports = Behavior;

},{"../dialogs":88,"../filter/DefaultFilter":108,"../lib/Base":110,"./Column":57,"object-iterators":46}],57:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');

var propertyNames = [
    'index',
    'name',
    'header',
    'type'
];

/** @summary Create a new `Column` object.
 * @constructor
 * @param behavior
 * @param {number|object} indexOrOptions - If a number, shorthand for `options.index`.
 *
 * For positive values of `options.index`, see {@link Column#initialize|initialize}. Note that for new columns, you must supply either `index` or `name`. If you supply both, they must match the definitiion in data model's `fields` list.
 *
 * Negative values are special cases:
 * `index` | Meaning
 * :-----: | --------
 *    -1   | Row header column
 *    -2   | Tree (drill-down) column
 *
 *
 */
function Column(behavior, indexOrOptions) {
    this.behavior = behavior;
    this.dataModel = behavior.dataModel;
    this.cellProperties = [];

    var options = typeof indexOrOptions === 'object' ? indexOrOptions : { index: indexOrOptions },
        index = options.index;

    switch (index) {

        case -1:
            this.index = index;
            this.name = '';
            this.header = '';
            break;

        case -2:
            this.index = index;
            this.name = 'tree';
            this.header = 'Tree';
            break;

        default:
            if (index < 0) {
                throw '`index` out of range';
            } else {
                this.set(options);
            }

    }
}

Column.prototype = {
    constructor: Column.prototype.constructor,

    /** @summary Set or reset the properties of a column object.
     * @desc When (re)setting a column object, the object must end up with fully defined `index` and `name` properties. If one is missing it will be derived from the data model's `fields` list.
     * Note: These properties of the column object should not be confused with the members of the columnProperties object which supports grid render and is something else entirely.
     * @param {object} options - Required because you must supply at least `index` or `name`.
     * @param {object} [options.index]
     * @param {object} [options.name]
     * @param {object} [options.header]
     * @param {object} [options.type]
     */
    set: function(options) {
        var fields = this.dataModel.getFields();
        var column = this;
        propertyNames.forEach(function(option) {
            if (option in options) {
                column[option] = options[option];
            }

            if (option === 'name') {
                if (column.name === undefined) {
                    column.name = fields[column.index];
                } else if (column.index === undefined) {
                    column.index = fields.indexOf(column.name);
                }

                if (column.index === undefined || column.name === undefined) {
                    throw 'Expected column name or index.';
                } else if (fields[column.index] !== column.name) {
                    throw 'Expected to find `column.name` in position `column.index` in data model\'s fields list.';
                }
            }
        });
    },

    set header(value) {
        this._header = value;
        this.dataModel.getHeaders()[this.index] = value;
    },

    get header() {
        return this._header;
    },

    getUnfilteredValue: function(y) {
        return this.dataModel.getUnfilteredValue(this.index, y);
    },

    getValue: function(y) {
        return this.dataModel.getValue(this.index, y);
    },

    setValue: function(y, value) {
        return this.dataModel.setValue(this.index, y, value);
    },

    getWidth: function() {
        var properties = this.getProperties();
        return properties && properties.width || this.behavior.resolveProperty('defaultColumnWidth');
    },

    setWidth: function(width) {
        this.getProperties().width = Math.max(5, width);
    },

    getCellRenderer: function(config, y) {
        config.x = this.index;
        config.y = y;

        var declaredRendererName =
            this.getCellProperties(y).renderer ||
            this.getProperties().renderer;

        var renderer = this.dataModel.getCell(config, declaredRendererName);
        renderer.config = config;
        return renderer;
    },

    getCellProperties: function(y) {
        y = this.dataModel.getDataIndex(y);
        return this.cellProperties[y] || {};
    },

    setCellProperties: function(y, value) {
        this.cellProperties[y] = value;
    },

    clearAllCellProperties: function() {
        this.cellProperties.length = 0;
    },

    checkColumnAutosizing: function(force) {
        var properties = this.getProperties();
        var a, b, d;
        if (properties) {
            a = properties.width;
            b = properties.preferredWidth || a;
            d = properties.columnAutosized && !force;
            if (a !== b || !d) {
                properties.width = !d ? b : Math.max(a, b);
                properties.columnAutosized = !isNaN(properties.width);
            }
        }
    },

    getCellType: function(y) {
        var value = this.getValue(y);
        var type = this.typeOf(value);
        return type;
    },

    getType: function() {
        var props = this.getProperties();
        var type = props.type;
        if (!type) {
            type = this.computeColumnType();
            if (type !== 'unknown') {
                props.type = type;
            }
        }
        return type;
    },

    computeColumnType: function() {
        var headerRowCount = this.behavior.getHeaderRowCount();
        var height = this.behavior.getRowCount();
        var value = this.getValue(headerRowCount);
        var eachType = this.typeOf(value);
        if (!eachType) {
            return 'unknown';
        }
        var type = this.typeOf(value);
        var isNumber = ((typeof value) === 'number');
        for (var y = headerRowCount; y < height; y++) {
            value = this.getValue(y);
            eachType = this.typeOf(value);
            if (type !== eachType) {
                if (isNumber && (typeof value === 'number')) {
                    type = 'float';
                } else {
                    return 'mixed';
                }
            }
        }
        return type;
    },

    typeOf: function(something) {
        if (something == null) {
            return null;
        }
        var typeOf = typeof something;
        switch (typeOf) {
            case 'object':
                return something.constructor.name.toLowerCase();
            case 'number':
                return parseInt(something) === something ? 'int' : 'float';
            default:
                return typeOf;
        }
    },

    getProperties: function() {
        return this.behavior.getPrivateState().columnProperties[this.index];
    },

    setProperties: function(properties) {
        var current = this.getProperties();
        this.clearObjectProperties(current, false);
        _(current).extendOwn(properties);
    },

    toggleSort: function(keys) {
        this.dataModel.toggleSort(this.index, keys);
    },

    unSort: function(deferred) {
        this.dataModel.unSortColumn(this.index, deferred);
    },

    /**
     * This method determines the proposed cell editor name from the render properties. The algorithm is:
     * 1. `editor` render property (cell editor name)
     * 2. `format` render property (localizer name)
     * 3. `type` column property (type name)
     *
     * Note that "render property" means in each case the first defined property found on the cell, column, or grid.
     *
     * @param {number} y - The original untranslated row index.
     * @param {object} options - Will be decorated with `format` and `column`.
     * @param {Point} options.editPoint
     * @returns {undefined|CellEditor} Falsy value means either no declared cell editor _or_ instantiation aborted by falsy return return from fireRequestCellEdit.
     */
    getCellEditorAt: function(y, options) {
        var cellEditor,
            cellProps = this.getCellProperties(y),
            columnProps = this.getProperties(),
            editorName = cellProps.editor || columnProps.editor;

        options.format = cellProps.format || columnProps.format;

        cellEditor = this.dataModel.getCellEditorAt(this.index, y, editorName, options);

        if (cellEditor && !cellEditor.grid) {
            // cell editor returned but not fully instantiated (aborted by falsy return from fireRequestCellEdit)
            cellEditor = undefined;
        }

        return cellEditor;
    },

    getFormatter: function() {
        var localizerName = this.getProperties().format;
        return this.behavior.grid.localization.get(localizerName).format;
    }
};

module.exports = Column;

},{"object-iterators":46}],58:[function(require,module,exports){
'use strict';

var Local = require('./Local');
var DataModelJSON = require('../dataModels/JSON');
var ColumnSchemaFactory = require('../filter/ColumnSchemaFactory');
var features = require('../features');
var aggregations = require('../Shared.js').analytics.util.aggregations;

/**
 * @name behaviors.JSON
 * @desc > Same parameters as {@link behaviors.Behavior#initialize|initialize}, which is called by this constructor.
 * @constructor
 */
var JSON = Local.extend('behaviors.JSON', {

    /**
     * @summary Constructor logic, called _after_{@link Behavior#initialize|Behavior.initialize()}.
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     *
     * @param grid - the hypergrid
     * @param {undefined|function|menuItem[]} schema - Already consumed by Behavior's {@link Behavior#initialize|initialize}.
     * @param {object[]} dataRows - May be:
     * * An array of congruent raw data objects
     * * A function returning same
     * @memberOf behaviors.JSON.prototype
     */
    initialize: function(grid, schema, dataRows) {
        this.setData(dataRows, schema);
    },

    features: [
        features.CellSelection,
        features.KeyPaging,
        features.ColumnPicker,
        features.ColumnResizing,
        features.RowResizing,
        features.Filters,
        features.RowSelection,
        features.ColumnSelection,
        features.ColumnMoving,
        features.ColumnSorting,
        features.CellEditing,
        features.CellClick,
        features.OnHover
    ],

    aggregations: aggregations,

    createColumns: function() {
        var dataModel = this.dataModel;
        var columnCount = dataModel.getColumnCount();
        var headers = dataModel.getHeaders();
        var fields = dataModel.getFields();
        var REGEX_CAMEL_CASE = /([^_A-Z])([A-Z]+)/g;
        this.clearColumns();
        for (var index = 0; index < columnCount; index++) {
            var header = headers[index];
            var column = this.addColumn({ index: index, header: header });
            this.columnEnum[column.name.replace(REGEX_CAMEL_CASE, '$1_$2').toUpperCase()] = index;
            var properties = column.getProperties();
            properties.field = fields[index];
            properties.header = header;
            properties.complexFilter = null;
        }
    },

    getNewDataModel: function() {
        return new DataModelJSON(this.grid);
    },

    applyAnalytics: function() {
        this.dataModel.applyAnalytics();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the header labels.
     * @param {string[]} headerLabels - The header labels.
     */
    setHeaders: function(headerLabels) {
        this.dataModel.setHeaders(headerLabels);
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the fields array.
     * @param {string[]} fieldNames - The field names.
     */
    setFields: function(fieldNames) {
        //were defining the columns based on field names....
        //we must rebuild the column definitions
        this.dataModel.setFields(fieldNames);
        this.createColumns();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the data field.
     * @param {object[]} dataRows - An array of uniform objects backing the rows in the grid.
     */
    setData: function(dataRows, options) {
        var self = this,
            grid = this.grid;

        this.dataModel.setData(dataRows, options);
        this.createColumns();

        this.schema = options && options.schema || deriveSchema;
        this.setGlobalFilter(this.getNewFilter());

        if (grid.cellEditor) {
            grid.cellEditor.cancelEditing();
        }

        if (grid.isColumnAutosizing()) {
            setTimeout(function() {
                self.autosizeAllColumns();
            }, 100);
            grid.allowEvents(dataRows.length);
        } else {
            setTimeout(function() {
                self.getColumn(-1).checkColumnAutosizing(true);
                grid.allowEvents(dataRows.length);
            });
        }
    },

    /**
     * @summary Set the top totals.
     * @memberOf behaviors.JSON.p rototype
     * @param {Array<Array>} totalRows - array of rows (arrays) of totals
     */
    setTopTotals: function(totalRows) {
        this.dataModel.setTopTotals(totalRows);
    },

    /**
     * @summary Get the top totals.
     * @memberOf behaviors.JSON.prototype
     * @returns {Array<Array>}
     */
    getTopTotals: function() {
        return this.dataModel.getTopTotals();
    },

    /**
     * @summary Set the bottom totals.
     * @memberOf behaviors.JSON.prototype
     * @param {Array<Array>} totalRows - array of rows (arrays) of totals
     */
    setBottomTotals: function(totalRows) {
        this.dataModel.setBottomTotals(totalRows);
    },

    /**
     * @summary Get the bottom totals.
     * @memberOf behaviors.JSON.prototype
     * @returns {Array<Array>}
     */
    getBottomTotals: function() {
        return this.dataModel.getBottomTotals();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Build the fields and headers from the supplied column definitions.
     * ```javascript
     * myJsonBehavior.setColumns([
     *     { header: 'Stock Name', name: 'short_description' },
     *     { header: 'Status', name: 'trading_phase' },
     *     { header: 'Reference Price', name: 'reference_price' }
     * ]);
     * ```
     * @param {Array} columnDefinitions - an array of objects with fields 'title', and 'field'
     */
    setColumns: function(columnDefinitions) {
        this.dataModel.setColumns(columnDefinitions); // TODO: this method is missing
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Enhance the double-click event just before it's broadcast to listeners.
     * @param {Point} event
     */
    enhanceDoubleClickEvent: function(event) {
        event.row = this.getRow(event.gridCell.y);
    },

    setDataProvider: function(dataProvider) {
        this.dataModel.setDataProvider(dataProvider);
    },

    hasHierarchyColumn: function() {
        return this.dataModel.hasHierarchyColumn();
    },

    getColumnAlignment: function(x) {
        if (x === 0 && this.hasHierarchyColumn()) {
            return 'left';
        } else {
            return 'center';
        }
    },


    getRowSelectionMatrix: function(selectedRows) {
        return this.dataModel.getRowSelectionMatrix(selectedRows);
    },

    getColumnSelectionMatrix: function(selectedColumns) {
        return this.dataModel.getColumnSelectionMatrix(selectedColumns);
    },

    getSelectionMatrix: function(selections) {
        return this.dataModel.getSelectionMatrix(selections);
    },

    getRowSelection: function() {
        var selectedRows = this.getSelectedRows();
        return this.dataModel.getRowSelection(selectedRows);
    },

    getColumnSelection: function() {
        var selectedColumns = this.getSelectedColumns();
        return this.dataModel.getColumnSelection(selectedColumns);
    },

    getSelection: function() {
        var selections = this.getSelections();
        return this.dataModel.getSelection(selections);
    },

    getGroups: function() {
        return this.dataModel.getGroups();
    },
    getAvailableGroups: function() {
        return this.dataModel.getAvailableGroups();
    },
    getHiddenColumns: function() {
        return this.dataModel.getHiddenColumns();
    },

    getActiveColumns: function() {
        return this.dataModel.getActiveColumns();
    },
    getVisibleColumns: function() {
        this.deprecated('getVisibleColumns()', 'getActiveColumns()', '1.0.6', arguments);
    },

    getSelectedRows: function() {
        var offset = -this.grid.getHeaderRowCount();
        var selections = this.grid.selectionModel.getSelectedRows();
        var result = selections.map(function(each) {
            return each + offset;
        });
        return result;
    },

    getSelectedColumns: function() {
        return this.grid.selectionModel.getSelectedColumns();
    },

    getSelections: function() {
        return this.grid.selectionModel.getSelections();
    },

    getSortedColumnIndexes: function(){
      return this.dataModel.getSortedColumnIndexes();
    },

    sortChanged: function(hiddenColumns){
        var dirty = removeHiddenColumns(
            this.getSortedColumnIndexes(),
            (hiddenColumns || this.getHiddenColumns())
        );
        if (dirty){
            this.applyAnalytics();
        }
    }

});


function deriveSchema() {
    return new ColumnSchemaFactory(this.columns).schema;
}


//Logic to moved to adapter layer outside of Hypergrid Core
function removeHiddenColumns(oldSorted, hiddenColumns){
    var dirty = false;
    oldSorted.forEach(function(i) {
        var j = 0,
            colIndex;
        while (j < hiddenColumns.length) {
            colIndex = hiddenColumns[j].index + 1; //hack to get around 0 index
            if (colIndex === i) {
                hiddenColumns[j].unSort();
                dirty = true;
                break;
            }
            j++;
        }
    });
    return dirty;
}

module.exports = JSON;

},{"../Shared.js":55,"../dataModels/JSON":83,"../features":106,"../filter/ColumnSchemaFactory":107,"./Local":59}],59:[function(require,module,exports){
'use strict';

//var ListDragon = require('list-dragon');

var Behavior = require('./Behavior');
//var DataModelJSON = require('../dataModels/JSON');
//var features = require('../features');
//var aggregations = require('../local_node_modules/finanalytics').aggregations;

/**
 * @name behaviors.Local
 * @desc > Same parameters as {@link behaviors.Behavior#initialize|initialize}, which is called by this constructor.
 * @constructor
 */
var Local = Behavior.extend('Local', {

});

module.exports = Local;

},{"./Behavior":56}],60:[function(require,module,exports){
'use strict';

var Behavior = require('./Behavior');

var noop = function() {},
    n00p = function() { return 0; };

/**
 * @constructor
 */
var Null = Behavior.extend('Null', {

    //initalize: function(grid, component) {},

    setScrollPositionY: noop,
    setScrollPositionX: noop,
    getActiveColumnCount: n00p,
    getFixedColumnCount: n00p,
    getFixedColumnsWidth: n00p,
    getFixedColumnsMaxWidth: n00p,
    setRenderedWidth: n00p,
    getRowCount: n00p,
    getFixedRowCount: n00p,
    getFixedRowsHeight: n00p,
    getFixedRowsMaxHeight: n00p,
    setRenderedHeight: n00p,
    getCellProvider: noop,
    click: noop,
    doubleClick: noop
});

module.exports = Null;

},{"./Behavior":56}],61:[function(require,module,exports){
'use strict';

module.exports = {
    Behavior: require('./Behavior'), // abstract base class
    JSON: require('./JSON'),
    Null: require('./Null')
};
},{"./Behavior":56,"./JSON":58,"./Null":60}],62:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var mustache = require('mustache');
var _ = require('object-iterators');

var Base = require('../lib/Base');
var effects = require('../lib/effects');
var Localization = require('../lib/Localization');

/**
 * @constructor
 */
var CellEditor = Base.extend('CellEditor', {

    /**
     * @param grid
     * @param {string} options - Properties listed below + arbitrary mustache "variables" for merging into template.
     * @param {Point} options.editPoint
     * @param {string} [options.format] - Name of a localizer with which to override prototype's `localizer` property.
     */
    initialize: function(grid, options) {

        // Establish `this.editPoint` and possibly `this.format`; plus other arbitrary properties for mustache use.
        for (var key in options) {
            if (options.hasOwnProperty(key) && this[key] !== null) {
                this[key] = options[key];
            }
        }

        var value = grid.behavior.getValue(this.editPoint.x, this.editPoint.y);
        if (value instanceof Array) {
            value = value[1]; //it's a nested object
        }

        /**
         * my instance of hypergrid
         * @type {Hypergrid}
         * @memberOf CellEditor.prototype
         */
        this.grid = grid;

        this.grid.cellEditor = this;

        this.locale = grid.localization.locale; // for template's `lang` attribute

        // override native localizer with localizer named in format if defined (from instantiation options)
        if (this.format) {
            this.localizer = this.grid.localization.get(this.format);
        }

        this.initialValue = value;

        var container = document.createElement('DIV');
        container.innerHTML = mustache.render(this.template, this);

        /**
         * This object's input control, one of:
         * * *input element* - an `HTMLElement` that has a `value` attribute, such as `HTMLInputElement`, `HTMLButtonElement`, etc.
         * * *container element* - an `HTMLElement` containing one or more input elements, only one of which contains the editor value.
         *
         * For access to the input control itself (which may or may not be the same as `this.el`), see `this.input`.
         *
         * @type {HTMLElement}
         * @default null
         * @memberOf CellEditor.prototype
         */
        this.el = container.firstChild;

        this.input = this.el;

        this.errors = 0;

        var self = this;
        this.el.addEventListener('keyup', this.keyup.bind(this));
        this.el.addEventListener('keydown', function(e) {
            grid.fireSyntheticEditorKeyDownEvent(self, e);
        });
        this.el.addEventListener('keypress', function(e) {
            grid.fireSyntheticEditorKeyPressEvent(self, e);
        });
        this.el.onblur = function(e) {
            self.cancelEditing();
        };
    },

    localizer: Localization.prototype.null,

    specialKeyups: {
        //0x08: 'clearStopEditing', // backspace
        0x09: 'stopEditing', // tab
        0x0d: 'stopEditing', // return/enter
        0x1b: 'cancelEditing' // escape
    },

    keyup: function(e) {
        if (e) {
            var specialKeyup = this.specialKeyups[e.keyCode];

            if (specialKeyup) {
                e.preventDefault();
                if (this[specialKeyup](3)) {
                    this.grid.repaint();
                    this.grid.takeFocus();
                }
            }

            this.grid.fireSyntheticEditorKeyUpEvent(this, e);
        }
    },

    /**
     * if true, check that the editor is in the right location
     * @type {boolean}
     * @default false
     * @memberOf CellEditor.prototype
     */
    checkEditorPositionFlag: false,

    /**
     * @memberOf CellEditor.prototype
     * @desc This function is a callback from the fin-hypergrid.   It is called after each paint of the canvas.
     */
    gridRenderedNotification: function() {
        this.checkEditor();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc scroll values have changed, we've been notified
     */
    scrollValueChangedNotification: function() {
        this.checkEditorPositionFlag = true;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc move the editor to the current editor point
     */
    moveEditor: function() {
        var cellBounds = this.grid._getBoundsOfCell(this.editPoint.x, this.editPoint.y);

        //hack to accommodate bootstrap margin issues...
        var xOffset =
            this.grid.div.getBoundingClientRect().left -
            this.grid.divCanvas.getBoundingClientRect().left;

        cellBounds.x -= xOffset;

        this.setBounds(cellBounds);
    },

    beginEditing: function() {
        if (this.grid.fireRequestCellEdit(this.editPoint, this.initialValue)) {
            this.checkEditorPositionFlag = true;
            this.checkEditor();
        }
    },
    beginEditAt: function(Constructor, name) {
        this.deprecated('beginEditAt(point)', 'beginEditing()', '1.0.6');
    },

    /**
     * @summary Put the value into our editor.
     * @desc Formats the value and displays it.
     * The localizer's {@link localizerInterface#format|format} method will be called.
     *
     * Override this method if your editor has additional or alternative GUI elements.
     *
     * @param {object} value - The raw unformatted value from the data source that we want to edit.
     * @memberOf CellEditor.prototype
     */
    setEditorValue: function(value) {
        this.input.value = this.localizer.format(value);
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc display the editor
     */
    showEditor: function() {
        this.el.style.display = 'inline';
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc hide the editor
     */
    hideEditor: function() {
        this.el.style.display = 'none';
    },

    /** @summary Stops editing.
     * @desc Before saving, validates the edited value in two phases as follows:
     * 1. Call `validateEditorValue`. (Calls the localizer's `invalid()` function, if available.)
     * 2. Catch any errors thrown by the {@link CellEditor#getEditorValue|getEditorValue} method.
     *
     * **If the edited value passes both phases of the validation:**
     * Saves the edited value by calling the {@link CellEditor#saveEditorValue|saveEditorValue} method.
     *
     * **On validation failure:**
     * 1. If `feedback` was omitted, cancels editing, discarding the edited value.
     * 2. If `feedback` was provided, gives the user some feedback (see `feedback`, below).
     *
     * @param {number} [feedback] What to do on validation failure:
     * * If omitted, simply cancels editing without saving edited value.
     * * If 0, shows the error feedback effect (see the {@link CellEditor#errorEffect|errorEffect} property).
     * * If > 0, shows the error feedback effect _and_ calls the {@link CellEditor#errorEffectEnd|errorEffectEnd} method) every `feedback` call(s) to `stopEditing`.
     * @returns {boolean} Truthy means successful stop. Falsy means syntax error prevented stop. Note that editing is canceled when no feedback requested and successful stop includes (successful) cancel.
     * @memberOf CellEditor.prototype
     */
    stopEditing: function(feedback) {
        /**
         * @type {boolean|string|Error}
         */
        var error = this.validateEditorValue();

        if (!error) {
            try {
                var value = this.getEditorValue();
            } catch (err) {
                error = err;
            }
        }

        if (!error && this.grid.fireSyntheticEditorDataChangeEvent(this, this.initialValue, value)) {
            try {
                this.saveEditorValue(value);
            } catch (err) {
                error = err;
            }
        }

        if (!error) {
            this.hideEditor();
            this.grid.cellEditor = null;
            this.el.remove();
        } else if (feedback >= 0) { // never true when `feedback` undefined
            var point = this.editPoint;
            this.grid.selectViewportCell(point.x, point.y - this.grid.getHeaderRowCount());
            this.errorEffectBegin(++this.errors % feedback === 0 && error);
        } else { // invalid but no feedback
            return this.cancelEditing();
        }

        return !error;
    },

    /** @summary Cancels editing.
     * @returns {boolean} Successful. (Cancel is always successful.)
     */
    cancelEditing: function() {
        if (this.grid.cellEditor) { // because stopEditing's .remove triggers blur which comes here
            this.setEditorValue(this.initialValue);
            this.hideEditor();
            this.grid.cellEditor = null;
            this.el.remove();
        }
        return true;
    },

    /**
     * Calls the effect function indicated in the {@link CellEditor#errorEffect|errorEffect} property which triggers a series of CSS transitions.
     * @param {boolean|string|Error} [error] - If defined, call the {@link CellEditor#errorEffectEnd|errorEffectEnd} method at the end of the last effect transition with this error.
     * @memberOf CellEditor.prototype
     */
    errorEffectBegin: function(error) {
        var options = { callback: error && this.errorEffectEnd.bind(this, error) },
            effect = this.errorEffect;

        if (typeof effect === 'string') {
            effect = this.errorEffects[effect];
        }

        if (typeof effect === 'object') {
            _(options).extendOwn(effect.options);
            effect = effect.effector;
        }

        if (typeof effect === 'function') {
            effect.call(this, options);
        } else {
            throw 'Expected `this.errorEffect` to resolve to an error effect function.';
        }
    },

    /**
     * This function expects to be passed an error. There is no point in calling this function if there is no error. Nevertheless, if called with a falsy `error`, returns without doing anything.
     * @this {CellEditor}
     * @param {boolean|string|Error} [error]
     */
    errorEffectEnd: function(error) {
        if (error) {
            var msg =
                'Invalid value. To resolve, do one of the following:\n\n' +
                '   * Correct the error and try again.\n' +
                '         - or -\n' +
                '   * Cancel editing by pressing the "esc" (escape) key.';

            error = error.message || error;

            if (typeof error !== 'string') {
                error = '';
            }

            if (this.localizer.expectation) {
                error = error ? error + '\n' + this.localizer.expectation : this.localizer.expectation;
            }

            if (error) {
                error = '\n' + error;
                error = error.replace(/[\n\r]+/g, '\n\n   * ');
                msg += '\n\nAdditional information about this error:' + error;
            }

            alert(msg); // eslint-disable-line no-alert
        }
    },

    /** @typedef effectObject
     * @property {effectFunction} effector
     * @property {object} [options] - An options object with which to call the function.
     */
    /**
     * May be one of:
     * * **string** - Name of registered error effect.
     * * **effectFunction** - Reference to an effect function.
     * * **effectObject** - Reference to an effectObject containing an {@link effectFunction} and an `options` object with which to call the function.
     * @type {string|effectFunction|effectObject}
     * @memberOf CellEditor.prototype
     */
    errorEffect: 'shaker',

    /**
     * Hash of registered {@link effectFunction}s or {@link effectObject}s.
     * @memberOf CellEditor.prototype
     */
    errorEffects: {
        shaker: effects.shaker,
        glower: effects.glower
    },

    /**
     * @desc save the new value into the behavior (model)
     * @memberOf CellEditor.prototype
     */
    saveEditorValue: function(value) {
        var point = this.editPoint;

        if (
            !(value && value === this.initialValue) && // data changed
            this.grid.fireBeforeCellEdit(point, this.initialValue, value, this) // not aborting
        ) {
            this.grid.behavior.setValue(point.x, point.y, value);
            this.grid.fireAfterCellEdit(point, this.initialValue, value, this);
        }
    },

    /**
     * @summary Extract the edited value from the editor.
     * @desc De-format the edited string back into a primitive value.
     *
     * The localizer's {@link localizerInterface#parse|parse} method will be called on the text box contents.
     *
     * Override this method if your editor has additional or alternative GUI elements. The GUI elements will influence the primitive value, either by altering the edited string before it is parsed, or by transforming the parsed value before returning it.
     * @returns {object} the current editor's value
     * @memberOf CellEditor.prototype
     */
    getEditorValue: function() {
        return this.localizer.parse(this.input.value);
    },

    /**
     * If there is no validator on the localizer, returns falsy (not invalid; possibly valid).
     * @returns {boolean|string} Truthy value means invalid. If a string, this will be an error message. If not a string, it merely indicates a generic invalid result.
     */
    validateEditorValue: function() {
        return this.localizer.invalid && this.localizer.invalid(this.input.value);
    },

    /**
     * @summary Request focus for my input control.
     * @desc See GRID-95 "Scrollbar moves inward" for issue and work-around explanation.
     * @memberOf CellEditor.prototype
     */
    takeFocus: function() {
        var el = this.el,
            leftWas = el.style.left,
            topWas = el.style.top;

        el.style.left = el.style.top = 0; // work-around: move to upper left

        this.input.focus();
        this.selectAll();

        el.style.left = leftWas;
        el.style.top = topWas;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc select everything
     */
    selectAll: nullPattern,

    /**
     * @memberOf CellEditor.prototype
     * @desc set the bounds of my input control
     * @param {rectangle} rectangle - the bounds to move to
     */
    setBounds: function(cellBounds) {
        var input = this.el;

        input.style.position = 'absolute';
        input.style.left = px(cellBounds.x - 1);
        input.style.top = px(cellBounds.y - 1);
        input.style.width = px(cellBounds.width + 2);
        input.style.height = px(cellBounds.height + 2);
    },

    /**
     * @desc check that the editor is in the correct location, and is showing/hidden appropriately
     * @memberOf CellEditor.prototype
     */
    checkEditor: function() {
        if (this.checkEditorPositionFlag) {
            this.checkEditorPositionFlag = false;
            if (this.grid.isDataVisible(this.editPoint.x, this.editPoint.y)) {
                this.setEditorValue(this.initialValue);
                this.attachEditor();
                this.moveEditor();
                this.showEditor();
                this.takeFocus();
            } else {
                this.hideEditor();
            }
        }
    },

    attachEditor: function() {
        var input = this.el,
            div = this.grid.div,
            referenceNode = div.querySelectorAll('.finbar-horizontal, .finbar-vertical');

        div.insertBefore(input, referenceNode.length ? referenceNode[0] : null);
    },

    template: ''

});

function nullPattern() {}
function px(n) { return n + 'px'; }


CellEditor.abstract = true; // don't instantiate directly


module.exports = CellEditor;

},{"../lib/Base":110,"../lib/Localization":111,"../lib/effects":116,"mustache":45,"object-iterators":46}],63:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor');

/**
 * As of spring 2016:
 * Functions well in Chrome and Firefox; unimplemented in Safari.
 * @constructor
 */
var Color = CellEditor.extend('Color', {

    template: '<input type="color" lang="{{locale}}" style="{{style}}">'

});

module.exports = Color;

},{"./CellEditor":62}],64:[function(require,module,exports){
// ComboBox.js - A combo-box is a combination of a text-box and a drop-down.
// User may type into it and/or select an item from the drop-down (by clicking on the triangle at the right).
// The drop-down has sections which are toggled from a control area between the text-box and the drop-down.

/* eslint-env browser */

'use strict';

var Textfield = require('./Textfield');
var prototype = require('./CellEditor').prototype;
var Queueless = require('../lib/queueless');
var elfor = require('../lib/elfor');

/*********************************/
/* eslint-disable no-unused-vars */
/*********************************/

var TOGGLE_MODE_PREFIX = 'toggle-mode-';

var stateToActionMap = {
    hidden: slideDown,
    visible: slideUp
};

/**
 * A combo box is a text box that also has a drop-down containing options. The drop-down consists of an actual drop-down list (a `<select>` list) plus a _control area_ above it containing toggles. The toggles control the visibility of the various "mode lists."
 *
 * Functions well in Chrome, Safari, Firefox, and Internet Explorer.
 * @constructor
 */
var ComboBox = Textfield.extend('ComboBox', {

    initialize: function() {
        var el = this.el;

        this.input = el.querySelector('input');
        this.dropper = el.querySelector('span');
        this.options = el.querySelector('div');
        this.controls = this.options.querySelector('div');
        this.dropdown = this.options.querySelector('select');

        this.controllable = this.modes.length > 1;

        // set up a transition end controller
        this.optionsTransition = new Queueless(this.options, this);

        this.menuModesSource = this.column.menuModes || { distinctValues: true };

        // wire-ups
        this.dropper.addEventListener('mousedown', this.toggleDropDown.bind(this));
        this.dropdown.addEventListener('mousewheel', function(e) { e.stopPropagation(); });
        this.dropdown.addEventListener('change', this.insertText.bind(this));
        el.onblur = null; // void this one, set by super's initialize
    },

    template: [
'<div class="hypergrid-input" title="">',
'    <input type="text" lang="{{locale}}" style="{{style}}">',
'    <span title="Click for options"></span>',
'    <div>',
'        <div></div>',
'        <select size="12" lang="{{locale}}"></select>',
'    </div>',
'</div>'
    ].join('\n'),

    modes: [
        {
            name: 'distinctValues',
            appendOptions: function(optgroup) {
                // get the distinct column values and sort them
                var distinct = {},
                    d = [],
                    columnName = this.column.name,
                    formatter = this.column.getFormatter();

                this.grid.behavior.getData().forEach(function(dataRow) {
                    var val = formatter(dataRow[columnName]);
                    distinct[val] = (distinct[val] || 0) + 1;
                });

                for (var key in distinct) {
                    d.push(key);
                }

                while (optgroup.firstElementChild) {
                    optgroup.firstElementChild.remove();
                }

                d.sort().forEach(function(val) {
                    var option = new Option(val + ' (' + distinct[val] + ')', val);
                    optgroup.appendChild(option);
                });

                return d.length;
            }
        }
    ],

    showEditor: function() {
        var menuModesSource = this.menuModesSource,
            menuModes = this.menuModes = {};

        // build the proxy
        this.modes.forEach(function(mode) {
            var modeName = mode.name;
            if (modeName in menuModesSource) {
                menuModes[modeName] = menuModesSource[modeName];
            }
        });

        // wire-ups
        if (this.controllable) {
            this.controls.addEventListener('click', onModeIconClick.bind(this));
        }

        // set the initial state of the mode toggles
        this.modes.forEach(function(mode) {
            // create a toggle
            var toggle = document.createElement('span');
            if (this.controllable) {
                toggle.className = TOGGLE_MODE_PREFIX + mode.name;
                toggle.title = 'Toggle ' + (mode.label || mode.name).toLowerCase();
                toggle.textContent = mode.symbol;
            }
            this.controls.appendChild(toggle);

            // create and label a new optgroup
            if (mode.selector) {
                var optgroup = document.createElement('optgroup');
                optgroup.label = mode.label;
                optgroup.className = 'submenu-' + mode.name;
                optgroup.style.backgroundColor = mode.backgroundColor;
                this.dropdown.add(optgroup);
            }

            setModeIconAndOptgroup.call(this, toggle, mode.name, menuModes[mode.name]);
        }.bind(this));

        prototype.showEditor.call(this);
    },

    hideEditor: function() {
        // this is where you would persist this.menuModes
        prototype.hideEditor.call(this);
    },

    toggleDropDown: function() {
        if (!this.optionsTransition.transitioning) {
            var state = window.getComputedStyle(this.dropdown).visibility;
            stateToActionMap[state].call(this);
        }
    },

    insertText: function(e) {
        // replace the input text with the drop-down text
        this.input.focus();
        this.input.value = this.dropdown.value;
        this.input.setSelectionRange(0, this.input.value.length);

        // close the drop-down
        this.toggleDropDown();
    }
});

function onModeIconClick(e) {
    var ctrl = e.target;

    if (ctrl.tagName === 'SPAN') {
        // extra ct the mode name from the toggle control's class name
        var modeClassName = Array.prototype.find.call(ctrl.classList, function(className) {
                return className.indexOf(TOGGLE_MODE_PREFIX) === 0;
            }),
            modeName = modeClassName.substr(TOGGLE_MODE_PREFIX.length);

        // toggle mode in the filter
        var modeState = this.menuModes[modeName] ^= 1;

        setModeIconAndOptgroup.call(this, ctrl, modeName, modeState);
    }
}

function setModeIconAndOptgroup(ctrl, name, state) {
    var style, optgroup, sum, display,
        mode = this.modes.find(function(mode) { return mode.name === name; }); // eslint-disable-line no-shadow

    // set icon state (color)
    ctrl.classList.toggle('active', !!state);

    // empty the optgroup if hiding; rebuild it if showing
    if (state) { // rebuild it
        // show progress cursor for (at least) 1/3 second
        style = this.el.style;
        style.cursor = 'progress';
        setTimeout(function() { style.cursor = null; }, 333);

        if (mode.selector) {
            optgroup = this.dropdown.querySelector(mode.selector);
            sum = mode.appendOptions.call(this, optgroup);

            // update sum
            optgroup.label = optgroup.label.replace(/ \(\d+\)$/, ''); // remove old sum
            optgroup.label += ' (' + sum + ')';
        } else {
            sum = mode.appendOptions.call(this, this.dropdown);
            if (!this.controllable) {
                ctrl.textContent = sum + ' values';
            }
        }

        display = null;
    } else {
        display = 'none';
    }

    // hide/show the group
    elfor.each(
        mode.selector || ':scope>option,:scope>optgroup:not([class])',
        function iteratee(el) { el.style.display = display; },
        this.dropdown
    );

    // TODO: Reset the width of this.options to the natural width of this.dropdown. To do this, we need to remove the latter's "width: 100%" from the CSS and then set an explicit this.options.style.width based on the computed width of this.dropdown. This is complicated by the fact that it cannot be done before it is in the DOM.
}

function slideDown() {
    // preserve the text box's current text selection, which is about to be lost
    this.selectionStart = this.input.selectionStart;
    this.selectionEnd = this.input.selectionEnd;

    // clean up the select list from last usage
    this.dropdown.selectedIndex = -1; // be kind (remove previous selection)
    this.dropdown.style.scrollTop = 0; // rewind

    // show the drop-down slide down effect
    this.options.style.visibility = 'visible';
    var dropDownHeight = this.dropdown.size * 15;
    this.options.style.height = 2 + 15 + dropDownHeight + 2 + 'px'; // starts the slide down effect

    // while in drop-down, listen for clicks in text box which means abprt
    this.input.addEventListener('mousedown', this.slideUpBound = slideUp.bind(this));

    // wait for transition to end
    this.optionsTransition.begin();
}

function slideUp() {
    // stop listening to input clicks
    this.input.removeEventListener('mousedown', this.slideUpBound);

    // start the slide up effect
    this.options.style.height = 0;

    // schedule the hide to occur after the slide up effect
    this.optionsTransition.begin(function(event) {
        this.style.visibility = 'hidden';
    });
}


module.exports = ComboBox;

},{"../lib/elfor":117,"../lib/queueless":120,"./CellEditor":62,"./Textfield":70}],65:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var CellEditor = require('./CellEditor');

var isChromium = window.chrome,
    winNav = window.navigator,
    vendorName = winNav.vendor,
    isOpera = winNav.userAgent.indexOf('OPR') > -1,
    isIEedge = winNav.userAgent.indexOf('Edge') > -1,
    isIOSChrome = winNav.userAgent.match('CriOS'),
    isChrome = !isIOSChrome &&
        isChromium !== null &&
        isChromium !== undefined &&
        vendorName === 'Google Inc.' &&
        isOpera == false && isIEedge == false; // eslint-disable-line eqeqeq

/**
 * As of spring 2016:
 * Functions well in Chrome except no localization (day, month names; date format).
 * Unimplemented in Safari, Firefox, Internet Explorer.
 * This is a "snmart" control. It detects Chrome:
 * * If Chrome, uses chromeDate overrides format to that required by the value attribute, yyyy-mm-dd. (Note that this is not the format displayed in the control, which is always mm/dd/yyyy.)
 * * Otherwise uses localized date format _but_ falls back to a regular text box.
 * @constructor
 */
var Date = CellEditor.extend('Date', {

    initialize: function(grid) {

        var localizerName,
            usesDateInputControl = isChrome;

        if (usesDateInputControl) {
            localizerName = 'chromeDate';
            this.template = '<input type="date">';
        } else {
            localizerName = 'date';
            this.template = '<input type="text">';

            this.selectAll = function() {
                var lastCharPlusOne = this.getEditorValue().length;
                this.input.setSelectionRange(0, lastCharPlusOne);
            };
        }

        this.localizer = grid.localization.get(localizerName);
    }
});


module.exports = Date;

},{"./CellEditor":62}],66:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var popMenu = require('pop-menu');
var Conditionals = require('../Shared').FilterTree.Conditionals;

var ComboBox = require('./ComboBox');
var prototype = require('./CellEditor').prototype;


/**
 * The select list consists of the following sets of drop-down items:
 * * `operators` (icon *&lt;*) The particular selection of operators for this column. Comes from the filter tree.
 * * `distinctValues` (icon *#*) List of distinct column values. Calculated from inspection of column values on _and_ on icon click.
 * * `columnNames` (icon *T*) List other column names. Calculated from inspection of column values on _and_ on icon click.
 *
 * The control area reflects the `this.modes` array (above). It is modeled by a 'menuModes` object, a hash with boolean properties representing the state of each of the sets of menu items outlined above. Missing properties are falsy by implication. The state semantics are:
 *   * `1` or `true` means adds CSS class `active` to icon _and_ shows set's items in drop-down.
 *   * `0` or `false` means removes (CSS class `active` from icon _and_ hides set's items in drop-down.
 *
 * *Persisting changes:* The only change this UI supports (besides the filter text itself) is the menu mode states, which are expected to be "sticky." That is, they are "persisted" (written back) to the filter. However, there is a problem: When the column filter is blank it doesn't actually exist yet in the filter, so there is nowhere to save it. The solution is to read the `menuModes` hash _from_ the filter tree but don't modify it until end of editing. Reading it from the filter tree picks up previous setting if there was an extant column filter or the default if there was not. But then, rather than modifying this structure (because it might be the default and we don't want to overwrite that), we hang a proxy copy off the behavior's column object for this column. This will persist it for the duration of the app session. At end of editing, if and only if there is now a column filter (text is not blank), we copy it to the column filter's subtree node in the filter tree.
 *
 * @constructor
 */
var FilterBox = ComboBox.extend('FilterBox', {

    initialize: function() {

        // look in the filter, under column filters, for a column filter for this column
        var root = this.grid.getGlobalFilter(),
            columnName = this.column.name,
            columnFilters = this.grid.getGlobalFilter().columnFilters,
            columnFilterSubtree = root.getColumnFilter(columnName) || {},
            columnSchema = root.schema.lookup(columnName) || {};


        // get the operator list from the node, schema, typeOpMap, or root:
        // (This mimics the code in FilterLeaf.js's `getOpMenu` function becauase the node may not exist yet.)
        this.opMenu =

            // pull operator list from column schema if available
            columnSchema.opMenu ||

            // operator list for the column's type if available
            root.typeOpMap && root.typeOpMap[columnSchema.type || columnFilterSubtree.type] ||

            // default operator list (which itself defaults to `Conditionals.defaultOpMenu`)
            root.opMenu;


        // get the column filter's `menuModes` object -- contains the states of the drop-down option icons:
        this.menuModesSource =

            // first try proxy from last time (because editing may have ended without a column filter to put in the filter tree)
            this.column.menuModes ||

            // ELSE try column filter's `menuModes` WHEN available
            columnFilterSubtree.menuModes ||
            columnFilterSubtree.menuModes ||

            // try use column schema's `menuModes` when defined
            columnSchema.menuModes ||

            // ELSE try the filter default (which itself defaults to operators ON, others OFF; see definition at top of DefaultFilter.js)
            columnFilters.menuModes;

    },


    /**
     * When there's only one mode defined here, the control area portion of the UI is hidden.
     */
    modes: [
        {
            name: 'operators',
            symbol: '<',
            appendOptions: function(dropdown) {
                if (!dropdown.length) {
                    // Various  operator options and/or optgroups vary per column based on `opMenu`.
                    popMenu.build(dropdown, this.opMenu, {
                        group: function(groupName) {
                            return Conditionals.groups[groupName];
                        },
                        prompt: null
                    });
                    // This list of conjunctions is an extra and is for all columns. All operator optgroups are classless.
                    var optgroup = document.createElement('optgroup');
                    optgroup.label = 'Conjunctions';
                    optgroup.appendChild(new Option('and', ' and '));
                    optgroup.appendChild(new Option('or', ' or '));
                    optgroup.appendChild(new Option('nor', ' nor '));
                }
            }
        }, {
            name: 'columnNames',
            label: 'Column Names',
            selector: 'optgroup.submenu-columnNames',
            symbol: 'A',
            backgroundColor: '#eff',
            appendOptions: function(optgroup) {
                var columns = this.grid.behavior.columns,
                    x = this.editPoint.x;

                while (optgroup.firstElementChild) {
                    optgroup.firstElementChild.remove();
                }

                columns.forEach(function(column, index) {
                    if (index !== x) {
                        var name = column.name,
                            option = new Option(name);
                        option.title = '[' + name + ']\r"' + column.header + '"';
                        optgroup.appendChild(option);
                    }
                });
                return columns.length;
            }
        }, {
            name: 'distinctValues',
            label: 'Distinct Values',
            selector: 'optgroup.submenu-distinctValues',
            symbol: '#',
            backgroundColor: '#fef',
            appendOptions: ComboBox.prototype.modes[0].appendOptions
        }
    ],

    /**
     * Write the `menuModes` proxy to the filter tree's column filter subtree node.
     * We look up the node again here because it might be new; or may have been deleted & recreated during editing.
     */
    hideEditor: function() {
        // look in the filter, under column filters, for a column filter for this column
        var filter = this.grid.getGlobalFilter(),
            columnName = this.column.name,
            columnFilterSubtree = filter.getColumnFilter(columnName);

        if (columnFilterSubtree) {
            // write back to filter-tree node for persisting with getState
            columnFilterSubtree.menuModes = this.menuModes;
        }

        this.column.menuModes = this.menuModes;

        ComboBox.prototype.hideEditor.call(this);
    },

    keyup: function(e) {
        if (e) {
            prototype.keyup.call(this, e);

            if (this.grid.resolveProperty('filteringMode') === 'immediate') {
                this.saveEditorValue(this.getEditorValue());
                this.moveEditor();
            }
        }
    },

    insertText: function(e) {
        // insert the drop-downb text at the insertion point or over the selected text
        this.input.focus();
        this.input.setRangeText(this.dropdown.value, this.selectionStart, this.selectionEnd, 'end');

        // close the drop-down
        this.toggleDropDown();
    }

});


module.exports = FilterBox;

},{"../Shared":55,"./CellEditor":62,"./ComboBox":64,"pop-menu":47}],67:[function(require,module,exports){
'use strict';

var Textfield = require('./Textfield');

/**
 * Functions well in Chrome, Safari, Firefox, and Internet Explorer.
 * @constructor
 */
var Number = Textfield.extend('Number', {

    initialize: function(grid) {
        this.localizer = grid.localization.get('number');
    }

});

module.exports = Number;

},{"./Textfield":70}],68:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor');

/**
 * @constructor
 */
var Slider = CellEditor.extend('Slider', {

    template: '<input type="range" lang="{{locale}}" style="{{style}}">'

});

module.exports = Slider;

},{"./CellEditor":62}],69:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor.js');

/**
 * @constructor
 */
var Spinner = CellEditor.extend('Spinner', {

    template: '<input type="number" lang="{{locale}}" style="{{style}}">'

});

module.exports = Spinner;

},{"./CellEditor.js":62}],70:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor.js');
var Localization = require('../lib/Localization');


/**
 * As of spring 2016:
 * Functions well in Chrome, Safari, Firefox, and Internet Explorer.
 * @constructor
 */
var Textfield = CellEditor.extend('Textfield', {

    template: '<input type="text" lang="{{locale}}" style="{{style}}">',

    localizer: Localization.prototype.string,

    selectAll: function() {
        var lastCharPlusOne = this.getEditorValue().length;
        this.input.setSelectionRange(0, lastCharPlusOne);
    }
});

module.exports = Textfield;

},{"../lib/Localization":111,"./CellEditor.js":62}],71:[function(require,module,exports){
/**
 * @module cellEditors
 */

'use strict';

/**
 *
 * @param {Hypergrid} grid
 * @param {boolean} [privateRegistry=false] - This instance will use a private registry.
 * @constructor
 */
function CellEditors(grid, privateRegistry) {
    this.grid = grid;

    if (privateRegistry) {
        this.editors = {};
    }

    // preregister the standard cell editors
    if (privateRegistry || !this.get('celleditor')) {
        this.add(require('./CellEditor'));
        this.add(require('./ComboBox'));
        this.add(require('./Color'));
        this.add(require('./Date'));
        this.add(require('./FilterBox'));
        this.add(require('./Number'));
        this.add(require('./Slider'));
        this.add(require('./Spinner'));
        this.add(require('./Textfield'));
    }
}

CellEditors.prototype = {
    constructor: CellEditors.prototype.constructor, // preserve constructor

    /**
     * @summary Register a cell editor constructor.
     * @desc Adds a custom cell editor constructor to the `editors` hash using the provided name (or the class name), converted to all lower case.
     *
     * > All native cell editors are "preregistered" in `editors`..
     *
     * @param {string} [name] - Case-insensitive editor key. If not given, `YourCellEditor.prototype.$$CLASS_NAME` is used.
     *
     * @param {YourCellEditor.prototype.constructor} Constructor - A constructor, typically extended from `CellEditor` (or a descendant therefrom).
     *
     * > Note: `$$CLASS_NAME` can be easily set up by providing a string as the (optional) first parameter (`alias`) in your {@link https://www.npmjs.com/package/extend-me|CellEditor.extend} call.
     *
     * @returns {CellEditor} A newly registered constructor extended from {@link CellEditor}.
     *
     * @memberOf module:cellEditors
     */
    add: function(name, Constructor) {
        if (typeof name === 'function') {
            Constructor = name;
            name = undefined;
        }

        name = name || Constructor.prototype.$$CLASS_NAME;
        name = name && name.toLowerCase();
        this.editors[name] = Constructor;
        return Constructor;
    },

    /**
     * @summary Register a synonym for an existing cell editor constructor.
     * @param {string} synonymName
     * @param {string} existingName
     * @returns {CellEditor} The previously registered constructor this new synonym points to.
     * @memberOf CellEditors.prototype
     */
    addSynonym: function(synonymName, existingName) {
        var cellEditor = this.get(existingName);
        return (this.editors[synonymName] = cellEditor);
    },

    /**
     * @param {string} name - Name of a registered editor.
     * @returns {CellEditor} A registered constructor extended from {@link CellEditor}.
     * @memberOf CellEditors.prototype
     */
    get: function(name) {
        return this.editors[name && name.toLowerCase()];
    },

    /**
     * @summary Lookup registered cell editor and return a new instance thereof.
     * @desc Note: Must be called with the Hypergrid object as context!
     * @returns {CellEditor} New instance of the named cell editor.
     * @param {string} name - Name of a registered editor.
     * @param {string} [options] - Properties to add to the instantiated editor primarily for mustache's use.
     * @memberOf CellEditors.prototype
     */
    create: function(name, options) {
        var cellEditor,
            Constructor = this.get(name);

        if (Constructor) {
            if (Constructor.abstract) {
                throw 'Attempt to instantiate an "abstract" cell editor class.';
            }
            cellEditor = new Constructor(this.grid, options);
        }

        return cellEditor;
    },

    /**
     * The cell editor registry containing all the "preregistered" cell editor constructors.
     * @private
     * @memberOf CellEditors.prototype
     */
    editors: {}
};

module.exports = CellEditors;

},{"./CellEditor":62,"./Color":63,"./ComboBox":64,"./Date":65,"./FilterBox":66,"./Number":67,"./Slider":68,"./Spinner":69,"./Textfield":70}],72:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 */
var Button = CellRenderer.extend('Button', {

    /**
     * @summary The default cell rendering function for a button cell.
     * @param {CanvasGraphicsContext} gc
     * @param {number} config.x - the x screen coordinate of my origin
     * @param {number} config.y - the y screen coordinate of my origin
     * @param {number} config.bounds.width - the width I'm allowed to draw within
     * @param {number} config.bounds.height - the height I'm allowed to draw within
     */
    paint: function(gc, config) {
        var val = config.value;
        var c = config.x;
        var r = config.y;
        var bounds = config.bounds;
        var x = bounds.x + 2;
        var y = bounds.y + 2;
        var width = bounds.width - 3;
        var height = bounds.height - 3;
        var radius = height / 2;
        var arcGradient = gc.createLinearGradient(x, y, x, y + height);
        if (config.mouseDown) {
            arcGradient.addColorStop(0, '#B5CBED');
            arcGradient.addColorStop(1, '#4d74ea');
        } else {
            arcGradient.addColorStop(0, '#ffffff');
            arcGradient.addColorStop(1, '#aaaaaa');
        }
        gc.fillStyle = arcGradient;
        gc.strokeStyle = '#000000';
        this.roundRect(gc, x, y, width, height, radius, arcGradient, true);

        var ox = (width - config.getTextWidth(gc, val)) / 2;
        var oy = (height - config.getTextHeight(gc.font).descent) / 2;

        if (gc.textBaseline !== 'middle') {
            gc.textBaseline = 'middle';
        }

        gc.fillStyle = '#000000';

        config.backgroundColor = 'rgba(0,0,0,0)';
        gc.fillText(val, x + ox, y + oy);

        //identify that we are a button
        config.buttonCells[c + ',' + r] = true;
    }
});

module.exports = Button;



},{"./CellRenderer":73}],73:[function(require,module,exports){
'use strict';

var Base = require('./../lib/Base');

/** @constructor
 * @desc Instances of `CellRenderer` are used to render the 2D graphics context within the bound of a cell. Extend this base class to implement your own cell renderer
 *
 *
 * See also {@tutorial cell-renderer}.
 */
var CellRenderer = Base.extend('CellRenderer', {
    /**
     * @desc An empty implementation of a cell renderer, see [the null object pattern](http://c2.com/cgi/wiki?NullObject).
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The bounding rect of the cell to be rendered.
     * @param config.x - The cell column position
     * @param config.y - The cell row position
     * @memberOf CellRenderer.prototype
     */
    paint: function(gc, config) {},

    /**
     * @desc A simple implementation of rounding a cell.
     * @param {CanvasGraphicsContext} gc
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @param {number} radius
     * @param {number} fill
     * @param {number} stroke
     * @memberOf CellRenderer.prototype
     */
    roundRect: function(gc, x, y, width, height, radius, fill, stroke) {

        if (!stroke) {
            stroke = true;
        }
        if (!radius) {
            radius = 5;
        }
        gc.beginPath();
        gc.moveTo(x + radius, y);
        gc.lineTo(x + width - radius, y);
        gc.quadraticCurveTo(x + width, y, x + width, y + radius);
        gc.lineTo(x + width, y + height - radius);
        gc.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        gc.lineTo(x + radius, y + height);
        gc.quadraticCurveTo(x, y + height, x, y + height - radius);
        gc.lineTo(x, y + radius);
        gc.quadraticCurveTo(x, y, x + radius, y);
        gc.closePath();
        if (stroke) {
            gc.stroke();
        }
        if (fill) {
            gc.fill();
        }
        gc.closePath();
    }
});

CellRenderer.abstract = true; // don't instantiate directly

module.exports = CellRenderer;

},{"./../lib/Base":110}],74:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 */
var ErrorCell = CellRenderer.extend('ErrorCell', {

    /**
     * @summary Writes error message into cell.
     *
     * @desc This function is guaranteed to be called as follows:
     *
     * ```javascript
     * gc.save();
     * gc.beginPath();
     * gc.rect(x, y, width, height);
     * gc.clip();
     * behavior.getCellProvider().renderCellError(gc, message, x, y, width, height);
     * gc.restore();
     * ```
     *
     * Before doing anything else, this function should clear the cell by setting `gc.fillStyle` and calling `gc.fill()`.
     *
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The bounding rect of the cell to be rendered.
     * @param config.x - The cell column position
     * @param config.y - The cell row position
     * @memberOf ErrorCell.prototype
     */
    paint: function(gc, config, message) {
        //var images = require('../../images/index');
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        // clear the cell
        // (this makes use of the rect path defined by the caller)
        gc.fillStyle = '#FFD500';
        gc.fill();
        // render cell border
        //gc.strokeStyle = gc.createPattern(images.caution, 'repeat'); // Causes Error
        gc.lineWidth = 5;
        gc.beginPath();
        gc.moveTo(x, y); // caution: do not use rect() here because Chrome does not clip its stroke properly
        gc.lineTo(x + width, y);
        gc.lineTo(x + width, y + height);
        gc.lineTo(x, y + height);
        gc.lineTo(x, y);
        gc.stroke();
        // adjust clip region to prevent text from rendering over right border should it overflow
        gc.beginPath();
        gc.rect(x, y, width - 2, height);
        gc.clip();
        // render message text
        gc.fillStyle = '#A00';
        gc.textAlign = 'start';
        gc.textBaseline = 'middle';
        gc.font = 'bold 6pt "arial narrow", verdana, geneva';
        gc.fillText(message, x + 4, y + height / 2 + 0.5);
    }
});

module.exports = ErrorCell;

},{"./CellRenderer":73}],75:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 */
var LastSelection = CellRenderer.extend('LastSelection', {

    /**
     * @desc A rendering of the last Selection Model
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The bounding rect of the cell to be rendered.
     * @param config.x - The cell column position
     * @param config.y - The cell row position
     * @memberOf LastSelection.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        // var focusLineStep =  [
        //     [5, 5],
        //     [0, 1, 5, 4],
        //     [0, 2, 5, 3],
        //     [0, 3, 5, 2],
        //     [0, 4, 5, 1],
        //     [0, 5, 5, 0],
        //     [1, 5, 4, 0],
        //     [2, 5, 3, 0],
        //     [3, 5, 2, 0],
        //     [4, 5, 1, 0]
        // ];
        gc.rect(x, y, width, height);
        gc.fillStyle = config.selectionRegionOverlayColor;
        gc.fill();
        gc.lineWidth = 1;
        gc.strokeStyle = config.selectionRegionOutlineColor;

        // animate the dashed line a bit here for fun

        gc.stroke();

        // gc.rect(x, y, width, height);
        //
        // gc.strokeStyle = 'white';
        //
        // //animate the dashed line a bit here for fun
        // gc.setLineDash(focusLineStep[Math.floor(10 * (Date.now() / 300 % 1)) % focusLineStep.length]);
        //
        // gc.stroke();
    }
});

module.exports = LastSelection;



},{"./CellRenderer":73}],76:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 */
var SimpleCell = CellRenderer.extend('SimpleCell', {

    /**
     * @summary The default cell rendering function for rendering a vanilla cell.
     * @desc Great care has been taken in crafting this function as it needs to perform extremely fast. Reads on the gc object are expensive but not quite as expensive as writes to it. We do our best to avoid writes, then avoid reads. Clipping bounds are not set here as this is also an expensive operation. Instead, we truncate overflowing text and content by filling a rectangle with background color column by column instead of cell by cell.  This column by column fill happens higher up on the stack in a calling function from fin-hypergrid-renderer.  Take note we do not do cell by cell border renderering as that is expensive.  Instead we render many fewer gridlines after all cells are rendered.
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The bounding rect of the cell to be rendered.
     * @param config.x - The cell column position
     * @param config.y - The cell row position
     * @memberOf SimpleCell.prototype
     */
    paint: function(gc, config) {
        var val = config.value,
            x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height,
            wrapHeaders = config.headerTextWrapping,
            leftPadding = 2, //TODO: fix this
            isHeader = config.y === 0;

        var leftIcon, rightIcon, centerIcon, ixoffset, iyoffset, font;

        // setting gc properties are expensive, let's not do it needlessly

        if (val && val.constructor === Array) {
            leftIcon = val[0];
            rightIcon = val[2];
            val = val[1];
            if (val && typeof val === 'object') {
                if (val.constructor.name === 'HTMLImageElement') { // must be an image
                    centerIcon = val;
                    val = null;
                }
            }
            if (leftIcon && leftIcon.nodeName !== 'IMG') {
                leftIcon = null;
            }
            if (rightIcon && rightIcon.nodeName !== 'IMG') {
                rightIcon = null;
            }
            if (centerIcon && centerIcon.nodeName !== 'IMG') {
                centerIcon = null;
            }
        }

        val = valOrFunc(val, config);
        val = config.formatValue(val);

        font = config.isSelected ? config.foregroundSelectionFont : config.font;

        if (gc.font !== font) {
            gc.font = font;
        }
        if (gc.textAlign !== 'left') {
            gc.textAlign = 'left';
        }
        if (gc.textBaseline !== 'middle') {
            gc.textBaseline = 'middle';
        }

        // fill background only if our bgColor is populated or we are a selected cell
        var backgroundColor, hover, hoverColor, selectColor,
            colors = [];

        if (config.isCellHovered && config.hoverCellHighlight.enabled) {
            hoverColor = config.hoverCellHighlight.backgroundColor;
        } else if (config.isRowHovered && (hover = config.hoverRowHighlight).enabled) {
            hoverColor = config.isGridColumn || !hover.header || hover.header.backgroundColor === undefined ? hover.backgroundColor : hover.header.backgroundColor;
        } else if (config.isColumnHovered && (hover = config.hoverColumnHighlight).enabled) {
            hoverColor = config.isGridRow || !hover.header || hover.header.backgroundColor === undefined ? hover.backgroundColor : hover.header.backgroundColor;
        }
        if (alpha(hoverColor) < 1) {
            if (config.isSelected) {
                selectColor = valOrFunc(config.backgroundSelectionColor, config);
            }
            if (alpha(selectColor) < 1) {
                backgroundColor = valOrFunc(config.backgroundColor, config);
                if (alpha(backgroundColor) > 0) {
                    colors.push(backgroundColor);
                }
            }
            if (selectColor !== undefined) {
                colors.push(selectColor);
            }
        }
        if (hoverColor !== undefined) {
            colors.push(hoverColor);
        }
        layerColors(gc, colors, x, y, width, height);

        // draw text
        var theColor = valOrFunc(config.isSelected ? config.foregroundSelectionColor : config.color, config);
        if (gc.fillStyle !== theColor) {
            gc.fillStyle = theColor;
            gc.strokeStyle = theColor;
        }

        if (isHeader && wrapHeaders) {
            this.renderMultiLineText(gc, config, val);
        } else {
            this.renderSingleLineText(gc, config, val);
        }

        var iconWidth = 0;
        if (leftIcon) {
            iyoffset = Math.round((height - leftIcon.height) / 2);
            gc.drawImage(leftIcon, x + leftPadding, y + iyoffset);
            iconWidth = Math.max(leftIcon.width + 2);
        }
        if (rightIcon && width > 1.75 * height) {
            iyoffset = Math.round((height - rightIcon.height) / 2);
            var rightX = x + width - rightIcon.width;
            if (backgroundColor !== undefined) {
                layerColors(gc, colors, rightX, y, rightIcon.width, height);
            } else {
                gc.clearRect(rightX, y, rightIcon.width, height);
            }
            gc.drawImage(rightIcon, rightX, y + iyoffset);
            iconWidth = Math.max(rightIcon.width + 2);
        }
        if (centerIcon) {
            iyoffset = Math.round((height - centerIcon.height) / 2);
            ixoffset = Math.round((width - centerIcon.width) / 2);
            gc.drawImage(centerIcon, x + width - ixoffset - centerIcon.width, y + iyoffset);
            iconWidth = Math.max(centerIcon.width + 2);
        }
        if (config.cellBorderThickness) {
            gc.beginPath();
            gc.rect(x, y, width, height);
            gc.lineWidth = config.cellBorderThickness;
            gc.strokeStyle = config.cellBorderStyle;

            // animate the dashed line a bit here for fun

            gc.stroke();
            gc.closePath();
        }
        config.minWidth = config.minWidth + 2 * (iconWidth);
    },

    /**
     * @summary Renders single line text.
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The bounding rect of the cell to be rendered.
     * @param {*} val - The text to render in the cell.
     * @memberOf SimpleCell.prototype
     */
    renderMultiLineText: function(gc, config, val) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;
        var lines = fitText(gc, config, val, width);
        if (lines.length === 1) {
            return this.renderSingleLineText(gc, config, squeeze(val));
        }

        var colHEdgeOffset = config.cellPadding,
            halignOffset = 0,
            valignOffset = config.voffset,
            halign = config.halign,
            textHeight = config.getTextHeight(config.font).height;

        switch (halign) {
            case 'right':
                halignOffset = width - colHEdgeOffset;
                break;
            case 'center':
                halignOffset = width / 2;
                break;
            case 'left':
                halignOffset = colHEdgeOffset;
                break;
        }

        var hMin = 0, vMin = Math.ceil(textHeight / 2);

        valignOffset += Math.ceil((height - (lines.length - 1) * textHeight) / 2);

        halignOffset = Math.max(hMin, halignOffset);
        valignOffset = Math.max(vMin, valignOffset);

        gc.save(); // define a clipping region for cell
        gc.rect(x, y, width, height);
        gc.clip();

        gc.textAlign = halign;

        for (var i = 0; i < lines.length; i++) {
            gc.fillText(lines[i], x + halignOffset, y + valignOffset + (i * textHeight));
        }

        gc.restore(); // discard clipping region
    },

    /**
     * @summary Renders single line text.
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The bounding rect of the cell to be rendered.
     * @param {*} val - The text to render in the cell.
     * @memberOf SimpleCell.prototype
     */
    renderSingleLineText: function(gc, config, val) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;
        var colHEdgeOffset = config.cellPadding,
            halignOffset = 0,
            valignOffset = config.voffset,
            halign = config.halign,
            isCellHovered = config.isCellHovered,
            isLink = config.link;

        var fontMetrics = config.getTextHeight(config.font);
        var textWidth = config.getTextWidth(gc, val);

        //we must set this in order to compute the minimum width
        //for column autosizing purposes
        config.minWidth = textWidth + (2 * colHEdgeOffset);

        switch (halign) {
            case 'right':
                //textWidth = config.getTextWidth(gc, config.value);
                halignOffset = width - colHEdgeOffset - textWidth;
                break;
            case 'center':
                //textWidth = config.getTextWidth(gc, config.value);
                halignOffset = (width - textWidth) / 2;
                break;
            case 'left':
                halignOffset = colHEdgeOffset;
                break;
        }

        halignOffset = Math.max(0, halignOffset);
        valignOffset = valignOffset + Math.ceil(height / 2);

        if (val !== null) {
            gc.fillText(val, x + halignOffset, y + valignOffset);
        }

        if (isCellHovered) {
            gc.beginPath();
            if (isLink) {
                underline(config, gc, val, x + halignOffset, y + valignOffset + Math.floor(fontMetrics.height / 2), 1);
                gc.stroke();
            }
            gc.closePath();
        }
        if (config.strikeThrough === true) {
            gc.beginPath();
            strikeThrough(config, gc, val, x + halignOffset, y + valignOffset + Math.floor(fontMetrics.height / 2), 1);
            gc.stroke();
            gc.closePath();
        }
    }
});


function fitText(gc, config, string, width) {
    return findLines(gc, config, squeeze(string).split(' '), width);
}

function findLines(gc, config, words, width) {

    if (words.length === 1) {
        return words;
    }

    // starting with just the first word
    var stillFits, line = [words.shift()];
    while (
        // so lone as line still fits within current column
    (stillFits = config.getTextWidth(gc, line.join(' ')) < width)
    // AND there are more words available
    && words.length
        ) {
        // add another word to end of line and retest
        line.push(words.shift());
    }

    if (
        !stillFits // if line is now too long
        && line.length > 1 // AND is multiple words
    ) {
        words.unshift(line.pop()); // back off by (i.e., remove) one word
    }

    line = [line.join(' ')];

    if (words.length) { // if there's anything left
        line = line.concat(findLines(gc, config, words, width)); // break it up as well
    }

    return line;
}

// trim string; then reduce all runs of multiple spaces to a single space
function squeeze(string) {
    return (string + '').trim().replace(/\s\s+/g, ' ');
}

function strikeThrough(config, gc, text, x, y, thickness) {
    var fontMetrics = config.getTextHeight(config.font);
    var width = config.getTextWidth(gc, text);
    y = y - (fontMetrics.height * 0.4);

    switch (gc.textAlign) {
        case 'center':
            x -= (width / 2);
            break;
        case 'right':
            x -= width;
            break;
    }

    //gc.beginPath();
    gc.lineWidth = thickness;
    gc.moveTo(x + 0.5, y + 0.5);
    gc.lineTo(x + width + 0.5, y + 0.5);
}

function underline(config, gc, text, x, y, thickness) {
    var width = config.getTextWidth(gc, text);

    switch (gc.textAlign) {
        case 'center':
            x -= (width / 2);
            break;
        case 'right':
            x -= width;
            break;
    }

    //gc.beginPath();
    gc.lineWidth = thickness;
    gc.moveTo(x + 0.5, y + 0.5);
    gc.lineTo(x + width + 0.5, y + 0.5);
}

function layerColors(gc, colors, x, y, width, height) {
    colors.forEach(function(color) {
        gc.fillStyle = color;
        gc.fillRect(x, y, width, height);
    });
}

function valOrFunc(vf, config) {
    var result = (typeof vf)[0] === 'f' ? vf(config) : vf;
    return result || result === 0 ? result : '';
}

function alpha(cssColorSpec) {
    if (cssColorSpec === undefined) {
        // undefined so not visible; treat as transparent
        return 0;
    }

    var matches = cssColorSpec.match(alpha.regex);

    if (matches === null) {
        // an opaque color (a color spec with no alpha channel)
        return 1;
    }

    var A = matches[4];

    if (A === undefined) {
        // cssColorSpec must have been 'transparent'
        return 0;
    }

    return Number(A);
}

alpha.regex = /^(transparent|((RGB|HSL)A\(.*,\s*([\d\.]+)\)))$/i;

module.exports = SimpleCell;

},{"./CellRenderer":73}],77:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 */
var Slider = CellRenderer.extend('Slider', {

    /**
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The bounding rect of the cell to be rendered.
     * @param config.x - The cell column position
     * @param config.y - The cell row position
     * @memberOf Slider.prototype
     * @desc Emerson's paint function for a slider button. currently the user cannot interact with it
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;
        gc.strokeStyle = 'white';
        var val = this.config.value;
        var radius = height / 2;
        var offset = width * val;
        var bgColor = this.config.isSelected ? this.config.backgroundColor : '#333333';
        var btnGradient = gc.createLinearGradient(x, y, x, y + height);
        btnGradient.addColorStop(0, bgColor);
        btnGradient.addColorStop(1, '#666666');
        var arcGradient = gc.createLinearGradient(x, y, x, y + height);
        arcGradient.addColorStop(0, '#aaaaaa');
        arcGradient.addColorStop(1, '#777777');
        gc.fillStyle = btnGradient;
        this.roundRect(gc, x, y, width, height, radius, btnGradient);
        if (val < 1.0) {
            gc.fillStyle = arcGradient;
        } else {
            gc.fillStyle = '#eeeeee';
        }
        gc.beginPath();
        gc.arc(x + Math.max(offset - radius, radius), y + radius, radius, 0, 2 * Math.PI);
        gc.fill();
        gc.closePath();
        this.config.minWidth = 100;
    }
});

module.exports = Slider;

},{"./CellRenderer":73}],78:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 */
var SparkBar = CellRenderer.extend('SparkBar', {

    /**
     * @desc A simple implementation of a sparkline, because it's a barchart we've changed the name ;).
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The bounding rect of the cell to be rendered.
     * @param config.x - The cell column position
     * @param config.y - The cell row position
     * @memberOf SparkBar.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        gc.beginPath();
        var val = this.config.value;
        if (!val || !val.length) {
            return;
        }
        var count = val.length;
        var eWidth = width / count;
        var fgColor = this.config.isSelected ? this.config.foregroundSelectionColor : this.config.color;
        if (this.config.backgroundColor || this.config.isSelected) {
            gc.fillStyle = this.config.isSelected ? 'blue' : this.config.backgroundColor;
            gc.fillRect(x, y, width, height);
        }
        gc.fillStyle = fgColor;
        for (var i = 0; i < val.length; i++) {
            var barheight = val[i] / 110 * height;
            gc.fillRect(x + 5, y + height - barheight, eWidth * 0.6666, barheight);
            x = x + eWidth;
        }
        gc.closePath();
        this.config.minWidth = count * 10;
    }
});

module.exports = SparkBar;

},{"./CellRenderer":73}],79:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 */
var SparkLine = CellRenderer.extend('SparkLine', {

    /**
     * @desc A simple implementation of a sparkline.  see [Edward Tufte sparkline](http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR)
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The bounding rect of the cell to be rendered.
     * @param config.x - The cell column position
     * @param config.y - The cell row position
     * @memberOf SparkLine.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        gc.beginPath();
        var val = this.config.value;
        if (!val || !val.length) {
            return;
        }
        var count = val.length;
        var eWidth = width / count;

        var fgColor = this.config.isSelected ? this.config.foregroundSelectionColor : this.config.color;
        if (this.config.backgroundColor || this.config.isSelected) {
            gc.fillStyle = this.config.isSelected ? this.config.backgroundSelectionColor : this.config.backgroundColor;
            gc.fillRect(x, y, width, height);
        }
        gc.strokeStyle = fgColor;
        gc.fillStyle = fgColor;
        gc.beginPath();
        var prev;
        for (var i = 0; i < val.length; i++) {
            var barheight = val[i] / 110 * height;
            if (!prev) {
                prev = barheight;
            }
            gc.lineTo(x + 5, y + height - barheight);
            gc.arc(x + 5, y + height - barheight, 1, 0, 2 * Math.PI, false);
            x = x + eWidth;
        }
        this.config.minWidth = count * 10;
        gc.stroke();
        gc.closePath();
    }
});

module.exports = SparkLine;

},{"./CellRenderer":73}],80:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 */
var TreeCell = CellRenderer.extend('TreeCell', {

    /**
     * @desc A simple implementation of a tree cell renderer for use mainly with the qtree.
     * @param {object} config
     * @param {Rectangle} config.bounds - The bounding rect of the cell to be rendered.
     * @param config.x - The cell column position
     * @param config.y - The cell row position
     * @memberOf TreeCell.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        var val = this.config.value.data;
        var indent = this.config.value.indent;
        var icon = this.config.value.icon;

        //fill background only if our bgColor is populated or we are a selected cell
        if (this.config.backgroundColor || this.config.isSelected) {
            gc.fillStyle = this.config.isSelected ? this.config.backgroundColor : this.config.backgroundColor;
            gc.fillRect(x, y, width, height);
        }

        if (!val || !val.length) {
            return;
        }
        var valignOffset = Math.ceil(height / 2);

        gc.fillStyle = this.config.isSelected ? this.config.backgroundColor : this.config.backgroundColor;
        gc.fillText(icon + val, x + indent, y + valignOffset);

        var textWidth = this.config.getTextWidth(gc, icon + val);
        var minWidth = x + indent + textWidth + 10;
        this.config.minWidth = minWidth;
    }
});

module.exports = TreeCell;

},{"./CellRenderer":73}],81:[function(require,module,exports){
/**
 * @summary API of cell renderer object constructors, plus some access methods.
 * @module cellRenderers
 */

'use strict';

/**
 * @param {boolean} [privateRegistry=false] - This instance will use a private registry.
 * @constructor
 */
function CellRenderers(privateRegistry) {
    if (privateRegistry) {
        this.singletons = {};
    }

    // preregister the standard cell renderers
    if (privateRegistry || !this.get('emptycell')) {
        this.add('EmptyCell', require('./CellRenderer'));
        this.add(require('./Button'));
        this.add(require('./SimpleCell'));
        this.add(require('./SliderCell'));
        this.add(require('./SparkBar'));
        this.add(require('./LastSelection'));
        this.add(require('./SparkLine'));
        this.add(require('./ErrorCell'));
        this.add(require('./TreeCell'));
    }
}

CellRenderers.prototype = {
    constructor: CellRenderers.prototype.constructor, // preserve constructor

    /**
     * @summary Register and instantiate a cell renderer singleton.
     * @desc Adds a custom cell renderer to the `singletons` hash using the provided name (or the class name), converted to all lower case.
     *
     * > All native cell renderers are "preregistered" in `singletons`. Add more by calling `get`.
     *
     * @param {string} [name] - Case-insensitive renderer key. If not given, `YourCellRenderer.prototype.$$CLASS_NAME` is used.
     *
     * @param {CellRenderer} Constructor - A constructor, typically extended from `CellRenderer` (or a descendant therefrom).
     *
     * > Note: `$$CLASS_NAME` can be easily set up by providing a string as the (optional) first parameter (`alias`) in your {@link https://www.npmjs.com/package/extend-me|CellEditor.extend} call.
     *
     * @returns {CellRenderers} A newly registered constructor extended from {@link CellRenderers}.
     *
     * @memberOf CellRenderers.prototype
     */
    add: function(name, Constructor) {
        if (typeof name === 'function') {
            Constructor = name;
            name = undefined;
        }

        name = name || Constructor.prototype.$$CLASS_NAME;
        name = name && name.toLowerCase();
        return (this.singletons[name] = new Constructor);
    },

    /**
     * @summary Register a synonym for an existing cell renderer singleton.
     * @param {string} synonymName
     * @param {string} existingName
     * @returns {CellRenderers} The previously registered constructor this new synonym points to.
     * @memberOf CellRenderers.prototype
     */
    addSynonym: function(synonymName, existingName) {
        var cellRenderer = this.get(existingName);
        return (this.singletons[synonymName] = cellRenderer);
    },

    /**
     * Fetch a registered cell renderer singleton.
     * @param {string} name
     * @returns {CellRenderers} A registered constructor extended from {@link CellRenderers}.
     * @memberOf CellRenderers.prototype
     */
    get: function(name) {
        return this.singletons[name && name.toLowerCase()];
    },

    /**
     * The cell editor registry containing all the "preregistered" cell renderer singletons.
     * @private
     * @memberOf CellRenderers.prototype
     */
    singletons: {}
};


module.exports = CellRenderers;

},{"./Button":72,"./CellRenderer":73,"./ErrorCell":74,"./LastSelection":75,"./SimpleCell":76,"./SliderCell":77,"./SparkBar":78,"./SparkLine":79,"./TreeCell":80}],82:[function(require,module,exports){
'use strict';

var Base = require('../lib/Base');

var A = 'A'.charCodeAt(0);

/**
 * @constructor
 */
var DataModel = Base.extend('DataModel', {

    next: null,

    grid: null,

    initialize: function(grid) {
        this.grid = grid;
    },

    changed: function() {
        this.grid.behavior.changed();
    },

    getPrivateState: function() {
        return this.grid.getPrivateState();
    },

    applyState: function() {

    },

    alphaFor: function(i) {
        // Name the column headers in A, .., AA, AB, AC, .., AZ format
        // quotient/remainder
        //var quo = Math.floor(col/27);
        var quo = Math.floor(i / 26);
        var rem = i % 26;
        var code = '';
        if (quo > 0) {
            code += this.alpha(quo - 1);
        }
        code += this.alpha(rem);
        return code;
    },

    alpha: function(i) {
        return String.fromCharCode(A + i);
    },

    /**
     * @param {object} config
     * @param {string} declaredRendererName - The proposed cell renderer name (form the render properties).
     * @returns {CellRenderer}
     * @memberOf DataModel.prototype
     */
    getCell: function(config, declaredRendererName) {
        return this.grid.cellRenderers.get(declaredRendererName);
    },

    /**
     * @summary Instantiate a new cell editor.
     * @desc The application developer may override this method to:
     * * Instantiate and return an arbitrary cell editor. The generic implementation here simply returns the declared cell editor. This is `undefined` when there was no such declaration, or if the named cell editor was not registered.
     * * Return `undefined` for no cell editor at all. The cell will not be editable.
     * * Set properties on the instance by passing them in the `options` object. These are applied to the new cell editor object after instantiation but before rendering.
     * * Manipulate the cell editor object (including its DOM elements) after rendering but before DOM insertion.
     *
     * Overriding this method with a null function (that always returns `undefined`) will have the effect of making all cells uneditable.
     *
     * @param {number} columnIndex - Absolute column index. I.e., the position of the column in the data source's original `fields` array, as echoed in `behavior.allColumns[]`.
     * @param {number} rowIndex - Row index of the data row in the currently filtered and sorted list of rows, regardless of vertical scroll position, offset by the number of header rows (all the rows above the first data row including the filter row). I.e., after subtracting out the number of header rows, this is the position of the data row in the `index` array of the data source (i.e., the last data source pipeline).
     * @param {string} declaredEditorName - The proposed cell editor name (from the render properties).
     * @param {object} options - Properties to copy to the new cell editor primarily for mustache's use. Additionally, always includes the following:
     * @param {string} options.format - The value of the `format` render prop. May be `undefined`.
     * @param {object} options.column - For convenience, the column object in `behavior.allColumns[]` to which `columnIndex` refers.
     * @param {Point} options.editPoint - The grid coordinates of the cell to edit.
     * @param {number} options.editPoint.x - The horizontal model coordinate of the cell to edit. This is the grid coordinate regardless of horizontal scroll position. I.e., the position of the column in the ordered list of selected columns (`behavior.columns[]`). (This is the coordinate required by {@link Hypergrid#editAt|editAt}.)
     * @param {number} options.editPoint.y - Same as `rowIndex`.
     *
     * @returns {undefined|CellEditor} An object instantiated from the registered cell editor constructor named in `declaredEditorName`. A falsy return means the cell is not editable because the `declaredEditorName` was not registered.
     *
     * @memberOf DataModel.prototype
     */
    getCellEditorAt: function(columnIndex, rowIndex, declaredEditorName, options) {
        return this.grid.cellEditors.create(declaredEditorName, options);
    }

});

module.exports = DataModel;

},{"../lib/Base":110}],83:[function(require,module,exports){
'use strict';

var analytics = require('../Shared.js').analytics;
var DataModel = require('./DataModel');
var images = require('../../images');

var UPWARDS_BLACK_ARROW = '\u25b2', // aka ''
    DOWNWARDS_BLACK_ARROW = '\u25bc'; // aka ''

var nullDataSource = {
    isNullObject: function() {
        return true;
    },
    getFields: function() {
        return [];
    },
    getHeaders: function() {
        return [];
    },
    getColumnCount: function() {
        return 0;
    },
    getRowCount: function() {
        return 0;
    },
    getAggregateTotals: function() {
        return [];
    },
    hasAggregates: function() {
        return false;
    },
    hasGroups: function() {
        return false;
    },
    getRow: function() {
        return null;
    },

    viewMakesSense: function() {
        return false;
    },
    setAggregates: function() {},
    setGroupBys: function() {},
    groupBys: [],

};

/**
 * @name dataModels.JSON
 * @constructor
 */
var JSON = DataModel.extend('dataModels.JSON', {

    //null object pattern for the source object
    resetSources: function() {
        this.sources = {
            source: nullDataSource,
            aggregator: nullDataSource,
            globalfilter: nullDataSource,
            sortercomposite: nullDataSource
        };
        this.dataSource = undefined;
    },

    topTotals: [],
    bottomTotals: [],

    initialize: function() {
        this.resetSources();
        this.selectedData = [];
    },

    clearSelectedData: function() {
        this.selectedData.length = 0;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {boolean}
     */
    hasAggregates: function() {
        return this.sources.aggregator.hasAggregates();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {boolean}
     */
    hasGroups: function() {
        return this.sources.aggregator.hasGroups();
    },

    getDataSource: function() {
        return this.dataSource;
    },

    getGlobalFilterDataSource: function() {
        return this.sources.globalfilter;
    },

    getData: function() {
        return this.sources.source.data;
    },

    getFilteredData: function() {
        var ds = this.getDataSource();
        var count = ds.getRowCount();
        var result = new Array(count);
        for (var y = 0; y < count; y++) {
            result[y] = ds.getRow(y);
        }
        return result;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @returns {*}
     */
    getValue: function(x, y) {
        var hasHierarchyColumn = this.hasHierarchyColumn();
        var headerRowCount = this.grid.getHeaderRowCount();
        var value;

        if (hasHierarchyColumn) {
            if (x === -2) {
                x = 0;
            }
        } else if (this.hasAggregates()) {
            x += 1;
        }
        if (y < headerRowCount) {
            value = this.getHeaderRowValue(x, y);
        } else {
            // if (hasHierarchyColumn) {
            //     y += 1;
            // }
            value = this.getDataSource().getValue(x, y - headerRowCount);
        }
        return value;
    },

    getDataIndex: function(y) {
        return this.getDataSource().getDataIndex(y - this.grid.getHeaderRowCount());
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y - negative values refer to _bottom totals_ rows
     * @returns {*}
     */
    getHeaderRowValue: function(x, y) {
        var value;
        if (y === undefined) {
            value = this.getHeaders()[Math.max(x, 0)];
        } else if (y < 0) { // bottom totals rows
            var bottomTotals = this.getBottomTotals();
            value = bottomTotals[bottomTotals.length + y][x];
        } else {
            var isFilterRow = this.grid.isShowFilterRow(),
                isHeaderRow = this.grid.isShowHeaderRow(),
                topTotalsOffset = (isFilterRow ? 1 : 0) + (isHeaderRow ? 1 : 0);
            if (y >= topTotalsOffset) { // top totals rows
                value = this.getTopTotals()[y - topTotalsOffset][x];
            } else if (isHeaderRow && y === 0) {
                value = this.getHeaders()[x];
                var sortString = this.getSortImageForColumn(x);
                if (sortString) { value = sortString + value; }
            } else { // must be filter row
                var filter = this.getGlobalFilter();
                value = filter && filter.getColumnFilterState(this.getFields()[x]) || '';
                var icon = images.filter(value.length);
                return [null, value, icon];
            }
        }
        return value;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @param value
     */
    setValue: function(x, y, value) {
        var hasHierarchyColumn = this.hasHierarchyColumn();
        var headerRowCount = this.grid.getHeaderRowCount();
        if (hasHierarchyColumn) {
            if (x === -2) {
                x = 0;
            }
        } else if (this.hasAggregates()) {
            x += 1;
        }
        if (y < headerRowCount) {
            this.setHeaderRowValue(x, y, value);
        } else {
            this.getDataSource().setValue(x, y - headerRowCount, value);
        }
        this.changed();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @param value
     * @returns {*}
     */
    setHeaderRowValue: function(x, y, value) {
        if (value === undefined) {
            return this._setHeader(x, y); // y is really the value
        }
        var isFilterRow = this.grid.isShowFilterRow();
        var isHeaderRow = this.grid.isShowHeaderRow();
        var topTotalsOffset = (isFilterRow ? 1 : 0) + (isHeaderRow ? 1 : 0);
        if (y >= topTotalsOffset) {
            this.getTopTotals()[y - topTotalsOffset][x] = value;
        } else if (x === -1) {
            return; // can't change the row numbers header
        } else if (isHeaderRow && y === 0) {
            return this._setHeader(x, value);
        } else if (isFilterRow) {
            this.setFilter(x, value, { alert: true });
        } else {
            return this._setHeader(x, value);
        }
        return '';
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @returns {*}
     */
    getColumnProperties: function(colIndex) {
        //access directly because we want it ordered
        var column = this.grid.behavior.getColumn(colIndex);
        if (column) {
            return column.getProperties();
        }
        return undefined;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {number}
     */
    getColumnCount: function() {
        var showTree = this.grid.resolveProperty('showTreeColumn') === true;
        var hasAggregates = this.hasAggregates();
        var offset = (hasAggregates && !showTree) ? -1 : 0;
        return this.sources.aggregator.getColumnCount() + offset;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {number}
     */
    getRowCount: function() {
        var count = this.getDataSource().getRowCount();
        count += this.grid.getHeaderRowCount();
        return count;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {string[]}
     */
    getHeaders: function() {
        return this.sources.aggregator.getHeaders();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string[]} headers
     */
    setHeaders: function(headers) {
        this.getDataSource().setHeaders(headers);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string[]} fields
     */
    setFields: function(fields) {
        this.getDataSource().setFields(fields);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {string[]}
     */
    getFields: function() {
        return this.getDataSource().getFields();
    },

    /** @typedef {object} dataSourcePipelineObject
     * @property {function} DataSource - A `hyper-analytics`-style  "data source" constructor.
     * @property {*} [options] - When defined, passed as 2nd argument to constructor.
     * @property {string} [parent] - Defines a branch off the main sequence.
     */

    /**
     * @type {dataSourcePipelineObject[]}
     * @memberOf dataModels.JSON.prototype
     */
    pipeline: [
        { type: 'JSDataSource' },
        { type: 'DataSourceAggregator' },
        { type: 'DataSourceGlobalFilter' },
        { type: 'DataSourceSorterComposite' },
        { type: 'DataNodeGroupSorter', parent: 'DataSourceAggregator' }
    ],

    /**
     * @summary Instantiates the data source pipeline.
     * @desc Each new layer is created using the supplied constructor and a reference to the previous data source in the pipeline. A reference to each new layer is added to `this` dataModel as a property using the layer's `name`.
     *
     * The first layer must have a `@@CLASS_NAME` of `'DataSource'`. Hence, the start of the pipeline is `this.source`. The last layer is assigned the synonym `this.dataSource`.
     *
     * Branches are created when a layer specifies a name in `parent`.
     * @param {object[]} dataSource - Array of uniform objects containing the grid data.
     * @memberOf dataModels.JSON.prototype
     */
    setData: function(dataSource) {
        this.resetSources();

        this.pipeline.forEach(function(sources, layer, index) {
            var DataSource = analytics[layer.type];

            layer.name = layer.name || getDataSourceName(layer.type);

            if (index === 0 && layer.name !== 'source') {
                throw 'Expected pipeline to begin with source.';
            }

            if (layer.parent) {
                this.dataSource = this.dataSource || dataSource; // tip of main trunk on first diversion
                dataSource = sources[getDataSourceName(layer.parent)];
                if (!dataSource) {
                    throw 'Parent data source not in pipeline.';
                }
            }

            dataSource = layer.options === undefined
                ? new DataSource(dataSource)
                : new DataSource(dataSource, layer.options);

            sources[layer.name] = dataSource;
        }.bind(this, this.sources));

        this.dataSource = this.dataSource || dataSource; // tip of main trunk if never branched

        this.applyAnalytics();
    },

    /**
     * Add a layer to the data source pipeline.
     * @param {dataSourcePipelineObject} newLayer - The new pipeline layer.
     * @param {string} [referenceLayer] - Name of an existing pipeline layer after which the new layer will be added. If not found (such as `null`), inserts at beginning. If `undefined` or omitted, adds to end.
     * @memberOf dataModels.JSON.prototype
     */
    addPipe: function(newLayer, referenceLayer) {
        var layerIndex;
        if (referenceLayer !== undefined) {
            referenceLayer = this.pipeline.find(function(layer, index) {
                var found = layer.type === referenceLayer;
                layerIndex = index;
                return found;
            });
        }
        if (referenceLayer === undefined) {
            layerIndex = this.pipeline.length;
        }
        this.pipeline.splice(layerIndex + 1, 0, newLayer);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {Array<Array>} totalRows
     */
    setTopTotals: function(totalRows) {
        this.topTotals = totalRows;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {Array<Array>}
     */
    getTopTotals: function() {
        return this.hasAggregates() ? this.getDataSource().getGrandTotals() : this.topTotals;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {Array<Array>} totalRows
     */
    setBottomTotals: function(totalRows) {
        this.bottomTotals = totalRows;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {Array<Array>}
     */
    getBottomTotals: function() {
        return this.hasAggregates() ? this.getDataSource().getGrandTotals() : this.bottomTotals;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param groups
     */
    setGroups: function(groups) {
        this.sources.aggregator.setGroupBys(groups);
        this.applyAnalytics();
        this.grid.fireSyntheticGroupsChangedEvent(this.getGroups());
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getGroups: function() {
        var headers = this.getHeaders().slice(0);
        var fields = this.getFields().slice(0);
        var groupBys = this.sources.aggregator.groupBys;
        var groups = [];
        for (var i = 0; i < groupBys.length; i++) {
            var field = headers[groupBys[i]];
            groups.push({
                id: groupBys[i],
                label: field,
                field: fields
            });
        }
        return groups;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getAvailableGroups: function() {
        var headers = this.sources.source.getHeaders().slice(0);
        var groupBys = this.sources.aggregator.groupBys;
        var groups = [];
        for (var i = 0; i < headers.length; i++) {
            if (groupBys.indexOf(i) === -1) {
                var field = headers[i];
                groups.push({
                    id: i,
                    label: field,
                    field: field
                });
            }
        }
        return groups;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getActiveColumns: function() {
        return this.grid.behavior.columns.filter(function(column) {
            return column.name !== 'tree';
        });
    },
    getVisibleColumns: function() {
        this.deprecated('getVisibleColumns()', 'getActiveColumns()', '1.0.6', arguments);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getHiddenColumns: function() {
        var visible = this.grid.behavior.columns;
        var all = this.grid.behavior.allColumns;
        var hidden = [];
        for (var i = 0; i < all.length; i++) {
            if (visible.indexOf(all[i]) === -1) {
                hidden.push(all[i]);
            }
        }
        hidden.sort(function(a, b) {
            return a.header < b.header;
        });
        return hidden;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param aggregations
     */
    setAggregates: function(aggregations) {
        this.sources.aggregator.setAggregates(aggregations);
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {boolean}
     */
    hasHierarchyColumn: function() {
        var showTree = this.grid.resolveProperty('showTreeColumn') === true;
        return this.hasAggregates() && this.hasGroups() && showTree;
    },

    setRelation: function(options) {
        this.sources.treeview.setRelation(options);
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    applyAnalytics: function(dontApplyAggregator) {
        selectedDataRowsBackingSelectedGridRows.call(this);

        this.pipeline.forEach(function(sources, layer) {
            var dataSource = sources[layer.name];

            switch (layer.type) {
                case 'DataSourceAggregator':
                    if (dontApplyAggregator) {
                        dataSource = undefined;
                    }
                    break;

                case 'DataSourceSorterComposite':
                    if (sources.aggregator && sources.aggregator.viewMakesSense()) {
                        dataSource = sources.groupsorter;
                    }
                    dataSource.clearSorts();
                    (this.getPrivateState().sorts || []).forEach(function(sort) {
                        dataSource.sortOn(Math.abs(sort) - 1, Math.sign(sort));
                    });
                    break;
            }

            if (dataSource && dataSource.apply) {
                dataSource.apply();
            }
        }.bind(this, this.sources));

        reselectGridRowsBackedBySelectedDataRows.call(this);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @param keys
     */
    toggleSort: function(colIndex, keys) {
        this.incrementSortState(colIndex, keys);
        this.applyAnalytics(true);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @param {boolean} deferred
     */
    unSortColumn: function(colIndex, deferred) {
        colIndex++; //hack to get around 0 index
        var already = this.getColumnSortState(colIndex);
        if (already > -1) {
            this.removeColumnSortState(colIndex, already);
            if (!deferred) {
                this.applyAnalytics(true);
            }
        }
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    getSortedColumnIndexes: function() {
        var state = this.getPrivateState();
        return state.sorts && state.sorts.slice() || [];
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @param {string[]} keys
     */
    incrementSortState: function(colIndex, keys) {
        colIndex++; //hack to get around 0 index
        var state = this.getPrivateState();
        var hasCTRL = keys.indexOf('CTRL') > -1;
        state.sorts = state.sorts || [];
        var already = this.getColumnSortState(colIndex);
        if (already > -1) {
            if (state.sorts[already] > 0) {
                state.sorts[already] = -1 * state.sorts[already]; //descending
            } else {
                this.removeColumnSortState(colIndex, already);
            }
        } else if (hasCTRL || state.sorts.length === 0) {
            state.sorts.unshift(colIndex);
        } else {
            state.sorts.length = 0;
            state.sorts.unshift(colIndex);
        }
        //Minor improvement, but this check can happen earlier and terminate earlier
        if (state.sorts.length > 3) {
            state.sorts.length = 3;
        }
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @returns {number}
     */
    getColumnSortState: function(colIndex) {
        //assumption is that colIndex has been hacked to get around 0
        var already,
            state = this.getPrivateState();

        state.sorts = state.sorts || [];

        //Check data columns
        already = state.sorts.indexOf(colIndex);

        //Check columns with negative indices. Meta columns??
        if (already === -1) {
            already = state.sorts.indexOf(-1 * colIndex);
        }
        return already;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @param {number} sortPosition
     */
    removeColumnSortState: function(colIndex, sortPosition) {
        //assumption is that colIndex has been hacked to get around 0
        var state = this.getPrivateState();
        state.sorts = state.sorts || [];
        state.sorts.splice(sortPosition, 1);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param index
     * @param returnAsString
     * @returns {*}
     */
    getSortImageForColumn: function(index) {
        index++;
        var up = true;
        var sorts = this.getPrivateState().sorts;
        if (!sorts) {
            return null;
        }
        var position = sorts.indexOf(index);
        if (position < 0) {
            position = sorts.indexOf(-1 * index);
            up = false;
        }
        if (position < 0) {
            return null;
        }
        var rank = sorts.length - position;
        var arrow = up ? UPWARDS_BLACK_ARROW : DOWNWARDS_BLACK_ARROW;
        return rank + arrow + ' ';
    },

    /**
     * @memberOf dataModels.JSON.prototypedrilldown
     * @param cell
     * @param event
     */
    cellClicked: function(cell, event) {
        if (
            this.sources.treeview && event.dataCell.x === this.sources.treeview.treeColumnIndex ||
            this.hasAggregates() && event.gridCell.x === 0
        ) {
            var expandable = this.getDataSource().click(event.gridCell.y - this.grid.getHeaderRowCount());
            if (expandable) {
                this.applyAnalytics(true);
                this.changed();
            }
        }
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} y
     * @returns {object}
     */
    getRow: function(y) {
        var headerRowCount = this.grid.getHeaderRowCount();
        if (y < headerRowCount && !this.hasAggregates()) {
            var topTotals = this.getTopTotals();
            return topTotals[y - (headerRowCount - topTotals.length)];
        }
        return this.getDataSource().getRow(y - headerRowCount);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} y
     * @returns {object}
     */
    buildRow: function(y) {
        var colCount = this.getColumnCount();
        var fields = [].concat(this.getFields());
        var result = {};
        if (this.hasAggregates()) {
            result.tree = this.getValue(-2, y);
            fields.shift();
        }
        for (var i = 0; i < colCount; i++) {
            result[fields[i]] = this.getValue(i, y);
        }
        return result;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} y
     * @returns {object}
     */
    getComputedRow: function(y) {
        var rcf = this.getRowContextFunction([y]);
        var fields = this.getFields();
        var row = {};
        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            row[field] = rcf(field)[0];
        }
        return row;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string} fieldName
     * @param {number} y
     * @returns {*}
     */
    getValueByField: function(fieldName, y) {
        var index = this.getFields().indexOf(fieldName);
        if (this.hasAggregates()) {
            y += 1;
        }
        return this.getDataSource().getValue(index, y);
    },

    /**
     * @summary Get a reference to the filter attached to the Hypergrid.
     * @returns {FilterTree}
     * @memberOf dataModels.JSON.prototype
     */
    getGlobalFilter: function() {
        return this.getGlobalFilterDataSource().get();
    },

    /**
     * @summary Attach/detach a filter to a Hypergrid.
     * @param {FilterTree} [filter] - The filter object. If undefined, any attached filter is removed, turning filtering OFF.
     * @memberOf dataModels.JSON.prototype
     */
    setGlobalFilter: function(filter) {
        this.getGlobalFilterDataSource().set(filter);
        this.applyAnalytics();
    },

    /**
     * @summary Set the case sensitivity of filter tests against data.
     * @desc Case sensitivity pertains to string compares only. This includes untyped columns, columns typed as strings, typed columns containing data that cannot be coerced to type or when the filter expression operand cannot be coerced.
     *
     * NOTE: This is a shared property and affects all grid managed by this instance of the app.
     * @param {boolean} isSensitive
     * @memberOf dataModels.JSON.prototype
     */
    setGlobalFilterCaseSensitivity: function(isSensitive) {
        this.getGlobalFilter().setCaseSensitivity(isSensitive);
        this.applyAnalytics();
    },

    /**
     * @summary Get a particular column filter's state.
     * @param {string} columnName
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @param {boolean} [options.syntax='CQL'] - The syntax to use to describe the filter state. Note that `getFilter`'s default syntax, `'CQL'`, differs from the other get state methods.
     * @returns {FilterTreeStateObject}
     * @memberOf dataModels.JSON.prototype
     */
    getFilter: function(columnIndexOrName, options) {
        var isIndex = !isNaN(Number(columnIndexOrName)),
            columnName = isIndex ? this.getFields()[columnIndexOrName] : columnIndexOrName;

        return this.getGlobalFilter().getColumnFilterState(columnName, options);
    },

    /**
     * @summary Set a particular column filter's state.
     * @desc After setting the new filter state, reapplies the filter to the data source.
     * @param {number|string} columnIndexOrName - The _column filter_ to set.
     * @param {string|object} [state] - A filter tree object or a JSON, SQL, or CQL subexpression string that describes the a new state for the named column filter. The existing column filter subexpression is replaced with a new node based on this state. If it does not exist, the new subexpression is added to the column filters subtree (`filter.columnFilters`).
     *
     * If undefined, removes the entire column filter subexpression from the column filters subtree.
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @param {string} [options.syntax='CQL'] - The syntax to use to describe the filter state. Note that `setFilter`'s default syntax, `'CQL'`, differs from the other get state methods.
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf dataModels.JSON.prototype
     */
    setFilter: function(columnIndexOrName, state, options) {
        var isIndex = !isNaN(Number(columnIndexOrName)),
            columnName = isIndex ? this.getFields()[columnIndexOrName] : columnIndexOrName;

        this.getGlobalFilter().setColumnFilterState(columnName, state, options);
        this.grid.fireSyntheticFilterAppliedEvent();
        this.applyAnalytics();
    },

    /**
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @returns {FilterTreeStateObject}
     * @memberOf dataModels.JSON.prototype
     */
    getFilters: function(options) {
        return this.getGlobalFilter().getColumnFiltersState(options);
    },

    /**
     * @param {FilterTreeStateObject} state
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf dataModels.JSON.prototype
     */
    setFilters: function(state, options) {
        this.getGlobalFilter().setColumnFiltersState(state, options);
        this.grid.fireSyntheticFilterAppliedEvent();
        this.applyAnalytics();
    },

    /**
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @returns {FilterTreeStateObject}
     * @memberOf dataModels.JSON.prototype
     */
    getTableFilter: function(options) {
        return this.getGlobalFilter().getTableFilterState(options);
    },

    /**
     * @summary Set a the table filter state.
     * @param {FilterTreeStateObject} state
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf dataModels.JSON.prototype
     */
    setTableFilter: function(state, options) {
        this.getGlobalFilter().setTableFilterState(state, options);
        this.grid.fireSyntheticFilterAppliedEvent();
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    applyState: function() {
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    reset: function() {
        this.setData([]);
    },

    getUnfilteredValue: function(x, y) {
        return this.sources.source.getValue(x, y);
    },

    getUnfilteredRowCount: function() {
        return this.sources.source.getRowCount();
    }
});

// LOCAL METHODS -- to be called with `.call(this`

/**
 * Accumulate actual data row objects backing current grid row selections.
 * This call should be paired with a subsequent call to `reselectGridRowsBackedBySelectedDataRows`.
 * @private
 * @memberOf dataModels.JSON.prototype
 */
function selectedDataRowsBackingSelectedGridRows() {
    var selectedData = this.selectedData,
        hasRowSelections = this.grid.selectionModel.hasRowSelections(),
        needFilteredDataList = selectedData.length || hasRowSelections;

    if (needFilteredDataList) {
        var filteredData = this.getFilteredData();
    }

    // STEP 1: Remove any filtered data rows from the recently selected list.
    selectedData.forEach(function(dataRow, index) {
        if (filteredData.indexOf(dataRow) >= 0) {
            delete selectedData[index];
        }
    });

    // STEP 2: Accumulate the data rows backing any currently selected grid rows in `this.selectedData`.
    if (hasRowSelections) { // any current grid row selections?
        this.grid.getSelectedRows().forEach(function(selectedRowIndex) {
            var dataRow = filteredData[selectedRowIndex];
            if (selectedData.indexOf(dataRow) < 0) {
                selectedData.push(dataRow);
            }
        });
    }
}

/**
 * Re-establish grid row selections based on actual data row objects accumulated by `selectedDataRowsBackingSelectedGridRows` which should be called first.
 * @private
 * @memberOf dataModels.JSON.prototype
 */
function reselectGridRowsBackedBySelectedDataRows() {
    if (this.selectedData.length) { // any data row objects added from previous grid row selections?
        var selectionModel = this.grid.selectionModel,
            offset = this.grid.getHeaderRowCount(),
            filteredData = this.getFilteredData();

        selectionModel.clearRowSelection();

        this.selectedData.forEach(function(dataRow) {
            var index = filteredData.indexOf(dataRow);
            if (index >= 0) {
                selectionModel.selectRow(offset + index);
            }
        });
    }
}

function getDataSourceName(name) {
    name = analytics[name].prototype.$$CLASS_NAME || name;
    return name.replace(/^Data(Source|Node)/, '').toLowerCase() || 'source';
}


module.exports = JSON;

},{"../../images":4,"../Shared.js":55,"./DataModel":82}],84:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var LRUCache = require('lru-cache');


/**
 * This module lists the properties that can be set on a {@link Hypergrid} along with their default values.
 * Edit this file to override the defaults.
 * @module defaults
 */

module.exports = {

    /**
     * The font for data cells.
     * @default
     * @type {cssFont}
     * @instance
     */
    noDataMessage: 'no data to display',


    /**
     * The font for data cells.
     * @default
     * @type {cssFont}
     * @instance
     */
    font: '13px Tahoma, Geneva, sans-serif',

    /**
     * Font color for data cells.
     * @default
     * @type {string}
     * @instance
     */
    color: 'rgb(25, 25, 25)',

    /**
     * Background color for data cells.
     * @default
     * @type {string}
     * @instance
     */
    backgroundColor: 'rgb(241, 241, 241)',

    /**
     * Font style for selected cell(s).
     * @default
     * @type {string}
     * @instance
     */
    foregroundSelectionFont: 'bold 13px Tahoma, Geneva, sans-serif',

    /**
     * Font color for selected cell(s).
     * @default
     * @type {string}
     * @instance
     */
    foregroundSelectionColor: 'rgb(0, 0, 128)',
    /**
     * @default
     * @type {boolean}
     * @instance
     */
    sortOnHiddenColumns: true,
    /**
     * Background color for selected cell(s).
     * @default
     * @type {string}
     * @instance
     */
    backgroundSelectionColor: 'rgba(147, 185, 255, 0.625)',


    /********** SECTION: COLUMN HEADER COLORS **********/

    // IMPORTANT CAVEAT: The code is inconsistent regarding the terminology. Is the "column header" section _the row_ of cells at the top (that act as headers for each column) or is it _the column_ of cells (that act as headers for each row)? Oh my.

    /**
     * @default
     * @type {cssFont}
     * @instance
     */
    columnHeaderFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderColor: 'rgb(25, 25, 25)',

    /**
     * Font style for selected columns' headers.
     * @default
     * @type {string}
     * @instance
     */
    columnHeaderForegroundSelectionFont: 'bold 12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderBackgroundColor: 'rgb(223, 227, 232)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderForegroundSelectionColor: 'rgb(80, 80, 80)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderForegroundColumnSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderBackgroundColumnSelectionColor: 'rgb(255, 180, 0)',


    /********** SECTION: ROW HEADER COLORS **********/

    /**
     * @default
     * @type {cssFont}
     * @instance
     */
    rowHeaderFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderBackgroundColor: 'rgb(223, 227, 232)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderForegroundSelectionColor: 'rgb(80, 80, 80)',

    /**
     * Font style for selected rows' headers.
     * @default
     * @type {string}
     * @instance
     */
    rowHeaderForegroundSelectionFont: 'bold 12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderForegroundRowSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderBackgroundRowSelectionColor: 'rgb(255, 180, 0)',


    /********** SECTION: FILTER ROW COLORS **********/

    /**
     * @default
     * @type {cssFont}
     * @instance
     */
    filterFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    filterColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    filterBackgroundColor: 'white',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    filterForegroundSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    filterBackgroundSelectionColor: 'rgb(255, 220, 97)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    filterCellBorderStyle: 'rgba(0,0,0,0.8)',

    /**
     * @default
     * @type {number}
     * @instance
     */
    filterCellBorderThickness: 0.4,
    /********** SECTION: TREE COLUMN COLORS **********/
    // The "tree column" contains the hierarchical drill-down controls.

    /**
     * @default
     * @type {cssFont}
     * @instance
     */
    treeColumnFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnBackgroundColor: 'rgb(223, 227, 232)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnForegroundSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnForegroundColumnSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnBackgroundColumnSelectionColor: 'rgb(255, 180, 0)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    backgroundColor2: 'rgb(201, 201, 201)',

    /**
     * @default
     * @type {number}
     * @instance
     */
    voffset: 0,

    /**
     * @default
     * @type {string}
     * @instance
     */
    scrollbarHoverOver: 'visible',

    /**
     * @default
     * @type {string}
     * @instance
     */
    scrollbarHoverOff: 'hidden',

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    scrollingEnabled: true,

    /**
     * @default
     * @type {string}
     * @instance
     */
    vScrollbarClassPrefix: '',

    /**
     * @default
     * @type {string}
     * @instance
     */
    hScrollbarClassPrefix: '',

    //these used to be in the constants element

    /**
     * @default
     * @type {string}
     * @instance
     */
    fixedRowAlign: 'center',

    /**
     * @default
     * @type {string}
     * @instance
     */
    fixedColAlign: 'center',

    /**
     * @default
     * @type {number}
     * @instance
     */
    cellPadding: 5,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    gridLinesH: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    gridLinesV: true,
    /**
     * @default
     * @type {boolean}
     * @instance
     */
    gridLinesVOverflow: false,

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    lineColor: 'rgb(199, 199, 199)',

    /**
     * @default
     * @type {number}
     * @instance
     */
    lineWidth: 0.4,


    /**
     * @default
     * @type {number}
     * @instance
     */
    defaultRowHeight: 15,

    /**
     * @default
     * @type {number}
     * @instance
     */
    defaultColumnWidth: 100,

    //for immediate painting, set these values to 0, true respectively

    /**
     * @default
     * @type {number}
     * @instance
     */
    repaintIntervalRate: 60,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    repaintImmediately: false,

    //enable or disable double buffering

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    useBitBlit: false,


    /**
     * @default
     * @type {boolean}
     * @instance
     */
    useHiDPI: true,

    /**
     * @default ['alt', 'esc']
     * @type {string}
     * @instance
     */
    editorActivationKeys: ['alt', 'esc'],

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    readOnly: false,

    // inherited by cell renderers

    /**
     * @default `getTextWidth`
     * @type {function}
     * @instance
     */
    getTextWidth: getTextWidth,

    /**
     * @default `getTextHeight`
     * @type {function}
     * @instance
     */
    getTextHeight: getTextHeight,


    /**
     * @default
     * @type {number}
     * @instance
     */
    fixedColumnCount: 0,

    /**
     * @default
     * @type {number}
     * @instance
     */
    fixedRowCount: 0,

    /**
     * @default
     * @type {number}
     * @instance
     */
    headerColumnCount: 0,


    /**
     * @default
     * @type {boolean}
     * @instance
     */
    showRowNumbers: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    showTreeColumn: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    showHeaderRow: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    showFilterRow: true,


    /** Clicking in a cell "selects" it; it is added to the select region and repainted with "cell selection" colors.
     * @default
     * @type {boolean}
     * @instance
     */
    cellSelection: true,

    /** Clicking in a row header (leftmost column) "selects" the row; the entire row is added to the select region and repainted with "row selection" colors.
     * @default
     * @type {boolean}
     * @instance
     */
    columnSelection: true,

    /** Clicking in a column header (top row) "selects" the column; the entire column is added to the select region and repainted with "column selection" colors.
     * @default
     * @type {boolean}
     * @instance
     */
    rowSelection: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    singleRowSelectionMode: true,

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    selectionRegionOverlayColor: 'rgba(0, 0, 48, 0.2)',

    /**
     * @default
     * @type {string}
     * @instance
     */
    selectionRegionOutlineColor: 'black',

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    columnAutosizing: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    rowNumberAutosizing: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    headerTextWrapping: false,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    rowResize: false,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    editable: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    editOnDoubleClick: true,

    /**
     * @default
     * @type {number}
     * @instance
     */
    doubleClickDelay: 325,

    /**
     * Grid-level property.
     * When user presses a printable character key _or_ BACKSPACE _or_ DELETE:
     * 1. Activate cell editor on current cell (i.e., origin of most recent selection).
     * 2. If cell editor is a text editor:
     *    1. Replace current value with the character the user typed; or
     *    2. Clear it on BACKSPACE, DELETE, or other invalid character (_e.g._ when user types a letter but the cell editor only accepts digits).
     *
     * > In invoked, user has the option to back out by pressing the ESCAPE key.
     *
     * @default
     * @type {boolean}
     * @instance
     */
    editOnKeydown: true,

    /**
     * @default
     * @type {boolean}
     */
    checkboxOnlyRowSelections: false,

    /** @summary Name of a formatter for cell text.
     * The default (`undefined`) falls back to `column.type`.
     * The value `null` does no formatting.
     * @default undefined
     * @type {undefined|null|string}
     * @tutorial localization
     */
    format: undefined,

    /** @summary Name of a cell editor from the {@link module:cellEditors|cellEditors API}..
     * @desc Not editable if named editor is does not exist.
     * @default undefined
     * @type {undefined|null|string}
     * @tutorial cell-editors
     */
    editor: undefined,

    /**
     * Name of cell renderer from the {@link module:cellRenderers|cellRenderers API}.
     * @default
     * @type {string}
     */
    renderer: 'SimpleCell',

    /********** HOVER COLORS **********/

    /** @typedef hoverColors
     * @property {boolean} [enable=false] - `false` means not hilite on hover
     * @property {cssColor} backgroundColor - cell, row, or column background color. Alpha channel will be respected and if given will be painted over the cells predetermined color.
     * @property {cssColor} [header.backgroundColor=backgroundColor] - for columns and rows, this is the background color of the column or row "handle" (header rows or columns, respectively). (Not used for cells.)
     */

    /** On mouse hover, whether to repaint the cell background and how.
     * @type {hoverColors}
     * @default '{ enabled: true, background: rgba(160, 160, 40, 0.30) }'
     */
    hoverCellHighlight: {
        enabled: true,
        backgroundColor: 'rgba(160, 160, 40, 0.45)'
    },

    /** On mouse hover, whether to repaint the row background and how.
     * @type {hoverColors}
     * @default '{ enabled: true, background: rgba(100, 100, 25, 0.15) }'
     */
    hoverRowHighlight: {
        enabled: true,
        backgroundColor: 'rgba(100, 100, 25, 0.30)'

    },

    /** On mouse hover, whether to repaint the column background and how.
     * @type {hoverColors}
     * @default '{ enabled: true, background: rgba(60, 60, 15, 0.15) }'
     */
    hoverColumnHighlight: {
        enabled: true,
        backgroundColor: 'rgba(60, 60, 15, 0.15)'
    },


    /** Display cell font with under-score line drawn over it.
     * > Implementation of links right now is not automatic; you must attach a 'fin-click' listener to the hypergrid object, etc.
     * @type {boolean}
     * @default
     */
    link: false,

    /** Display cell font with strike-through line drawn over it.
     * @type {boolean}
     * @default
     */
    strikeThrough: false,

};

/** @typedef {string} cssColor
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
 */
/** @typedef {string} cssFont
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font
 */

var textWidthCache = new LRUCache(2000);

function getTextWidth(gc, string) {
    if (string === null || string === undefined) {
        return 0;
    }
    string = string + '';
    if (string.length === 0) {
        return 0;
    }
    var key = gc.font + string;
    var width = textWidthCache.get(key);
    if (!width) {
        width = gc.measureText(string).width;
        textWidthCache.set(key, width);
    }
    return width;
}

var fontData = {};

function getTextHeight(font) {
    var result = fontData[font];

    if (!result) {
        result = {};

        var text = document.createElement('span');
        text.textContent = 'Hg';
        text.style.font = font;

        var block = document.createElement('div');
        block.style.display = 'inline-block';
        block.style.width = '1px';
        block.style.height = '0px';

        var div = document.createElement('div');
        div.appendChild(text);
        div.appendChild(block);

        div.style.position = 'absolute';
        document.body.appendChild(div);

        try {

            block.style.verticalAlign = 'baseline';

            var blockRect = block.getBoundingClientRect();
            var textRect = text.getBoundingClientRect();

            result.ascent = blockRect.top - textRect.top;

            block.style.verticalAlign = 'bottom';
            result.height = blockRect.top - textRect.top;

            result.descent = result.height - result.ascent;

        } finally {
            document.body.removeChild(div);
        }
        if (result.height !== 0) {
            fontData[font] = result;
        }
    }

    return result;
}

},{"lru-cache":44}],85:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var ListDragon = require('list-dragon');

var Dialog = require('./Dialog');
var stylesheet = require('../lib/stylesheet');

/**
 * @constructor
 */
var ColumnPicker = Dialog.extend('ColumnPicker', {
    /**
     * @param {Hypergrid} grid
     * @param {object} [options] - May include `Dialog` options.
     */
    initialize: function(grid, options) {
        var behavior = grid.behavior;

        this.grid = grid;

        if (behavior.isColumnReorderable()) {
            // grab the lists from the behavior
            this.selectedGroups = {
                title: 'Groups',
                models: behavior.getGroups()
            };

            this.availableGroups = {
                title: 'Available Groups',
                models: behavior.getAvailableGroups()
            };

            this.inactiveColumns = {
                title: 'Inactive Columns',
                models: behavior.getHiddenColumns().sort(compareByName)
            };

            this.activeColumns = {
                title: 'Active Columns',
                models: behavior.getActiveColumns()
            };

            this.sortOnHiddenColumns = this.wasSortOnHiddenColumns = grid.resolveProperty('sortOnHiddenColumns');

            // parse & add the drag-and-drop stylesheet addendum
            var stylesheetAddendum = stylesheet.inject('list-dragon-addendum');

            // create drag-and-drop sets from the lists
            var listSets = [
                new ListDragon([
                    this.selectedGroups,
                    this.availableGroups
                ], {
                    // add the list-dragon-base stylesheet right before the addendum
                    cssStylesheetReferenceElement: stylesheetAddendum
                }),
                new ListDragon([
                    this.inactiveColumns,
                    this.activeColumns
                ], {
                    // these models have a header property as their labels
                    label: '{header}'
                })
            ];

            // add the drag-and-drop sets to the dialog
            var self = this;
            listSets.forEach(function(listSet) {
                listSet.modelLists.forEach(function(list) {
                    self.append(list.container);
                });
            });
            //Listen to the visible column changes
            listSets[1].modelLists[1].element.addEventListener('listchanged', function(e){
                grid.fireSyntheticOnColumnsChangedEvent();
            });

            this.sortOnHiddenColumns = this.grid.resolveProperty('sortOnHiddenColumns');
        } else {
            var div = document.createElement('div');
            div.style.textAlign = 'center';
            div.style.marginTop = '2em';
            div.innerHTML = 'The selection of visible columns in the grid may not be changed.';
            this.append(div);
        }

        // Add checkbox to control panel for sorting on hidden fields
        var label = document.createElement('label');
        label.innerHTML = '<input type="checkbox"> Allow sorting on hidden columns';
        label.style.fontWeight = 'normal';
        label.style.marginRight = '2em';

        var checkbox = label.querySelector('input');
        checkbox.checked = this.sortOnHiddenColumns;
        checkbox.addEventListener('click', function(e){
            self.sortOnHiddenColumns = checkbox.checked;
            e.stopPropagation();
        });

        var panel = this.el.querySelector('.hypergrid-dialog-control-panel');
        panel.insertBefore(label, panel.firstChild);

        // add the dialog to the DOM
        this.open(options.container);
    },

    onClosed: function() {
        if (this.activeColumns) {
            var behavior = this.grid.behavior,
                columns = behavior.columns,
                tree = columns[0];

            // TODO: breaking encapsulation; should be using setters and getters on the behavior
            columns.length = 0;
            if (tree && tree.label === 'Tree') {
                columns.push(tree);
            }
            this.activeColumns.models.forEach(function(column) {
                columns.push(column);
            });
            var groupBys = this.selectedGroups.models.map(function(e) {
                return e.id;
            });
            behavior.dataModel.setGroups(groupBys);

            if (this.sortOnHiddenColumns !== this.wasSortOnHiddenColumns) {
                this.grid.addProperties({ sortOnHiddenColumns: this.sortOnHiddenColumns });
                behavior.sortChanged(this.inactiveColumns.models);
            }

            behavior.changed();
        }
    }
});

function compareByName(a, b) {
    a = a.header.toString().toUpperCase();
    b = b.header.toString().toUpperCase();
    return a < b ? -1 : a > b ? +1 : 0;
}


module.exports = ColumnPicker;

},{"../lib/stylesheet":121,"./Dialog":86,"list-dragon":43}],86:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var automat = require('automat');

var Base = require('../lib/Base');
var markup = require('../../html');
var images = require('../../images');
var elfor = require('../lib/elfor');

/**
 * Creates and services a DOM element used as a cntainer for a dialog. The standard `markup.dialog` is simply a div with a _control panel_ containing a close box and a settings gear icon.
 *
 * You can supply an alternative dialog template. The interface is:
 * * Class name `hypergrid-dialog`.
 * * At least one child element. Content will be inserted before this first child.
 * * Typically contains a close-box element with class name `hypergrid-dialog-close` and possibly other controls with class name `hypergrid-dialog-xxxx` (where _xxxx_ is a unique name for your control).
 *
 * @constructor
 */
var Dialog = Base.extend('Dialog', {

    /**
     * Creates a basic dialog box in `this.el`.
     * @param {Hypergrid} grid
     * @param {object} [options]
     * @param {string|function} [options.dialogTemplate] - An alternate dialog template. The last child element must be the "control panel."
     * @param {boolean} [options.settings=true] - Control box has settings icon. (Settings icon must be included in template. This option removes it. That is, if explicitly `false` _and_ there is a settings control, remove it.)
     * @param {string|boolean} [options.backgroundImage=images.dialog.src] - A URI for a background image. If explicitly `false`, background image is suppressed.
     * @param {function} [terminate]
     */
    initialize: function(grid, options) {
        options = options || {};

        this.grid = grid;

        // create the backdrop; it is absolute-positioned and stretched
        this.el = automat.firstChild(options.dialogTemplate || markup.dialog, options.dialogReplacements);

        this.originalFirstChild = this.el.firstElementChild;

        if (options.settings === false) {
            var settings = this.el.querySelector('.hypergrid-dialog-settings');
            if (settings) {
                settings.remove();
            }
        }

        // add background image
        if (options.backgroundImage !== false) {
            this.el.style.backgroundImage = 'url(\'' + (options.backgroundImage || images.dialog.src) + '\')';
        }

        // listen for clicks
        this.el.addEventListener('click', onClick.bind(this));

        if (options.terminate) {
            this.terminate = options.terminate;
        }
    },

    /**
     * @summary Adds DOM `Node`s to dialog.
     * @desc Input can be nodes or a template from which to create nodes. The nodes are inserted into the dialog's DOM (`this.el`), right before the "control panel."
     * @param {string|function|Node|Node[]} nodes - See `automat`.
     * @param {...*} [replacements] - See `automat`.
     */
    append: function(nodes, replacements/*...*/) {
        var el = this.el;

        if (typeof nodes === 'string' || typeof nodes === 'function') {
            var args = Array.prototype.slice.call(arguments);
            args.splice(1, 0, el, this.originalFirstChild);
            automat.append.apply(null, args);

        } else if ('length' in nodes) {
            for (var i = 0; i < nodes.length; ++i) {
                el.insertBefore(nodes[i], this.originalFirstChild);
            }

        } else {
            el.insertBefore(nodes, this.originalFirstChild);
        }
    },

    /**
     * Insert dialog into DOM.
     *
     * @param {HTMLElement} [container] - If undefined, dialog is appended to body.
     *
     * If defined, dialog is appended to container. When container is not body, it will be:
     * # made visible before append (it should initially be hidden)
     * # made hidden after remove
     */
    open: function(container) {
        var error;

        if (!(this.opened || this.opening || this.closed || this.closing)) {
            error = this.onOpen();

            if (!error) {
                var el = this.el;

                this.opening = true;

                container = container || document.querySelector('body');

                if (container.tagName !== 'BODY') {
                    container.style.visibility = 'visible';
                }

                // insert the new dialog markup into the DOM
                container.appendChild(el);

                // schedule it for a show transition
                setTimeout(function() { el.classList.add('hypergrid-dialog-visible'); }, 50);

                // at end of show transition, hide all the hypergrids behind it to prevent any key/mouse events from getting to them
                // todo: pause all hypergrids so they don't spin uselessly
                el.addEventListener('transitionend', this.hideAppBound = hideApp.bind(this));
            }
        }

        return error;
    },

    /**
     * Remove dialog from DOM.
     */
    close: function() {
        var error;

        if (this.opened && !(this.closed || this.closing)) {
            error = this.onClose();

            if (!error) {
                var el = this.el;

                this.closing = true;

                // unhide all the hypergrids behind the dialog
                this.appVisible('visible');

                // start a hide transition of dialog revealing grids behind it
                el.classList.remove('hypergrid-dialog-visible');

                // at end of hide transition, remove dialog from the DOM
                el.addEventListener('transitionend', this.removeDialogBound = removeDialog.bind(this));
            }
        }

        return error;
    },

    appSelector: 'canvas.hypergrid',
    appVisible: function(visibility) {
        elfor.each(this.appSelector, function(el) {
            el.style.visibility = visibility;
        });
    },

    onOpen: nullPattern,
    onOpened: nullPattern,
    onClose: nullPattern,
    onClosed: nullPattern,
    terminate: nullPattern
});

function nullPattern() {}

function removeDialog(evt) {
    if (evt.target === this.el && evt.propertyName === 'opacity') {
        if (this.el.parentElement.tagName !== 'BODY') {
            this.el.parentElement.style.visibility = 'hidden';
        }
        this.el.remove();
        delete this.el;

        this.onClosed();
        this.terminate();
        this.closing = false;
        this.closed = true;
    }
}

function hideApp(evt) {
    if (evt.target === this.el && evt.propertyName === 'opacity') {
        this.appVisible('hidden');
        this.el.removeEventListener('transitionend', this.hideAppBound);
        this.onOpened();
        this.opening = false;
        this.opened = true;
    }
}

function onClick(evt) {
    if (this) {
        if (evt.target.classList.contains('hypergrid-dialog-close')) {
            evt.preventDefault(); // ignore href
            this.close();

        } else if (evt.target.classList.contains('hypergrid-dialog-settings')) {
            evt.preventDefault(); // ignore href
            if (this.settings) { this.settings(); }

        } else if (this.onClick && !this.onClick.call(this, evt) && evt.target.tagName === 'A') {
            evt.preventDefault(); // ignore href of handled event
        }
    }

    evt.stopPropagation(); // the click stops here, handled or not
}

module.exports = Dialog;

},{"../../html":2,"../../images":4,"../lib/Base":110,"../lib/elfor":117,"automat":5}],87:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var Tabz = require('tabz');
var popMenu = require('pop-menu');
var automat = require('automat');

var Dialog = require('./Dialog');
var markup = require('../../html');
var copyInput = require('../lib/copy-input');

var tabProperties = {
    tableQB: {
        isTableFilter: true
    },
    tableSQL: {
        isTableFilter: true,
        language: 'SQL'
    },
    columnsQB: {
        isColumnFilter: true
    },
    columnsSQL: {
        isColumnFilter: true,
        language: 'SQL'
    },
    columnsCQL: {
        isColumnFilter: true,
        language: 'CQL'
    }
};

/**
 * @constructor
 */
var ManageFilters = Dialog.extend('ManageFilters', {

    /**
     * @param {Hypergrid} grid
     * @param {object} [options] - May include `Dialog` options.
     * @param {HTMLElement} [options.container=document.body]
     */
    initialize: function(grid, options) {
        this.filter = grid.getGlobalFilter();

        this.append(markup.filterTrees);

        // initialize the folder tabs
        var tabz = this.tabz = new Tabz({
            root: this.el,
            onEnable: renderFolder.bind(this),
            onDisable: saveFolders.bind(this, null) // null options
        });

        // wire-up the New Column drop-down
        var newColumnDropDown = this.el.querySelector('#add-column-filter-subexpression');
        newColumnDropDown.onmousedown = onNewColumnMouseDown.bind(this);
        newColumnDropDown.onchange = onNewColumnChange.bind(this);

        // put the two subtrees in the two panels
        tabz.folder('#tableQB').appendChild(this.filter.tableFilter.el);
        tabz.folder('#columnsQB').appendChild(this.filter.columnFilters.el);

        // copy the SQL more-info block from the table to the columns tab
        var columnSqlEl = tabz.folder('#columnsSQL');
        var moreSqlInfo = tabz.folder('#tableSQL').firstElementChild.cloneNode(true);
        columnSqlEl.insertBefore(moreSqlInfo, columnSqlEl.firstChild);

        // add it to the DOM
        this.open(options.container);

        // following needed for unclear reasons to get drop-down to display correctly
        newColumnDropDown.selectedIndex = 0;
    },

    onClose: function() {
        return saveFolders.call(this);
    },

    onClosed: function() {
        var behavior = this.grid.behavior;
        behavior.applyAnalytics();
        behavior.changed();
    },

    /**
     * Custom click handlers; called by curtain.onclick in context
     * @param evt
     * @returns {boolean}
     */
    onClick: function(evt) { // to be called with filter object as syntax
        var ctrl = evt.target;

        if (ctrl.classList.contains('more-info')) {
            // find all more-info links and their adjacent blocks (blocks always follow links)
            var els = this.el.querySelectorAll('.more-info');

            // hide all more-info blocks except the one following this link (unless it's already visible in which case hide it too).
            for (var i = 0; i < els.length; ++i) {
                var el = els[i];
                if (el.tagName === 'A') {
                    var found = el === ctrl;
                    el.classList[found ? 'toggle' : 'remove']('hide-info');
                    el = els[i + 1];
                    el.style.display = found && el.style.display !== 'block' ? 'block' : 'none';
                }
            }

        } else if (ctrl.classList.contains('filter-copy')) {
            var isCopyAll = ctrl.childNodes.length; // contains "All"
            if (isCopyAll) {
                ctrl = this.tabz.folder(ctrl).querySelector(copyInput.selectorTextControls);
                copyInput(ctrl, this.filter.columnFilters.getState({ syntax: 'SQL' }));
            } else {
                copyInput(ctrl.parentElement.querySelector(copyInput.selectorTextControls));
            }

        } else {
            return true; // means unhandled
        }
    }
});

/**
 * @param options
 * @param tab
 * @param folder
 * @param [panel] Panel to save (from tab click). If omitted, save both panels (from onclose).
 * @returns {boolean|undefined|string}
 */
function saveFolders(options, tab, folder, panel) {
    return (
        (!panel || panel.id === 'tableFilterPanel') && saveFolder.call(this, this.filter.tableFilter, options) ||
        (!panel || panel.id === 'columnFiltersPanel') && saveFolder.call(this, this.filter.columnFilters, options)
    );
}

/**
 * @this Filter
 * @param {DefaultFilter} subtree
 * @param {object} [options={alert:true,focus:true}] - Side effects as per `FilterTree.prototype.invalid`'s `options`' parameter.
 * @returns {undefined|string} - Validation error text; falsy means valid (no error).
 */
function saveFolder(subtree, options) { // to be called with filter object as syntax
    var isColumnFilters = subtree === this.filter.columnFilters,
        tabQueryBuilder = this.tabz.tab(isColumnFilters ? '#columnsQB' : '#tableQB'),
        tab = this.tabz.enabledTab(tabQueryBuilder),
        folder = this.tabz.folder(tab),
        isQueryBuilder = tab === tabQueryBuilder,
        defaultedOptions = options || {
            alert: true,
            focus: true
        },
        enhancedOptions = {
            alert: defaultedOptions.alert,
            focus: defaultedOptions.focus && isQueryBuilder
        },
        error, ctrl;

    if (isColumnFilters || isQueryBuilder) {
        error = subtree.invalid(enhancedOptions);
    } else { // table filter SQL tab
        ctrl = folder.querySelector('textarea');
        error = this.filter.setTableFilterState(ctrl.value, options);
    }

    if (error && !isQueryBuilder) {
        // If there was a validation error, move the focus from the query builder control to the text box control.
        if (isColumnFilters) {
            // We're in SQL or CQL tab so find text box that goes with this subexpression and focus on it instead of QB control.
            var errantColumnName = error.node.el.parentElement.querySelector('input').value;
            ctrl = folder.querySelector('[name="' + errantColumnName + '"]');
        }
    }

    if (ctrl) {
        decorateFilterInput(ctrl, error);
    }

    return error;
}

function decorateFilterInput(ctrl, error) {
    ctrl.classList.toggle('filter-tree-error', !!error);

    ctrl.focus();

    // find the nearby warning element
    var warningEl;
    do {
        ctrl = ctrl.parentElement;
        warningEl = ctrl.querySelector('.filter-tree-warn');
    } while (!warningEl);

    // show or hide the error
    warningEl.innerHTML = error.message || error || '';
}

function onNewColumnMouseDown(evt) { // to be called with filter object as syntax
    if (saveFolder.call(this, this.filter.columnFilters)) {
        evt.preventDefault(); // do not drop down
    } else {
        // (re)build the drop-down contents, with same prompt, but excluding columns with active filter subexpressions
        var ctrl = evt.target,
            prompt = ctrl.options[0].text.replace('', ''), // use original but w/o ellipsis as .build() appends one
            blacklist = this.filter.columnFilters.children.map(function(columnFilter) {
                return columnFilter.children.length && columnFilter.children[0].column;
            }),
            options = {
                prompt: prompt,
                blacklist: blacklist
            };

        popMenu.build(ctrl, this.filter.root.schema, options);
    }
}

function onNewColumnChange(evt) {
    var ctrl = evt.target,
        tabColumnQB = this.tabz.folder('#tableQB'),
        tab = this.tabz.enabledTab(tabColumnQB.parentElement),
        isQueryBuilder = tab === tabColumnQB,
        tabProps = tabProperties[tab.id];

    this.filter.columnFilters.add({
        state: {
            type: 'columnFilter',
            children: [ { column: ctrl.value } ]
        },
        focus: isQueryBuilder
    });

    if (tabProps.isColumnFilter && tabProps.lanugage) {
        renderFolder.call(this, tab);
    }

    // remove all but the prompt option (first child)
    ctrl.selectedIndex = 0;
    while (ctrl.lastChild !== ctrl.firstChild) {
        ctrl.removeChild(ctrl.lastChild);
    }
}

function renderFolder(tab) { // to be called with filter object as syntax
    var tabProps = tabProperties[tab.id],
        queryLanguage = tabProps.language;

    if (queryLanguage) {
        var globalFilter = this.filter,
            folder = this.tabz.folder(tab);

        if (tabProps.isTableFilter) {

            folder.querySelector('textarea').value = globalFilter.tableFilter.getState({ syntax: 'SQL' });

        } else { // column filter

            var columnFilters = globalFilter.columnFilters.children,
                el = folder.lastElementChild,
                msgEl = el.querySelector('span'),
                listEl = el.querySelector('ol'),
                copyAllLink = el.querySelector('a:first-of-type');

            msgEl.innerHTML = activeFiltersMessage(columnFilters.length);
            listEl.innerHTML = '';

            // for each column filter subtree, append an <li>...</li> element containing:
            // column title, "(copy)" link, and editable text input box containing the subexpression
            columnFilters.forEach(function(filter) {
                var conditional = filter.children[0],
                    item = conditional.schema[0],
                    name = conditional.column,
                    alias = item.alias || name,
                    expression = filter.getState({ syntax: queryLanguage }),
                    isNull = expression === '(NULL IS NULL)' || expression === '',
                    content = isNull ? '' : expression,
                    className = isNull ? 'filter-tree-error' : '',
                    li = automat.firstChild(markup[queryLanguage], alias, name, content, className);

                listEl.appendChild(li);
            });

            folder.onkeyup = setColumnFilterState.bind(this, queryLanguage);

            if (copyAllLink) {
                // if there's a "(copy all)" link, hide it if only 0 or 1 subexpressions
                copyAllLink.style.display = columnFilters.length > 1 ? 'block' : 'none';
            }
        }

    }
}

//var RETURN_KEY = 0x0d, ESCAPE_KEY = 0x1b;
/**
 * Called from key-up events from `#columnSQL` and `#columnCQL` tabs.
 * @this Filter
 * @param {string} queryLanguage
 * @param {KeyboardEvent} evt
 */
function setColumnFilterState(queryLanguage, evt) {
    var ctrl = evt.target;

    // Only handle if key was pressed inside a text box.
    if (ctrl.classList.contains('filter-text-box')) {
        //switch (evt.keyCode) {
        //    case ESCAPE_KEY:
        //        ctrl.value = oldArg;
        //    case RETURN_KEY: // eslint-disable-line no-fallthrough
        //        ctrl.blur();
        //        break;
        //    default:
        var error,
            options = { syntax: queryLanguage, alert: true };

        try {
            error = this.filter.setColumnFilterState(ctrl.name, ctrl.value, options);
        } catch (err) {
            error = err;
        }

        decorateFilterInput(ctrl, error);
        //}
    }
}

function activeFiltersMessage(n) {
    var result;

    switch (n) {
        case 0:
            result = 'There are no active column filters.';
            break;
        case 1:
            result = 'There is 1 active column filter:';
            break;
        default:
            result = 'There are ' + n + ' active column filters:';
    }

    return result;
}


module.exports = ManageFilters;

},{"../../html":2,"../lib/copy-input":114,"./Dialog":86,"automat":5,"pop-menu":47,"tabz":51}],88:[function(require,module,exports){
'use strict';

module.exports.ColumnPicker = require('./ColumnPicker');
module.exports.ManageFilters = require('./ManageFilters');

},{"./ColumnPicker":85,"./ManageFilters":87}],89:[function(require,module,exports){
/* eslint-env browser */

'use strict';

/* NOTE
 *
 * What this file is:
 * * This file is browserify's entry point.
 * * This file creates the `window.fin.Hypergrid` object.
 *
 * What this file is not:
 * * This file is not a node module; it has no reference to `module.exports` or `exports`; it cannot be "required" by any other file.
 * * This file is blacklisted in .npmignore and is not published to npm.
 *
 * Note: The npm "main" entry point (as noted in package.json) is src/Hypergrid.js.
 */

var Hypergrid = require('./Hypergrid');

// Expose some namespaces to users of the hypergrid.js file through `fin.Hypergrid`:
Hypergrid.JSON = require('./lib/json');
Hypergrid.images = require('../images');
Hypergrid.behaviors = require('./behaviors');
Hypergrid.features = require('./features');
Hypergrid.analytics = require('./Shared.js').analytics;
Hypergrid.DefaultFilter = require('./filter/DefaultFilter');
Hypergrid.ColumnSchemaFactory = require('./filter/ColumnSchemaFactory');
Hypergrid.FilterTree = require('./Shared').FilterTree;
Hypergrid.rectangular = require('rectangular');

// Create the `fin` and in particular the `fin.Hypergrid` objects:
(window.fin = window.fin || {}).Hypergrid = Hypergrid;

// Note that while users of the npm module can also access the above namespaces through the Hypergrid object, in reality they also have access to any namespace through `require`, for example:
// var behaviorJSON = require('fin-hypergrid/src/behaviors/JSON');

},{"../images":4,"./Hypergrid":54,"./Shared":55,"./Shared.js":55,"./behaviors":61,"./features":106,"./filter/ColumnSchemaFactory":107,"./filter/DefaultFilter":108,"./lib/json":118,"rectangular":48}],90:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var CellClick = Feature.extend('CellClick', {

    /**
     * @memberOf CellClick.prototype
     * @desc Handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleClick: function(grid, event) {
        if (
            event.gridCell.y >= grid.behavior.getHeaderRowCount() &&
            event.gridCell.x >= grid.behavior.getHeaderColumnCount()
        ) {
            grid.cellClicked(event);
        } else if (this.next) {
            this.next.handleClick(grid, event);
        }
    }
});

module.exports = CellClick;

},{"./Feature.js":99}],91:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');
var CellEditor = require('../cellEditors/CellEditor');

/**
 * @constructor
 */
var CellEditing = Feature.extend('CellEditing', {

    /**
     * @memberOf CellEditing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDoubleClick: function(grid, event) {
        var isDoubleClickEditorActivation = grid.resolveProperty('editOnDoubleClick');
        if (this.checkActivateEditor(grid, event, isDoubleClickEditorActivation)) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    handleClick: function(grid, event) {
        var isDoubleClickEditorActivation = grid.resolveProperty('editOnDoubleClick');
        if (this.checkActivateEditor(grid, event, !isDoubleClickEditorActivation)) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleClick(grid, event);
        }
    },

    checkActivateEditor: function(grid, event, isDoubleClickEditorActivation) {
        var headerRowCount = grid.behavior.getHeaderRowCount();
        var headerColumnCount = grid.behavior.getHeaderColumnCount();
        var gridCell = event.gridCell;
        var isFilterRow = grid.isFilterRow(gridCell.y);

        return isDoubleClickEditorActivation &&
            gridCell.x >= headerColumnCount &&
            (isFilterRow || gridCell.y >= headerRowCount);
    },

    /**
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf KeyPaging.prototype
     */
    handleKeyDown: function(grid, event) {
        var char, isVisibleChar, isDeleteChar, currentCell, editor;

        if (
            grid.resolveProperty('editOnKeydown') &&
            !grid.cellEditor &&
            (
                (char = event.detail.char) === 'F2' ||
                (isVisibleChar = char.length === 1 && !(event.detail.meta || event.detail.ctrl)) ||
                (isDeleteChar = char === 'DELETE' || char === 'BACKSPACE')
            )
        ) {
            currentCell = grid.selectionModel.getLastSelection();
            if (currentCell) {
                var pseudoEvent = { gridCell: currentCell.origin };
                editor = grid.onEditorActivate(pseudoEvent);
                if (editor instanceof CellEditor) {
                    if (isVisibleChar) {
                        editor.setEditorValue(char);
                    } else if (isDeleteChar) {
                        editor.setEditorValue('');
                    }
                    event.detail.primitiveEvent.preventDefault();
                }
            }
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    }

});

module.exports = CellEditing;

},{"../cellEditors/CellEditor":62,"./Feature.js":99}],92:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var CellSelection = Feature.extend('CellSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {window.fin.rectangular.Point}
     * @memberOf CellSelection.prototype
     */
    currentDrag: null,

    /**
     * the cell coordinates of the where the mouse pointer is during a drag operation
     * @type {Object}
     * @memberOf CellSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf CellSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf CellSelection.prototype
     */
    sbAutoStart: 0,

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragging) {
            this.dragging = false;
        }
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        var isRightClick = event.primitiveEvent.detail.isRightClick;
        var cell = event.gridCell;
        var viewCell = event.viewPoint;
        var dx = cell.x;
        var dy = cell.y;
        var headerRowCount = grid.behavior.getHeaderRowCount();
        var headerColumnCount = grid.behavior.getHeaderColumnCount();
        var columnCount = grid.getColumnCount();
        var isOutside = viewCell.x >= columnCount;

        var isHeader = dy < headerRowCount || dx < headerColumnCount;

        if (!grid.isCellSelection() || isRightClick || isHeader || isOutside) {
            if (this.next) {
                this.next.handleMouseDown(grid, event);
            }
        } else {
            var numFixedColumns = grid.getFixedColumnCount();
            var numFixedRows = grid.getFixedRowCount();

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(dx, dy);

            var primEvent = event.primitiveEvent;
            var keys = primEvent.detail.keys;
            this.dragging = true;
            this.extendSelection(grid, dCell, keys);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        var isRightClick = event.primitiveEvent.detail.isRightClick;

        if (!grid.isCellSelection() || isRightClick || !this.dragging) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
        } else {

            var numFixedColumns = grid.getFixedColumnCount();
            var numFixedRows = grid.getFixedRowCount();

            var cell = event.gridCell;
            var viewCell = event.viewPoint;
            var dx = cell.x;
            var dy = cell.y;

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(dx, dy);

            var primEvent = event.primitiveEvent;
            this.currentDrag = primEvent.detail.mouse;
            this.lastDragCell = dCell;

            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, dCell, primEvent.detail.keys);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        var handler;
        if ((handler = this['handle' + event.detail.char])) {
            handler.call(this, grid, event.detail);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle a mousedrag selection.
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {

        var headerRowCount = grid.behavior.getHeaderRowCount();
        var headerColumnCount = grid.behavior.getHeaderColumnCount();
        var x = gridCell.x;
        var y = gridCell.y;
        x = Math.max(headerColumnCount, x);
        y = Math.max(headerRowCount, y);

        var previousDragExtent = grid.getDragExtent();
        var mouseDown = grid.getMouseDown();

        //var scrollingNow = grid.isScrollingNow();

        var newX = x - mouseDown.x;
        var newY = y - mouseDown.y;

        if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
            return;
        }

        grid.clearMostRecentSelection();

        grid.select(mouseDown.x, mouseDown.y, newX, newY);
        grid.setDragExtent(grid.newPoint(newX, newY));

        grid.repaint();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {

        if (!grid.isScrollingNow()) {
            return;
        }

        var dragStartedInHeaderArea = grid.isMouseDownInHeaderArea();
        var lastDragCell = this.lastDragCell;
        var b = grid.getDataBounds();
        var xOffset = 0;
        var yOffset = 0;

        var numFixedColumns = grid.getFixedColumnCount();
        var numFixedRows = grid.getFixedRowCount();

        var dragEndInFixedAreaX = lastDragCell.x < numFixedColumns;
        var dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (!dragStartedInHeaderArea) {
            if (this.currentDrag.x < b.origin.x) {
                xOffset = -1;
            }
            if (this.currentDrag.y < b.origin.y) {
                yOffset = -1;
            }
        }
        if (this.currentDrag.x > b.origin.x + b.extent.x) {
            xOffset = 1;
        }
        if (this.currentDrag.y > b.origin.y + b.extent.y) {
            yOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }

        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        var hasCTRL = keys.indexOf('CTRL') >= 0;
        var hasSHIFT = keys.indexOf('SHIFT') >= 0;
        // var scrollTop = grid.getVScrollValue();
        // var scrollLeft = grid.getHScrollValue();

        // var numFixedColumns = 0;//grid.getFixedColumnCount();
        // var numFixedRows = 0;//grid.getFixedRowCount();

        var mousePoint = grid.getMouseDown();
        var x = gridCell.x; // - numFixedColumns + scrollLeft;
        var y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        //we have repeated a click in the same spot deslect the value from last time
        if (
            hasCTRL &&
            x === mousePoint.x &&
            y === mousePoint.y
        ) {
            grid.clearMostRecentSelection();
            grid.popMouseDown();
            grid.repaint();
            return;
        }

        if (!hasCTRL && !hasSHIFT) {
            grid.clearSelections();
        }

        if (hasSHIFT) {
            grid.clearMostRecentSelection();
            grid.select(mousePoint.x, mousePoint.y, x - mousePoint.x + 1, y - mousePoint.y + 1);
            grid.setDragExtent(grid.newPoint(x - mousePoint.x + 1, y - mousePoint.y));
        } else {
            grid.select(x, y, 0, 0);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {
        this.moveShiftSelect(grid, 0, 1);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {
        this.moveShiftSelect(grid, 0, -1);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid, event) {
        //keep the browser viewport from auto scrolling on key event
        event.primitiveEvent.preventDefault();

        var count = this.getAutoScrollAcceleration();
        this.moveSingleSelect(grid, 0, count);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid, event) {
        //keep the browser viewport from auto scrolling on key event
        event.primitiveEvent.preventDefault();

        var count = this.getAutoScrollAcceleration();
        this.moveSingleSelect(grid, 0, -count);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {
        this.moveSingleSelect(grid, -1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {
        this.moveSingleSelect(grid, 1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetX, offsetY) {

        var maxColumns = grid.getColumnCount() - 1;
        var maxRows = grid.getRowCount() - 1;

        var maxViewableColumns = grid.getVisibleColumns() - 1;
        var maxViewableRows = grid.getVisibleRows() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var origin = grid.getMouseDown();
        var extent = grid.getDragExtent();

        var newX = extent.x + offsetX;
        var newY = extent.y + offsetY;

        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));
        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

        grid.clearMostRecentSelection();
        grid.select(origin.x, origin.y, newX, newY);

        grid.setDragExtent(grid.newPoint(newX, newY));

        if (grid.insureModelColIsVisible(newX + origin.x, offsetX)) {
            this.pingAutoScroll();
        }
        if (grid.insureModelRowIsVisible(newY + origin.y, offsetY)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetX, offsetY) {

        var maxColumns = grid.getColumnCount() - 1;
        var maxRows = grid.getRowCount() - 1;

        var maxViewableColumns = grid.getVisibleColumnsCount() - 1;
        var maxViewableRows = grid.getVisibleRowsCount() - 1;

        var minRows = grid.getHeaderRowCount();
        var minCols = grid.getHeaderColumnCount();

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());

        var newX = mouseCorner.x + offsetX;
        var newY = mouseCorner.y + offsetY;

        newX = Math.min(maxColumns, Math.max(minCols, newX));
        newY = Math.min(maxRows, Math.max(minRows, newY));

        grid.clearSelections();
        grid.select(newX, newY, 0, 0);
        grid.setMouseDown(grid.newPoint(newX, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        grid.selectCellAndScrollToMakeVisible(newX, newY);

        // if (grid.insureModelColIsVisible(newX, offsetX)) {
        //     this.pingAutoScroll();
        // }
        // if (grid.insureModelRowIsVisible(newY, offsetY)) {
        //     this.pingAutoScroll();
        // }

        grid.repaint();

    }

});

module.exports = CellSelection;

},{"./Feature.js":99}],93:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ColumnAutosizing = Feature.extend('ColumnAutosizing', {

    /**
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf ColumnAutosizing.prototype
     */
    handleDoubleClick: function(grid, event) {
        var headerRowCount = grid.getHeaderRowCount();
        //var headerColCount = grid.getHeaderColumnCount();
        var gridCell = event.gridCell;
        if (gridCell.y <= headerRowCount) {
            grid.autosizeColumn(gridCell.x);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    }

});

module.exports = ColumnAutosizing;

},{"./Feature.js":99}],94:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

// This feature is responsible for column drag and drop reordering.
// This object is a mess and desperately needs a complete rewrite.....

var Feature = require('./Feature.js');

var columnAnimationTime = 150;
var dragger;
var draggerCTX;
var floatColumn;
var floatColumnCTX;

/**
 * @constructor
 */
var ColumnMoving = Feature.extend('ColumnMoving', {

    /**
     * queue up the animations that need to play so they are done synchronously
     * @type {Array}
     * @memberOf CellMoving.prototype
     */
    floaterAnimationQueue: [],

    /**
     * am I currently auto scrolling right
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    columnDragAutoScrollingRight: false,

    /**
     * am I currently auto scrolling left
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    columnDragAutoScrollingLeft: false,

    /**
     * is the drag mechanism currently enabled ("armed")
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    dragArmed: false,

    /**
     * am I dragging right now
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    dragging: false,

    /**
     * the column index of the currently dragged column
     * @type {number}
     * @memberOf CellMoving.prototype
     */
    dragCol: -1,

    /**
     * an offset to position the dragged item from the cursor
     * @type {number}
     * @memberOf CellMoving.prototype
     */
    dragOffset: 0,

    /**
     * @memberOf CellMoving.prototype
     * @desc give me an opportunity to initialize stuff on the grid
     * @param {Hypergrid} grid
     */
    initializeOn: function(grid) {
        this.isFloatingNow = false;
        this.initializeAnimationSupport(grid);
        if (this.next) {
            this.next.initializeOn(grid);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc initialize animation support on the grid
     * @param {Hypergrid} grid
     */
    initializeAnimationSupport: function(grid) {
        if (!dragger) {
            dragger = document.createElement('canvas');
            dragger.setAttribute('width', '0px');
            dragger.setAttribute('height', '0px');

            document.body.appendChild(dragger);
            draggerCTX = dragger.getContext('2d');
        }
        if (!floatColumn) {
            floatColumn = document.createElement('canvas');
            floatColumn.setAttribute('width', '0px');
            floatColumn.setAttribute('height', '0px');

            document.body.appendChild(floatColumn);
            floatColumnCTX = floatColumn.getContext('2d');
        }

    },

    getCanDragCursorName: function() {
        return '-webkit-grab';
    },

    getDraggingCursorName: function() {
        return '-webkit-grabbing';
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {

        var gridCell = event.gridCell;
        var x;
        //var y;

        var distance = Math.abs(event.primitiveEvent.detail.dragstart.x - event.primitiveEvent.detail.mouse.x);

        if (distance < 10 || this.isFixedColumn(grid, event)) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
            return;
        }

        if (this.isHeaderRow(grid, event) && this.dragArmed && !this.dragging) {
            this.dragging = true;
            this.dragCol = gridCell.x;
            this.dragOffset = event.mousePoint.x;
            this.detachChain();
            x = event.primitiveEvent.detail.mouse.x - this.dragOffset;
            //y = event.primitiveEvent.detail.mouse.y;
            this.createDragColumn(grid, x, this.dragCol);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }

        if (this.dragging) {
            x = event.primitiveEvent.detail.mouse.x - this.dragOffset;
            //y = event.primitiveEvent.detail.mouse.y;
            this.dragColumn(grid, x);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (grid.behavior.isColumnReorderable() && !this.isFixedColumn(grid, event)) {
            if (this.isHeaderRow(grid, event) && event.gridCell.x !== -1) {
                this.dragArmed = true;
                this.cursor = this.getDraggingCursorName();
                grid.clearSelections();
            }
        }
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        //var col = event.gridCell.x;
        if (this.dragging) {
            this.cursor = null;
            //delay here to give other events a chance to be dropped
            var self = this;
            this.endDragColumn(grid);
            setTimeout(function() {
                self.attachChain();
            }, 200);
        }
        this.dragCol = -1;
        this.dragging = false;
        this.dragArmed = false;
        this.cursor = null;
        grid.repaint();

        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {

        if (!this.dragging && event.mousePoint.y < 5 && event.viewPoint.y === 0 && !this.isFixedColumn(grid, event)) {
            this.cursor = this.getCanDragCursorName();
        } else {
            this.cursor = null;
        }

        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }

        if (this.isHeaderRow(grid, event) && this.dragging) {
            this.cursor = this.getDraggingCursorName(); //move';
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc this is the main event handler that manages the dragging of the column
     * @param {Hypergrid} grid
     * @param {boolean} draggedToTheRight - are we moving to the right
     */
    floatColumnTo: function(grid, draggedToTheRight) {
        this.floatingNow = true;

        var renderer = grid.getRenderer();
        var colEdges = renderer.getColumnEdges();
        var scrollLeft = grid.getHScrollValue();
        var floaterIndex = grid.renderOverridesCache.floater.columnIndex;
        var draggerIndex = grid.renderOverridesCache.dragger.columnIndex;
        var hdpiratio = grid.renderOverridesCache.dragger.hdpiratio;

        var draggerStartX;
        var floaterStartX;
        var fixedColumnCount = grid.getFixedColumnCount();
        var draggerWidth = grid.getColumnWidth(draggerIndex);
        var floaterWidth = grid.getColumnWidth(floaterIndex);

        var max = grid.getVisibleColumnsCount();

        var doffset = 0;
        var foffset = 0;

        if (draggerIndex >= fixedColumnCount) {
            doffset = scrollLeft;
        }
        if (floaterIndex >= fixedColumnCount) {
            foffset = scrollLeft;
        }

        if (draggedToTheRight) {
            draggerStartX = colEdges[Math.min(max, draggerIndex - doffset)];
            floaterStartX = colEdges[Math.min(max, floaterIndex - foffset)];

            grid.renderOverridesCache.dragger.startX = (draggerStartX + floaterWidth) * hdpiratio;
            grid.renderOverridesCache.floater.startX = draggerStartX * hdpiratio;

        } else {
            floaterStartX = colEdges[Math.min(max, floaterIndex - foffset)];
            draggerStartX = floaterStartX + draggerWidth;

            grid.renderOverridesCache.dragger.startX = floaterStartX * hdpiratio;
            grid.renderOverridesCache.floater.startX = draggerStartX * hdpiratio;
        }
        grid.swapColumns(draggerIndex, floaterIndex);
        grid.renderOverridesCache.dragger.columnIndex = floaterIndex;
        grid.renderOverridesCache.floater.columnIndex = draggerIndex;


        this.floaterAnimationQueue.unshift(this.doColumnMoveAnimation(grid, floaterStartX, draggerStartX));

        this.doFloaterAnimation(grid);

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc manifest the column drag and drop animation
     * @param {Hypergrid} grid
     * @param {number} floaterStartX - the x start coordinate of the column underneath that floats behind the dragged column
     * @param {number} draggerStartX - the x start coordinate of the dragged column
     */
    doColumnMoveAnimation: function(grid, floaterStartX, draggerStartX) {
        var self = this;
        return function() {
            var d = floatColumn;
            d.style.display = 'inline';
            self.setCrossBrowserProperty(d, 'transform', 'translate(' + floaterStartX + 'px, ' + 0 + 'px)');

            //d.style.webkit-webkit-Transform = 'translate(' + floaterStartX + 'px, ' + 0 + 'px)';
            //d.style.webkit-webkit-Transform = 'translate(' + floaterStartX + 'px, ' + 0 + 'px)';

            requestAnimationFrame(function() {
                self.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + columnAnimationTime + 'ms ease');
                self.setCrossBrowserProperty(d, 'transform', 'translate(' + draggerStartX + 'px, ' + -2 + 'px)');
            });
            grid.repaint();
            //need to change this to key frames

            setTimeout(function() {
                self.setCrossBrowserProperty(d, 'transition', '');
                grid.renderOverridesCache.floater = null;
                grid.repaint();
                self.doFloaterAnimation(grid);
                requestAnimationFrame(function() {
                    d.style.display = 'none';
                    self.isFloatingNow = false;
                });
            }, columnAnimationTime + 50);
        };
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc manifest the floater animation
     * @param {Hypergrid} grid
     */
    doFloaterAnimation: function(grid) {
        if (this.floaterAnimationQueue.length === 0) {
            this.floatingNow = false;
            grid.repaint();
            return;
        }
        var animation = this.floaterAnimationQueue.pop();
        animation();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc create the float column at columnIndex underneath the dragged column
     * @param {Hypergrid} grid
     * @param {number} columnIndex - the index of the column that will be floating
     */
    createFloatColumn: function(grid, columnIndex) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var renderer = grid.getRenderer();
        var columnEdges = renderer.getColumnEdges();

        var columnWidth = grid.getColumnWidth(columnIndex);
        var colHeight = grid.div.clientHeight;
        var d = floatColumn;
        var style = d.style;
        var location = grid.div.getBoundingClientRect();

        style.top = (location.top - 2) + 'px';
        style.left = location.left + 'px';
        style.position = 'fixed';

        var hdpiRatio = grid.getHiDPI(floatColumnCTX);

        d.setAttribute('width', Math.round(columnWidth * hdpiRatio) + 'px');
        d.setAttribute('height', Math.round(colHeight * hdpiRatio) + 'px');
        style.boxShadow = '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)';
        style.width = columnWidth + 'px'; //Math.round(columnWidth / hdpiRatio) + 'px';
        style.height = colHeight + 'px'; //Math.round(colHeight / hdpiRatio) + 'px';
        style.borderTop = '1px solid ' + renderer.resolveProperty('lineColor');
        style.backgroundColor = renderer.resolveProperty('backgroundColor');

        var startX = columnEdges[columnIndex - scrollLeft];
        startX = startX * hdpiRatio;

        floatColumnCTX.scale(hdpiRatio, hdpiRatio);

        grid.renderOverridesCache.floater = {
            columnIndex: columnIndex,
            ctx: floatColumnCTX,
            startX: startX,
            width: columnWidth,
            height: colHeight,
            hdpiratio: hdpiRatio
        };

        style.zIndex = '4';
        this.setCrossBrowserProperty(d, 'transform', 'translate(' + startX + 'px, ' + -2 + 'px)');
        style.cursor = this.getDraggingCursorName();
        grid.repaint();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc utility function for setting cross browser css properties
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setCrossBrowserProperty: function(element, property, value) {
        var uProperty = property[0].toUpperCase() + property.substr(1);
        this.setProp(element, 'webkit' + uProperty, value);
        this.setProp(element, 'Moz' + uProperty, value);
        this.setProp(element, 'ms' + uProperty, value);
        this.setProp(element, 'O' + uProperty, value);
        this.setProp(element, property, value);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc utility function for setting properties on HTMLElements
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setProp: function(element, property, value) {
        if (property in element.style) {
            element.style[property] = value;
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc create the dragged column at columnIndex above the floated column
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     * @param {number} columnIndex - the index of the column that will be floating
     */
    createDragColumn: function(grid, x, columnIndex) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var renderer = grid.getRenderer();
        var columnEdges = renderer.getColumnEdges();
        var hdpiRatio = grid.getHiDPI(draggerCTX);
        var columnWidth = grid.getColumnWidth(columnIndex);
        var colHeight = grid.div.clientHeight;
        var d = dragger;
        var location = grid.div.getBoundingClientRect();
        var style = d.style;

        style.top = location.top + 'px';
        style.left = location.left + 'px';
        style.position = 'fixed';
        style.opacity = 0.85;
        style.boxShadow = '0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22)';
        //style.zIndex = 100;
        style.borderTop = '1px solid ' + renderer.resolveProperty('lineColor');
        style.backgroundColor = grid.renderer.resolveProperty('backgroundColor');

        d.setAttribute('width', Math.round(columnWidth * hdpiRatio) + 'px');
        d.setAttribute('height', Math.round(colHeight * hdpiRatio) + 'px');

        style.width = columnWidth + 'px'; //Math.round(columnWidth / hdpiRatio) + 'px';
        style.height = colHeight + 'px'; //Math.round(colHeight / hdpiRatio) + 'px';

        var startX = columnEdges[columnIndex - scrollLeft];
        startX = startX * hdpiRatio;

        draggerCTX.scale(hdpiRatio, hdpiRatio);

        grid.renderOverridesCache.dragger = {
            columnIndex: columnIndex,
            startIndex: columnIndex,
            ctx: draggerCTX,
            startX: startX,
            width: columnWidth,
            height: colHeight,
            hdpiratio: hdpiRatio
        };

        this.setCrossBrowserProperty(d, 'transform', 'translate(' + x + 'px, -5px)');
        style.zIndex = '5';
        style.cursor = this.getDraggingCursorName();
        grid.repaint();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc this function is the main dragging logic
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    dragColumn: function(grid, x) {

        //TODO: this function is overly complex, refactor this in to something more reasonable
        var self = this;
        //var renderer = grid.getRenderer();
        //var columnEdges = renderer.getColumnEdges();

        var autoScrollingNow = this.columnDragAutoScrollingRight || this.columnDragAutoScrollingLeft;

        var hdpiRatio = grid.getHiDPI(draggerCTX);

        var dragColumnIndex = grid.renderOverridesCache.dragger.columnIndex;

        var minX = 0;
        var maxX = grid.renderer.getFinalVisableColumnBoundary();
        x = Math.min(x, maxX + 15);
        x = Math.max(minX - 15, x);

        //am I at my lower bound
        var atMin = x < minX && dragColumnIndex !== 0;

        //am I at my upper bound
        var atMax = x > maxX;

        var d = dragger;

        this.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + 0 + 'ms ease, box-shadow ' + columnAnimationTime + 'ms ease');

        this.setCrossBrowserProperty(d, 'transform', 'translate(' + x + 'px, ' + -10 + 'px)');
        requestAnimationFrame(function() {
            d.style.display = 'inline';
        });

        var overCol = grid.renderer.getColumnFromPixelX(x + (d.width / 2 / hdpiRatio));

        if (atMin) {
            overCol = 0;
        }

        if (atMax) {
            overCol = grid.getColumnCount() - 1;
        }

        var doAFloat = dragColumnIndex > overCol;
        doAFloat = doAFloat || (overCol - dragColumnIndex >= 1);

        if (doAFloat && !atMax && !autoScrollingNow) {
            var draggedToTheRight = dragColumnIndex < overCol;
            // if (draggedToTheRight) {
            //     overCol = overCol - 1;
            // }
            if (this.isFloatingNow) {
                return;
            }

            this.isFloatingNow = true;
            this.createFloatColumn(grid, overCol);
            this.floatColumnTo(grid, draggedToTheRight);
        } else {

            if (x < minX - 10) {
                this.checkAutoScrollToLeft(grid, x);
            }
            if (x > minX - 10) {
                this.columnDragAutoScrollingLeft = false;
            }
            //lets check for autoscroll to right if were up against it
            if (atMax || x > maxX + 10) {
                this.checkAutoScrollToRight(grid, x);
                return;
            }
            if (x < maxX + 10) {
                this.columnDragAutoScrollingRight = false;
            }
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc autoscroll to the right if necessary
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    checkAutoScrollToRight: function(grid, x) {
        if (this.columnDragAutoScrollingRight) {
            return;
        }
        this.columnDragAutoScrollingRight = true;
        this._checkAutoScrollToRight(grid, x);
    },

    _checkAutoScrollToRight: function(grid, x) {
        if (!this.columnDragAutoScrollingRight) {
            return;
        }
        var scrollLeft = grid.getHScrollValue();
        if (!grid.dragging || scrollLeft > (grid.sbHScroller.range.max - 2)) {
            return;
        }
        var draggedIndex = grid.renderOverridesCache.dragger.columnIndex;
        grid.scrollBy(1, 0);
        var newIndex = draggedIndex + 1;
        console.log(newIndex, draggedIndex);
        grid.swapColumns(newIndex, draggedIndex);
        grid.renderOverridesCache.dragger.columnIndex = newIndex;

        setTimeout(this._checkAutoScrollToRight.bind(this, grid, x), 250);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc autoscroll to the left if necessary
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    checkAutoScrollToLeft: function(grid, x) {
        if (this.columnDragAutoScrollingLeft) {
            return;
        }
        this.columnDragAutoScrollingLeft = true;
        this._checkAutoScrollToLeft(grid, x);
    },

    _checkAutoScrollToLeft: function(grid, x) {
        if (!this.columnDragAutoScrollingLeft) {
            return;
        }

        var scrollLeft = grid.getHScrollValue();
        if (!grid.dragging || scrollLeft < 1) {
            return;
        }
        var draggedIndex = grid.renderOverridesCache.dragger.columnIndex;
        grid.swapColumns(draggedIndex + scrollLeft, draggedIndex + scrollLeft - 1);
        grid.scrollBy(-1, 0);
        setTimeout(this._checkAutoScrollToLeft.bind(this, grid, x), 250);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc a column drag has completed, update data and cleanup
     * @param {Hypergrid} grid
     */
    endDragColumn: function(grid) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        var columnIndex = grid.renderOverridesCache.dragger.columnIndex;

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var renderer = grid.getRenderer();
        var columnEdges = renderer.getColumnEdges();
        var self = this;
        var startX = columnEdges[columnIndex - scrollLeft];
        var d = dragger;
        var changed = grid.renderOverridesCache.dragger.startIndex !== grid.renderOverridesCache.dragger.columnIndex;
        self.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + columnAnimationTime + 'ms ease, box-shadow ' + columnAnimationTime + 'ms ease');
        self.setCrossBrowserProperty(d, 'transform', 'translate(' + startX + 'px, ' + -1 + 'px)');
        d.style.boxShadow = '0px 0px 0px #888888';

        setTimeout(function() {
            grid.renderOverridesCache.dragger = null;
            grid.repaint();
            requestAnimationFrame(function() {
                d.style.display = 'none';
                grid.endDragColumnNotification(); //internal notification
                if (changed){
                    grid.fireSyntheticOnColumnsChangedEvent(); //public notification
                }
            });
        }, columnAnimationTime + 50);

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isHeaderRow: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.y === 0;
        return isFixed;
    }

});

module.exports = ColumnMoving;

},{"./Feature.js":99}],95:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ColumnPicker = Feature.extend('ColumnPicker', {

    /**
     * @memberOf ColumnPicker.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyUp: function(grid, event) {
        var key = event.detail.char.toLowerCase();
        var keys = grid.resolveProperty('editorActivationKeys');
        if (keys.indexOf(key) > -1) {
           grid.toggleDialog('ColumnPicker');
        }
    },

});

module.exports = ColumnPicker;

},{"./Feature.js":99}],96:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ColumnResizing = Feature.extend('ColumnResizing', {

    /**
     * the index of the column wall were currently dragging
     * @type {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    dragIndex: -2,

    /**
     * the pixel location of the where the drag was initiated
     * @type {number}
     * @default -1
     * @memberOf ColumnResizing.prototype
     */
    dragStart: -1,

    /**
     * the starting width/height of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf ColumnResizing.prototype
     */
    dragIndexStartingSize: -1,

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the mouse x,y coordinate
     * @returns {number}
     * @param {MouseEvent} event - the mouse event to query
     */
    getMouseValue: function(event) {
        return event.primitiveEvent.detail.mouse.x;
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the grid cell x,y coordinate
     * @returns {number}
     * @param {window.fin.rectangular.Point} gridCell
     */
    getGridCellValue: function(gridCell) {
        return gridCell.y;
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the grids x,y scroll value
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getScrollValue: function(grid) {
        return grid.getHScrollValue();
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the width/height of the row/column of interest
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getAreaSize: function(grid, index) {
        return grid.getColumnWidth(index);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc set the width/height of the row/column at index
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     * @param {number} value - the width/height to set to
     */
    setAreaSize: function(grid, index, value) {
        grid.setColumnWidth(index, value);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the recently rendered area's width/height
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getPreviousAbsoluteSize: function(grid, index) {
        return grid.getRenderedWidth(index);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc returns the index of which divider I'm over
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    overAreaDivider: function(grid, event) {
        return grid.overColumnDivider(event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc am I over the column/row area
     * @returns {boolean}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedOtherArea: function(grid, event) {
        return this.isFirstFixedRow(grid, event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the cursor name
     * @returns {string}
     */
    getCursorName: function() {
        return 'col-resize';
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (this.dragIndex > -2) {
            //var fixedAreaCount = this.getFixedAreaCount(grid);
            //var offset = this.getFixedAreaSize(grid, fixedAreaCount + areaIndex);
            var mouse = this.getMouseValue(event);
            var scrollValue = this.getScrollValue(grid);
            if (this.dragIndex < this.getFixedAreaCount(grid)) {
                scrollValue = 0;
            }
            var previous = this.getPreviousAbsoluteSize(grid, this.dragIndex - scrollValue);
            var distance = mouse - previous;
            this.setAreaSize(grid, this.dragIndex, distance);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the width/height of a specific row/column
     * @param {Hypergrid} grid
     * @param {number} areaIndex - the row/column index of interest
     */
    getSize: function(grid, areaIndex) {
        return this.getAreaSize(grid, areaIndex);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the fixed area rows/columns count
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getOtherFixedAreaCount: function(grid) {
        return grid.getFixedRowCount();
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        var overArea = this.overAreaDivider(grid, event);
        if (isEnabled && overArea > -1 && this.isFirstFixedOtherArea(grid, event)) {
            var scrollValue = this.getScrollValue(grid);
            if (overArea < this.getFixedAreaCount(grid)) {
                scrollValue = 0;
            }
            this.dragIndex = overArea - 1 + scrollValue;
            this.dragStart = this.getMouseValue(event);
            this.dragIndexStartingSize = 0;
            this.detachChain();
        } else if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        if (isEnabled && this.dragIndex > -2) {
            this.cursor = null;
            this.dragIndex = -2;

            event.primitiveEvent.stopPropagation();
            //delay here to give other events a chance to be dropped
            var self = this;
            grid.synchronizeScrollingBoundries();
            setTimeout(function() {
                self.attachChain();
            }, 200);
        } else if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        if (this.dragIndex > -2) {
            return;
        }
        this.cursor = null;
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
        this.checkForAreaResizeCursorChange(grid, event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc fill this in
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    checkForAreaResizeCursorChange: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        if (isEnabled && this.overAreaDivider(grid, event) > -1 && this.isFirstFixedOtherArea(grid, event)) {
            this.cursor = this.getCursorName();
        } else {
            this.cursor = null;
        }

    },

    /**
     * @param {Hypergrid} grid
     * @returns {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    getFixedAreaCount: function(grid) {
        var count = grid.getFixedColumnCount() + (grid.isShowRowNumbers() ? 1 : 0) + (grid.hasHierarchyColumn() ? 1 : 0);
        return count;
    },

    /**
     * @param {Hypergrid} grid
     * @param event
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    handleDoubleClick: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        var hasCursor = this.overAreaDivider(grid, event) > -1; //this.cursor !== null;
        var headerRowCount = grid.getHeaderRowCount();
        //var headerColCount = grid.getHeaderColumnCount();
        var gridCell = event.gridCell;
        if (isEnabled && hasCursor && (gridCell.y <= headerRowCount)) {
            grid.autosizeColumn(gridCell.x - 1);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @param {Hypergrid} grid
     * @returns {boolean}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    isEnabled: function(grid) {
        return true;
    }

});

module.exports = ColumnResizing;

},{"./Feature.js":99}],97:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * Extra msecs to avoid race condition with fincanvas's double click timer.
 * @type {number}
 * @defaultvalue 50
 * NOTE: 50 msecs seems to work well. 10 and even 25 proved insufficient in Chrome.
 * @private
 */
var RACE_TIME = 50;

/**
 * @constructor
 */
var ColumnSelection = Feature.extend('ColumnSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {window.fin.rectangular.Point}
     * @default null
     * @memberOf ColumnSelection.prototype
     */
    currentDrag: null,

    /**
     * The cell coordinates of the where the mouse pointer is during a drag operation.
     * @type {Object}
     * @default null
     * @memberOf ColumnSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf ColumnSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf ColumnSelection.prototype
     */
    sbAutoStart: 0,


    /**
     * @memberOf ColumnSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragging) {
            this.dragging = false;
        }
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    handleDoubleClick: function(grid, event) {
        if (this.doubleClickTimer) {
            clearTimeout(this.doubleClickTimer); // prevent mouseDown from continuing
            this.doubleClickTimer = undefined;
        }
        if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.doubleClickTimer) {
            return;
        }

        if ((!grid.isColumnSelection() || event.mousePoint.y < 5) && this.next) {
            this.next.handleMouseDown(grid, event);
            return;
        }

        var isRightClick = event.primitiveEvent.detail.isRightClick;
        var cell = event.gridCell;
        var viewCell = event.viewPoint;
        var dx = cell.x;
        var dy = cell.y;

        var isHeader = grid.isShowHeaderRow() && dy === 0 && dx !== -1;

        if (isRightClick || !isHeader) {
            if (this.next) {
                this.next.handleMouseDown(grid, event);
            }
        } else {
            // HOLD OFF WHILE WAITING FOR DOUBLE-CLICK
            this.doubleClickTimer = setTimeout(function() {
                this.doubleClickTimer = undefined;
                var numFixedColumns = grid.getFixedColumnCount();

                //if we are in the fixed area do not apply the scroll values
                //check both x and y values independently
                if (viewCell.x < numFixedColumns) {
                    dx = viewCell.x;
                }

                var dCell = grid.newPoint(dx, 0);

                var primEvent = event.primitiveEvent;
                var keys = primEvent.detail.keys;
                this.dragging = true;
                this.extendSelection(grid, dCell, keys);
            }.bind(this), grid.resolveProperty('doubleClickDelay') + RACE_TIME);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {

        if ((!grid.isColumnSelection() || this.isColumnDragging(grid)) && this.next) {
            this.next.handleMouseDrag(grid, event);
            return;
        }

        var isRightClick = event.primitiveEvent.detail.isRightClick;

        if (isRightClick || !this.dragging) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
        } else {

            var numFixedColumns = grid.getFixedColumnCount();

            var cell = event.gridCell;
            var viewCell = event.viewPoint;
            var dx = cell.x;
            var dy = cell.y;

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            var dCell = grid.newPoint(dx, dy);

            var primEvent = event.primitiveEvent;
            this.currentDrag = primEvent.detail.mouse;
            this.lastDragCell = dCell;

            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, dCell, primEvent.detail.keys);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        var handler;
        if (
            grid.getLastSelectionType() === 'column' &&
            (handler = this['handle' + event.detail.char])
        ) {
            handler.call(this, grid, event.detail);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Handle a mousedrag selection
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {
        var x = gridCell.x;
        //            var previousDragExtent = grid.getDragExtent();
        var mouseDown = grid.getMouseDown();

        var newX = x - mouseDown.x;
        //var newY = y - mouseDown.y;

        // if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
        //     return;
        // }

        grid.clearMostRecentColumnSelection();

        grid.selectColumn(mouseDown.x, x);
        grid.setDragExtent(grid.newPoint(newX, 0));

        grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {

        if (!grid.isScrollingNow()) {
            return;
        }

        var lastDragCell = this.lastDragCell;
        var b = grid.getDataBounds();
        var xOffset = 0;
        var yOffset = 0;

        var numFixedColumns = grid.getFixedColumnCount();
        var numFixedRows = grid.getFixedRowCount();

        var dragEndInFixedAreaX = lastDragCell.x < numFixedColumns;
        var dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (this.currentDrag.x < b.origin.x) {
            xOffset = -1;
        }

        if (this.currentDrag.x > b.origin.x + b.extent.x) {
            xOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }

        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        grid.stopEditing();
        //var hasCTRL = keys.indexOf('CTRL') !== -1;
        var hasSHIFT = keys.indexOf('SHIFT') !== -1;

        // var scrollTop = grid.getVScrollValue();
        // var scrollLeft = grid.getHScrollValue();

        // var numFixedColumns = 0;//grid.getFixedColumnCount();
        // var numFixedRows = 0;//grid.getFixedRowCount();

        var mousePoint = grid.getMouseDown();
        var x = gridCell.x; // - numFixedColumns + scrollLeft;
        var y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        //we have repeated a click in the same spot deslect the value from last time
        // if (mousePoint && x === mousePoint.x && y === mousePoint.y) {
        //     grid.clearSelections();
        //     grid.popMouseDown();
        //     grid.repaint();
        //     return;
        // }

        // if (!hasCTRL && !hasSHIFT) {
        //     grid.clearSelections();
        // }

        if (hasSHIFT) {
            grid.clearMostRecentColumnSelection();
            grid.selectColumn(x, mousePoint.x);
            grid.setDragExtent(grid.newPoint(x - mousePoint.x, 0));
        } else {
            grid.toggleSelectColumn(x, keys);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid) {

        // var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());
        // var maxRows = grid.getRowCount() - 1;

        // var newX = mouseCorner.x;
        // var newY = grid.getHeaderRowCount() + grid.getVScrollValue();

        // newY = Math.min(maxRows, newY);

        // grid.clearSelections();
        // grid.select(newX, newY, 0, 0);
        // grid.setMouseDown(new grid.rectangular.Point(newX, newY));
        // grid.setDragExtent(new grid.rectangular.Point(0, 0));

        // grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {
        this.moveSingleSelect(grid, -1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {
        this.moveSingleSelect(grid, 1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetX) {

        var maxColumns = grid.getColumnCount() - 1;

        var maxViewableColumns = grid.getVisibleColumns() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
        }

        var origin = grid.getMouseDown();
        var extent = grid.getDragExtent();

        var newX = extent.x + offsetX;
        //var newY = grid.getRowCount();

        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));

        grid.clearMostRecentColumnSelection();
        grid.selectColumn(origin.x, origin.x + newX);

        grid.setDragExtent(grid.newPoint(newX, 0));

        if (grid.insureModelColIsVisible(newX + origin.x, offsetX)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetX) {

        var maxColumns = grid.getColumnCount() - 1;

        var maxViewableColumns = grid.getVisibleColumnsCount() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
        }

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());

        var newX = mouseCorner.x + offsetX;
        //var newY = grid.getRowCount();

        newX = Math.min(maxColumns, Math.max(0, newX));

        grid.clearSelections();
        grid.selectColumn(newX);
        grid.setMouseDown(grid.newPoint(newX, 0));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelColIsVisible(newX, offsetX)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    },

    isColumnDragging: function(grid) {
        var dragger = grid.lookupFeature('ColumnMoving');
        if (!dragger) {
            return false;
        }
        var isActivated = dragger.dragging && !this.dragging;
        return isActivated;
    }

});

module.exports = ColumnSelection;

},{"./Feature.js":99}],98:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ColumnSorting = Feature.extend('ColumnSorting', {

    /**
     * @memberOf ColumnSorting.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */

    handleDoubleClick: function(grid, event) {
        var gridCell = event.gridCell;
        if (grid.isShowHeaderRow() && gridCell.y === 0 && gridCell.x !== -1) {
            var keys = event.primitiveEvent.detail.keys;
            grid.toggleSort(gridCell.x, keys);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf ColumnSorting.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        var y = event.gridCell.y;
        if (this.isFixedRow(grid, event) && y < 1) {
            this.cursor = 'pointer';
        } else {
            this.cursor = null;
        }
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    }

});

module.exports = ColumnSorting;

},{"./Feature.js":99}],99:[function(require,module,exports){
'use strict';

var Base = require('../lib/Base');

/**
 * @constructor
 * @desc instances of features are connected to one another to make a chain of responsibility for handling all the input to the hypergrid.
 */
var Feature = Base.extend('Feature', {

    /**
     * the next feature to be given a chance to handle incoming events
     * @type {Feature}
     * @default null
     * @memberOf Feature.prototype
     */
    next: null,

    /**
     * a temporary holding field for my next feature when I'm in a disconnected state
     * @type {Feature}
     * @default null
     * @memberOf Feature.prototype
     */
    detached: null,

    /**
     * the cursor I want to be displayed
     * @type {string}
     * @default null
     * @memberOf Feature.prototype
     */
    cursor: null,

    /**
     * the cell location where the cursor is currently
     * @type {Point}
     * @default null
     * @memberOf Feature.prototype
     */
    currentHoverCell: null,

    /**
     * @memberOf Feature.prototype
     * @desc set my next field, or if it's populated delegate to the feature in my next field
     * @param {Feature} nextFeature - this is how we build the chain of responsibility
     */
    setNext: function(nextFeature) {
        if (this.next) {
            this.next.setNext(nextFeature);
        } else {
            this.next = nextFeature;
            this.detached = nextFeature;
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc disconnect my child
     */
    detachChain: function() {
        this.next = null;
    },

    /**
     * @memberOf Feature.prototype
     * @desc reattach my child from the detached reference
     */
    attachChain: function() {
        this.next = this.detached;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle mouse move down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseExit: function(grid, event) {
        if (this.next) {
            this.next.handleMouseExit(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseEnter: function(grid, event) {
        if (this.next) {
            this.next.handleMouseEnter(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyUp: function(grid, event) {
        if (this.next) {
            this.next.handleKeyUp(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleWheelMoved: function(grid, event) {
        if (this.next) {
            this.next.handleWheelMoved(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDoubleClick: function(grid, event) {
        if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleClick: function(grid, event) {
        if (this.next) {
            this.next.handleClick(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleContextMenu: function(grid, event) {
        if (this.next) {
            this.next.handleContextMenu(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc toggle the column picker
     */

    moveSingleSelect: function(grid, x, y) {
        if (this.next) {
            this.next.moveSingleSelect(grid, x, y);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFixedRow: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.y < grid.getFixedRowCount();
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedRow: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.y < 1;
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFixedColumn: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.x < grid.getFixedColumnCount();
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedColumn: function(grid, event) {
        var gridCell = event.viewPoint;
        var edge = grid.isShowRowNumbers() ? 0 : 1;
        var isFixed = gridCell.x < edge;
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isTopLeft: function(grid, event) {
        var isTopLeft = this.isFixedRow(grid, event) && this.isFixedColumn(grid, event);
        return isTopLeft;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    setCursor: function(grid) {
        if (this.next) {
            this.next.setCursor(grid);
        }
        if (this.cursor) {
            grid.beCursor(this.cursor);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    initializeOn: function(grid) {
        if (this.next) {
            this.next.initializeOn(grid);
        }
    }

});

module.exports = Feature;

},{"../lib/Base":110}],100:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var Filters = Feature.extend('Filters', {

    handleDoubleClick: function(grid, event) {
        if (grid.isFilterRow(event.gridCell.y)) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    handleClick: function(grid, event) {
        if (grid.isFilterRow(event.gridCell.y)) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleClick(grid, event);
        }
    }

});

module.exports = Filters;

},{"./Feature.js":99}],101:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

var commands = {
    PAGEDOWN: function(grid) { grid.pageDown(); },
    PAGEUP: function(grid) { grid.pageUp(); },
    PAGELEFT: function(grid) { grid.pageLeft(); },
    PAGERIGHT: function(grid) { grid.pageRight(); }
};

/**
 * @constructor
 */
var KeyPaging = Feature.extend('KeyPaging', {

    /**
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf KeyPaging.prototype
     */
    handleKeyDown: function(grid, event) {
        var func = commands[event.detail.char];
        if (func) {
            func(grid);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    }

});

module.exports = KeyPaging;

},{"./Feature.js":99}],102:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var OnHover = Feature.extend('OnHover', {

    /**
     * @desc Hhandle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf OnHover.prototype
     */
    handleMouseMove: function(grid, event) {
        var currentHoverCell = grid.getHoverCell();
        if (!event.gridCell.equals(currentHoverCell)) {
            if (currentHoverCell) {
                this.handleMouseExit(grid, currentHoverCell);
            }
            this.handleMouseEnter(grid, event);
            grid.setHoverCell(event.gridCell);
        } else {
            if (this.next) {
                this.next.handleMouseMove(grid, event);
            }
        }
    }

});

module.exports = OnHover;

},{"./Feature.js":99}],103:[function(require,module,exports){
'use strict';

var ColumnResizing = require('./ColumnResizing');

/**
 * @constructor
 */
var RowResizing = ColumnResizing.extend('RowResizing', {

    /**
     * the index of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragArea: -1,

    /**
     * the pixel location of the where the drag was initiated
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragStart: -1,

    /**
     * the starting width/height of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragAreaStartingSize: -1,

    /**
     * @memberOf RowResizing.prototype
     * @desc get the mouse x,y coordinate
     * @returns {number}
     * @param {MouseEvent} event - the mouse event to query
     */
    getMouseValue: function(event) {
        return event.primitiveEvent.detail.mouse.y;
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc get the grid cell x,y coordinate
     * @returns {number}
     * @param {Point} gridCell
     */
    getGridCellValue: function(gridCell) {
        return gridCell.x;
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the grids x,y scroll value
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getScrollValue: function(grid) {
        return grid.getVScrollValue();
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the width/height of the row/column of interest
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getAreaSize: function(grid, index) {
        return grid.getRowHeight(index);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc set the width/height of the row/column at index
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     * @param {number} value - the width/height to set to
     */
    setAreaSize: function(grid, index, value) {
        grid.setRowHeight(index, value);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc returns the index of which divider I'm over
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    overAreaDivider: function(grid, event) {
        return grid.overRowDivider(event);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc am I over the column/row area
     * @returns {boolean}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedOtherArea: function(grid, event) {
        return this.isFirstFixedColumn(grid, event);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the cursor name
     * @returns {string}
     */
    getCursorName: function() {
        return 'row-resize';
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the recently rendered area's width/height
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getPreviousAbsoluteSize: function(grid, index) {
        return grid.getRenderedHeight(index);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the fixed area rows/columns count
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getOtherFixedAreaCount: function(grid) {
        return grid.getFixedColumnCount();
    },

    /**
     *
     * @param {Hypergrid} grid
     * @returns {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    getFixedAreaCount: function(grid) {
        return grid.getFixedRowCount() + grid.getHeaderRowCount();
    },

    /**
     *
     * @param {Hypergrid} grid
     * @returns {boolean}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    isEnabled: function(grid) {
        return grid.isRowResizeable();
    }

});

module.exports = RowResizing;

},{"./ColumnResizing":96}],104:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var RowSelection = Feature.extend('RowSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {Point}
     * @default null
     * @memberOf RowSelection.prototype
     */
    currentDrag: null,

    /**
     * The cell coordinates of the where the mouse pointer is during a drag operation.
     * @type {Object}
     * @default null
     * @memberOf RowSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf RowSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf RowSelection.prototype
     */
    sbAutoStart: 0,

    dragArmed: false,

    /**
     * @memberOf RowSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragArmed) {
            this.dragArmed = false;
            //global row selection
            if (event.gridCell.x === -1 && event.gridCell.y === 0) {
                grid.toggleSelectAllRows();
            }
            grid.fireSyntheticRowSelectionChangedEvent();
        } else if (this.dragging) {
            this.dragging = false;
            grid.fireSyntheticRowSelectionChangedEvent();
        } else if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {

        var isRightClick = event.primitiveEvent.detail.isRightClick;
        var cell = event.gridCell;
        var viewCell = event.viewPoint;
        var dx = cell.x;
        var dy = cell.y;


        var isHeader = grid.isShowRowNumbers() && dx < 0;

        if (!grid.isRowSelection() || isRightClick || !isHeader) {
            if (this.next) {
                this.next.handleMouseDown(grid, event);
            }
        } else {

            var numFixedRows = grid.getFixedRowCount();

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(0, dy);

            var primEvent = event.primitiveEvent;
            var keys = primEvent.detail.keys;
            this.dragArmed = true;
            this.extendSelection(grid, dCell, keys);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        var isRightClick = event.primitiveEvent.detail.isRightClick;

        if (!this.dragArmed || !grid.isRowSelection() || isRightClick) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
        } else {
            this.dragging = true;
            var numFixedRows = grid.getFixedRowCount();

            var cell = event.gridCell;
            var viewCell = event.viewPoint;
            //var dx = cell.x;
            var dy = cell.y;

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(0, dy);

            var primEvent = event.primitiveEvent;
            this.currentDrag = primEvent.detail.mouse;
            this.lastDragCell = dCell;

            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, dCell, primEvent.detail.keys);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        var handler;
        if (
            grid.getLastSelectionType() === 'row' &&
            (handler = this['handle' + event.detail.char])
        ) {
            handler.call(this, grid, event.detail);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Handle a mousedrag selection
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {
        var y = gridCell.y;
        //            var previousDragExtent = grid.getDragExtent();
        var mouseDown = grid.getMouseDown();

        var newY = y - mouseDown.y;
        //var newY = y - mouseDown.y;

        // if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
        //     return;
        // }

        grid.clearMostRecentRowSelection();

        grid.selectRow(mouseDown.y, y);
        grid.setDragExtent(grid.newPoint(0, newY));

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {
        if (!grid.isScrollingNow()) {
            return;
        }

        var lastDragCell = this.lastDragCell;
        var b = grid.getDataBounds();
        var xOffset = 0;
        var yOffset = 0;

        var numFixedColumns = grid.getFixedColumnCount();
        var numFixedRows = grid.getFixedRowCount();

        var dragEndInFixedAreaX = lastDragCell.x < numFixedColumns;
        var dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (this.currentDrag.y < b.origin.y) {
            yOffset = -1;
        }

        if (this.currentDrag.y > b.origin.y + b.extent.y) {
            yOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }

        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        grid.stopEditing();
        //var hasCTRL = keys.indexOf('CTRL') !== -1;
        var hasSHIFT = keys.indexOf('SHIFT') !== -1;

        var mousePoint = grid.getMouseDown();
        var x = gridCell.x; // - numFixedColumns + scrollLeft;
        var y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        if (hasSHIFT) {
            grid.clearMostRecentRowSelection();
            grid.selectRow(y, mousePoint.y);
            grid.setDragExtent(grid.newPoint(0, y - mousePoint.y));
        } else {
            grid.toggleSelectRow(y, keys);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid) {
        this.moveSingleSelect(grid, 1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid) {
        this.moveSingleSelect(grid, -1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());
        var maxColumns = grid.getColumnCount() - 1;

        var newX = grid.getHeaderColumnCount() + grid.getHScrollValue();
        var newY = mouseCorner.y;

        newX = Math.min(maxColumns, newX);

        grid.clearSelections();
        grid.select(newX, newY, 0, 0);
        grid.setMouseDown(grid.newPoint(newX, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetY) {

        var maxRows = grid.getRowCount() - 1;

        var maxViewableRows = grid.getVisibleRows() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var origin = grid.getMouseDown();
        var extent = grid.getDragExtent();

        var newY = extent.y + offsetY;
        //var newY = grid.getRowCount();

        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

        grid.clearMostRecentRowSelection();
        grid.selectRow(origin.y, origin.y + newY);

        grid.setDragExtent(grid.newPoint(0, newY));

        if (grid.insureModelRowIsVisible(newY + origin.y, offsetY)) {
            this.pingAutoScroll();
        }

        grid.fireSyntheticRowSelectionChangedEvent();
        grid.repaint();

    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetY) {

        var maxRows = grid.getRowCount() - 1;

        var maxViewableRows = grid.getVisibleRowsCount() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());

        var newY = mouseCorner.y + offsetY;
        //var newY = grid.getRowCount();

        newY = Math.min(maxRows, Math.max(0, newY));

        grid.clearSelections();
        grid.selectRow(newY);
        grid.setMouseDown(grid.newPoint(0, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelRowIsVisible(newY, offsetY)) {
            this.pingAutoScroll();
        }

        grid.fireSyntheticRowSelectionChangedEvent();
        grid.repaint();

    },

    isSingleRowSelection: function() {
        return true;
    }

});

module.exports = RowSelection;

},{"./Feature.js":99}],105:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ThumbwheelScrolling = Feature.extend('ThumbwheelScrolling', {

    /**
     * @memberOf ThumbwheelScrolling.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleWheelMoved: function(grid, e) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }

        var primEvent = e.primitiveEvent,
            deltaX = Math.sign(primEvent.wheelDeltaX || -primEvent.deltaX),
            deltaY = Math.sign(primEvent.wheelDeltaY || -primEvent.deltaY);

        if (deltaX || deltaY) {
            grid.scrollBy(
                -deltaX || 0, // 0 if NaN
                -deltaY || 0
            );
        }
    }

});


module.exports = ThumbwheelScrolling;

},{"./Feature.js":99}],106:[function(require,module,exports){
'use strict';

module.exports = {
    Feature: require('./Feature'), // abstract base class
    CellClick: require('./CellClick'),
    CellEditing: require('./CellEditing'),
    CellSelection: require('./CellSelection'),
    ColumnAutosizing: require('./ColumnAutosizing'),
    ColumnMoving: require('./ColumnMoving'),
    ColumnResizing: require('./ColumnResizing'),
    ColumnSelection: require('./ColumnSelection'),
    ColumnSorting: require('./ColumnSorting'),
    Filters: require('./Filters'),
    KeyPaging: require('./KeyPaging'),
    OnHover: require('./OnHover'),
    ColumnPicker: require('./ColumnPicker'),
    RowResizing: require('./RowResizing'),
    RowSelection: require('./RowSelection'),
    ThumbwheelScrolling: require('./ThumbwheelScrolling')
};

},{"./CellClick":90,"./CellEditing":91,"./CellSelection":92,"./ColumnAutosizing":93,"./ColumnMoving":94,"./ColumnPicker":95,"./ColumnResizing":96,"./ColumnSelection":97,"./ColumnSorting":98,"./Feature":99,"./Filters":100,"./KeyPaging":101,"./OnHover":102,"./RowResizing":103,"./RowSelection":104,"./ThumbwheelScrolling":105}],107:[function(require,module,exports){
'use strict';

var popMenu = require('pop-menu');

/**
 * @constructor
 * @summary Build, organize, and sort a column schema list from a list of columns.
 * @desc FilterTree requires a column schema. As a fallback when you don't have a column schema of your own, the string array returned by behavior.dataModel.getFields() would work as is. This factory object will do a little better than that, taking Hypergrid's column array and creating a more textured column schema, including column aliases and types.
 *
 * CAVEAT: Set up the schema completely before instantiating your filter state. Filter-tree uses the schema (in part) to generate column selection drop-downs as part of its "query builder" UI. Note that the UI is *not* automatically updated if you change the schema later.
 *
 * @param {Column[]} columns
 *
 * @property {menuItem[]} schema - This is the output produced by the factory.
 */
function ColumnSchemaFactory(columns, findOptions) {
    this.schema = columns.map(function(column) {
        return {
            name: column.name,
            alias: column.header,
            type: column.getType()
        };
    });
}

ColumnSchemaFactory.prototype = {

    constructor: ColumnSchemaFactory.prototype.constructor,

    /**
     * Organize schema into submenus.
     * @param {RegExp} columnGroupsRegex - Schema names or aliases that match this are put into a submenu.
     * @param {string} [options.key='name'] - Must be either 'name' or 'alias'.
     */
    organize: function(columnGroupsRegex, options) {
        var key = options && options.key || 'name',
            submenus = {},
            menu = [];

        this.schema.forEach(function(item) {
            var value = item[key],
                group = value.match(columnGroupsRegex);
            if (group) {
                group = group[0];
                if (!(group in submenus)) {
                    submenus[group] = {
                        label: group.toUpperCase(),
                        submenu: []
                    };
                }
                submenus[group].submenu.push(item);
            } else {
                menu.push(item);
            }
        });

        for (var submenuName in submenus) {
            menu.push(submenus[submenuName]);
        }

        this.schema = menu;
    },

    lookup: function(findOptions, value) {
        var args = Array.prototype.slice.call(arguments);
        return popMenu.lookup.apply(this.schema, args);
    },

    walk: function(iteratee) {
        return popMenu.walk.call(this.schema, iteratee);
    },

    /**
     * @summary Sort the schema.
     * @desc Walk the menu structure, sorting each submenu until finally the top-level menu is sorted.
     * @param {string} [prefix=''] - A submenu sort prefix:
     * * Omit to give no special treatment to submenus.
     * * Give `'\u0000'` to place all the submenus at the top of each enclosing submenu.
     * * Give `'\uffff'` to place all the submenus at the bottom of each enclosing submenu.
     */
    sort: function(prefix) {
        this.schema.sort(function recurse(a, b) {
            if (a.label && !a.sorted) {
                a.submenu.sort(recurse);
                a.sorted = true;
            }
            a = a.label ? prefix + a.label : a.alias || a.name || a;
            b = b.label ? prefix + b.label : b.alias || b.name || b;
            return a < b ? -1 : a > b ? 1 : 0;
        });
    }
};

module.exports = ColumnSchemaFactory;

},{"pop-menu":47}],108:[function(require,module,exports){
'use strict';

var _ = require('object-iterators');

var FilterTree = require('../Shared').FilterTree;
var ParserCQL = require('./parser-CQL');

// Add a property `menuModes` to the tree, defaulting to `operators` as the only active mode
FilterTree.Node.optionsSchema.menuModes = {
    default: {
        operators: 1
    }
};

function quote(text) {
    var qt = ParserCQL.qt;
    return qt + text.replace(new RegExp(qt, 'g'), qt + qt) + qt;
}

var likeDresses = [
    { regex: /^(NOT )?LIKE %(.+)%$/i, operator: 'contains' },
    { regex: /^(NOT )?LIKE (.+)%$/i, operator: 'begins' },
    { regex: /^(NOT )?LIKE %(.+)$/i, operator: 'ends' }
];
var regexEscapedLikePatternChars = /\[([_\[\]%])\]/g; // capture all _, [, ], and % chars enclosed in []
var regexLikePatternChar = /[_\[\]%]/; // find any _, [, ], and % chars NOT enclosed in []

// convert certain LIKE expressions to BEGINS, ENDS, CONTAINS
function convertLikeToPseudoOp(result) {
    likeDresses.find(function(dress) {
        var match = result.match(dress.regex);

        if (match) {
            // unescape all LIKE pattern chars escaped with brackets
            var not = (match[1] || '').toLowerCase(),
                operator = dress.operator,
                operand = match[2],
                operandWithoutEscapedChars = operand.replace(regexEscapedLikePatternChars, '');

            // if result has no actua remaining LIKE pattern chars, go with the conversion
            if (!regexLikePatternChar.test(operandWithoutEscapedChars)) {
                operand = operand.replace(regexEscapedLikePatternChars, '$1'); // unescape the escaped chars
                result = not + operator + ' ' + operand;
            }

            return true; // break out of loop
        }
    });

    return result;
}

var conditionalsCQL = new FilterTree.Conditionals();
conditionalsCQL.makeLIKE = function(beg, end, op, originalOp, c) {
    op = originalOp.toLowerCase();
    return op + ' ' + quote(c.operand);
};
conditionalsCQL.makeIN = function(op, c) {
    return op.toLowerCase() + ' (' + c.operand.replace(/\s*,\s*/g, ', ') + ')';
};
conditionalsCQL.make = function(op, c) {
    var numericOperand;
    op = op.toLowerCase();
    if (/\w/.test(op)) { op += ' '; }
    op += c.getType() === 'number' && !isNaN(numericOperand = Number(c.operand))
        ? numericOperand
        : quote(c.operand);
    return op;
};

// replace the default filter tree terminal node constructor with an extension of same
var CustomFilterLeaf = FilterTree.prototype.addEditor({
    getState: function getState(options) {
        var result,
            syntax = options && options.syntax;

        if (syntax === 'CQL') {
            result = this.getSyntax(conditionalsCQL);
            result = convertLikeToPseudoOp(result);
            var defaultOp = this.schema.lookup(this.column).defaultOp || this.root.parserCQL.defaultOp; // mimics logic in parser-CQL.js, line 110
            if (result.toUpperCase().indexOf(defaultOp) === 0) {
                result = result.substr(defaultOp.length);
            }
        } else {
            result = FilterTree.Leaf.prototype.getState.call(this, options);
        }

        return result;
    }
});

FilterTree.prototype.addEditor('Columns');

// Add some node templates by updating shared instance of FilterNode's templates. (OK to mutate shared instance; filter-tree not being used for anything else here. Alternatively, we could have instantiated a new Templates object for our DefaultFilter prototype, although this would only affect tree nodes, not leaf nodes, but that would be ok in this case since the additions below are tree node templates.)
_(FilterTree.Node.prototype.templates).extendOwn({
    columnFilter: [
        '<span class="filter-tree">',
        '   <strong><span>{2} </span></strong><br>',
        '   Match',
        '   <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-or">any</label>',
        '   <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-and">all</label>',
        '   <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-nor">none</label>',
        '   of the following:',
        '   <select>',
        '       <option value="">New expression&hellip;</option>',
        '   </select>',
        '   <ol></ol>',
        '</span>'
    ]
        .join('\n'),

    columnFilters: [
        '<span class="filter-tree filter-tree-type-column-filters">',
        '   Match <strong>all</strong> of the following column filter subexpressions:',
        '   <ol></ol>',
        '</span>'
    ]
        .join('\n')
});

/** @constructor
 *
 * @desc This extension of FilterTree forces a specific tree structure.
 * See {@link makeNewRoot} for a description.
 *
 * See also {@tutorial filter-api}.
 *
 * @param {FilterTreeOptionsObject} options - You should provide a column schema. The easiest approach is to provide a schema for the entire filter tree through `options.schema`.
 *
 * Although not recommended, the column schema can also be embedded in the state object, either at the root, `options.state.schema`, or for any descendant node. For example, a separate schema could be provided for each expression or subexpression that need to render column list drop-downs.
 *
 * NOTE: If `options.state` is undefined, it is defined in `preInitialize()` as a new empty state scaffold (see {@link makeNewRoot}) with the two trunks to hold a table filter and column filters. Expressions and subexpressions can be added to this empty scaffold either programmatically or through the Query Builder UI.
 */

var DefaultFilter = FilterTree.extend('DefaultFilter', {
    preInitialize: function(options) {
        options = options || {};

        // Set up the default "Hyperfilter" profile (see function comments)
        var state = options.state = options.state || this.makeNewRoot();

        // Upon creation of a 'columnFilter' node, force the schema to the one column
        if ((options.type || state && state.type) === 'columnFilter') {
            this.schema = [
                options.parent.root.schema.lookup(state.children[0].column)
            ];
        }

        return [options];
    },

    initialize: function(options) {
        this.cache = {};

        if (!this.parent) {
            this.extractSubtrees();
        }
    },

    postInitialize: function(options) {
        if (this === this.root && !this.parserCQL) {
            this.parserCQL = new ParserCQL(this.conditionals.ops, {
                schema: this.schema,
                defaultOp: options.defaultColumnFilterOperator
            });
        }

        if (this.type === 'columnFilter') {
            this.dontPersist.schema = true;
        }
    },

    /**
     * Create convenience vars to reference the 2 root "Hyperfilter" nodes
     * @memberOf DefaultFilter.prototype
     */
    extractSubtrees: function() {
        var rootNodes = this.root.children;
        this.tableFilter = rootNodes[0];
        this.columnFilters = rootNodes[1];
    },

    /**
     * @summary Make a new empty Hypergrid filter tree state object.
     * @desc This function makes a new default state object as used by Hypergrid, a root with exactly two "trunks."
     *
     * > **Definition:** A *trunk* is defined as a child node with a truthy `keep` property, making this node immune to the usual pruning that would occur when it has no child nodes of its own. To be a true trunk, all ancestor nodes to be trunks as well. Note that the root is a natural trunk; it does not require a `keep` property.
     *
     * The two trunks of the Hypergrid filter are:
     * * The **Table Filter** (left trunk, or `children[0]`), a hierarchy of filter expressions and subexpressions.
     * * The **Column Filters** (right trunk, or `children[1]`), a series of subexpressions, one per active column filter. Each subexpression contains any number of expressions bound to that column but no further subexpressions.
     *
     * The `operator` properties for all subexpressions default to `'op-and'`, which means:
     * * All table filter expressions and subexpressions are AND'd together. (This is just the default and may be changed from the UI.)
     * * All expressions within a column filter subexpression are AND'd together. (This is just the default and may be changed from the UI.)
     * * All column Filters subexpressions are AND'd together. (This may not be changed from UI.)
     * * Finally, the table filter and column filters are AND'd together. (This may not be changed from UI.)
     *
     * @returns {object} A plain object to serve as a filter-tree state object representing a new Hypergrid filter.
     *
     * @memberOf DefaultFilter.prototype
     */
    makeNewRoot: function() {

        this.tableFilter = {
            keep: true,
            children: [
                // table filter expressions and subexpressions go here
            ]
        };

        this.columnFilters = {
            keep: true,
            type: 'columnFilters',
            children: [
                // subexpressions with type 'columnFilter' go here, one for each active column filter
            ]
        };

        var filter = {
            children: [
                this.tableFilter,
                this.columnFilters
            ]
        };

        return filter;
    },

    /**
     * @summary Get the column filter subexpression node.
     * @desc Each column filter subexpression node is a child node of the `columnFilters` trunk of the Hypergrid filter tree.
     * Each such node contains all the column filter expressions for the named column. It will never be empty; if there is no column filter for the named column, it won't exist in `columnFilters`.
     *
     * CAUTION: This is the actual node object. Do not confuse it with the column filter _state_ object (for which see the {@link DefaultFilter#getColumnFilterState|getColumnFilterState()} method).
     * @param {string} columnName
     * @returns {undefined|DefaultFilter} Returns `undefined` if the column filter does not exist.
     */
    getColumnFilter: function(columnName) {
        return this.columnFilters.children.find(function(columnFilter) {
            return columnFilter.children.length && columnFilter.children[0].column === columnName;
        });
    },

    /** @typedef {object} FilterTreeGetStateOptionsObject
     * See the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeGetStateOptionsObject|type definition} in the filter-tree documentation.
     */

    /** @typedef {object} FilterTreeSetStateOptionsObject
     * See the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeSetStateOptionsObject|type definition} in the filter-tree documentation.
     */

    /**
     * @summary Get a particular column filter's state.
     * @param {string} rawColumnName - Column name for case and alias lookup.
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @param {boolean} [options.syntax='CQL'] - The syntax to use to describe the filter state. Note that `getFilter`'s default syntax, `'CQL'`, differs from the other get state methods.
     * @returns {FilterTreeStateObject}
     * @memberOf DefaultFilter.prototype
     */
    getColumnFilterState: function(rawColumnName, options) {
        var result = '',
            columnSchema = this.schema.lookup(rawColumnName);

        if (columnSchema) {
            var subexpression = this.getColumnFilter(columnSchema.name);

            if (subexpression) {
                if (!(options && options.syntax)) {
                    options = options || {};
                    options.syntax = 'CQL';
                }
                result = subexpression.getState(options);
            }
        }

        return result;
    },

    /**
     * @summary Set a particular column filter's state.
     * @desc Adds CQL support to this.getState(). This function throws parser errors.
     *
     * @param {string} columnName
     *
     * @param {string|object} [state] - A filter tree object or a JSON, SQL, or CQL subexpression string that describes the a new state for the named column filter. The existing column filter subexpression is replaced with a new node based on this state. If it does not exist, the new subexpression is added to the column filters subtree (`this.root.columnFilters`).
     *
     * If undefined, removes the entire column filter subexpression from the column filters subtree.
     *
     * @param {string} rawColumnName - Column name for case and alias lookup.
     *
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     *
     * @param {boolean} [options.syntax='CQL'] - The syntax to use to describe the filter state. Note that `setColumnFilterState`'s default syntax, `'CQL'`, differs from the other get state methods.
     *
     * @memberOf DefaultFilter.prototype
     */
    setColumnFilterState: function(rawColumnName, state, options) {
        var error,
            subexpression;

        var columnName = this.schema.lookup(rawColumnName).name;

        if (!columnName) {
            throw 'Unknown column name "' + rawColumnName + '"';
        }

        subexpression = this.getColumnFilter(columnName);

        if (state) {
            options = _({}).extend(options); // clone it because we may mutate it below
            options.syntax = options.syntax || 'CQL';

            if (options.syntax === 'CQL') {
                // Convert some CQL state syntax into a filter tree state object.
                // There must be at least one complete expression or `state` will become undefined.
                try {
                    state = this.root.parserCQL.parse(state, columnName);
                    if (state) {
                        options.syntax = 'object';
                    } else {
                        error = new Error('DefaultFilter: No complete expression.');
                    }
                } catch (e) {
                    error = e;
                }
            }

            if (!error) { // parse successful
                if (subexpression) { // subexpression already exists
                    // replace subexpression representing this column
                    subexpression.setState(state, options);
                } else {
                    // add a new subexpression representing this column
                    state = this.parseStateString(state, options); // because .add() only takes object syntax
                    subexpression = this.columnFilters.add(state);
                }
                options.throw = true;
                error = subexpression.invalid(options);
            }
        }

        if (subexpression && (!state || error)) {
            // remove subexpression representing this column
            subexpression.remove();
        }

        if (error) {
            throw error;
        }
    },

    /**
     * @summary Get state of all column filters.
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @returns {FilterTreeStateObject}
     * @memberOf DefaultFilter.prototype
     */
    getColumnFiltersState: function(options) {
        if (options && options.syntax === 'CQL') {
            throw 'The CQL syntax is intended for use on a single column filter only. It does not support multiple columns or subexpressions.';
        }
        return this.root.columnFilters.getState(options);
    },

    /**
     * @summary Set state of all column filters.
     * @desc Note that the column filters implementation depends on the nodes having certain meta-data; you should not be calling this without these meta-data being in place. Specifically `type = 'columnFilters'` and  `keep = true` for the column filters subtree and`type = 'columnFilter'` for each individual column filter subexpression. In addition the subtree operators should always be `'op-and'`.
     * @param {string} state
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     *
     * @returns {undefined|Error|string} `undefined` indicates success.
     *
     * @memberOf DefaultFilter.prototype
     */
    setColumnFiltersState: function(state, options) {
        var error;

        if (state) {
            this.root.columnFilters.setState(state, options);
            error = this.root.columnFilters.invalid(options);
        }

        return error;
    },

    /**
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @returns {FilterTreeStateObject}
     * @memberOf DefaultFilter.prototype
     */
    getTableFilterState: function(options) {
        if (options && options.syntax === 'CQL') {
            throw 'The CQL syntax is intended for use on a single column filter only. It does not support multiple columns or subexpressions.';
        }
        return this.root.tableFilter.getState(options);
    },

    /**
     * @param {string} state
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf DefaultFilter.prototype
     */
    setTableFilterState: function(state, options) {
        var error;

        if (state) {
            this.root.tableFilter.setState(state, options);
            error = this.root.tableFilter.invalid(options);
        } else {
            this.root.tableFilter.children.length = 0;
        }

        return error;
    },

    /**
     * @desc The CQL syntax should only be requested for a subtree containing homogeneous column names and no subexpressions.
     *
     * @param {string} [options.syntax='object'] - If `'CQL'`, walks the tree, returning a string suitable for a Hypergrid filter cell. All other values are forwarded to the prototype's `getState` method for further interpretation.
     *
     * NOTE: CQL is not intended to be used outside the context of a `columnFilters` subexpression.
     *
     * @returns {FilterTreeStateObject}
     *
     * @memberOf DefaultFilter.prototype
     */
    getState: function getState(options) {
        var result,
            syntax = options && options.syntax;

        if (syntax === 'CQL') {
            var operator = this.operator.substr(3); // remove the 'op-' prefix
            result = '';
            this.children.forEach(function(child, idx) {
                if (child) {
                    if (child instanceof CustomFilterLeaf) {
                        if (idx) {
                            result += ' ' + operator + ' ';
                        }
                        result += child.getState(options);
                    } else if (child.children.length) {
                        throw new Error('DefaultFilter: Expected a conditional but found a subexpression. Subexpressions are not supported in CQL (Column Query Language, the filter cell syntax).');
                    }
                }
            });
        } else {
            result = FilterTree.prototype.getState.call(this, options);
        }

        return result;
    },

    loadColumnPropertiesFromSchema: function(columns) {
        this.root.schema.walk(function(columnSchema) {
            var column = columns.find(function(thisColumn) {
                return thisColumn.name === columnSchema.name || columnSchema;
            });
            if (column) {
                column.type = columnSchema.type || column.type;
                column.header = columnSchema.alias || column.header;
            }
        });
    }
});


module.exports = DefaultFilter;

},{"../Shared":55,"./parser-CQL":109,"object-iterators":46}],109:[function(require,module,exports){
'use strict';

var _ = require('object-iterators');

var REGEXP_BOOLS = /\b(AND|OR|NOR)\b/gi,
    EXP = '(.*?)', BR = '\\b',
    PREFIX = '^' + EXP + BR,
    INFIX = BR + EXP + BR,
    POSTFIX = BR + EXP + '$';

function ParserCqlError(message) {
    this.message = message;
}
ParserCqlError.prototype = Object.create(Error.prototype);
ParserCqlError.prototype.name = 'ParserCqlError';

/**
 * @constructor
 *
 * @summary Column Query Language (CQL) parser
 *
 * @author Jonathan Eiten jonathan@openfin.com
 *
 * @desc See {@tutorial CQL} for the grammar.
 *
 * @param {object} operatorsHash - Hash of valid operators. Each is an object, the only property of interest being `complex` which if truthy means operand may be a list of multiple operands.
 * @param {object} [options]
 * @param {menuItem[]} [options.schema] - Column schema for column name/alias validation. Throws an error if name fails validation (but see `resolveAliases`). Omit to skip column name validation.
 * @param {boolean} [options.defaultOp='='] - Default operator for column when not defined in column schema.
 */
function ParserCQL(operatorsHash, options) {
    var operators = [];

    this.schema = options && options.schema;
    this.defaultOp = (options && options.defaultOp || '=').toUpperCase();

    _(operatorsHash).each(function(props, op) {
        if (op !== 'undefined') {
            operators.push(op);
        }
    });

    // Put larger ones first so that in case a smaller one is a substring of a larger one (such as '<' is to '<='), larger one will be matched first.
    operators = operators.sort(descendingByLength);

    // Escape all symbolic (non alpha) operators.
    operators = operators.map(function(op) { return /[^\w]/.test(op) ? '\\' + op.split('').join('\\') : op; });

    var symbolicOperators = operators.filter(function(op) { return op[0] === '\\'; }),
        alphaOperators = operators.filter(function(op) { return op[0] !== '\\'; }).join('|');

    if (alphaOperators) {
        alphaOperators = '\\b(' + alphaOperators + ')\\b';
    }
    /** @summary Regex to match any operator.
     * @desc Matches symbolic operators (made up of non-alpha characters) or identifier operators (word-boundary-isolated runs of alphanumeric characters).
     * @type {RegExp}
     */
    this.REGEX_OPERATOR = new RegExp(symbolicOperators.concat(alphaOperators).join('|'), 'ig');

    operators = operators.join('|') // pipe them
        .replace(/\s+/g, '\\s+'); // arbitrary string of whitespace chars -> whitespace regex matcher

    /** @summary Regex to match an operator + optional operator
     * @desc THe operator is optional. The operand may (or may not) be enclosed in parentheses.
     * @desc Match list:
     * 0. _input string_
     * 1. operator
     * 2. outer operand (may include parentheses)
     * 3. inner operand without parentheses (when an operand was given with parentheses)
     * 4. inner operand (when an operand was given without parentheses)
     * @type {RegExp}
     * @private
     * @memberOf ParserCQL.prototype
     */
    this.REGEX_EXPRESSION = new RegExp('^\\s*(' + operators + ')?\\s*(\\(\\s*(.+?)\\s*\\)|(.+?))\\s*$', 'i');

    this.REGEX_LITERAL_TOKENS = new RegExp('\\' + ParserCQL.qt + '(\\d+)' + '\\' + ParserCQL.qt, 'g');

}

/** @summary Operand quotation mark character.
 * @desc Should be a single character (length === 1).
 * @default '"'
 * @type {string}
 */
ParserCQL.qt = '"';

ParserCQL.prototype = {

    constructor: ParserCQL.prototype.constructor,

    /**
     * @summary Extract the boolean operators from an expression chain.
     * @desc Returns list of homogeneous operators transformed to lower case.
     *
     * Throws an error if all the boolean operators in the chain are not identical.
     * @param {string} cql
     * @returns {string[]}
     */
    captureBooleans: function(cql) {
        var booleans = cql.match(REGEXP_BOOLS);

        if (booleans) {
            var heterogeneousOperator = booleans.find(function(op, i) {
                booleans[i] = op.toLowerCase();
                return booleans[i] !== booleans[0];
            });

            if (heterogeneousOperator) {
                throw new ParserCqlError('Expected homogeneous boolean operators. You cannot mix AND, OR, and NOR operators here because the order of operations is ambiguous. Everything after your ' + heterogeneousOperator.toUpperCase() + ' was ignored. Tip: You can group operations with subexpressions but only in the QueryBuilder or by using parentheses in SQL.');
            }
        }

        return booleans;
    },

    /**
     * @summary Break an expression chain into a list of expressions.
     * @param {string} cql
     * @param {string[]} booleans
     * @returns {string[]}
     */
    captureExpressions: function(cql, booleans) {
        var expressions, re;

        if (booleans) {
            re = new RegExp(PREFIX + booleans.join(INFIX) + POSTFIX, 'i');
            expressions = cql.match(re);
            expressions.shift(); // discard [0] (input)
        } else {
            expressions = [cql];
        }

        return expressions;
    },

    /**
     * @summary Make a list of children out of a list of expressions.
     * @desc Uses only _complete_ expressions (a value OR an operator + a value).
     *
     * Ignores _incomplete_ expressions (empty string OR an operator - a value).
     *
     * @param {string} columnName
     * @param {string[]} expressions
     * @param {string[]} literals - list of literals indexed by token
     *
     * @returns {expressionState[]} where `expressionState` is one of:
     * * `{column: string, operator: string, operand: string}`
     * * `{column: string, operator: string, operand: string, editor: 'Columns'}`
     */
    makeChildren: function(columnName, expressions, literals) {
        var self = this;
        return expressions.reduce(function(children, exp) {
            if (exp) {
                var parts = exp.match(self.REGEX_EXPRESSION);
                if (parts) {
                    var op = parts[1],
                        outerLiteral = parts[2],
                        innerLiteral = parts.slice(3).find(function(part) {
                            return part !== undefined;
                        });

                    op = (op || '').replace(/\s+/g, ' ').trim().toUpperCase();

                    var parenthesized = /^\(.*\)$/.test(outerLiteral),
                        innerOperators = innerLiteral.match(self.REGEX_OPERATOR);

                    if (!parenthesized && innerOperators) {
                        if (op === '' && outerLiteral === innerOperators[0]) {
                            throw new ParserCqlError('Expected an operand.');
                        }

                        throw new ParserCqlError(
                            'Expected operand but found additional operator(s): ' +
                            innerOperators
                                .toString() // convert to comma-separated list
                                .toUpperCase()
                                .replace(/,/g, ', ') // add spaces after the commas
                                .replace(/^([^,]+), ([^,]+)$/, '$1 and $2') // replace only comma with "and"
                                .replace(/(.+,.+), ([^,]+)$/, '$1, and $2') // add "and" after last of several commas
                        );
                    }

                    op = op ||
                        self.schema && self.schema.lookup(columnName).defaultOp || // column's default operator from schema
                        self.defaultOp; // grid's default operator

                    var child = {
                        column: columnName,
                        operator: op
                    };

                    var fieldName = self.schema && self.schema.lookup(innerLiteral);
                    if (fieldName) {
                        child.operand = fieldName.name || fieldName;
                        child.editor = 'Columns';
                    } else {
                        // Find and expand all collapsed literals.
                        child.operand = innerLiteral.replace(self.REGEX_LITERAL_TOKENS, function(match, index) {
                            return literals[index];
                        });
                    }

                    children.push(child);
                }

                return children;
            }
        }, []);
    },

    /**
     * @summary Make a "locked" subexpression definition object from an expression chain.
     * @desc _Locked_ means it is locked to a single field.
     *
     * When there is only a single expression in the chain, the `operator` is omitted (defaults to `'op-and'`).
     *
     * @param {string} cql - A compound CQL expression, consisting of one or more simple expressions all separated by the same logical operator).
     *
     * @param {string} columnName

     * @returns {undefined|{operator: string, children: string[], schema: string[]}}
     * `undefined` when there are no complete expressions
     *
     * @memberOf module:CQL
     */
    parse: function(cql, columnName) {
        // reduce all runs of white space to a single space; then trim
        cql = cql.replace(/\s\s+/g, ' ').trim();

        var literals = [];
        cql = tokenizeLiterals(cql, ParserCQL.qt, literals);

        var booleans = this.captureBooleans(cql),
            expressions = this.captureExpressions(cql, booleans),
            children = this.makeChildren(columnName, expressions, literals),
            operator = booleans && booleans[0],
            state;

        if (children.length) {
            state = {
                type: 'columnFilter',
                children: children
            };

            if (operator) {
                state.operator = 'op-' + operator;
            }
        }

        return state;
    }
};

function descendingByLength(a, b) {
    return b.length - a.length;
}

/**
 * @summary Collapse literals.
 * @desc Allows reserved words to exist inside a quoted string.
 * Literals are collapsed to a quoted numerical index into the `literals` array.
 * @param {string} text
 * @param {string} qt
 * @param {string[]} literals - Empty array in which to return extracted literals.
 * @returns {string}
 */
function tokenizeLiterals(text, qt, literals) {
    literals.length = 0;

    for (
        var i = 0, j = 0, k, innerLiteral;
        (j = text.indexOf(qt, j)) >= 0;
        j = j + 1 + (i + '').length + 1, i++
    ) {
        k = j;
        do {
            k = text.indexOf(qt, k + 1);
            if (k < 0) {
                throw new ParserCqlError('Quotation marks must be paired; nested quotation marks must be doubled.');
            }
        } while (text[++k] === qt);

        innerLiteral = text
            .slice(++j, --k) // extract
            .replace(new RegExp(qt + qt, 'g'), qt); // unescape escaped quotation marks

        literals.push(innerLiteral);

        text = text.substr(0, j) + i + text.substr(k); // collapse
    }

    return text;
}

module.exports = ParserCQL;

},{"object-iterators":46}],110:[function(require,module,exports){
'use strict';

var deprecated = require('./deprecated');
var Base = require('extend-me').Base;

Base.prototype.deprecated = deprecated;
Base.prototype.HypergridError = HypergridError;


function HypergridError(message) {
    this.message = message;
}
HypergridError.prototype = Object.create(Error.prototype);
HypergridError.prototype.name = 'HypergridError';


module.exports = Base;

},{"./deprecated":115,"extend-me":7}],111:[function(require,module,exports){
/* eslint-env browser */

/**
 * @module localization
 */

'use strict';

var Base = require('./Base');
var deprecated = require('./deprecated');


/**
 * @param {string} defaultLocale
 * @param {string} [locale=defaultlocale]
 * @param {object} [options]
 * @constructor
 */
var Formatter = Base.extend({
    initialize: function(defaultLocale, locale, options) {
        if (typeof locale === 'object') {
            options = locale;
            locale = defaultLocale;
        }

        this.locale = locale;

        if (options) {
            if (typeof options.invalid === 'function') {
                this.invalid = options.invalid;
            }

            if (options.expectation) {
                this.expectation = options.expectation;
            }
        }
    }
});

/**
 * @summary Create a number localizer.
 * @implements localizerInterface
 * @desc Create an object conforming to {@link localizerInterface} for numbers, using {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat|Intl.NumberFormat}.
 * @param {string} defaultLocale
 * @param {string} [locale=defaultLocale] - Passed to the {@link Intl.NumberFormat|https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat} constructor.
 * @param {object} [options] - Passed to the `Intl.NumberFormat` constructor.
 * @param {boolean} [options.acceptStandardDigits=false] - Accept standard digits and decimal point interchangeably with localized digits and decimal point. (This option is interpreted here; it is not used by `Intl.NumberFormat`.)
 * @constructor
 * @tutorial localization
 */
var NumberFormatter = Formatter.extend('NumberFormatter', {
    initialize: function(defaultLocale, locale, options) {
        if (typeof locale === 'object') {
            options = locale;
        }

        options = options || {};

        this.format = new Intl.NumberFormat(this.locale, options).format;

        var mapperOptions = { useGrouping: false },
            mapper = new Intl.NumberFormat(this.locale, mapperOptions).format;

        this.demapper = demap.bind(this);

        /**
         * @summary A string containing the valid characters.
         * @desc Contains all localized digits + localized decimal point.
         * If we're accepting standard digits, will also contain all the standard digits + standard decimal point (if different than localized versions).
         * @type {string}
         * @private
         * @desc Localized digits and decimal point. Will also include standardized digits and decimal point if `options.acceptStandardDigits` is truthy.
         *
         * For internal use by the {@link NumberFormatter#standardize|standardize} method.
         * @memberOf NumberFormatter.prototype
         */
        this.map = mapper(10123456789.5).substr(1, 11); // localized '0123456789.'

        if (options.acceptStandardDigits && this.map !== '0123456789.') {
            this.map += '0123456789.';  // standard '0123456789.'
        }

        /** @summary A regex that tests `true` on first invalid character.
         * @type {RegExp}
         * @private
         * @desc Valid characters include:
         *
         * * Localized digits
         * * Localized decimal point
         * * Standard digits (when `options.acceptStandardDigits` is truthy)
         * * Standard decimal point (when `options.acceptStandardDigits` is truthy)
         * * Cosmetic characters added by formatter as per `options` (for human-friendly readability).
         *
         * Any characters outside this set are considered invalid.
         *
         * Set by the constructor; consumed by the {@link module:localization~NumberFormatter#invalid|invalid} method.
         *
         * Testing a string against this pattern yields `true` if at least one invalid character or `false` if all characters are valid.
         * @memberOf NumberFormatter.prototype
         */
        this.invalids = new RegExp(
            '[^' +
            this.format(11111).replace(this.map[1], '') + // thousands separator if in use
            this.map + // digits + decimal point
            ']'
        );
    },

    /** @summary Tests for invalid characters.
     * @desc Tests a localized string representation of a number that it contains any invalid characters.
     *
     * The number may be unformatted or it may be formatted with any of the permitted formatting characters, as implied by the constructor's `options` (passed to `Intl.NumberFormat`). Any other characters are considered invalid.
     *
     * However, standard digits and the standard decimal point are considered valid if the value of `options.acceptStandardDigits` as provided to the constructor was truthy. (Of course, these are always valid for locales that use them.)
     *
     * Use this method to:
     * 1. Filter out invalid characters on a `onkeydown` event; or
     * 2. Test an edited string prior to calling the {@link module:localization~NumberFormatter#standardize|standardize}.
     *
     * NOTE: This method does not check grammatical syntax; it only checks for invalid characters.
     *
     * @param number
     * @returns {boolean|string} Falsy means valid which in this case means contains only valid characters.
     * @memberOf NumberFormatter.prototype
     */
    invalid: function(number) {
        return this.invalids.test(number);
    },

    expectation:
        'Expected a number with optional commas (thousands grouping separator), optional decimal point, and an optional fractional part.\n' +
        'Comma separators are part of the format and will always be displayed for values >= 1000.\n' +
        'Edited values are always saved in their entirety even though the formatted value is rounded to the specified number of decimal places.',

    /**
     * This method will:
     * * Convert localized digits and decimal point characters to standard digits and decimal point characters.
     * * "Clean" the string by ignoring all other characters.
     * * Coerce the string to a number primitive.
     * @param {string} formattedLocalizedNumber - May or may not be formatted.
     * @returns {number} Number primitive.
     * @throws {string} Invalid number.
     * @memberOf NumberFormatter.prototype
     */
    parse: function(formattedLocalizedNumber) {
        var number = Number(
            formattedLocalizedNumber.split('').map(this.demapper).join('')
        );

        if (isNaN(number)) {
            throw 'Invalid Number';
        }

        return number;
    }
});

function demap(c) {
    var d = this.map.indexOf(c) % 11;
    return d < 0 ? '' : d < 10 ? d : '.';
}

/**
 * @implements localizerInterface
 * @param {string} defaultLocale
 * @param {string} [locale=defaultlocale] - Passed to the {@link Intl.DateFormat|https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateFormat} constructor.
 * @param {object} [options] - Passed to the `Intl.DateFormat` constructor.
 * @constructor
 */
var DateFormatter = Formatter.extend('DateFormatter', {
    initialize: function(defaultLocale, locale, options) {
        if (typeof locale === 'object') {
            options = locale;
        }

        options = options || {};

        /** @summary Transform a date object into human-friendly string representation.
         * @method
         */
        this.format = new Intl.DateTimeFormat(this.locale, options).format;

        // Get digits because may be chinese or "real Arabic" numerals.
        var testOptions = { useGrouping: false, style: 'decimal' },
            localizeNumber = new Intl.NumberFormat(this.locale, testOptions).format,
            localizedDigits = this.localizedDigits = localizeNumber(10123456789).substr(1, 10); // all localized digits in numerical order

        this.digitFormatter = formatDigit.bind(this);
        this.digitParser = parseDigit.bind(this);

        // Localize a test date with the default numeric parts to find out the resulting order of these parts.
        var yy = 1987,
            mm = 12,
            dd = 30,
            YY = this.transformNumber(this.digitFormatter, yy),
            MM = this.transformNumber(this.digitFormatter, mm),
            DD = this.transformNumber(this.digitFormatter, dd),
            testDate = new Date(yy, mm - 1, dd),
            localizeDate = new Intl.DateTimeFormat(this.locale).format,
            localizedDate = localizeDate(testDate), // all localized digits + localized punctuation
            missingDigits = new Intl.NumberFormat(this.locale).format(456),
            localizedNumberPattern = this.localizedNumberPattern = new RegExp('[' + localizedDigits + ']+', 'g'),
            parts = localizedDate.match(localizedNumberPattern);

        this.partsMap = {
            yy: parts.indexOf(YY),
            mm: parts.indexOf(MM),
            dd: parts.indexOf(DD)
        };

        if (options.acceptStandardDigits) {
            missingDigits += '1234567890';
        }

        /** @summary A regex that tests `true` on first invalid character.
         * @type {RegExp}
         * @private
         * @desc Valid characters include:
         *
         * * Localized digits
         * * Standard digits (when `options.acceptStandardDigits` is truthy)
         * * Localized punctuation to delimit date parts
         *
         * Any characters outside this set are considered invalid. Note that this only currently implemented when all three date parts are numeric
         *
         * Set by the constructor; consumed by the {@link NumberFormatter#valid|valid} method.
         *
         * Testing a string against this pattern yields `true` if at least one invalid character or `false` if all characters are valid.
         * @memberOf DateFormatter.prototype
         */
        this.invalids = new RegExp(
            '[^' +
            localizedDate +
            missingDigits +
            ']'
        );
    },

    /** @summary Tests for invalid characters.
     * @desc Tests a localized string representation of a number that it contains any invalid characters.
     *
     * The date is assumed to contain localized digits and punctuation as would be returned by `Intl.DateFormat` with the given `locale` and `options`. Any other characters are considered invalid.
     *
     * However, standard digits and the standard decimal point are also considered valid if the value of `options.acceptStandardDigits` as provided to the constructor was truthy. (Of course, these are always valid for locales that use them.)
     *
     * Use this method to:
     * 1. Filter out invalid characters on a `onkeydown` event; or
     * 2. Test an edited string prior to calling the {@link module:localization~DateFormatter#standardize|standardize}.
     *
     * NOTE: The current implementation only supports date formats using all numerics (which is the default for `Intl.DateFormat`).
     *
     * NOTE: This method does not check grammatical syntax; it only checks for invalid characters.
     *
     * @param number
     * @returns {boolean} Contains only valid characters.
     * @memberOf DateFormatter.prototype
     */
    invalid: function(number) {
        return this.invalids.test(number);
    },

    /**
     * This method will:
     * * Convert localized date to Date object.
     * * "Clean" the string by ignoring all other characters.
     * * Coerce the string to a number primitive.
     * @param {string} localizedDate
     * @returns {Date}
     * @throws {string} Invalid date.
     * @memberOf DateFormatter.prototype
     */
    parse: function(localizedDate) {
        var date,
            parts = localizedDate.match(this.localizedNumberPattern);

        if (parts && parts.length === 3) {
            var y = this.transformNumber(this.digitParser, parts[this.partsMap.yy]),
                m = this.transformNumber(this.digitParser, parts[this.partsMap.mm]) - 1,
                d = this.transformNumber(this.digitParser, parts[this.partsMap.dd]);

            date = new Date(y, m, d);
        } else {
            throw 'Invalid Date';
        }

        return date;
    },

    /**
     * Transform a number to or from a string representation with localized digits.
     * @param {function} digitTransformer - A function bound to `this`.
     * @param {number} number
     * @returns {string}
     * @private
     * @memberOf DateFormatter.prototype
     */
    transformNumber: function(digitTransformer, number) {
        return number.toString().split('').map(digitTransformer).join('');
    }
});

function formatDigit(d) {
    return this.localizedDigits[d];
}

function parseDigit(c) {
    var d = this.localizedDigits.indexOf(c);
    if (d < 0) { d = ''; }
    return d;
}

/**
 * All members are localizers (conform to {@link localizerInterface}) with exception of `get`, `set`, and localizer constructors which are named (by convention) ending in "Formmatter".
 *
 * The application developer is free to add localizers and localizer factory methods. See the {@link Localization#construct|construct} convenience method which may be helpful in this regard.
 * @param locale
 * @param {object} [numberOptions]
 * @param {object} [dateOptions]
 * @constructor
 */
function Localization(locale, numberOptions, dateOptions) {
    this.locale = locale;

    /**
     * @name number
     * @see The {@link NumberFormatter|NumberFormatter} class
     * @memberOf Localization.prototype
     */
    this.int = this.float = this.construct('number', NumberFormatter, numberOptions);

    /**
     * @see The {@link DateFormatter|DateFormatter} class
     * @memberOf Localization.prototype
     */
    this.construct('date', DateFormatter, dateOptions);
}

Localization.prototype = {
    constructor: Localization.prototype.constructor,

    /** @summary Creates a localizer from a localizer factory object using the default locale.
     * @desc Performs the following actions:
     * 1. Binds `Constructor` to `locale`.
     * 2. Adds the newly bound constructor to this object (for future reference) with the key "NameFormatter" (where "Name" is the localizer name, all lower case but with an initial capital).
     * 3. Uses the newly bound constructor to create a new localized localizer with the provided options.
     * 4. Adds new localizer to this object via {@link Localization#add|add}.
     *
     * @param {string} localizerName
     * @param {Constructor
     * @param {object} {factoryOptions}
     * @returns {localizeInerface} The new localizer.
     */
    construct: function(localizerName, Constructor, factoryOptions) {
        var constructorName = localizerName[0].toUpperCase() + localizerName.substr(1).toLowerCase() + 'Formatter',
            BoundConstructor = Constructor.bind(null, this.locale),
            localizer = new BoundConstructor(factoryOptions);

        this[constructorName] = BoundConstructor;

        return this.add(localizerName, localizer);
    },

    /** @summary Register a localizer.
     * @desc Checks the provided localizer that it conforms to {@link localizerInterface}
     * and adds it to the object using localizerName all lower case as the key.
     * @param {string} name
     * @param {localizerInterface} localizer
     * @memberOf Localization.prototype
     * @returns {localizeInerface} The provided localizer.
     */
    add: function(name, localizer) {
        if (typeof name === 'object') {
            localizer = name;
            name = undefined;
        }

        if (
            typeof localizer !== 'object' ||
            typeof localizer.format !== 'function' ||
            typeof localizer.parse !== 'function' ||
            localizer.invalid && typeof localizer.invalid !== 'function' ||
            localizer.expectation && typeof localizer.expectation !== 'string'
        ) {
            throw 'Expected localizer object to conform to interface.';
        }

        name = name || localizer.name;
        name = name && name.toLowerCase();
        this[name] = localizer;

        return localizer;
    },
    deprecated: deprecated,
    set: function(name) {
        this.deprecated('set(name, localizer)', 'add(name, localizer)', '1.0.6', arguments);
    },

    /**
     *
     * @param localizerName
     * @returns {localizerInterface}
     * @memberOf Localization.prototype
     */
    get: function(name) {
        return this[name && name.toLowerCase()] || this.string;
    },

    ///  ///  ///  ///  ///    LOCALIZERS    ///  ///  ///  ///  ///

    // Special localizer for use by Chrome's date input control.
    chromeDate: {
        format: function(date) {
            if (date != null) {
                if (typeof date !== 'object') {
                    date = new Date(date);
                }

                var yy = date.getFullYear(),
                    m = date.getMonth() + 1, mm = m < 10 ? '0' + m : m,
                    d = date.getDate(), dd = d < 10 ? '0' + d : d;

                date = yy + '-' + mm + '-' + dd;
            } else {
                date = null;
            }
            return date;
        },
        parse: function(str) {
            var date,
                parts = str.split('-');
            if (parts && parts.length === 3) {
                date = new Date(parts[0], parts[1] - 1, parts[2]);
            } else {
                date = null;
            }
            return date;
        }
    },

    null: {
        format: function(value) {
            return value;
        },
        parse: function(str) {
            return str;
        }
    },

    string: {
        format: function(value) {
            return value + '';
        },
        parse: function(str) {
            return str + '';
        }
    }
};

module.exports = Localization;

},{"./Base":110,"./deprecated":115}],112:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

var _ = require('object-iterators');

var Base = require('./Base');
var images = require('../../images');

/** @typedef {object} CanvasRenderingContext2D
 * @see [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
 */

/**
 * @constructor
 * @desc fin-hypergrid-renderer is the canvas enabled top level sub component that handles the renderering of the Grid.
 *
 * It relies on two other external subprojects
 *
 * 1. fin-canvas: a wrapper to provide a simpler interface to the HTML5 canvas component
 * 2. rectangular: a small npm module providing Point and Rectangle objects
 *
 * The fin-hypergrid-renderer is in a unique position to provide critical functionality to the fin-hypergrid in a hightly performant manner.
 * Because it MUST iterate over all the visible cells it can store various bits of information that can be encapsulated as a service for consumption by the fin-hypergrid component.
 *
 * Instances of this object have basically four main functions.
 *
 * 1. render fixed row headers
 * 2. render fixed col headers
 * 3. render main data cells
 * 4. render grid lines
 *
 * Same parameters as {@link Renderer#initialize|initialize}, which is called by this constructor.
 *
 */
var Renderer = Base.extend('Renderer', {

    //the shared single item "pooled" cell object for drawing each cell
    cell: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    },

    scrollHeight: 0,

    viewHeight: 0,

    reset: function() {
        this.bounds = {
            width: 0,
            height: 0
        };
        this.columnEdges = [];
        this.columnEdgesIndexMap = [];
        this.renderedColumnMinWidths = [];
        this.rowEdges = [];
        this.rowEdgesIndexMap = [];
        this.visibleColumns = [];
        this.visibleRows = [];
        this.insertionBounds = [];
    },

    /**
     * @summary Constructor logic
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     * @memberOf Renderer.prototype
     */
    initialize: function(grid) {
        this.grid = grid;
        this.reset();
    },

    //this function computes the grid coordinates used for extremely fast iteration over
    //painting the grid cells. this function is very fast, for thousand rows X 100 columns
    //on a modest machine taking usually 0ms and no more that 3 ms.
    computeCellsBounds: function() {

        //var startTime = Date.now();

        var scrollTop = this.getScrollTop(),
            scrollLeft = this.getScrollLeft(),

            numColumns = this.getColumnCount(),
            numFixedColumns = this.getFixedColumnCount(),

            numRows = this.getRowCount(),
            numFixedRows = this.getFixedRowCount(),

            bounds = this.getBounds(),
            grid = this.grid,
            numberOfBottomTotalsRows = grid.behavior.dataModel.getBottomTotals().length,
            viewWidth = bounds.width || grid.canvas.width, // if 0, we must be in bootstrap
            viewHeight = bounds.height - numberOfBottomTotalsRows * grid.behavior.getDefaultRowHeight(),

            insertionBoundsCursor = 0,
            previousInsertionBoundsCursorValue = 0,

            start = 0,
            x = 0, y = 0,
            c, r,
            vx, vy,
            width, height,
            firstVX, lastVX,
            firstVY, lastVY;

        this.getColumnEdges().length = 0;
        this.rowEdges.length = 0;

        this.columnEdges[0] = 0;
        this.rowEdges[0] = 0;
        this.scrollHeight = 0;

        this.visibleColumns.length = 0;
        this.visibleRows.length = 0;
        this.columnEdgesIndexMap = [];
        this.rowEdgesIndexMap = [];

        this.insertionBounds = [];

        if (this.grid.isShowRowNumbers()) {
            start--;
            this.columnEdges[-1] = -1;
        }

        for (c = start; c < numColumns; c++) {
            vx = c;
            if (c >= numFixedColumns) {
                vx = vx + scrollLeft;
                if (firstVX === undefined) {
                    firstVX = vx;
                }
                lastVX = vx;
            }
            if (x > viewWidth || numColumns <= vx) {
                break;
            }
            width = grid.getColumnWidth(vx);
            x = x + width;
            this.columnEdges[c + 1] = Math.round(x);
            this.visibleColumns[c] = vx;
            this.columnEdgesIndexMap[vx] = c;

            insertionBoundsCursor = insertionBoundsCursor + Math.round(width / 2) + previousInsertionBoundsCursorValue;
            this.insertionBounds.push(insertionBoundsCursor);
            previousInsertionBoundsCursorValue = Math.round(width / 2);
        }

        for (r = 0; r < numRows; r++) {
            vy = r;
            if (r >= numFixedRows) {
                vy = vy + scrollTop;
                if (firstVY === undefined) {
                    firstVY = vy;
                }
                lastVY = vy;
            }
            if (y > viewHeight || numRows <= vy) {
                break;
            }
            height = grid.getRowHeight(vy);
            y = y + height;
            this.rowEdges[r + 1] = Math.round(y);
            this.visibleRows[r] = vy;
            this.rowEdgesIndexMap[vy] = r;
        }
        this.viewHeight = viewHeight;
        this.dataWindow = this.grid.newRectangle(firstVX, firstVY, lastVX - firstVX, lastVY - firstVY);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {Object} a property value at a key, delegates to the grid
     */
    resolveProperty: function(key) {
        return this.grid.resolveProperty(key);
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Notify the fin-hypergrid everytime we've repainted.
     * @desc This is the entry point from fin-canvas.
     * @param {CanvasRenderingContext2D} gc
     */
    paint: function(gc) {
        if (this.grid) {
            if (!this.hasData()) {
                var message = this.grid.resolveProperty('noDataMessage');
                gc.font = '20px Arial';
                gc.fillText(message, 20, 30);
            } else {
                this.renderGrid(gc);
                this.grid.gridRenderedNotification();
            }
        }
    },

    hasData: function() {
        var data = this.grid.behavior.getData();
        if (data) {
            return data.length > 0;
        }
        return false;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Answer how many rows we rendered
     */
    getVisibleRowsCount: function() {
        return this.visibleRows.length - 1;
    },

    getVisibleScrollHeight: function() {
        return this.viewHeight - this.grid.getFixedRowsHeight();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number[]} Rows we just rendered.
     */
    getVisibleRows: function() {
        return this.visibleRows;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Numer of columns we just rendered.
     */
    getVisibleColumnsCount: function() {
        return this.visibleColumns.length - 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Columns we just rendered.
     */
    getVisibleColumns: function() {
        return this.visibleColumns;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The column index whne the mouseEvent coordinates are over a column divider.
     */
    overColumnDivider: function(x) {
        x = Math.round(x);
        var edges = this.getColumnEdges();
        var whichCol = edges.indexOf(x - 1);
        if (whichCol < 0) {
            whichCol = edges.indexOf(x);
        }
        if (whichCol < 0) {
            whichCol = edges.indexOf(x - 2);
        }
        if (whichCol < 0) {
            whichCol = edges.indexOf(x + 1);
        }
        if (whichCol < 0) {
            whichCol = edges.indexOf(x - 3);
        }

        return whichCol;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row index when the mouseEvent coordinates are over a row divider.
     */
    overRowDivider: function(y) {
        y = Math.round(y);
        var which = this.rowEdges.indexOf(y + 1);
        if (which < 0) {
            which = this.rowEdges.indexOf(y);
        }
        if (which < 0) {
            which = this.rowEdges.indexOf(y - 1);
        }
        return which;
    },

    /**
     * @memberOf Renderer.prototype
     * @param {Point} cell
     * @returns {Rectangle} Bounding rect of the given `cell`.
     */
    getBoundsOfCell: function(cell) {
        return this._getBoundsOfCell(cell.x, cell.y);
    },

    /**
     * @memberOf Renderer.prototype
     * @param {number} c - The horizontal coordinate.
     * @param {number} r - The vertical coordinate.
     * @returns {Rectangle} Bounding rect of cell with the given coordinates.
     */
    _getBoundsOfCell: function(c, r) {
        var xOutside = false,
            yOutside = false,
            cell = this.cell;

        var y, x = this.columnEdgesIndexMap[c];
        if (x === undefined) {
            x = this.columnEdgesIndexMap[c - 1];
            xOutside = true;
        }

        var oy, ox = this.columnEdges[x],
            cy, cx = this.columnEdges[x + 1],
            ey, ex = cx - ox;

        cell.x = xOutside ? cx : ox;
        cell.width = xOutside ? 0 : ex;

        if (r < 0) { // bottom totals rows
            var behavior = this.grid.behavior,
                bounds = this.getBounds();

            ey = behavior.getDefaultRowHeight();
            oy = bounds.height + r * ey;
            cy = oy + ey;
        } else {
            y = this.rowEdgesIndexMap[r];
            if (y === undefined) {
                y = this.rowEdgesIndexMap[r - 1];
                yOutside = true;
            }

            oy = this.rowEdges[y];
            cy = this.rowEdges[y + 1];
            ey = cy - oy;
        }

        cell.y = yOutside ? cy : oy;
        cell.height = yOutside ? 0 : ey;

        return cell;
    },

    /**
     * @memberOf Renderer.prototype
     * @desc answer the column index under the coordinate at pixelX
     * @param {number} pixelX - The horizontal coordinate.
     * @returns {number} The column index under the coordinate at pixelX.
     */
    getColumnFromPixelX: function(pixelX) {
        var width = 0,
            fixedColumnCount = this.getFixedColumnCount(),
            scrollLeft = this.grid.getHScrollValue(),
            edges = this.getColumnEdges();

        for (var c = 1; c < edges.length - 1; c++) {
            width = edges[c] - (edges[c] - edges[c - 1]) / 2;
            if (pixelX < width) {
                if (c > fixedColumnCount) {
                    c = c + scrollLeft;
                }
                return c - 1;
            }
        }
        if (c > fixedColumnCount) {
            c = c + scrollLeft;
        }
        return c - 1;
    },


    /**
     * @memberOf Renderer.prototype
     * @desc Answer specific data cell coordinates given mouse coordinates in pixels.
     * @param {Point} point
     * @returns {Point} Cell coordinates
     */
    getGridCellFromMousePoint: function(point) {

        var behavior = this.grid.behavior;
        var width = 0;
        var height = 0;
        var x, y, c, r;
        var previous = 0;
        var columnEdges = this.getColumnEdges();
        var fixedColumnCount = this.getFixedColumnCount(); // + gridSize;
        var fixedRowCount = this.getFixedRowCount();

        // var fixedColumnCount = this.getFixedColumnCount();
        // var fixedRowCount = this.getFixedRowCount();
        var scrollX = this.getScrollLeft();
        var scrollY = this.getScrollTop();

        for (c = 0; c < columnEdges.length; c++) {
            width = columnEdges[c];
            if (point.x < width) {
                x = Math.max(0, point.x - previous - 2);
                break;
            }
            previous = width;
        }
        c--;
        previous = 0;
        for (r = 0; r < this.rowEdges.length; r++) {
            height = this.rowEdges[r];
            if (point.y < height) {
                y = Math.max(0, point.y - previous - 2);
                break;
            }
            previous = height;
        }
        r--;
        if (point.x < 0) {
            c = -1;
        }
        if (point.y < 0) {
            r = -1;
        }

        var viewPoint = this.grid.newPoint(c, r);

        //compensate if we are scrolled
        if (c >= fixedColumnCount) {
            c = c + scrollX;
        }
        if (r >= fixedRowCount) {
            r = r + scrollY;
        }

        var translatedIndex = -1;

        var column = behavior.getActiveColumn(c);
        if (column) {
            translatedIndex = column.index;
        }

        return {
            gridCell: this.grid.newPoint(c, r),
            mousePoint: this.grid.newPoint(x, y),
            viewPoint: viewPoint,
            dataCell: this.grid.newPoint(translatedIndex, r),
        };
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines if a column is visible.
     * @param {number} colIndex - the column index*
     * @returns {boolean} The given column is fully visible.
     */
    isColumnVisible: function(colIndex) {
        var isVisible = this.visibleColumns.indexOf(colIndex) !== -1;
        return isVisible;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The width x coordinate of the last rendered column
     */
    getFinalVisableColumnBoundary: function() {
        var isMaxX = this.isLastColumnVisible();
        var chop = isMaxX ? 2 : 1;
        var colWall = this.getColumnEdges()[this.getColumnEdges().length - chop];
        var result = Math.min(colWall, this.getBounds().width - 200);
        return result;
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines visibility of a row.
     * @param {number} rowIndex - the row index
     * @returns {boolean} The given row is fully visible.
     */
    isRowVisible: function(rowIndex) {
        var isVisible = this.visibleRows.indexOf(rowIndex) !== -1;
        return isVisible;
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines if a cell is selected.
     * @param {number} x - the x cell coordinate
     * @param {number} y - the y cell coordinate*
     * @returns {boolean} The given cell is fully visible.
     */
    isSelected: function(x, y) {
        return this.grid.isSelected(x, y);
    },

    /**
     * @memberOf Renderer.prototype
     * @desc This is the main forking of the renderering task.
     * @param {CanvasRenderingContext2D} gc
     */
    renderGrid: function(gc) {
        gc.beginPath();

        this.paintCells(gc);
        this.paintGridlines(gc);
        this.renderOverrides(gc);
        this.renderLastSelection(gc);
        gc.closePath();
    },

    renderLastSelection: function(gc) {
        gc.beginPath();
        this._renderLastSelection(gc);
        gc.closePath();
    },

    _renderLastSelection: function(gc) {

        /*

            Compute the Bounds of the Last Selection that is visible

         */

        var selections = this.grid.selectionModel.getSelections();
        if (!selections || selections.length === 0) {
            return;
        }
        var selection = this.grid.selectionModel.getLastSelection();
        var mouseDown = selection.origin;
        if (mouseDown.x === -1) {
            //no selected area, lets exit
            return;
        }

        var visibleColumns = this.getVisibleColumns();
        var visibleRows = this.getVisibleRows();
        var lastVisibleColumn = visibleColumns[visibleColumns.length - 1];
        var lastVisibleRow = visibleRows[visibleRows.length - 1];

        var extent = selection.extent;

        var dpOX = Math.min(mouseDown.x, mouseDown.x + extent.x);
        var dpOY = Math.min(mouseDown.y, mouseDown.y + extent.y);

        //lets check if our selection rectangle is scrolled outside of the visible area
        if (dpOX > lastVisibleColumn) {
            return; //the top of our rectangle is below visible
        }
        if (dpOY > lastVisibleRow) {
            return; //the left of our rectangle is to the right of being visible
        }

        var dpEX = Math.max(mouseDown.x, mouseDown.x + extent.x) + 1;
        dpEX = Math.min(dpEX, 1 + lastVisibleColumn);

        var dpEY = Math.max(mouseDown.y, mouseDown.y + extent.y) + 1;
        dpEY = Math.min(dpEY, 1 + lastVisibleRow);

        var o = this._getBoundsOfCell(dpOX, dpOY);
        var ox = Math.round((o.x === undefined) ? this.grid.getFixedColumnsWidth() : o.x);
        var oy = Math.round((o.y === undefined) ? this.grid.getFixedRowsHeight() : o.y);
        // var ow = o.width;
        // var oh = o.height;
        var e = this._getBoundsOfCell(dpEX, dpEY);
        var ex = Math.round((e.x === undefined) ? this.grid.getFixedColumnsWidth() : e.x);
        var ey = Math.round((e.y === undefined) ? this.grid.getFixedRowsHeight() : e.y);
        // var ew = e.width;
        // var eh = e.height;
        var x = Math.min(ox, ex);
        var y = Math.min(oy, ey);
        var width = 1 + ex - ox;
        var height = 1 + ey - oy;
        if (x === ex) {
            width = ox - ex;
        }
        if (y === ey) {
            height = oy - ey;
        }
        if (width * height < 1) {
            //if we are only a skinny line, don't render anything
            return;
        }

        /*

          Render the selection model around the bounds

         */

        var config = {
            bounds: {
                x: x,
                y: y,
                width: width,
                height: height
            },
            selectionRegionOverlayColor: this.grid.resolveProperty('selectionRegionOverlayColor'),
            selectionRegionOutlineColor: this.grid.resolveProperty('selectionRegionOutlineColor')
        };
        this.grid.cellRenderers.get('lastselection').paint(gc, config);
    },

    /**
     * @memberOf Renderer.prototype
     * @desc iterate the renderering overrides and manifest each
     * @param {CanvasRenderingContext2D} gc
     */
    renderOverrides: function(gc) {
        var cache = this.grid.renderOverridesCache;
        for (var key in cache) {
            if (cache.hasOwnProperty(key)) {
                var override = cache[key];
                if (override) {
                    this.renderOverride(gc, override);
                }
            }
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @desc copy each overrides specified area to it's target and blank out the source area
     * @param {CanvasRenderingContext2D} gc
     * @param {OverrideObject} override - an object with details contain an area and a target context
     */
    renderOverride: function(gc, override) {
        //lets blank out the drag row
        var hdpiRatio = override.hdpiratio;
        //var edges = this.getColumnEdges();
        var startX = override.startX; //hdpiRatio * edges[override.columnIndex];
        var width = override.width + 1;
        var height = override.height;
        var targetCTX = override.ctx;
        var imgData = gc.getImageData(startX, 0, Math.round(width * hdpiRatio), Math.round(height * hdpiRatio));
        targetCTX.putImageData(imgData, 0, 0);
        gc.fillStyle = this.resolveProperty('backgroundColor2');
        gc.fillRect(Math.round(startX / hdpiRatio), 0, width, height);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Current vertical scroll value.
     */
    getScrollTop: function() {
        return this.grid.getVScrollValue();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Current horizontal scroll value.
     */
    getScrollLeft: function() {
        return this.grid.getHScrollValue();
    },

    getColumnEdges: function() {
        return this.columnEdges;
    },

    getRowEdges: function() {
        return this.rowEdges;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} The last col was rendered (is visible)
     */
    isLastColumnVisible: function() {
        var lastColumnIndex = this.getColumnCount() - 1;
        return this.visibleColumns.indexOf(lastColumnIndex) !== -1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The rendered column width at index
     */
    getRenderedWidth: function(index) {
        return this.getColumnEdges()[index];
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The rendered row height at index
     */
    getRenderedHeight: function(index) {
        return this.rowEdges[index];
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {fin-canvas} my [fin-canvas](https://github.com/stevewirts/fin-canvas)
     */
    getCanvas: function() {
        return this.grid.getCanvas();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} User is currently dragging a column for reordering.
     */
    isDraggingColumn: function() {
        return this.grid.isDraggingColumn();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to goto for a page up.
     */
    getPageUpRow: function() {
        var grid = this.grid,
            scrollHeight = this.getVisibleScrollHeight(),
            headerRows = this.grid.getFixedRowCount(),
            top = this.dataWindow.origin.y - headerRows,
            scanHeight = 0;
        while (scanHeight < scrollHeight && top > -1) {
            scanHeight = scanHeight + grid.getRowHeight(top);
            top--;
        }
        return top + 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to goto for a page down.
     */
    getPageDownRow: function() {
        var headerRows = this.grid.getFixedRowCount();
        var rowNum = this.dataWindow.corner.y - headerRows - 1;
        return rowNum;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of columns.
     */
    getColumnCount: function() {
        return this.grid.getColumnCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of rows.
     */
    getRowCount: function() {
        return this.grid.getRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.grid.getFixedColumnCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of fixed rows.
     */
    getFixedRowCount: function() {
        return this.grid.getFixedRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of header rows.
     */
    getHeaderRowCount: function() {
        return this.grid.getHeaderRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of header columns.
     */
    getHeaderColumnCount: function() {
        return this.grid.getHeaderColumnCount();
    },

    /** @summary Smart render the grid.
     * @desc Paint all the cells of a grid, including all "fixed" columns and rows.
     * We snapshot the context to insure against its pollution.
     * `try...catch` surrounds each cell paint in case a cell editor throws an error.
     * The error message is error-logged to console AND displayed in cell.
     * @memberOf Renderer.prototype
     * @param {CanvasRenderingContext2D} gc
     */
    paintCells: function(gc) {
        var message,
            config = {},
            x, y,
            c, r,

            columnEdges = this.getColumnEdges(),
            rowEdges = this.rowEdges,

            visibleCols = this.getVisibleColumns(),
            visibleRows = this.getVisibleRows(),

            behavior = this.grid.behavior,

            clipX = 0,
            clipY = 0,
            clipWidth,
            clipHeight = this.getBounds().height,

            loopStart = this.grid.isShowRowNumbers() ? -1 : 0,
            loopLength = visibleCols.length; // regardless of loopStart, due to definition of .length

        this.buttonCells = {};

        if (loopLength) { // this if prevents painting just the fixed columns when there are no visible columns

            // For each column...
            for (x = loopStart; x < loopLength; x++, clipX += clipWidth) {

                c = visibleCols[x];
                this.renderedColumnMinWidths[c] = 0;

                gc.save();

                // Clip to visible portion of column to prevent overflow to right. Previously we clipped to entire visible grid and dealt with overflow by overpainting with next column. However, this strategy fails when transparent background (no background color).
                // TODO: if extra clip() calls per column affect performance (not the clipping itself which was happening anyway, but the clip calls which set up the clipping), use previous strategy when there is a background color
                clipWidth = columnEdges[x + 1] - clipX;
                gc.beginPath();
                gc.rect(clipX, clipY, clipWidth, clipHeight);
                gc.clip();

                // For each row (of each column)...
                for (y = 0; y < visibleRows.length; y++) {

                    r = visibleRows[y];

                    try {

                        this._paintCell(gc, c, r);

                        //if (r === 9 && c === 2) { throw Error('She sells sea shells by the sea shore.'); }

                    } catch (e) {

                        message = e && (e.message || e) || 'Unknown error.';

                        console.error(message);

                        var rawGc = gc.gc || gc, // Don't log these canvas calls
                            errY = rowEdges[y],
                            errHeight = rowEdges[y + 1] - errY;

                        rawGc.save(); // define clipping region
                        rawGc.beginPath();
                        rawGc.rect(clipX, errY, clipWidth, errHeight);
                        rawGc.clip();
                        config = {
                            bounds: {
                                y: errY,
                                x: clipX,
                                height: errHeight,
                                width: clipWidth
                            }
                        };

                        this.grid.cellRenderers.get('errorcell').paint(rawGc, config, message);

                        rawGc.restore(); // discard clipping region

                    }
                }

                // Bottom totals rows...
                for (y = -behavior.dataModel.getBottomTotals().length; y; y++) {
                    this._paintCell(gc, c, y);
                }

                gc.restore(); // Remove column's clip region (and anything else renderCellError() might have set)
            }
        }

        setNumberColumnWidth(gc, behavior, this.grid.getRowCount());
    },

    /**
     * @memberOf Renderer.prototype
     * @desc We opted to not paint borders for each cell as that was extremely expensive. Instead we draw gridlines here. Also we record the widths and heights for later.
     * @param {CanvasRenderingContext2D} gc
     */
    paintGridlines: function(gc) {
        var x, y, c, r = 0;

        var colWidths = this.getColumnEdges();
        var rowHeights = this.rowEdges;
        var viewHeight;
        var viewWidth = colWidths[colWidths.length - 1];
        var drawThemH = this.resolveProperty('gridLinesH');
        var drawThemVOverflow = this.resolveProperty('gridLinesVOverflow');
        var drawThemV = this.resolveProperty('gridLinesV');
        var lineColor = this.resolveProperty('lineColor');
        if (drawThemVOverflow){
            viewHeight = this.getBounds().height;
        } else {
            viewHeight = rowHeights[rowHeights.length - 1];
        }

        gc.beginPath();

        if (drawThemV) {
            for (c = 0; c < colWidths.length + 1; c++) {
                x = colWidths[c] + 0.5;
                gc.moveTo(x, 0);
                gc.lineTo(x, viewHeight);
            }
        }

        if (drawThemH) {
            for (r = 0; r < rowHeights.length - 1; r++) {
                y = rowHeights[r] + 0.5;
                gc.moveTo(0, y);
                gc.lineTo(viewWidth, y);
            }

            // Bottom totals rows...
            var behavior = this.grid.behavior,
                rowHeight = behavior.getDefaultRowHeight();
            for (r = -behavior.dataModel.getBottomTotals().length, y = this.getBounds().height; r; r++) {
                y -= rowHeight;
                gc.moveTo(0, y);
                gc.lineTo(viewWidth, y);
            }
        }

        gc.closePath();

        gc.strokeStyle = lineColor;
        gc.lineWidth = this.resolveProperty('lineWidth');
        gc.stroke();
    },

    /**
     * @memberOf Renderer.prototype
     * @param {CanvasRenderingContext2D} gc
     * @param x
     * @param y
     */
    paintCell: function(gc, x, y) {
        gc.moveTo(0, 0);

        var c = this.getVisibleColumns()[x],
            r = this.getVisibleRows()[y];

        if (c) { //something is being viewed at at the moment (otherwise returns undefined)
            this._paintCell(gc, c, r);
        }
    },

    _paintCell: function(gc, c, r) {

        var grid = this.grid,
            behavior = grid.behavior,
            baseProperties = behavior.getColumnProperties(c);

        if (baseProperties.isNull) {
            return;
        }

        var columnProperties = baseProperties,

            headerRowCount = behavior.getHeaderRowCount(),
            isGridRow = r >= headerRowCount,
            isFooterRow = r < 0,
            isHeaderRow = !isGridRow && !isFooterRow,
            isFilterRow = grid.isFilterRow(r),

            headerColumnCount = behavior.getHeaderColumnCount(),
            isGridColumn = c >= headerColumnCount,
            isShowRowNumbers = grid.isShowRowNumbers(),
            isHierarchyColumn = grid.isHierarchyColumn(c),

            isRowSelected = grid.isRowSelected(r),
            isColumnSelected = grid.isColumnSelected(c),
            isCellSelected = grid.isCellSelected(c, r),
            isCellSelectedInColumn = grid.isCellSelectedInColumn(c),
            isCellSelectedInRow = grid.isCellSelectedInRow(r),
            areAllRowsSelected = grid.areAllRowsSelected(),
            cellProperties;

        if ((isShowRowNumbers && c === -1) || isHierarchyColumn) {
            if (isRowSelected) {
                cellProperties = Object.create(baseProperties.rowHeaderRowSelection);
                cellProperties.isSelected = true;
            } else {
                cellProperties = Object.create(baseProperties.rowHeader);
                cellProperties.isSelected = isCellSelectedInRow;
            }
            cellProperties.isUserDataArea = false;
        } else if (isHeaderRow || isFooterRow) {
            if (isFilterRow) {
                cellProperties = Object.create(baseProperties.filterProperties);
                cellProperties.isSelected = false;
            } else if (isColumnSelected) {
                cellProperties = Object.create(baseProperties.columnHeaderColumnSelection);
                cellProperties.isSelected = true;
            } else {
                cellProperties = Object.create(baseProperties.columnHeader);
                cellProperties.isSelected = isCellSelectedInColumn;
            }
            cellProperties.isUserDataArea = false;
        } else if (isHierarchyColumn) {
            cellProperties = Object.create(baseProperties.rowHeader);
            cellProperties.isSelected = isCellSelectedInRow;
        } else {
            cellProperties = Object.create(baseProperties);
            cellProperties.isSelected = isCellSelected || isRowSelected || isColumnSelected;
            cellProperties.isUserDataArea = true;
        }

        var rowNum = r - headerRowCount + 1;

        if (c === -1) {
            if (r === 0) { // header row gets "master" checkbox
                cellProperties.value = [images.checkbox(areAllRowsSelected), '', null];
            } else if (isFilterRow) { // no checkbox but show filter icon
                cellProperties.value = [images.filter(false), '', null];
            } else if (isHeaderRow || isFooterRow) { // no checkbox on "totals" rows
                cellProperties.value = '';
            } else {
                cellProperties.value = [images.checkbox(isRowSelected), rowNum, null];
            }
            cellProperties.halign = 'right';
        } else {
            cellProperties.value = grid.getValue(c, r);
            cellProperties.halign = grid.getColumnAlignment(c);
        }

        cellProperties.isGridColumn = isGridColumn;
        cellProperties.isGridRow = isGridRow;
        cellProperties.isColumnHovered = grid.isColumnHovered(c) && isGridColumn;
        cellProperties.isRowHovered = grid.isRowHovered(r) && isGridRow;
        cellProperties.isCellHovered = grid.isHovered(c, r) && isGridColumn && isGridRow;
        cellProperties.bounds = this._getBoundsOfCell(c, r);
        cellProperties.isCellSelected = isCellSelected;
        cellProperties.isRowSelected = isRowSelected;
        cellProperties.isColumnSelected = isColumnSelected;
        cellProperties.isInCurrentSelectionRectangle = grid.isInCurrentSelectionRectangle(c, r);

        if (grid.mouseDownState) {
            var point = grid.mouseDownState.gridCell;
            cellProperties.mouseDown = point.x === c && point.y === r;
        }

        cellProperties.x = c;
        cellProperties.y = r;

        behavior.cellPropertiesPrePaintNotification(cellProperties);

        var cell = behavior.getCellRenderer(cellProperties, c, r);
        var column = behavior.getActiveColumn(c);

        //declarative cell properties
        if (isGridRow) {
            var overrides = behavior.getCellProperties(column.index, r);
            _(cellProperties).extendOwn(overrides);
        }

        //allow the renderer to identify itself if it's a button
        cellProperties.buttonCells = this.buttonCells;

        cellProperties.formatValue = grid.getFormatter(cellProperties.isUserDataArea && cellProperties.format);
        cell.paint(gc, cellProperties);

        this.renderedColumnMinWidths[c] = Math.max(cellProperties.minWidth || 0, this.renderedColumnMinWidths[c]);
        columnProperties.preferredWidth = this.renderedColumnMinWidths[c];
    },

    isViewableButton: function(c, r) {
        var key = c + ',' + r;
        return this.buttonCells[key] === true;
    },

    getRowNumbersWidth: function() {
        var colEdges = this.getColumnEdges();
        if (colEdges.length === 0) {
            return 0;
        }
        return colEdges[0];
    },

    startAnimator: function() {
        var self = this;
        requestAnimationFrame(function animate() {
            self.animate();
            requestAnimationFrame(animate);
        });
    },

    animate: function() {
        var ctx = this.getCanvas().canvasCTX;
        ctx.beginPath();
        ctx.save();
        this.renderLastSelection(ctx);
        ctx.restore();
        ctx.closePath();
    },

    getBounds: function() {
        return this.bounds;
    },

    setBounds: function(bounds) {
        return (this.bounds = bounds);
    }

});

function setNumberColumnWidth(gc, behavior, maxRow) {
    var columnProperties = behavior.getColumnProperties(-1),
        cellProperties = columnProperties.rowHeader,
        icon = images.checked;

    gc.font = cellProperties.font;

    columnProperties.preferredWidth = icon.width + 7 + cellProperties.getTextWidth(gc, maxRow + 1);
}

module.exports = Renderer;

},{"../../images":4,"./Base":110,"object-iterators":46}],113:[function(require,module,exports){
'use strict';

var RangeSelectionModel = require('sparse-boolean-array');

/**
 *
 * @constructor
 * @desc We represent selections as a list of rectangles because large areas can be represented and tested against quickly with a minimal amount of memory usage. Also we need to maintain the selection rectangles flattened counter parts so we can test for single dimension contains. This is how we know to highlight the fixed regions on the edges of the grid.
 */

function SelectionModel(grid) {

    this.grid = grid;

    /**
     * @name selections
     * @type {Rectangle[]}
     * @summary The selection rectangles.
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.selections = [];

    /**
     * @name flattenedX
     * @type {Rectangle[]}
     * @summary The selection rectangles flattened in the horizontal direction (no width).
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.flattenedX = [];

    /**
     * @name flattenedY
     * @type {Rectangle[]}
     * @summary The selection rectangles flattened in the vertical direction (no height).
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.flattenedY = [];

    /**
     * @name rowSelectionModel
     * @type {RangeSelectionModel}
     * @summary The selection rectangles.
     * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.rowSelectionModel = new RangeSelectionModel();

    /**
     * @name columnSelectionModel
     * @type {RangeSelectionModel}
     * @summary The selection rectangles.
     * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.columnSelectionModel = new RangeSelectionModel();

    this.setLastSelectionType('');
}

SelectionModel.prototype = {

    constructor: SelectionModel.prototype.constructor,

    /**
     * @type {boolean}
     * @memberOf SelectionModel.prototype
     */
    allRowsSelected: false,

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getLastSelection: function() {
        var sels = this.selections;
        var sel = sels[sels.length - 1];
        return sel;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getLastSelectionType: function() {
        return this.lastSelectionType;
    },

    /**
     * @param type
     * @memberOf SelectionModel.prototype
     */
    setLastSelectionType: function(type) {
        this.lastSelectionType = type;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @description Select the region described by the given coordinates.
     *
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     * @param {boolean} silent - whether to fire selection changed event
     */
    select: function(ox, oy, ex, ey, silent) {
        var newSelection = this.grid.newRectangle(ox, oy, ex, ey);
        newSelection.firstSelectedCell = this.grid.newPoint(ox, oy); //Cache the first selected cell before it gets normalized to top-left origin
        newSelection.lastSelectedCell = (
            (newSelection.firstSelectedCell.x === newSelection.origin.x && newSelection.firstSelectedCell.y === newSelection.origin.y)
            ?
                newSelection.corner
                :
                newSelection.origin
        );
        this.selections.push(newSelection);
        this.flattenedX.push(newSelection.flattenXAt(0));
        this.flattenedY.push(newSelection.flattenYAt(0));
        this.setLastSelectionType('cell');
        if (!silent) {this.grid.selectionChanged();}
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     */
    toggleSelect: function(ox, oy, ex, ey) {

        var selected, index;

        selected = this.selections.find(function(selection, idx) {
            index = idx;
            return (
                selection.origin.x === ox && selection.origin.y === oy &&
                selection.extent.x === ex && selection.extent.y === ey
            );
        });

        if (selected) {
            this.selections.splice(index, 1);
            this.flattenedX.splice(index, 1);
            this.flattenedY.splice(index, 1);
            this.grid.selectionChanged();
        } else {
            this.select(ox, oy, ex, ey);
        }
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc Remove the last selection that was created.
     */
    clearMostRecentSelection: function(dontClearRowSelections) {
        dontClearRowSelections = dontClearRowSelections === true;
        if (!dontClearRowSelections) {
            this.setAllRowsSelected(false);
        }
        if (this.selections.length) { --this.selections.length; }
        if (this.flattenedX.length) { --this.flattenedX.length; }
        if (this.flattenedY.length) { --this.flattenedY.length; }
        //this.getGrid().selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearMostRecentColumnSelection: function() {
        this.columnSelectionModel.clearMostRecentSelection();
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearMostRecentRowSelection: function() {
        this.rowSelectionModel.clearMostRecentSelection();
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearRowSelection: function() {
        this.rowSelectionModel.clear();
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getSelections: function() {
        return this.selections;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean} There are active selection(s).
     */
    hasSelections: function() {
        return this.selections.length !== 0;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    hasRowSelections: function() {
        return !this.rowSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    hasColumnSelections: function() {
        return !this.columnSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @return {boolean} Selection covers a specific column.
     * @param {number} y
     */
    isCellSelectedInRow: function(y) {
        return this._isCellSelected(this.flattenedX, 0, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns Selection covers a specific row.
     * @param {number} x
     */
    isCellSelectedInColumn: function(x) {
        return this._isCellSelected(this.flattenedY, x, 0);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @summary Selection query function.
     * @returns {boolean} The given cell is selected (part of an active selection).
     * @param {Rectangle[]} selections - Selection rectangles to search through.
     * @param {number} x
     * @param {number} y
     */
    isSelected: function(x, y) {
        return (
            this.isColumnSelected(x) ||
            this.isRowSelected(y) ||
            this._isCellSelected(this.selections, x, y)
        );
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isCellSelected: function(x, y) {
        return this._isCellSelected(this.selections, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param selections
     * @param x
     * @param y
     * @returns {boolean}
     * @private
     */
    _isCellSelected: function(selections, x, y) {
        var self = this;
        return !!selections.find(function(selection) {
            return self.rectangleContains(selection, x, y);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc empty out all our state
     *
     */
    clear: function(dontClearRowSelections) {
        dontClearRowSelections = dontClearRowSelections === true;
        this.selections.length = 0;
        this.flattenedX.length = 0;
        this.flattenedY.length = 0;
        this.columnSelectionModel.clear();
        if (!dontClearRowSelections) {
            this.setAllRowsSelected(false);
            this.rowSelectionModel.clear();
        }
        //this.getGrid().selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     * @returns {boolean}
     */
    isRectangleSelected: function(ox, oy, ex, ey) {
        return !!this.selections.find(function(selection) {
            return (
                selection.origin.x === ox && selection.origin.y === oy &&
                selection.extent.x === ex && selection.extent.y === ey
            );
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @returns {*}
     */
    isColumnSelected: function(x) {
        return this.columnSelectionModel.isSelected(x);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y
     * @returns {boolean|*}
     */
    isRowSelected: function(y) {
        return this.allRowsSelected || this.rowSelectionModel.isSelected(y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x1
     * @param x2
     */
    selectColumn: function(x1, x2) {
        this.columnSelectionModel.select(x1, x2);
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    selectAllRows: function() {
        this.clear();
        this.setAllRowsSelected(true);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */

    setAllRowsSelected: function(isIt) {
        this.allRowsSelected = isIt;
    },

    areAllRowsSelected: function() {
        return this.allRowsSelected;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y1
     * @param y2
     */
    selectRow: function(y1, y2) {
        this.rowSelectionModel.select(y1, y2);
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x1
     * @param x2
     */
    deselectColumn: function(x1, x2) {
        this.columnSelectionModel.deselect(x1, x2);
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y1
     * @param y2
     */
    deselectRow: function(y1, y2) {
        this.rowSelectionModel.deselect(y1, y2);
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getSelectedRows: function() {
        if (this.areAllRowsSelected()) {
            var headerRows = this.grid.getHeaderRowCount();
            var rowCount = this.grid.getRowCount() - headerRows;
            var result = new Array(rowCount);
            for (var i = 0; i < rowCount; i++) {
                result[i] = i + headerRows;
            }
            return result;
        }
        return this.rowSelectionModel.getSelections();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*|Array.Array.number}
     */
    getSelectedColumns: function() {
        return this.columnSelectionModel.getSelections();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
     isColumnOrRowSelected: function() {
        return !this.columnSelectionModel.isEmpty() || !this.rowSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {Array}
     */
    getFlattenedYs: function() {
        var result = [];
        var set = {};
        this.selections.forEach(function(selection) {
            var top = selection.origin.y;
            var size = selection.extent.y + 1;
            for (var r = 0; r < size; r++) {
                var ti = r + top;
                if (!set[ti]) {
                    result.push(ti);
                    set[ti] = true;
                }
            }
        });
        result.sort(function(x, y) {
            return x - y;
        });
        return result;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param offset
     */
    selectRowsFromCells: function(offset, dontClearRowSelections) {
        offset = offset || 0;
        dontClearRowSelections = dontClearRowSelections === true;

        var sm = this.rowSelectionModel;

        if (!dontClearRowSelections) {
            this.setAllRowsSelected(false);
            sm.clear();
        }

        this.selections.forEach(function(selection) {
            var top = selection.origin.y,
                extent = selection.extent.y;
            top += offset;
            sm.select(top, top + extent);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param offset
     */
    selectColumnsFromCells: function(offset) {
        offset = offset || 0;

        var sm = this.columnSelectionModel;
        sm.clear();

        this.selections.forEach(function(selection) {
            var left = selection.origin.x,
                extent = selection.extent.x;
            left += offset;
            sm.select(left, left + extent);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isInCurrentSelectionRectangle: function(x, y) {
        var last = this.selections[this.selections.length - 1];
        return last && this.rectangleContains(last, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param rect
     * @param x
     * @param y
     * @returns {boolean}
     */
    rectangleContains: function(rect, x, y) { //TODO: explore why this works and contains on rectanglular does not
        var minX = rect.origin.x;
        var minY = rect.origin.y;
        var maxX = minX + rect.extent.x;
        var maxY = minY + rect.extent.y;

        if (rect.extent.x < 0) {
            minX = maxX;
            maxX = rect.origin.x;
        }

        if (rect.extent.y < 0) {
            minY = maxY;
            maxY = rect.origin.y;
        }

        var result =
            x >= minX &&
            y >= minY &&
            x <= maxX &&
            y <= maxY;

        return result;
    }
};

module.exports = SelectionModel;

},{"sparse-boolean-array":50}],114:[function(require,module,exports){
/* eslint-env browser */

'use strict';

/**
 *
 * @param {HTMLElement} [containingEl=document]
 * @param {string} [prefix='']
 * @param {string} [separator='']
 * @param {string} [suffix='']
 * @param {function} [transformer=multiLineTrim] - Function to transform each input control's text value.
 */
function copyAll(containingEl, prefix, separator, suffix, transformer) {
    var texts = [], lastTextEl, text;

    Array.prototype.forEach.call((containingEl || document).querySelectorAll(copyAll.selector), function(textEl) {
        text = (transformer || multiLineTrim)(textEl.value);
        if (text) { texts.push(text); }
        lastTextEl = textEl;
    });

    if (lastTextEl) {
        copy(lastTextEl, (prefix || '') + texts.join(separator || '') + (suffix || ''));
    }
}

/**
 * 1. Trim the text in the given input element
 * 2. select it
 * 3. copy it to the clipboard
 * 4. deselect it
 * 5. return it
 * @param {HTMLElement|HTMLTextAreaElement} el
 * @param {string} [text=el.value] - Text to copy.
 * @returns {undefined|string} Trimmed text in element or undefined if unable to copy.
 */
function copy(el, text) {
    var result, textWas;

    if (text) {
        textWas = el.value;
        el.value = text;
    } else {
        text = el.value;
    }

    el.value = multiLineTrim(text);

    try {
        el.select();
        result = document.execCommand('copy');
    } catch (err) {
        result = false;
    } finally {
        if (textWas !== undefined) {
            el.value = textWas;
        }
        el.blur();
    }
    return result;
}

function multiLineTrim(s) {
    return s.replace(/^\s*(.*?)\s*$/, '$1');
}

copy.all = copyAll;
copy.multiLineTrim = multiLineTrim;
copy.selectorTextControls = 'input:not([type]), input[type=text], textarea';

module.exports = copy;

},{}],115:[function(require,module,exports){
'use strict';

// console.warn polyfill as needed
// used for deprecation warnings
if (!console.warn) {
    console.warn = function() {
        console.log.apply(console, ['WARNING:'].concat(Array.prototype.slice.call(arguments)));
    };
}

var warned = {};

var regexIsMethod = /\)$/;

/**
 * User is warned and new property is returned or new method is called and the result is returned.
 * @param {string} methodName - Deprecated method name with parentheses (required) containing argument list (optional).
 * @param {string} dotProps - Dot-separated new property name to invoke or method name to call. Method names are indicated by including parentheses with optional argument list. The arguments in each list are drawn from the arguments presented in the `methodName` parameter.
 * @param {string} since - Version in which the name was deprecated.
 * @param {Arguments|Array} [args] - Actual arguments. Only needed when arguments are listed in `methodName`. The order of the arguments must match.
 * @param {string} [notes] - Notes to add to message.
 * @returns {*} Return value of new property or method call.
 */
var deprecated = function(methodName, dotProps, since, args, notes) {
    if (!regexIsMethod.test(methodName)) {
        throw 'Expected method name to have parentheses.';
    }

    if (typeof args === 'string') {
        // `args` omitted
        notes = args;
        args = undefined;
    }

    var chain = dotProps.split('.'),
        formalArgList = argList(methodName),
        result = this;

    if (!(methodName in warned)) {
        warned[methodName] = deprecated.warnings;
    }
    if (warned[methodName]) {
        var memberType = regexIsMethod.test(dotProps) ? 'method' : 'property';
        var warning = 'The .' + methodName + '() method is deprecated as of v' + since +
            ' in favor of the .' + chain.join('.') + ' ' + memberType + '.' +
            ' (Will be removed in a future release.)';

        if (notes) {
            warning += ' ' + notes;
        }

        console.warn(warning);

        --warned[methodName];
    }

    function mapToFormalArg(argName) {
        var index = formalArgList.indexOf(argName);
        if (index === -1) {
            throw 'Actual arg "' + argName + '" not found in formal arg list ' + formalArgList;
        }
        return args[index];
    }

    for (var i = 0, last = chain.length - 1; i <= last; ++i) {
        var link = chain[i],
            actualArgList = regexIsMethod.test(link) ? argList(link) : undefined,
            actualArgs = [];

        if (actualArgList) {
            actualArgs = actualArgList.map(mapToFormalArg);
            link = link.match(/(\w+)/)[1];
            result = result[link].apply(result, actualArgs);
        } else {
            result = result[link];
        }
    }

    return result;
};

deprecated.warnings = 5; // just enough to be annoying

function argList(s) {
    return s.match(/^\w+\((.*)\)$/)[1].match(/(\w+)/g);
}

module.exports = deprecated;

},{}],116:[function(require,module,exports){
/* eslint-env browser */

/** @module effects */

/** @typedef {function} effectFunction
 * @desc Element to perform transitions upon is `options.el` if defined or `this.el`.
 * @param {object} [options]
 * @param {HTMLElement} [options.el=this.el]
 * @param {function} [options.callback] Function to call at conclusion of transitions.
 * @param {string} [options.duration='0.065s'] - Duration of each transition.
 * @param {object} [options.styles=defaultGlowerStyles] - Hash of CSS styles and values to transition. (For {@link effects~glower|glower} only.
 */

'use strict';

/**
 * Shake element back and fourth a few times as if to say, "Nope!"
 * @type {effectFunction}
 * @memberOf module:effects
 */
exports.shaker = function(options) {
    options = options || {};
    var context = this,
        el = options.el || context.el,
        duration = options.duration || '0.065s',
        computedStyle = window.getComputedStyle(el),
        transitions = computedStyle.transition.split(','),
        position = computedStyle.position,
        x = parseInt(computedStyle.left),
        dx = -3,
        shakes = 6;

    transitions.push('left ' + duration);
    el.style.transition = transitions.join(',');
    el.addEventListener('transitionend', shaker);
    shaker();
    function shaker(event) {
        if (!event || event.propertyName === 'left') {
            el.style.left = x + dx + 'px';
            if (!shakes--) {
                el.removeEventListener('transitionend', shaker);
                transitions.pop();
                el.style.transition = transitions.join(',');
                el.style.position = position;
                if (options.callback) {
                    options.callback.call(context, options);
                }
            }
            dx = shakes ? -dx : 0;
        }
    }
};

var defaultGlowerStyles = {
    'background-color': 'yellow',
    'box-shadow': '0 0 10px red'
};

/**
 * Transition styles on element for a moment and revert as if to say, "Whoa!."
 * @type {effectFunction}
 * @memberOf module:effects
 */
exports.glower = function(options) {
    options = options || {};
    var context = this,
        el = options.el || context.el,
        duration = options.duration || '0.25s',
        styles = options.styles || defaultGlowerStyles,
        values = styles.length,
        computedStyle = window.getComputedStyle(el),
        styleWas = {},
        transition = computedStyle.transition,
        transitions = transition.split(',');

    Object.keys(styles).forEach(function(style) {
        styleWas[style] = {
            style: computedStyle[style],
            undo: true
        };
        transitions.push(style + ' ' + duration);
    });

    el.style.transition = transitions.join(',');
    el.addEventListener('transitionend', glower);
    Object.keys(styles).forEach(function(style) {
        el.style[style] = styles[style];
    });

    function glower(event) {
        var was = styleWas[event.propertyName];
        if (was.undo) {
            el.style[event.propertyName] = was.style;
            was.undo = false;
        } else if (!--values) {
            el.removeEventListener('transitionend', glower);
            el.style.transition = transition;
            if (options.callback) {
                options.callback.call(context, options);
            }
        }
    }
};

},{}],117:[function(require,module,exports){
/* eslint-env browser */

'use strict';

module.exports.each = function(selector, iteratee, context) {
    return Array.prototype.forEach.call((context || document).querySelectorAll(selector), iteratee);
};

module.exports.find = function(selector, iteratee, context) {
    return Array.prototype.find.call((context || document).querySelectorAll(selector), iteratee);
};

},{}],118:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var HTTP_STATE_DONE = 4,
    HTTP_STATUS_OK = 200;

module.exports.get = function(url, callback) {
    var httpRequest = new XMLHttpRequest();

    httpRequest.open('GET', url, true);

    httpRequest.onreadystatechange = function() {
        if (
            httpRequest.readyState === HTTP_STATE_DONE &&
            httpRequest.status === HTTP_STATUS_OK
        ) {
            callback(JSON.parse(httpRequest.responseText));
        }
    };

    httpRequest.send(null);
};

},{}],119:[function(require,module,exports){
'use strict';

Math.sign = Math.sign || function(x) {
    x = +x; // convert to a number
    if (x === 0 || isNaN(x)) {
        return x;
    }
    return x > 0 ? 1 : -1;
};

},{}],120:[function(require,module,exports){
'use strict';

function Queueless(element, context) {
    this.element = element;
    this.context = context;
    this.transitioning = false;
}

Queueless.prototype.begin = function(callback) {
    var self = this;

    this.transitioning = true;

    this.element.addEventListener('transitionend', function end(transEvent) {
        self.element.removeEventListener('transitionend', end);

        if (callback) {
            callback.call(this, transEvent, self);
        }

        self.transitioning = false;
    });
};

module.exports = Queueless;

},{}],121:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var automat = require('automat');

var css = require('../../css');

// note the position of the  first "natural" stylesheet. We will insert our stylesheets before this node.
var head = document.querySelector('head');
var refNode = Array.prototype.slice.call(head.children).find(function(child) {
    return child.tagName === 'STYLE' ||
        child.tagName === 'LINK' &&
        child.getAttribute('rel') === 'stylesheet' &&
        child.getAttribute('type') === 'text/css';
});

exports.prefix = 'injected-stylesheet-';

exports.inject = function(id, replacements) {
    var stylesheet = document.querySelector('#' + this.prefix + id);

    if (!stylesheet) {
        stylesheet = css[id];
        stylesheet = '<style>\n' + stylesheet + '\n</style>\n';
        var args = [stylesheet, head, refNode].concat(Array.prototype.slice.call(arguments, 1));
        stylesheet = automat.append.apply(null, args)[0];
        stylesheet.id = this.prefix + id;
    }

    return stylesheet;
};

},{"../../css":1,"automat":5}]},{},[89])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvY3NzL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9odG1sL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9pbWFnZXMvaW1hZ2VzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9pbWFnZXMvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9hdXRvbWF0L2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvY3NzLWluamVjdG9yL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZXh0ZW5kLW1lL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmlsdGVyLXRyZWUvaHRtbC9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbHRlci10cmVlL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmlsdGVyLXRyZWUvanMvQ29uZGl0aW9uYWxzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmlsdGVyLXRyZWUvanMvRmlsdGVyTGVhZi5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbHRlci10cmVlL2pzL0ZpbHRlck5vZGUuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maWx0ZXItdHJlZS9qcy9GaWx0ZXJUcmVlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmlsdGVyLXRyZWUvanMvVGVtcGxhdGVzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmlsdGVyLXRyZWUvanMvZXh0ZW5zaW9ucy9jb2x1bW5zLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmlsdGVyLXRyZWUvanMvcGFyc2VyLVNRTC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbHRlci10cmVlL2pzL3N0eWxlc2hlZXQuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maWx0ZXItdHJlZS9qcy90cmVlLW9wZXJhdG9ycy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbmJhcnMvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maW5jYW52YXMvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maW5jYW52YXMvanMvR3JhcGhpY3NDb250ZXh0LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmluY2FudmFzL2pzL2djLWNvbnNvbGUtbG9nZ2VyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmluY2FudmFzL2pzL3BvbHltZXJnZXN0dXJlcy5kZXYuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvZ2VuZXJhdGVTYW1wbGVEYXRhLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0Jhc2UuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YU5vZGVCYXNlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0RhdGFOb2RlR3JvdXAuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YU5vZGVHcm91cFNvcnRlci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhTm9kZUxlYWYuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YU5vZGVUcmVlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0RhdGFTb3VyY2UuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YVNvdXJjZUFnZ3JlZ2F0b3IuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YVNvdXJjZUdsb2JhbEZpbHRlci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhU291cmNlSW5kZXhlZC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhU291cmNlU29ydGVyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0RhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YVNvdXJjZVRyZWV2aWV3LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL3V0aWwvTWFwcHkuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvdXRpbC9hZ2dyZWdhdGlvbnMuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvdXRpbC9oZWFkZXJpZnkuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvdXRpbC9zdGFibGVTb3J0LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvbGlzdC1kcmFnb24vaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvbGliL2xydS1jYWNoZS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL211c3RhY2hlL211c3RhY2hlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvb2JqZWN0LWl0ZXJhdG9ycy9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL3BvcC1tZW51L2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvcmVjdGFuZ3VsYXIvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9yZWdleHAtbGlrZS9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL3NwYXJzZS1ib29sZWFuLWFycmF5L2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvdGFiei9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL3RlbXBsZXgvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy91bnN0cnVuZ2lmeS9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL0h5cGVyZ3JpZC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL1NoYXJlZC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9CZWhhdmlvci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9Db2x1bW4uanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9iZWhhdmlvcnMvSlNPTi5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9Mb2NhbC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9OdWxsLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvQ2VsbEVkaXRvci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxFZGl0b3JzL0NvbG9yLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvQ29tYm9Cb3guanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9EYXRlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvRmlsdGVyQm94LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvTnVtYmVyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvU2xpZGVyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvU3Bpbm5lci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxFZGl0b3JzL1RleHRmaWVsZC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxFZGl0b3JzL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9CdXR0b24uanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9jZWxsUmVuZGVyZXJzL0NlbGxSZW5kZXJlci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxSZW5kZXJlcnMvRXJyb3JDZWxsLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9MYXN0U2VsZWN0aW9uLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9TaW1wbGVDZWxsLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9TbGlkZXJDZWxsLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9TcGFya0Jhci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxSZW5kZXJlcnMvU3BhcmtMaW5lLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9UcmVlQ2VsbC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxSZW5kZXJlcnMvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9kYXRhTW9kZWxzL0RhdGFNb2RlbC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2RhdGFNb2RlbHMvSlNPTi5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2RlZmF1bHRzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZGlhbG9ncy9Db2x1bW5QaWNrZXIuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9kaWFsb2dzL0RpYWxvZy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2RpYWxvZ3MvTWFuYWdlRmlsdGVycy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2RpYWxvZ3MvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mYWtlXzNkOWI4NWZlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvQ2VsbENsaWNrLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvQ2VsbEVkaXRpbmcuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9DZWxsU2VsZWN0aW9uLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvQ29sdW1uQXV0b3NpemluZy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NvbHVtbk1vdmluZy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NvbHVtblBpY2tlci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NvbHVtblJlc2l6aW5nLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvQ29sdW1uU2VsZWN0aW9uLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvQ29sdW1uU29ydGluZy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0ZlYXR1cmUuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9GaWx0ZXJzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvS2V5UGFnaW5nLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvT25Ib3Zlci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL1Jvd1Jlc2l6aW5nLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvUm93U2VsZWN0aW9uLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvVGh1bWJ3aGVlbFNjcm9sbGluZy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmlsdGVyL0NvbHVtblNjaGVtYUZhY3RvcnkuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9maWx0ZXIvRGVmYXVsdEZpbHRlci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZpbHRlci9wYXJzZXItQ1FMLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvbGliL0Jhc2UuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9saWIvTG9jYWxpemF0aW9uLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvbGliL1JlbmRlcmVyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvbGliL1NlbGVjdGlvbk1vZGVsLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvbGliL2NvcHktaW5wdXQuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9saWIvZGVwcmVjYXRlZC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9lZmZlY3RzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvbGliL2VsZm9yLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvbGliL2pzb24uanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9saWIvcG9seWZpbGxzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvbGliL3F1ZXVlbGVzcy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9zdHlsZXNoZWV0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2plQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMveEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbDFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbllBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25uQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdDVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2b0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5ncmlkID0gW1xuJy5oeXBlcmdyaWQtaW5wdXQgeycsXG4nXHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdGRpc3BsYXk6IG5vbmU7JyxcbidcdG91dGxpbmU6IDA7JyxcbidcdHBhZGRpbmc6IDA7JyxcbidcdGJvcmRlcjogc29saWQgMnB4IGJsYWNrOycsXG4nXHRib3gtc2l6aW5nOiBib3JkZXItYm94OycsXG4nXHRib3gtc2hhZG93OiB3aGl0ZSAwIDAgMXB4IDFweDsnLFxuJ1x0YmFja2dyb3VuZC1jb2xvcjogaXZvcnk7JyxcbidcdGNvbG9yOiBibGFjazsnLFxuJ1x0Zm9udC1zaXplOiA3cHQ7JyxcbidcdGxpbmUtLWhlaWdodDogMDsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtaW5wdXQgPiBpbnB1dCB7JyxcbidcdHBvc2l0aW9uOiBhYnNvbHV0ZTsnLFxuJ1x0aGVpZ2h0OiAxMDAlOycsXG4nXHRyaWdodDogMjBweDsnLFxuJ1x0bGVmdDogMDsnLFxuJ1x0d2lkdGg6IDEwMCU7JyxcbidcdG91dGxpbmU6IDA7JyxcbidcdHBhZGRpbmc6IDA7JyxcbicnLFxuJ1x0Ym9yZGVyOiA1cHggc29saWQgdHJhbnNwYXJlbnQ7JyxcbidcdGJvcmRlci1yaWdodC13aWR0aDogMjBweDsnLFxuJ1x0Ym9yZGVyLWJvdHRvbS13aWR0aDogMDsnLFxuJ1x0Ym9yZGVyLXRvcC13aWR0aDogMDsnLFxuJ1x0Ym94LXNpemluZzogYm9yZGVyLWJveDsnLFxuJycsXG4nXHRmb250LXNpemU6IDdwdDsnLFxuJ1x0bGluZS0taGVpZ2h0OiAwOycsXG4nXHRjb2xvcjogYmxhY2s7JyxcbidcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1pbnB1dCA+IHNwYW4geycsXG4nXHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7JyxcbidcdHdpZHRoOiAyMHB4OycsXG4nXHRoZWlnaHQ6IDEwMCU7JyxcbidcdHJpZ2h0OiAwOycsXG4nXHR0ZXh0LWFsaWduOiBjZW50ZXI7JyxcbidcdGZvbnQtc2l6ZTogMTVweDsnLFxuJ1x0bGluZS1oZWlnaHQ6IDExcHg7Jyxcbid9JyxcbidkaXYuaHlwZXJncmlkLWlucHV0IHNwYW5bdGl0bGVdIHsnLFxuJ1x0Y29sb3I6IGxpZ2h0Z3JleTsnLFxuJ1x0Y3Vyc29yOiBwb2ludGVyOycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1pbnB1dCBzcGFuW3RpdGxlXTpob3ZlciB7JyxcbidcdGNvbG9yOiBncmV5OycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1pbnB1dCBzcGFuW3RpdGxlXTphY3RpdmUsIGRpdi5oeXBlcmdyaWQtaW5wdXQgc3Bhblt0aXRsZV0uYWN0aXZlIHsnLFxuJ1x0Y29sb3I6IGJsdWU7Jyxcbid9JyxcbidkaXYuaHlwZXJncmlkLWlucHV0ID4gc3Bhbjo6YWZ0ZXIgeycsXG4nXHRjb250ZW50OiBcXCdcXFxcMjVCRVxcJzsnLFxuJ1x0Zm9udC1zaXplOiAyMHB4OycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1pbnB1dCA+IGRpdiB7JyxcbidcdHBvc2l0aW9uOiBhYnNvbHV0ZTsnLFxuJ1x0aGVpZ2h0OiAxMzdweDsnLFxuJ1x0bGVmdDogLTJweDsnLFxuJ1x0cmlnaHQ6IC0ycHg7JyxcbidcdHRvcDogMTNweDsnLFxuJ1x0aGVpZ2h0OiAwOycsXG4nXHR0cmFuc2l0aW9uOiBoZWlnaHQgLjI1czsnLFxuJ1x0dmlzaWJpbGl0eTogaGlkZGVuOycsXG4nXHRib3gtc2hhZG93OiB3aGl0ZSAwIDAgMXB4IDFweDsnLFxuJ1x0Ym94LXNpemluZzogYm9yZGVyLWJveDsnLFxuJ1x0Ym9yZGVyOiAycHggc29saWQgYmxhY2s7JyxcbidcdGJhY2tncm91bmQtY29sb3I6IGl2b3J5OycsXG4nXHQtd2Via2l0LXVzZXItc2VsZWN0OiBub25lOycsXG4nXHQtbW96LXVzZXItc2VsZWN0OiBub25lOycsXG4nXHQtbXMtdXNlci1zZWxlY3Q6IG5vbmU7Jyxcbid9JyxcbidkaXYuaHlwZXJncmlkLWlucHV0ID4gZGl2ID4gZGl2IHsnLFxuJ1x0cG9zaXRpb246IGFic29sdXRlOycsXG4nXHRoZWlnaHQ6IDEzcHg7JyxcbidcdHdpZHRoOiAxMDAlOycsXG4nXHR0ZXh0LWFsaWduOiBjZW50ZXI7Jyxcbid9JyxcbidkaXYuaHlwZXJncmlkLWlucHV0ID4gZGl2IHNwYW5bdGl0bGVdIHsnLFxuJ1x0Zm9udC13ZWlnaHQ6IGJvbGQ7JyxcbidcdGZvbnQtc2l6ZTogMTBweDsnLFxuJ1x0Zm9udC1mYW1pbHk6IHZlcmRhbmEsIGdlbmV2YSwgc2Fucy1zZXJpZjsnLFxuJ1x0bWFyZ2luLWxlZnQ6IDZweDsnLFxuJ1x0bWFyZ2luLXJpZ2h0OiA2cHg7Jyxcbid9JyxcbidkaXYuaHlwZXJncmlkLWlucHV0ID4gZGl2IHNwYW46bm90KFt0aXRsZV0pIHsnLFxuJ1x0Zm9udC1zdHlsZTogaXRhbGljOycsXG4nXHRwYWRkaW5nLXRvcDogMXB4OycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1pbnB1dCA+IGRpdiBzZWxlY3QgeycsXG4nXHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdGJvcmRlcjogMDsnLFxuJ1x0b3V0bGluZTogMDsnLFxuJ1x0Ym9yZGVyLXRvcDogMnB4IHNvbGlkIGJsYWNrOycsXG4nXHR3aWR0aDogMTAwJTsnLFxuJ1x0Ym90dG9tOiAwOycsXG4nXHR0b3A6MTRweDsnLFxuJ1x0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7Jyxcbid9J1xuXS5qb2luKCdcXG4nKTtcblxuZXhwb3J0c1snbGlzdC1kcmFnb24tYWRkZW5kdW0nXSA9IFtcbidkaXYuZHJhZ29uLWxpc3QsIGxpLmRyYWdvbi1wb3AgeycsXG4nXHRmb250LWZhbWlseTogUm9ib3RvLCBzYW5zLXNlcmlmOycsXG4nXHR0ZXh0LXRyYW5zZm9ybTogY2FwaXRhbGl6ZTsgfScsXG4nZGl2LmRyYWdvbi1saXN0IHsnLFxuJ1x0cG9zaXRpb246IGFic29sdXRlOycsXG4nXHR0b3A6IDQlOycsXG4nXHRsZWZ0OiA0JTsnLFxuJ1x0aGVpZ2h0OiA5MiU7JyxcbidcdHdpZHRoOiAyMCU7IH0nLFxuJ2Rpdi5kcmFnb24tbGlzdDpudGgtY2hpbGQoMikgeyBsZWZ0OiAyOCU7IH0nLFxuJ2Rpdi5kcmFnb24tbGlzdDpudGgtY2hpbGQoMykgeyBsZWZ0OiA1MiU7IH0nLFxuJ2Rpdi5kcmFnb24tbGlzdDpudGgtY2hpbGQoNCkgeyBsZWZ0OiA3NiU7IH0nLFxuJ2Rpdi5kcmFnb24tbGlzdCA+IGRpdiwgZGl2LmRyYWdvbi1saXN0ID4gdWwgPiBsaSwgbGkuZHJhZ29uLXBvcCB7IGxpbmUtaGVpZ2h0OiA0NnB4OyB9JyxcbidkaXYuZHJhZ29uLWxpc3QgPiB1bCB7IHRvcDogNDZweDsgfScsXG4nZGl2LmRyYWdvbi1saXN0ID4gdWwgPiBsaTpub3QoOmxhc3QtY2hpbGQpOjpiZWZvcmUsIGxpLmRyYWdvbi1wb3A6OmJlZm9yZSB7JyxcbidcdGNvbnRlbnQ6IFxcJ1xcXFwyYjI0XFwnOycsXG4nXHRjb2xvcjogI2I2YjZiNjsnLFxuJ1x0Zm9udC1zaXplOiAzMHB4OycsXG4nXHRtYXJnaW46IDhweCAxNHB4IDhweCA4cHg7IH0nLFxuJ2xpLmRyYWdvbi1wb3AgeyBvcGFjaXR5Oi44OyB9J1xuXS5qb2luKCdcXG4nKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5DUUwgPSBbXG4nPGxpPicsXG4nXHQ8bGFiZWwgdGl0bGU9XCIkezF9XCI+JyxcbidcdFx0PGEgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiZmlsdGVyLWNvcHlcIj48L2E+JyxcbidcdFx0PGRpdiBjbGFzcz1cImZpbHRlci10cmVlLXJlbW92ZS1idXR0b25cIiB0aXRsZT1cImRlbGV0ZSBjb25kaXRpb25hbFwiPjwvZGl2PicsXG4nXHRcdDxzdHJvbmc+JXswfTo8L3N0cm9uZz4nLFxuJ1x0XHQ8aW5wdXQgbmFtZT1cIiR7MX1cIiBjbGFzcz1cImZpbHRlci10ZXh0LWJveCAkezN9XCIgdmFsdWU9XCIlezJ9XCI+JyxcbidcdDwvbGFiZWw+JyxcbidcdDxkaXYgY2xhc3M9XCJmaWx0ZXItdHJlZS13YXJuXCI+PC9kaXY+Jyxcbic8L2xpPidcbl0uam9pbignXFxuJyk7XG5cbmV4cG9ydHMuU1FMID0gW1xuJzxsaT4nLFxuJ1x0PGxhYmVsIHRpdGxlPVwiJHsxfVwiPicsXG4nXHRcdDxhIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImZpbHRlci1jb3B5XCI+PC9hPicsXG4nXHRcdDxkaXYgY2xhc3M9XCJmaWx0ZXItdHJlZS1yZW1vdmUtYnV0dG9uXCIgdGl0bGU9XCJkZWxldGUgY29uZGl0aW9uYWxcIj48L2Rpdj4nLFxuJ1x0XHQ8c3Ryb25nPiV7MH06PC9zdHJvbmc+JyxcbidcdFx0PHRleHRhcmVhIG5hbWU9XCIkezF9XCIgcm93cz1cIjFcIiBjbGFzcz1cImZpbHRlci10ZXh0LWJveCAkezN9XCI+JXsyfTwvdGV4dGFyZWE+JyxcbidcdDwvbGFiZWw+JyxcbidcdDxkaXYgY2xhc3M9XCJmaWx0ZXItdHJlZS13YXJuXCI+PC9kaXY+Jyxcbic8L2xpPidcbl0uam9pbignXFxuJyk7XG5cbmV4cG9ydHMuZGlhbG9nID0gW1xuJzxkaXYgaWQ9XCJoeXBlcmdyaWQtZGlhbG9nXCI+JyxcbicnLFxuJ1x0PHN0eWxlPicsXG4nXHRcdCNoeXBlcmdyaWQtZGlhbG9nIHsnLFxuJ1x0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTsnLFxuJ1x0XHRcdHRvcDogMDsnLFxuJ1x0XHRcdGxlZnQ6IDA7JyxcbidcdFx0XHRib3R0b206IDA7JyxcbidcdFx0XHRyaWdodDogMDsnLFxuJ1x0XHRcdGJhY2tncm91bmQtY29sb3I6IHdoaXRlOycsXG4nXHRcdFx0Zm9udDogMTBwdCBzYW5zLXNlcmlmOycsXG4nXHRcdFx0b3BhY2l0eTogMDsnLFxuJ1x0XHRcdHRyYW5zaXRpb246IG9wYWNpdHkgMXM7JyxcbidcdFx0XHRib3gtc2hhZG93OiByZ2JhKDAsIDAsIDAsIDAuMjk4MDM5KSAwcHggMTlweCAzOHB4LCByZ2JhKDAsIDAsIDAsIDAuMjE5NjA4KSAwcHggMTVweCAxMnB4OycsXG4nXHRcdH0nLFxuJ1x0XHQjaHlwZXJncmlkLWRpYWxvZy5oeXBlcmdyaWQtZGlhbG9nLXZpc2libGUgeycsXG4nXHRcdFx0b3BhY2l0eTogMTsnLFxuJ1x0XHRcdHRyYW5zaXRpb246IG9wYWNpdHkgMXM7JyxcbidcdFx0fScsXG4nJyxcbidcdFx0I2h5cGVyZ3JpZC1kaWFsb2cgLmh5cGVyZ3JpZC1kaWFsb2ctY29udHJvbC1wYW5lbCB7JyxcbidcdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdFx0XHR0b3A6IDBweDsnLFxuJ1x0XHRcdHJpZ2h0OiAxMnB4OycsXG4nXHRcdH0nLFxuJ1x0XHQjaHlwZXJncmlkLWRpYWxvZyAuaHlwZXJncmlkLWRpYWxvZy1jb250cm9sLXBhbmVsIGEgeycsXG4nXHRcdFx0Y29sb3I6ICM5OTk7JyxcbidcdFx0XHRmb250LXNpemU6IDMzcHg7JyxcbidcdFx0XHR0cmFuc2l0aW9uOiB0ZXh0LXNoYWRvdyAuMzVzLCBjb2xvciAuMzVzOycsXG4nXHRcdFx0dGV4dC1kZWNvcmF0aW9uOiBub25lOycsXG4nXHRcdH0nLFxuJ1x0XHQjaHlwZXJncmlkLWRpYWxvZyAuaHlwZXJncmlkLWRpYWxvZy1jbG9zZTphZnRlciB7JyxcbidcdFx0XHRjb250ZW50OiBcXCdcXFxcRDdcXCc7JyxcbidcdFx0fScsXG4nXHRcdCNoeXBlcmdyaWQtZGlhbG9nIC5oeXBlcmdyaWQtZGlhbG9nLXNldHRpbmdzOmFmdGVyIHsnLFxuJ1x0XHRcdGZvbnQtZmFtaWx5OiBBcHBsZSBTeW1ib2xzOycsXG4nXHRcdFx0Y29udGVudDogXFwnXFxcXDI2OTlcXCc7JyxcbidcdFx0fScsXG4nXHRcdCNoeXBlcmdyaWQtZGlhbG9nIC5oeXBlcmdyaWQtZGlhbG9nLWNvbnRyb2wtcGFuZWwgYTpob3ZlciB7JyxcbidcdFx0XHRjb2xvcjogYmxhY2s7JyxcbidcdFx0XHR0ZXh0LXNoYWRvdzogMCAwIDZweCAjMzM3YWI3OycsXG4nXHRcdFx0dHJhbnNpdGlvbjogdGV4dC1zaGFkb3cgLjM1cywgY29sb3IgLjM1czsnLFxuJ1x0XHR9JyxcbidcdFx0I2h5cGVyZ3JpZC1kaWFsb2cgLmh5cGVyZ3JpZC1kaWFsb2ctY29udHJvbC1wYW5lbCBhOmFjdGl2ZSB7JyxcbidcdFx0XHRjb2xvcjogI2QwMDsnLFxuJ1x0XHRcdHRyYW5zaXRpb246IGNvbG9yIDBzOycsXG4nXHRcdH0nLFxuJ1x0PC9zdHlsZT4nLFxuJycsXG4nXHQ8c3BhbiBjbGFzcz1cImh5cGVyZ3JpZC1kaWFsb2ctY29udHJvbC1wYW5lbFwiPicsXG4nXHRcdDxhIGNsYXNzPVwiaHlwZXJncmlkLWRpYWxvZy1zZXR0aW5nc1wiIHRpdGxlPVwiKFRoZXJlIGFyZSBubyBzZXR0aW5ncyBmb3IgTWFuYWdlIEZpbHRlcnMgYXQgdGhpcyB0aW1lLilcIj48L2E+JyxcbidcdFx0PGEgY2xhc3M9XCJoeXBlcmdyaWQtZGlhbG9nLWNsb3NlXCI+PC9hPicsXG4nXHQ8L3NwYW4+JyxcbicnLFxuJzwvZGl2Pidcbl0uam9pbignXFxuJyk7XG5cbmV4cG9ydHMuZmlsdGVyVHJlZXMgPSBbXG4nPHN0eWxlPicsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyA+IGRpdiB7JyxcbidcdFx0cG9zaXRpb246IGFic29sdXRlOycsXG4nXHRcdHRvcDogMDsnLFxuJ1x0XHRsZWZ0OiAwOycsXG4nXHRcdGJvdHRvbTogMDsnLFxuJ1x0XHRyaWdodDogMDsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyA+IGRpdjpmaXJzdC1vZi10eXBlIHsnLFxuJ1x0XHRwYWRkaW5nOiAxZW0gMWVtIDFlbSAwLjVlbTsnLFxuJ1x0XHRtYXJnaW4tbGVmdDogNTAlOycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nID4gZGl2Omxhc3Qtb2YtdHlwZSB7JyxcbidcdFx0cGFkZGluZzogMWVtIDAuNWVtIDFlbSAxZW07JyxcbidcdFx0bWFyZ2luLXJpZ2h0OiA1MCU7JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgPiBkaXYgPiBwOmZpcnN0LWNoaWxkIHsnLFxuJ1x0XHRtYXJnaW4tdG9wOiAwOycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nID4gZGl2ID4gcCA+IHNwYW46Zmlyc3QtY2hpbGQgeycsXG4nXHRcdGZvbnQtc2l6ZTogbGFyZ2VyOycsXG4nXHRcdGxldHRlci1zcGFjaW5nOiAycHg7JyxcbidcdFx0Zm9udC13ZWlnaHQ6IGJvbGQ7JyxcbidcdFx0Y29sb3I6ICM2NjY7JyxcbidcdFx0bWFyZ2luLXJpZ2h0OiAxZW07JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgaW5wdXQsICNoeXBlcmdyaWQtZGlhbG9nIHRleHRhcmVhIHsnLFxuJ1x0XHRvdXRsaW5lOiAwOycsXG4nXHRcdGxpbmUtaGVpZ2h0OiBpbml0aWFsOycsXG4nXHR9JyxcbicnLFxuJ1x0LnRhYnogeyB6LWluZGV4OiAwIH0nLFxuJ1x0LnRhYnogPiBwOmZpcnN0LWNoaWxkLCAudGFieiA+IHNlY3Rpb24gPiBwOmZpcnN0LWNoaWxkLCAudGFieiA+IHNlY3Rpb24gPiBkaXYgPiBwOmZpcnN0LWNoaWxkIHsgbWFyZ2luLXRvcDogMCB9JyxcbicnLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgYS5tb3JlLWluZm8geyBmb250LXNpemU6IHNtYWxsZXI7IH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgYS5tb3JlLWluZm86OmFmdGVyIHsgY29udGVudDogXFwnKG1vcmUgaW5mbylcXCc7IH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgYS5tb3JlLWluZm8uaGlkZS1pbmZvIHsgY29sb3I6IHJlZDsgfScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyBhLm1vcmUtaW5mby5oaWRlLWluZm86OmFmdGVyIHsgY29udGVudDogXFwnKGhpZGUgaW5mbylcXCc7IH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgZGl2Lm1vcmUtaW5mbyB7JyxcbidcdFx0Ym9yZGVyOiAxcHggdGFuIHNvbGlkOycsXG4nXHRcdGJvcmRlci1yYWRpdXM6IDhweDsnLFxuJ1x0XHRwYWRkaW5nOiAwIDhweCAuMmVtOycsXG4nXHRcdGRpc3BsYXk6IG5vbmU7JyxcbidcdFx0YmFja2dyb3VuZC1jb2xvcjogaXZvcnk7JyxcbidcdFx0Ym94LXNoYWRvdzogM3B4IDNweCA1cHggIzcwNzA3MDsnLFxuJ1x0XHRtYXJnaW4tYm90dG9tOiAxZW07JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgZGl2Lm1vcmUtaW5mbyA+IHAgeyBtYXJnaW46IC41ZW0gMDsgfScsXG4nJyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIC50YWJ6IHVsIHsnLFxuJ1x0XHRwYWRkaW5nLWxlZnQ6IDEuNWVtOycsXG4nXHRcdGxpc3Qtc3R5bGUtdHlwZTogY2lyY2xlOycsXG4nXHRcdGZvbnQtd2VpZ2h0OiBib2xkOycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIC50YWJ6IHVsID4gbGkgPiB1bCB7JyxcbidcdFx0bGlzdC1zdHlsZS10eXBlOiBkaXNjOycsXG4nXHRcdGZvbnQtd2VpZ2h0OiBub3JtYWw7JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgLnRhYnogbGkgeycsXG4nXHRcdG1hcmdpbjogLjNlbSAwOycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIC50YWJ6IGxpID4gY29kZSB7JyxcbidcdFx0YmFja2dyb3VuZDogI2UwZTBlMDsnLFxuJ1x0XHRtYXJnaW46IDAgLjFlbTsnLFxuJ1x0XHRwYWRkaW5nOiAwIDVweDsnLFxuJ1x0XHRib3JkZXItcmFkaXVzOiA0cHg7JyxcbidcdH0nLFxuJycsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyAudGFieiA+IHNlY3Rpb24uZmlsdGVyLWV4cHJlc3Npb24tc3ludGF4ID4gZGl2Omxhc3QtY2hpbGQgb2wgeycsXG4nXHRcdHBhZGRpbmctbGVmdDogMS42ZW07JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgLnRhYnogPiBzZWN0aW9uLmZpbHRlci1leHByZXNzaW9uLXN5bnRheCA+IGRpdjpsYXN0LWNoaWxkIG9sID4gbGkgPiBsYWJlbCB7JyxcbidcdFx0d2lkdGg6IDEwMCU7JyxcbidcdFx0Zm9udC13ZWlnaHQ6IG5vcm1hbDsnLFxuJ1x0XHRkaXNwbGF5OiBpbmxpbmU7JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgLnRhYnogLmZpbHRlci10cmVlLXdhcm4geycsXG4nXHRcdGNvbG9yOiBkYXJrcmVkOycsXG4nXHRcdGZvbnQtc2l6ZTogc21hbGxlcjsnLFxuJ1x0XHRmb250LXN0eWxlOiBpdGFsaWM7JyxcbidcdFx0bGluZS1oZWlnaHQ6IGluaXRpYWw7JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgLnRhYnogPiBzZWN0aW9uLmZpbHRlci1leHByZXNzaW9uLXN5bnRheCA+IHRleHRhcmVhLCcsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyAudGFieiA+IHNlY3Rpb24uZmlsdGVyLWV4cHJlc3Npb24tc3ludGF4ID4gZGl2Omxhc3QtY2hpbGQgdGV4dGFyZWEsJyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIC50YWJ6ID4gc2VjdGlvbi5maWx0ZXItZXhwcmVzc2lvbi1zeW50YXggPiBkaXY6bGFzdC1jaGlsZCBpbnB1dCB7JyxcbidcdFx0ZGlzcGxheTogYmxvY2s7JyxcbidcdFx0cG9zaXRpb246IHJlbGF0aXZlOycsXG4nXHRcdG1pbi13aWR0aDogMTAwJTsnLFxuJ1x0XHRtYXgtd2lkdGg6IDEwMCU7JyxcbidcdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDsnLFxuJ1x0XHRib3JkZXI6IDFweCBzb2xpZCBibGFjazsnLFxuJ1x0XHRwYWRkaW5nOiAuNGVtIC43ZW07JyxcbidcdFx0Zm9udC1mYW1pbHk6IG1vbm9zcGFjZTsnLFxuJ1x0XHRmb250LXNpemU6IDlwdDsnLFxuJ1x0XHRtYXJnaW4tdG9wOiAzcHg7JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgLnRhYnogPiBzZWN0aW9uLmZpbHRlci1leHByZXNzaW9uLXN5bnRheCA+IHRleHRhcmVhIHsnLFxuJ1x0XHRoZWlnaHQ6IDk2JTsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyAudGFieiBhLmZpbHRlci1jb3B5IHsnLFxuJ1x0XHRkaXNwbGF5OiBibG9jazsnLFxuJ1x0XHRmbG9hdDogcmlnaHQ7JyxcbidcdFx0Zm9udC1zaXplOiBzbWFsbGVyOycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIC50YWJ6IGEuZmlsdGVyLWNvcHk6YmVmb3JlIHsnLFxuJ1x0XHRjb250ZW50OiBcXCcoY29weVxcJzsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyAudGFieiBhLmZpbHRlci1jb3B5OmFmdGVyIHsnLFxuJ1x0XHRjb250ZW50OiBcXCcpXFwnOycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIC50YWJ6IGEuZmlsdGVyLWNvcHk6YWN0aXZlIHsnLFxuJ1x0XHRjb2xvcjogcmVkOycsXG4nXHR9Jyxcbic8L3N0eWxlPicsXG4nJyxcbic8ZGl2PicsXG4nXHQ8c2VsZWN0IGlkPVwiYWRkLWNvbHVtbi1maWx0ZXItc3ViZXhwcmVzc2lvblwiIHN0eWxlPVwiZmxvYXQ6cmlnaHQ7IG1hcmdpbi1sZWZ0OjFlbTsgbWFyZ2luLXJpZ2h0OjRlbTtcIj4nLFxuJ1x0XHQ8b3B0aW9uIHZhbHVlPVwiXCI+TmV3IGNvbHVtbiBmaWx0ZXImaGVsbGlwOzwvb3B0aW9uPicsXG4nXHQ8L3NlbGVjdD4nLFxuJycsXG4nXHQ8cD4nLFxuJ1x0XHQ8c3Bhbj5Db2x1bW4gRmlsdGVyczwvc3Bhbj4nLFxuJ1x0XHQ8YSBjbGFzcz1cIm1vcmUtaW5mb1wiPjwvYT4nLFxuJ1x0PC9wPicsXG4nXHQ8ZGl2IGNsYXNzPVwibW9yZS1pbmZvXCI+JyxcbidcdFx0PHA+VGhlIHRhYmxlIGZpbHRlciBjYW4gYmUgdmlld2VkIGluIHRoZSBRdWVyeSBCdWlsZGVyIG9yIGFzIFNRTCBXSEVSRSBjbGF1c2Ugc3ludGF4LiBCb3RoIGludGVyZmFjZXMgbWFuaXB1bGF0ZSB0aGUgc2FtZSB1bmRlcmx5aW5nIGZpbHRlciBkYXRhIHN0cnVjdHVyZS48L3A+JyxcbidcdFx0PHA+QWxsIGNvbHVtbiBmaWx0ZXJzIGFyZSBBTkQmcnNxdW87ZCB0b2dldGhlci4gRWFjaCBncmlkIHJvdyBpcyBmaXJzdCBxdWFsaWZpZWQgYnkgdGhlIHRhYmxlIGZpbHRlciBhbmQgdGhlbiBzdWNjZXNzaXZlbHkgcXVhbGlmaWVkIGJ5IGVhY2ggY29sdW1uIGZpbHRlciBzdWJleHByZXNzaW9uLjwvcD4nLFxuJ1x0PC9kaXY+JyxcbicnLFxuJ1x0PGRpdiBjbGFzcz1cInRhYnpcIiBpZD1cImNvbHVtbkZpbHRlcnNQYW5lbFwiPicsXG4nJyxcbidcdFx0PGhlYWRlciBpZD1cImNvbHVtbnNRQlwiIGNsYXNzPVwiZGVmYXVsdC10YWJcIj4nLFxuJ1x0XHRcdFF1ZXJ5IEJ1aWxkZXInLFxuJ1x0XHQ8L2hlYWRlcj4nLFxuJycsXG4nXHRcdDxzZWN0aW9uPicsXG4nXHRcdDwvc2VjdGlvbj4nLFxuJycsXG4nXHRcdDxoZWFkZXIgaWQ9XCJjb2x1bW5zU1FMXCIgY2xhc3M9XCJ0YWJ6LWJnMlwiPicsXG4nXHRcdFx0U1FMJyxcbidcdFx0PC9oZWFkZXI+JyxcbicnLFxuJ1x0XHQ8c2VjdGlvbiBjbGFzcz1cImZpbHRlci1leHByZXNzaW9uLXN5bnRheCB0YWJ6LWJnMlwiPicsXG4nXHRcdFx0PGRpdj4nLFxuJ1x0XHRcdFx0PHA+JyxcbidcdFx0XHRcdFx0PHNwYW4+PC9zcGFuPicsXG4nXHRcdFx0XHRcdDxhIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImZpbHRlci1jb3B5XCIgdGl0bGU9XCJUaGUgc3RhdGUgb2YgdGhlIGNvbHVtbiBmaWx0ZXJzIHN1YnRyZWUgZXhwcmVzc2VkIGluIFNRTCBzeW50YXggKGFsbCB0aGUgY29sdW1uIGZpbHRlciBzdWJleHByZXNzaW9ucyBzaG93biBiZWxvdyBBTkQmcnNxdW87ZCB0b2dldGhlcikuXCI+JyxcbidcdFx0XHRcdFx0XHRhbGw8L2E+JyxcbidcdFx0XHRcdDwvcD4nLFxuJ1x0XHRcdFx0PG9sPjwvb2w+JyxcbidcdFx0XHQ8L2Rpdj4nLFxuJ1x0XHQ8L3NlY3Rpb24+JyxcbicnLFxuJ1x0XHQ8aGVhZGVyIGlkPVwiY29sdW1uc0NRTFwiIGNsYXNzPVwidGFiei1iZzFcIj4nLFxuJ1x0XHRcdENRTCcsXG4nXHRcdDwvaGVhZGVyPicsXG4nJyxcbidcdFx0PHNlY3Rpb24gY2xhc3M9XCJmaWx0ZXItZXhwcmVzc2lvbi1zeW50YXggdGFiei1iZzFcIj4nLFxuJ1x0XHRcdDxwPicsXG4nXHRcdFx0XHQ8ZW0+JyxcbidcdFx0XHRcdFx0PHNtYWxsPkNvbHVtbiBmaWx0ZXIgY2VsbHMgYWNjZXB0IGEgc2ltcGxpZmllZCwgY29tcGFjdCwgYW5kIGludHVpdGl2ZSBzeW50YXgsIHdoaWNoIGlzIGhvd2V2ZXIgbm90IGFzIGZsZXhpYmxlIG9yIGNvbmNpc2UgYXMgU1FMIHN5bnRheCBvciB1c2luZyB0aGUgUXVlcnkgQnVpbGRlci48L3NtYWxsPicsXG4nXHRcdFx0XHRcdDxhIGNsYXNzPVwibW9yZS1pbmZvXCI+PC9hPicsXG4nXHRcdFx0XHQ8L2VtPicsXG4nXHRcdFx0PC9wPicsXG4nXHRcdFx0PGRpdiBjbGFzcz1cIm1vcmUtaW5mb1wiPicsXG4nXHRcdFx0XHQ8dWw+JyxcbidcdFx0XHRcdFx0PGxpPicsXG4nXHRcdFx0XHRcdFx0U2ltcGxlIGV4cHJlc3Npb25zJyxcbidcdFx0XHRcdFx0XHQ8dWw+JyxcbidcdFx0XHRcdFx0XHRcdDxsaT5BbGwgc2ltcGxlIGV4cHJlc3Npb25zIHRha2UgdGhlIGZvcm0gPGk+b3BlcmF0b3IgbGl0ZXJhbDwvaT4gb3IgPGk+b3BlcmF0b3IgaWRlbnRpZmllcjwvaT4uIFRoZSAobGVmdCBzaWRlKSBjb2x1bW4gaXMgYWx3YXlzIGltcGxpZWQgYW5kIGlzIHRoZSBzYW1lIGZvciBhbGwgc2ltcGxlIGV4cHJlc3Npb25zIGluIGEgY29tcG91bmQgZXhwcmVzc2lvbi4gVGhpcyBpcyBiZWNhdXNlIGNvbHVtbiBmaWx0ZXJzIGFyZSBhbHdheXMgdGllZCB0byBhIGtub3duIGNvbHVtbi48L2xpPicsXG4nJyxcbidcdFx0XHRcdFx0XHRcdDxsaT5JZiB0aGUgb3BlcmF0b3IgaXMgYW4gZXF1YWxzIHNpZ24gKD0pLCBpdCBtYXkgYmUgb21pdHRlZC48L2xpPicsXG4nJyxcbidcdFx0XHRcdFx0XHRcdDxsaT5CZXNpZGVzIG9wZXJhdG9ycywgbm8gb3RoZXIgcHVuY3R1YXRpb24gaXMgcGVybWl0dGVkLCBtZWFuaW5nIHRoYXQgbm8gcXVvdGF0aW9uIG1hcmtzIGFuZCBubyBwYXJlbnRoZXNlcy48L2xpPicsXG4nJyxcbidcdFx0XHRcdFx0XHRcdDxsaT5JZiBhIGxpdGVyYWwgZXhhY3RseSBtYXRjaGVzIGEgY29sdW1uIG5hbWUgb3IgYWxpYXMsIHRoZSBvcGVyYW5kIGlzIG5vdCB0YWtlbiBsaXRlcmFsbHkgYW5kIGluc3RlYWQgcmVmZXJzIHRvIHRoZSB2YWx1ZSBpbiB0aGF0IGNvbHVtbi4gKFRoZXJlIGFyZSBwcm9wZXJ0aWVzIHRvIGNvbnRyb2wgd2hhdCBjb25zdGl0dXRlcyBzdWNoIGEgbWF0Y2g6IENvbHVtbiBuYW1lLCBhbGlhcywgb3IgZWl0aGVyOyBhbmQgdGhlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgdGhlIG1hdGNoLik8L2xpPicsXG4nJyxcbidcdFx0XHRcdFx0XHRcdDxsaT5BcyBsaXRlcmFscyBhcmUgdW5xdW90ZWQsIGFueSBvcGVyYXRvciBzeW1ib2wgb3Igb3BlcmF0b3Igd29yZCAoaW5jbHVkaW5nIGxvZ2ljYWwgb3BlcmF0b3JzIGZvciBjb21wb3VuZCBleHByZXNzaW9ucykgdGVybWluYXRlcyBhIGxpdGVyYWwuPC9saT4nLFxuJycsXG4nXHRcdFx0XHRcdFx0XHQ8bGk+QW4gaW1wb3J0YW50IGNvcm9sbGFyeSB0byB0aGUgYWJvdmUgZmVhdHVyZXMgaXMgdGhhdCBvcGVyYXRvcnMgbWF5IG5vdCBhcHBlYXIgaW4gbGl0ZXJhbHMuPC9saT4nLFxuJ1x0XHRcdFx0XHRcdDwvdWw+JyxcbidcdFx0XHRcdFx0PC9saT4nLFxuJycsXG4nXHRcdFx0XHRcdDxsaT4nLFxuJ1x0XHRcdFx0XHRcdENvbXBvdW5kIGV4cHJlc3Npb25zJyxcbidcdFx0XHRcdFx0XHQ8dWw+JyxcbidcdFx0XHRcdFx0XHRcdDxsaT5Db21wb3VuZCBleHByZXNzaW9ucyBhcmUgZm9ybWVkIGJ5IGNvbm5lY3Rpbmcgc2ltcGxlIGV4cHJlc3Npb25zIHdpdGggdGhlIGxvZ2ljYWwgb3BlcmF0b3JzIDxjb2RlPkFORDwvY29kZT4sIDxjb2RlPk9SPC9jb2RlPiwgPGNvZGU+Tk9SPC9jb2RlPiwgb3IgPGNvZGU+TkFORDwvY29kZT4gKFwibm90IGFuZFwiKS48L2xpPicsXG4nJyxcbidcdFx0XHRcdFx0XHRcdDxsaT5Ib3dldmVyLCBhbGwgbG9naWNhbCBvcGVyYXRvcnMgdXNlZCBpbiBhIGNvbXBvdW5kIGNvbHVtbiBmaWx0ZXIgZXhwcmVzc2lvbiBtdXN0IGJlIGhvbW9nZW5lb3VzLiBZb3UgbWF5IG5vdCBtaXggdGhlIGFib3ZlIGxvZ2ljYWwgb3BlcmF0b3JzIGluIGEgc2luZ2xlIGNvbHVtbi4gKElmIHlvdSBuZWVkIHRvIGRvIHRoaXMsIGNyZWF0ZSBhIHRhYmxlIGZpbHRlciBleHByZXNzaW9uIGluc3RlYWQuKTwvbGk+JyxcbidcdFx0XHRcdFx0XHQ8L3VsPicsXG4nXHRcdFx0XHRcdDwvbGk+JyxcbicnLFxuJ1x0XHRcdFx0XHQ8bGk+JyxcbidcdFx0XHRcdFx0XHRIaWRkZW4gbG9naWMnLFxuJ1x0XHRcdFx0XHRcdDx1bD4nLFxuJ1x0XHRcdFx0XHRcdFx0PGxpPklmIHRoZSBjb2x1bW4gaXMgYWxzbyByZWZlcmVuY2VkIGluIGEgdGFibGUgZmlsdGVyIGV4cHJlc3Npb24gKG9uIHRoZSBsZWZ0IHNpZGUgb2YgYSBzaW1wbGUgZXhwcmVzc2lvbiksIHRoZSBjb2x1bW4gZmlsdGVyIGlzIGZsYWdnZWQgaW4gaXRzIGdyaWQgY2VsbCB3aXRoIGEgc3BlY2lhbCBzdGFyIGNoYXJhY3Rlci4gVGhpcyBpcyBqdXN0IGEgZmxhZzsgaXQgaXMgbm90IHBhcnQgb2YgdGhlIHN5bnRheC4gPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWQ7IGZvbnQtc3R5bGU6aXRhbGljXCI+Tm90IHlldCBpbXBsZW1lbnRlZC48L3NwYW4+PC9saT4nLFxuJ1x0XHRcdFx0XHRcdDwvdWw+JyxcbidcdFx0XHRcdFx0PC9saT4nLFxuJ1x0XHRcdFx0PC91bD4nLFxuJ1x0XHRcdDwvZGl2PicsXG4nJyxcbidcdFx0XHQ8ZGl2PicsXG4nXHRcdFx0XHQ8cD48c3Bhbj48L3NwYW4+PC9wPicsXG4nXHRcdFx0XHQ8b2w+PC9vbD4nLFxuJ1x0XHRcdDwvZGl2PicsXG4nXHRcdDwvc2VjdGlvbj4nLFxuJ1x0PC9kaXY+Jyxcbic8L2Rpdj4nLFxuJycsXG4nPGRpdj4nLFxuJ1x0PHA+JyxcbidcdFx0PHNwYW4+VGFibGUgRmlsdGVyPC9zcGFuPicsXG4nXHRcdDxhIGNsYXNzPVwibW9yZS1pbmZvXCI+PC9hPicsXG4nXHQ8L3A+JyxcbidcdDxkaXYgY2xhc3M9XCJtb3JlLWluZm9cIj4nLFxuJ1x0XHQ8cD5UaGUgdGFibGUgZmlsdGVyIGNhbiBiZSB2aWV3ZWQgaW4gdGhlIFF1ZXJ5IEJ1aWxkZXIgb3IgYXMgU1FMIFdIRVJFIGNsYXVzZSBzeW50YXguIEJvdGggaW50ZXJmYWNlcyBtYW5pcHVsYXRlIHRoZSBzYW1lIHVuZGVybHlpbmcgZmlsdGVyIGRhdGEgc3RydWN0dXJlLjwvcD4nLFxuJ1x0XHQ8cD4nLFxuJ1x0XHRcdFRoZXNlIGZpbHRlciBzdWJleHByZXNzaW9ucyBhcmUgYm90aCByZXF1aXJlZCAoPGNvZGU+QU5EPC9jb2RlPiZyc3F1bztkIHRvZ2V0aGVyKSwgcmVzdWx0aW5nIGluIGEgc3Vic2V0IG9mIDxlbT5xdWFsaWZpZWQgcm93czwvZW0+IHdoaWNoIGhhdmUgcGFzc2VkIHRocm91Z2ggYm90aCBmaWx0ZXJzLicsXG4nXHRcdFx0SXRcXCdzIGNhbGxlZCBhIDxkZm4+dHJlZTwvZGZuPiBiZWNhdXNlIGl0IGNvbnRhaW5zIGJvdGggPGRmbj5icmFuY2hlczwvZGZuPiBhbmQgPGRmbj5sZWF2ZXM8L2Rmbj4uJyxcbidcdFx0XHRUaGUgbGVhdmVzIHJlcHJlc2VudCA8ZGZuPmNvbmRpdGlvbmFsIGV4cHJlc3Npb25zPC9kZm4+IChvciBzaW1wbHkgPGRmbj5jb25kaXRpb25hbHM8L2Rmbj4pLicsXG4nXHRcdFx0VGhlIGJyYW5jaGVzLCBhbHNvIGtub3duIGFzIDxkZm4+c3VidHJlZXM8L2Rmbj4sIGNvbnRhaW4gbGVhdmVzIGFuZC9vciBvdGhlciBicmFuY2hlcyBhbmQgcmVwcmVzZW50IHN1YmV4cHJlc3Npb25zIHRoYXQgZ3JvdXAgY29uZGl0aW9uYWxzIHRvZ2V0aGVyLicsXG4nXHRcdFx0R3JvdXBlZCBjb25kaXRpb25hbHMgYXJlIGV2YWx1YXRlZCB0b2dldGhlciwgYmVmb3JlIGNvbmRpdGlvbmFscyBvdXRzaWRlIHRoZSBncm91cC4nLFxuJ1x0XHQ8L3A+JyxcbidcdDwvZGl2PicsXG4nJyxcbidcdDxkaXYgY2xhc3M9XCJ0YWJ6XCIgaWQ9XCJ0YWJsZUZpbHRlclBhbmVsXCI+JyxcbidcdFx0PGhlYWRlciBpZD1cInRhYmxlUUJcIj4nLFxuJ1x0XHRcdFF1ZXJ5IEJ1aWxkZXInLFxuJ1x0XHQ8L2hlYWRlcj4nLFxuJycsXG4nXHRcdDxzZWN0aW9uPicsXG4nXHRcdDwvc2VjdGlvbj4nLFxuJycsXG4nXHRcdDxoZWFkZXIgaWQ9XCJ0YWJsZVNRTFwiIGNsYXNzPVwidGFiei1iZzJcIj4nLFxuJ1x0XHRcdFNRTCcsXG4nXHRcdDwvaGVhZGVyPicsXG4nJyxcbidcdFx0PHNlY3Rpb24gY2xhc3M9XCJmaWx0ZXItZXhwcmVzc2lvbi1zeW50YXggdGFiei1iZzJcIj4nLFxuJ1x0XHRcdDxkaXY+JyxcbidcdFx0XHRcdDxwPicsXG4nXHRcdFx0XHRcdFNRTCBXSEVSRSBjbGF1c2Ugc3ludGF4IHdpdGggY2VydGFpbiByZXN0cmljdGlvbnMuJyxcbidcdFx0XHRcdFx0PGEgY2xhc3M9XCJtb3JlLWluZm9cIj48L2E+JyxcbidcdFx0XHRcdDwvcD4nLFxuJ1x0XHRcdFx0PGRpdiBjbGFzcz1cIm1vcmUtaW5mb1wiPicsXG4nXHRcdFx0XHRcdDx1bD4nLFxuJ1x0XHRcdFx0XHRcdDxsaT4nLFxuJ1x0XHRcdFx0XHRcdFx0U2ltcGxlIGV4cHJlc3Npb25zJyxcbidcdFx0XHRcdFx0XHRcdDx1bD4nLFxuJ1x0XHRcdFx0XHRcdFx0XHQ8bGk+QWxsIHNpbXBsZSBleHByZXNzaW9ucyBtdXN0IGJlIG9mIHRoZSBmb3JtIDxpPmNvbHVtbiBvcGVyYXRvciBsaXRlcmFsPC9pPiBvciA8aT5jb2x1bW4gb3BlcmF0b3IgaWRlbnRpZmllcjwvaT4uIFRoYXQgaXMsIHRoZSBsZWZ0IHNpZGUgbXVzdCByZWZlciB0byBhIGNvbHVtbiAobWF5IG5vdCBiZSBhIGxpdGVyYWwpOyB3aGVyZWFzIHRoZSByaWdodCBzaWRlIG1heSBiZSBlaXRoZXIuPC9saT4nLFxuJycsXG4nXHRcdFx0XHRcdFx0XHRcdDxsaT5Db2x1bW4gbmFtZXMgbWF5IGJlIHF1b3RlZCB3aXRoIHRoZSBjdXJyZW50bHkgc2V0IHF1b3RlIGNoYXJhY3RlcnMgKHR5cGljYWxseSBkb3VibGUtcXVvdGVzKS4gSWYgdW5xdW90ZWQsIHRoZXkgbXVzdCBjb25zaXN0IG9mIGNsYXNzaWMgaWRlbnRpZmllciBzeW50YXggKGFscGhhbnVtZXJpY3MgYW5kIHVuZGVyc2NvcmUsIGJ1dCBub3QgYmVnaW5uaW5nIHdpdGggYSBudW1lcmFsKS48L2xpPicsXG4nJyxcbidcdFx0XHRcdFx0XHRcdFx0PGxpPkFsbCBsaXRlcmFscyBtdXN0IGJlIHF1b3RlZCBzdHJpbmdzICh1c2luZyBzaW5nbGUgcXVvdGVzKS4gKEluIGEgZnV0dXJlIHJlbGVhc2Ugd2UgZXhwZWN0IHRvIHN1cHBvcnQgdW5xdW90ZWQgbnVtZXJpYyBzeW50YXggZm9yIGNvbHVtbnMgZXhwbGljaXRseSB0eXBlZCBhcyBudW1lcmljLik8L2xpPicsXG4nXHRcdFx0XHRcdFx0XHQ8L3VsPicsXG4nXHRcdFx0XHRcdFx0PC9saT4nLFxuJycsXG4nXHRcdFx0XHRcdFx0PGxpPicsXG4nXHRcdFx0XHRcdFx0XHRDb21wb3VuZCBleHByZXNzaW9ucycsXG4nXHRcdFx0XHRcdFx0XHQ8dWw+JyxcbidcdFx0XHRcdFx0XHRcdFx0PGxpPkNvbXBvdW5kIGV4cHJlc3Npb25zIGFyZSBmb3JtZWQgYnkgY29ubmVjdGluZyBzaW1wbGUgZXhwcmVzc2lvbnMgd2l0aCB0aGUgbG9naWNhbCBvcGVyYXRvcnMgPGNvZGU+QU5EPC9jb2RlPiBvciA8Y29kZT5PUjwvY29kZT4uPC9saT4nLFxuJycsXG4nXHRcdFx0XHRcdFx0XHRcdDxsaT5Ib3dldmVyLCBhbGwgbG9naWNhbCBvcGVyYXRvcnMgYXQgZWFjaCBsZXZlbCBpbiBhIGNvbXBsZXggZXhwcmVzc2lvbiAoZWFjaCBwYXJlbnRoZXNpemVkIHN1YmV4cHJlc3Npb24pIG11c3QgYmUgaG9tb2dlbmVvdXMsIDxpPmkuZS4sPC9pPiBlaXRoZXIgPGNvZGU+QU5EPC9jb2RlPiBvciA8Y29kZT5PUjwvY29kZT4gYnV0IG5vdCBhIG1peHR1cmUgb2YgdGhlIHR3by4gSW4gb3RoZXIgd29yZHMsIHRoZXJlIGlzIG5vIGltcGxpY2l0IG9wZXJhdG9yIHByZWNlZGVuY2U7IGdyb3VwaW5nIG9mIGV4cHJlc3Npb25zIG11c3QgYWx3YXlzIGJlIGV4cGxpY2l0bHkgc3RhdGVkIHdpdGggcGFyZW50aGVzZXMuPC9saT4nLFxuJycsXG4nXHRcdFx0XHRcdFx0XHRcdDxsaT5UaGUgdW5hcnkgbG9naWNhbCBvcGVyYXRvciA8Y29kZT5OT1Q8L2NvZGU+IGlzIHN1cG9vcnRlZCBiZWZvcmUgcGFyZW50aGVzZXMgb25seS4gV2hpbGUgdGhlIFF1ZXJ5IEJ1aWxkZXIgYW5kIHRoZSBDb2x1bW4gRmlsdGVyIGFsbG93IHRoZXkgc3ludGF4IDxjb2RlPiZoZWxsaXA7IE5PVCA8aT5vcGVyYXRvcjwvaT4gJmhlbGxpcDs8L2NvZGU+ICh3aGVyZSA8Y29kZT48aT5vcGVyYXRvcjwvaT48L2NvZGU+IGlzIDxjb2RlPklOPC9jb2RlPiwgPGNvZGU+TElLRTwvY29kZT4sIDxpPmV0Yy48L2k+KSwgdGhlc2UgbXVzdCBiZSBleHByZXNzZWQgaGVyZSB3aXRoIHBhcmVudGhldGhlczogPGNvZGU+Tk9UICgmaGVsbGlwOyA8aT5vcGVyYXRvcjwvaT4gJmhlbGxpcDspPC9jb2RlPi48L2xpPicsXG4nJyxcbidcdFx0XHRcdFx0XHRcdFx0PGxpPldoaWxlIHRoZSBRdWVyeSBCdWlsZGVyIGFuZCBDb2x1bW4gRmlsdGVyIHN5bnRheCBzdXBwb3J0IHRoZSBwc2V1ZG8tb3BlcmF0b3JzIDxjb2RlPk5PUjwvY29kZT4gYW5kIDxjb2RlPk5BTkQ8L2NvZGU+LCBpbiBTUUwgdGhlc2UgbXVzdCBiZSBleHByZXNzZWQgYXMgPGNvZGU+Tk9UICgmaGVsbGlwOyBPUiAmaGVsbGlwOyk8L2NvZGU+IGFuZCA8Y29kZT5OT1QgKCZoZWxsaXA7IEFORCAmaGVsbGlwOyk8L2NvZGU+LCByZXNwZWN0aXZlbHkuPC9saT4nLFxuJycsXG4nXHRcdFx0XHRcdFx0XHRcdDxsaT5UaGUgUXVlcnkgQnVpbGRlciBhbmQgQ29sdW1uIEZpbHRlciBzeW50YXggYWxzbyBzdXBwb3J0IHRoZSBwc2V1ZG8tb3BlcmF0b3JzIDxjb2RlPkJFR0lOUyBhYmM8L2NvZGU+LCA8Y29kZT5FTkRTIHh5ejwvY29kZT4sIGFuZCA8Y29kZT5DT05UQUlOUyBkZWY8L2NvZGU+LiBUaGVzZSBhcmUgZXhwcmVzc2VkIGluIFNRTCBieSA8Y29kZT5MSUtFIFxcJ2FiYyVcXCc8L2NvZGU+LCA8Y29kZT5MSUtFIFxcJyV4eXpcXCc8L2NvZGU+LCBhbmQgPGNvZGU+TElLRSBcXCclZGVmJVxcJzwvY29kZT4sIHJlc3BlY3RpdmVseS48L2xpPicsXG4nXHRcdFx0XHRcdFx0XHQ8L3VsPicsXG4nXHRcdFx0XHRcdFx0PC9saT4nLFxuJ1x0XHRcdFx0XHQ8L3VsPicsXG4nXHRcdFx0XHQ8L2Rpdj4nLFxuJ1x0XHRcdDwvZGl2PicsXG4nXHRcdFx0PGRpdiBjbGFzcz1cImZpbHRlci10cmVlLXdhcm5cIj48L2Rpdj4nLFxuJ1x0XHRcdDx0ZXh0YXJlYT48L3RleHRhcmVhPicsXG4nXHRcdDwvc2VjdGlvbj4nLFxuJycsXG4nXHQ8L2Rpdj4nLFxuJzwvZGl2Pidcbl0uam9pbignXFxuJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHsgLy8gVGhpcyBmaWxlIGdlbmVyYXRlZCBieSBndWxwLWltYWdpbmUtNjQgYXQgMjo0NDo1NiBQTSBvbiA2LzIzLzIwMTZcblx0XCJIeXBlcmJsb3R0ZXIgVGFibGVkIFJlZHVjZWQgUm93c1wiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUF0UUFBQURuQ0FZQUFBQStYTUhhQUFBTUYybERRMUJKUTBNZ1VISnZabWxzWlFBQVNJbVZWd2RZVThrV25sdFNDQWt0RUFFcG9UZEJlcFhlQlFIcFlDTWtBVUlKSVJCVTdNaWlnbXNYQzFaMEJVVEJ0UUN5VmtTeHNBalk2d1lSRldWZExOaFFlWk1FMEhWZitkNzV2cm56NTh3NVovNXo3c3pOREFDSzlpeUJJQk5WQWlDTG55ZU1EUFJoeGlja01rbGlnQUJsUUFKdWdNRmk1d3E4SXlKQ0FaVFIvdS95N2lhMGhuTE5VaExybitQL1ZaUTUzRncyQUVnRXhNbWNYSFlXeEVjQndEWFpBbUVlQUlRT3FEZVluU2VRNExjUXF3b2hRUUNJWkFsT2xXRXRDVTZXWVd1cFRYU2tMOFIrQUpDcExKWXdGUUFGU1h4bVBqc1Z4bEVRUUd6TjUvRDRFTytDMklPZHh1SkFMSVo0UWxaV05zU0tWSWhOazcrTGsvcTNtTWxqTVZtczFERXN5MFVxWkQ5ZXJpQ1ROZmYvTE1mL2xxeE0wZWdjK3JCUjA0UkJrWktjWWQycU1ySkRKQmh5UjA3d2s4UENJVmFCK0NLUEk3V1g0THRwb3FDWUVmdCtkcTR2ckJsZ0FJQUNEc3N2QkdKWVM1UWh5b2p4SHNHMkxLSFVGOXFqWWJ5ODRPZ1JuQ3pNamh5SmorYnpNOE5DUitJc1QrTUdqK0lkM0Z6L3FGR2JGRjVBTU1Sd3BhRkhDOUtpNDJRODBaWjhYbXdZeEFvUWQrUm1SSVdNK0Q0c1NQTU5HN1VSaWlJbG5BMGhmcHNpRElpVTJXRHFXYm1qZVdGV2JKWjBMbldJdmZMU29vTmt2bGc4TnpjK2RKUURoK3ZuTCtPQWNiajhtQkZ1R0Z4ZFBwRWp2c1dDeklnUmUyd0hOek13VWxabjdGQnVmdFNvYjFjZVhHQ3lPbUNQMGxtVEkyVDhzWGVDdklob0dUY2NCNkhBRi9nQkpoREJsZ3l5UVRyZ3RmYzM5TU5mc3BFQXdBSkNrQXE0d0hKRU0rb1JKeDNodzJjVUtBQi9Rc1FGdVdOK1B0SlJMc2lIK2k5ald0blRFcVJJUi9PbEhobmdDY1JadUNidWdidmhvZkRwQlpzdDdveTdqUG94RlVkbkpmb1QvWWhCeEFDaTJSZ1BObVNkQ1pzUThQNk5MZ1QyWEppZGhBdC9OSWR2OFFoUENKMkVSNFFiQkRIaERvZ0ZqNlZSUnF4bThRcUZQekJuZ2lsQURLTUZqR1NYREdQMmpkcmd4cEMxQSs2RHUwUCtrRHZPd0RXQkpXNFBNL0hHUFdGdURsRDdQVVBSR0xkdnRmeHhQZ25yNy9NWjBTdVlLemlNc0VnZWV6TytZMVkvUnZIOXJrWWMySWY4YUlrdHg0NWdyZGhaN0JKMkFtc0FUT3cwMW9pMVlTY2xlR3dsUEphdWhOSFpJcVhjTW1BYzNxaU5kWTExbi9YbmY4ek9HbUVnbEw1dmtNZWRreWZaRUw3WmdybENYbXBhSHRNYmZwRzV6R0ErMjJvQzA5YmF4aEVBeWZkZDl2bDR3NUIrdHhIRzVXKzZuRE1BdUpSQVplbzNIY3NBZ09OUEFLQy8rNll6ZUEyMzF4b0FUbmF3UmNKOG1RNlhQQWlBQWhUaHp0QUFPc0FBbU1LY2JJRWovQi94QXY1Z01nZ0gwU0FCeklSVlR3TlprUFZzTUI4c0FjV2dGS3dCRzhGV3NCUHNBVlhnSURnTUdzQUpjQlpjQUZkQUI3Z0I3c0cxMFF0ZWdBSHdEZ3doQ0VKQ2FBZ2QwVUIwRVNQRUFyRkZuQkVQeEI4SlJTS1JCQ1FKU1VYNGlBaVpqeXhGU3BGMXlGWmtOMUtOL0lvY1I4NGlsNUJPNUE3U2pmUWhyNUZQS0laU1VWVlVHelZHSjZMT3FEY2Fna2FqTTlCVU5BY3RRSXZRVmVobXRBSTlnTmFqWjlFcjZBMVVqTDVBQnpHQXlXTU1UQSt6eEp3eFh5d2NTOFJTTUNHMkVDdkJ5ckFLckJacmd1LzZHaWJHK3JHUE9CR240MHpjRXE3UElEd0daK001K0VKOEpiNFZyOExyOFJiOEd0Nk5EK0JmQ1RTQ0ZzR0M0RW9JSnNRVFVnbXpDY1dFTXNJK3dqSENlYmgzZWdudmlFUWlnMmhDZElKN000R1lUcHhIWEVuY1Rxd2puaUYyRW51SWd5UVNTWU5rUVhJbmhaTllwRHhTTVdrTDZRRHBOS21MMUV2NlFKWW42NUp0eVFIa1JES2ZYRWd1SSs4bm55SjNrWitTaCtTVTVJemtYT1hDNVRoeWMrVld5KzJWYTVLN0t0Y3JOMFJScHBoUTNDblJsSFRLRXNwbVNpM2xQT1UrNVkyOHZMeSt2SXY4VkhtZS9HTDV6ZktINUMvS2Q4dC9wS3BRemFtKzFPbFVFWFVWdFpKNmhucUgrb1pHb3huVHZHaUp0RHphS2xvMTdSenRJZTJEQWwzQlNpRllnYU93U0tGY29WNmhTK0dsb3B5aWthSzM0a3pGQXNVeXhTT0tWeFg3bGVTVWpKVjhsVmhLQzVYS2xZNHIzVklhVktZcjJ5aUhLMmNwcjFUZXIzeEorWmtLU2NWWXhWK0ZvMUtrc2tmbG5Fb1BIYU1iMEgzcGJQcFMrbDc2ZVhxdktsSFZSRFZZTlYyMVZQV2dhcnZxZ0pxS21yMWFyTm9jdFhLMWsycGlCc1l3WmdRek1obXJHWWNaTnhtZnhtbVA4eDdISGJkaVhPMjRybkh2MWNlcmU2bHoxVXZVNjlSdnFIL1NZR3I0YTJSb3JOVm8wSGlnaVd1YWEwN1ZuSzI1US9POFp2OTQxZkZ1NDlualM4WWZIbjlYQzlVeTE0clVtcWUxUjZ0TmExQmJSenRRVzZDOVJmdWNkcjhPUThkTEoxMW5nODRwblQ1ZHVxNkhMazkzZys1cDNlZE1OYVkzTTVPNW1kbkNITkRUMGd2U0UrbnQxbXZYRzlJMzBZL1JMOVN2MDM5Z1FERndOa2d4MkdEUWJEQmdxR3M0eFhDK1lZM2hYU001STJlak5LTk5ScTFHNzQxTmpPT01seGszR0Q4elVUY0pOaWt3cVRHNWIwb3o5VFROTWEwd3ZXNUdOSE0yeXpEYmJ0WmhqcG83bUtlWmw1dGZ0VUF0SEMxNEZ0c3RPaWNRSnJoTTRFK29tSERMa21ycGJabHZXV1BaYmNXd0NyVXF0R3F3ZWpuUmNHTGl4TFVUV3lkK3RYYXd6clRlYTMzUFJzVm1zazJoVFpQTmExdHpXN1p0dWUxMU81cGRnTjBpdTBhN1YvWVc5bHo3SGZhM0hlZ09VeHlXT1RRN2ZIRjBjaFE2MWpyMk9SazZKVGx0YzdybHJPb2M0YnpTK2FJTHdjWEhaWkhMQ1plUHJvNnVlYTZIWGY5eXMzVExjTnZ2OW15U3lTVHVwTDJUZXR6MTNWbnV1OTNGSGt5UEpJOWRIbUpQUFUrV1o0WG5JeThETDQ3WFBxK24zbWJlNmQ0SHZGLzZXUHNJZlk3NXZQZDE5VjNnZThZUDh3djBLL0ZyOTFmeGovSGY2djh3UUQ4Z05hQW1ZQ0RRSVhCZTRKa2dRbEJJME5xZ1c4SGF3ZXpnNnVDQnlVNlRGMHh1Q2FHR1JJVnNEWGtVYWg0cURHMmFnazZaUEdYOWxQdGhSbUg4c0lad0VCNGN2ajc4UVlSSlJFN0ViMU9KVXlPbWxrOTlFbWtUT1QreU5Zb2VOU3RxZjlTN2FKL28xZEgzWWt4alJESE5zWXF4MDJPclk5L0grY1d0aXhQSFQ0eGZFSDhsUVRPQmw5Q1lTRXFNVGR5WE9Eak5mOXJHYWIzVEhhWVhUNzg1dzJUR25CbVhabXJPekp4NWNwYmlMTmFzSTBtRXBMaWsvVW1mV2VHc0N0WmdjbkR5dHVRQnRpOTdFL3NGeDR1emdkUEhkZWV1NHo1TmNVOVpsL0lzMVQxMWZXcGZtbWRhV1ZvL3o1ZTNsZmNxUFNoOVovcjdqUENNeW96aHpMak11aXh5VmxMV2NiNEtQNFBma3EyVFBTZTdVMkFoS0JhSWMxeHpOdVlNQ0VPRSszS1IzQm01alhtcThLalRKaklWL1NUcXp2ZklMOC8vTUR0MjlwRTV5blA0YzlybW1zOWRNZmRwUVVEQkwvUHdlZXg1emZQMTVpK1ozNzNBZThIdWhjakM1SVhOaXd3V0ZTM3FYUnk0dUdvSlpVbkdrdDhMclF2WEZiNWRHcmUwcVVpN2FIRlJ6MCtCUDlVVUt4UUxpMjh0YzF1MmN6bStuTGU4ZllYZGlpMHJ2cFp3U2k2WFdwZVdsWDVleVY1NStXZWJuemYvUEx3cVpWWDdhc2ZWTzlZUTEvRFgzRnpydWJacW5mSzZnblU5NjZlc3I5L0EzRkN5NGUzR1dSc3ZsZG1YN2R4RTJTVGFKTjRjdXJseGkrR1dOVnMrYjAzYmVxUGNwN3h1bTlhMkZkdmViK2RzNzlyaHRhTjJwL2JPMHAyZmR2RjIzZDRkdUx1K3dyaWliQTl4VC82ZUozdGo5N2IrNHZ4TDlUN05mYVg3dmxUeUs4VlZrVlV0MVU3VjFmdTE5cSt1UVd0RU5YMEhwaC9vT09oM3NMSFdzblozSGFPdTlCQTRKRHIwL05la1gyOGVEam5jZk1UNVNPMVJvNlBianRHUGxkUWo5WFByQnhyU0dzU05DWTJkeHljZmIyNXlhenIybTlWdmxTZjBUcFNmVkR1NStoVGxWTkdwNGRNRnB3ZlBDTTcwbjAwOTI5TThxL25ldWZoejExdW10clNmRHpsLzhVTEFoWE90M3Eybkw3cGZQSEhKOWRMeHk4NlhHNjQ0WHFsdmMyZzc5cnZENzhmYUhkdnJyenBkYmV4dzZXanFuTlI1cXN1ejYrdzF2MnNYcmdkZnYzSWo3RWJuelppYnQyOU52eVcremJuOTdFN21uVmQzOCs4TzNWdDhuM0MvNUlIU2c3S0hXZzhyL2pEN28wN3NLRDdaN2RmZDlpanEwYjBlZHMrTHg3bVBQL2NXUGFFOUtYdXErN1Q2bWUyekUzMEJmUjNQcHozdmZTRjRNZFJmL0tmeW45dGVtcjQ4K3BmWFgyMEQ4UU85cjRTdmhsK3ZmS1B4cHZLdC9kdm13WWpCaCsreTNnMjlML21nOGFIcW8vUEgxazl4bjU0T3pmNU0rcno1aTltWHBxOGhYKzhQWncwUEMxaENsdlFvZ01HR3BxUUE4TG9TQUZvQ1BEdkFleHhGUVhiL2tnb2l1ek5LRWZoUFdIWkhrd284dVZSNkFSQ3pHSUJRZUViWkFac1J4RlRZUzQ3ZjBWNEF0Yk1iYXlPU20ySm5LNHRGaGJjWXdvZmg0VGZhQUpDYUFQZ2lIQjRlMmo0OC9HVXZKSHNIZ0RNNXNudWZSSWp3akwvTFRJTGEyeWpnUi9rWEhvMXNlUFVtakowQUFFQUFTVVJCVkhnQjdKMEZmRlRIRThkL0Y0Y0Vkdy91ME9MdTd1NHVMZHFpTGJUUTBxS2xGT2VQdGxDZ2FJRVdMVnBjaTd1N0JBdVNFRS8rTXh2dXVBdVg1SEs1SkhlNTJRL2gzcjIzdTIvMysrNjlOenM3TTZzcFhiRkZHQ1FKQVNFZ0JJU0FFQkFDUWtBSUNBRWhZQllCQjdOS1NTRWhJQVNFZ0JBUUFrSkFDQWdCSVNBRUZBRVJxT1dISUFTRWdCQVFBa0pBQ0FnQklTQUVZa0ZBQk9wWXdKT2lRa0FJQ0FFaElBU0VnQkFRQWtKQUJHcjVEUWdCSVNBRWhJQVFFQUpDUUFnSWdWZ1FFSUU2RnZDa3FCQVFBa0pBQ0FnQklTQUVoSUFRRUlGYWZnTkNRQWdJQVNFZ0JJU0FFQkFDUWlBV0JKeWlLNXM1VTNvMHFGY05HbzFHWlgzNjdBVzI3ZGlId0lBZ0xQdHRDczZldjRJcDB4WkZWNDBjRndKQ1FBZ0lBU0VnQklTQUVCQUNWa25Bd1VHRDdGbFM0OG5UTi9BbkdWZWJNcVpQam9DQVlIaS9mcWZkWmZReldnMDFDOVRkdTdSRThtUWVDQXNMUTkvZTdkR3ZkMGVqbFJuYk9YN01FUHh2NWcvcVVONDhPYkIvMTBxVUtsSEVXRmJaSndTRWdCQVFBa0pBQ0FnQklTQUU0cFdBaG9UcFlvV3lvWENCTENoYk1qZmMzSnpWK1QyenBrR0pZcDRvVXpJWFVxZHlqN0pOMFdxb3VYUklTQ2cyYnRtRjZ6ZnVJbTJhVkNocFJDQk9udHdERGV0VmhidTdPODVkdUlMako4NmhRdmtTeUowck85eVN1Tkt4YXNpZlB4ZWNuQnhSdjI1VjNMN3pBTy9lK2FGaC9lcElsU29GZmIrUFhYc09JMThlVDZxL0tBbnZvYmg3N3hHT0hEc2RaUWZrb0JBUUFrSkFDQWdCSVNBRWhJQVFNSmVBQTFsaHBFcVpWQlgzY0hkQjJSSzU4ZWlKTi9MbXlrQVdHb0NUb3dOU3AvVEFTMi9mU0U4UnJZWmF2MlRLbE1tUkwxOU8zTHA5WDM4M1NmS3VtUG5MYU5TclUxVnBzbitlOERYcTFLcUVkNzUrOFBQM0oxVjVJTjc2K09MVnE3ZEt5LzNxOVZzRWg0Umc1RmQ5MGJoUkRUZzRPR0RFOE0vUnFINDFzQlo3OEJmZFVMdG1KYVJPbmR6Z1BQSkZDQWdCSVNBRWhJQVFFQUpDUUFoWWtnQXJqaytjdmcxLy8zQlREeGFxOCtVT0Y2YjVQUGNldnNUTnUwK2pQS1ZKR21vWEZ5Y3NXVGhaU2VtQlFjR1kvYitsQnBVV0tad1BucDVaMGF2UE43aHg4eTZTa2JhNlZmTjYrS3ovS0R4NjlCU3BVcWZBL29NbjhQakpVM1RyM0FKSGpwNkNJMG43RmNwOWl0RS9URmRhNkR5a3lhNVdwUnorM1hjRWI5NzQ0SXVoWStIckc3Vzlpa0VqNUlzUUVBSkNRQWdJQVNFZ0JJU0FFRENEZ0k5dkFJNmR1b1h5cGZQQXhkbFJWOFA5aDk2NGNPVWh3a0xEZFB1TWJaaWtvUTRNREVhMzNsK2hRclcyMkxaOUg0WU82bWxRVjlJa2Jrb0x6Y0kwcDR1WHJwTjJPWVZCbm9oZjBxUk9pU1JVYnNxa0VUajA3MnBsSHVMaTZxS3loWVNHaWpBZEVaaDhGd0pDUUFnSUFTRWdCSVNBRUlnekFtblRKSWN6bVNicnAxUXAzZUZLaXVYb1V2UTVJdFJ3NGNKVjFLaFdQc0plS0kyemgwZFMrUGk4UXpJUGR3UUdmdkNRL0NnejdXQUh4NkRnWUF3YU9nNW56bDNXWldFN2JFbENRQWdJQVNFZ0JJU0FFQkFDUWlDK0NIaG1UNGRDK1RJcGF3dytaeWpKcVd4YnJiV3BQbmJxcHM0a3hGaWJUTkpRYXdzcU00M3lKZkhpaGJkMmwvcThmZmVCQ3F0WHIzWmxja3BNaWlxVlN1SEN4ZXZxV0VCZ0lCbHpoMHY3d1NSQWg1S3pvU045Zi96NEdabDJ2RVdsaXFWVXZpcVZTcU5Rd1R3Rzljb1hJU0FFaElBUUVBSkNRQWdJQVNFUWx3U2N5Y1FqZndTYjZRTkhydXNFYUJhcWM1SEFIVlV5U2FEVzJsQWYyTDBLeFlzVnhQVFpTd3pxdkgvL01lYk1YWTYrbjNYRWpzMkxWVlNRaGIrdFZubjJIVGlHUW9YeTRNZnZ2c1E5eXNkbUlaTW5mbzFNRkk1dk5wVnAzS0FHRHU5ZGpSSERQa2Y2ZEdrTTZwVXZRa0FJQ0FFaElBU0VnQkFRQWtJZ0xna0VCWVhnM0tYN0NDVTdhWFpBWkp0cEgxOS9aVlBOam9xdjNyekRqZHRlVVRaQlU3cGlpNml0cktNc0xnZUZnQkFRQWtKQUNBZ0JJU0FFaElEdEUyQkxERGIxMEhkQTVFaDBaS2lzaE8yb2VoaGpHK3FvS3BOalFrQUlDQUVoSUFTRWdCQVFBa0xBRmdsdytMeUlLWlFDWlppU1RETDVNS1VpeVNNRWhJQVFFQUpDUUFnSUFTRWdCT3lSZ0FqVTlualZwYzlDUUFnSUFTRWdCSVNBRUJBQ0ZpTWdBclhGVUVwRlFrQUlDQUVoSUFTRWdCQVFBdlpJUUFScWU3enEwbWNoSUFTRWdCQVFBa0pBQ0FnQml4RVFnZHBpS0tVaUlTQUVoSUFRRUFKQ1FBZ0lBWHNrSUFLMVBWNTE2Yk1RRUFKQ1FBZ0lBU0VnQklTQXhRaUlRRzB4bEZLUkVCQUNRa0FJQ0FFaElBU0VnRDBTY1BKNi9NZ2UreTE5RmdKQ1FBZ0lBU0VnQklTQUVCQUNGaUdnY1hYTFppY3JKV29JbUoxMDFTSS9EYWxFQ0FnQklTQUVoSUFRRUFKQ3dCUUNZdkpoQ2lYSkl3U0VnQkFRQWtKQUNBZ0JJU0FFSWlFZ0FuVWtZR1MzRUJBQ1FrQUlDQUVoSUFTRWdCQXdoWUFJMUtaUWtqeENRQWdJQVNFZ0JJU0FFQkFDUWlBU0FpSlFSd0pHZGdzQklTQUVoSUFRRUFKQ1FBZ0lBVk1JaUVCdENpWEpJd1NFZ0JBUUFrSkFDQWdCSVNBRUlpRWdBblVrWUdTM0VCQUNRa0FJQ0FFaElBU0VnQkF3aFlBSTFLWlFranhDUUFnSUFTRWdCSVNBRUJBQ1FpQVNBaUpRUndKR2Rnc0JJU0FFaElBUUVBSkNRQWdJQVZNSUpLaEE3ZWpzZ1F6RjJwdlNUcVRLVlIxSjB1UTFLYTlrRWdKQ1FBZ0lnWVFsa0tGd1M3Z2tTWk93alpDekN3RUxFZEE0T0NMVEo1M2c0T0Jpb1JydHQ1cVl5SDYyUk1sc2dUcFo1aEw0dFBzT2xPaXhHM25yL1FRSEo3Y1k5OXZSMVFNWlRSV29jMVpEMGpSNVlud09LV0IvQkxLVi93SUZtc3loanZQcW1FQ3VtajhnVGI3NmFsditFd0pDSUdZRWtxVElqdUpkdHFCRXozOVJkc0JwdGUxWmRXUzBsYVFqZ2RveFNlcG84MG1HaENYQXdzMG5YYmVaSlNqeWdJa0hUb2t0T2JvbVE4SG1DK2szdjBmSk9TenZhT0NJRE1VN1F1TW9Bcld4NjUyK2NBc2xDMnFQSmM5YUNrWGJyWVpHRS80ZTF1N256NWpJZnZybHJIM2JiSUhhczhvSVhOODZGS2QrcTZYNm1EWmZnd1R0YStaUG02UHkwQjFJWHlpOFBRbmFHRGw1Z2hQZ0dRMlBERVVTdkIzU0FDRmc2d1Q4WHQvRDJhVU5jWFA3U0x5NmMxQnQzOWszMGRhN0plMjNBQUVlTVBIQUtiR2w3QlVINCsyRC8zRHExeHE0OGMvWDhLejJMVFFPWm90TGlRMlAwZjY4dW5zSUhoay8xUTNNVW1hdmdwYzNkaUVzTE14by9zUzQwOG44VG9YQnlTMFZGUS9EL1NOejFLZ3RmK05aZUhicEx6RFk0cDMreHNVL3U2SndxNlVJOVBWQzByVDU4UHpLWnZCSXp5VlpSbHpkMkI4QmJ4N0J5VDJOR3NXNHBzd09ma2cvdjd5UnRJbjFrS1BTY0lDbVdCNGVudyt2Y3l1amJHYkdZZzJRcDJaLzBtQm5RNzY2UTBsYjdvSW41N1pHV1VZT0ptNEN6eTc5amF4bCsrTHFwdjY2anZLVVhhNWFQeUo1NWxKMGs0Zmk2dC85RUJMc2g2THRWeVB3N1JNa1NlVUpyd3Zya1NwblZUZzRKOEdsdFIwUlFQdHpWQjJCbEo1VlZUM1hOMzhCMytkWGRYWEtoaEN3VndMR250TjhiK1Z0TkIzQnZzL2g1SkZlb1hGSm1nYjVHczJFVTlLMENIenpFRmZvMlYrSXRIOTNELzRDUCsvYjZ2bC83bzltQ0FueXMxZVVWdGR2WTg5Sy96Y1BrSWRtb3ozU0YwRnd3Q3RjM3pJRW5sV0dxWGQ3aHFKdDRYVit0ZFgxdzl3RzhlLzRHajNyT2ZsNlhjUUxrbDJnY1NLUnhBVUZtdjVQOWZrZS9YNjlMcXhWczUvWkt3NGxnWnZrbFdOemFOK2ZOSXV6R1VGMER5Uk5sdzlQVGkzRmcrUHoxSHRIZTIvdysrWEt4Z0VJQy9GSHZvYlRTV09iSEQ2UFQrSEdqbThRRmhwaWJyTVR0RnlnejFNRXZYdEdiUExDOTlsbHBNeFpHZGUzRFFQUGdPUnJOQTF1S1QwUjVQY0MxNmpmK3FsNHA0MjQvTmRuQ0Fud1FkRU9hM0Z1V1ZQa2JmQUxuSk9rZ211cUhQQjVkQWFPTHU1SW1yNGdIaDJiaDBlbmYxZnY2QnhWdjFIWDQvSEpYL0g0ekhMOUtoTnMyK3doMTUyOUU1R3p4bmRxYXAwRlpMK1hOL0RpeGs2a3lGRVJTVlBuSm1INUlZTGZ2YVFmb1lZMDJVTndZVzFucE01YkJ4ZldkTUR0UFQ4Z1hZRW1xdE5oUWY1SzhMNndzZzJ5bE94SjhOMlJyZndnbGUvczd3MlFxVVEzdUxpSFA1Z2pvL1RzOGw2Y1dOZ1p6Njd1eC9HRm5jRGZKZGszQWQrbkZ4RWFFb2hrV1VycFFQQnY2L1c5SXppOXBCNmUwVU12ZGQ3YTZsaG9VQUQ5M2pyaDV1N3ZrVHhMQ1p4ZDFnalBMckpnWFFQdTZRckFMVVUybktFeTl3OU5SY1lTWFhUMXlZWVFzRmNDYk9KbjdEbWR0VncvOWJ3L3Q2SWxnbnk4RkI1SE1ndTRkM2dHM1VOMVNWZ0lobnZhL0hoNWN6ZFNacTlBczBpRjRmUDBnZ2pUVnZaRE12YXNkRXVlaFpRT09YSG05M3A0ZEhJeG5Famd1Yk4vQ3Q0OXY1YW9oR250cFFnSjlsZWJvYUdCZUhScU1RbS9nZXI3clYyajZYM1JFZW1MdEZMZldaQSt2NklGTHYzWkJSbUt0Z3ZmUndZaTkrazN6OEpoV3BKMU5BN095RkxtTTl6WU9neDhiNFFFdlZQNU1wZitEUGNPemNEcHhYWGc0cEdKN28wQ2FyOXQvaGNHNzF0N1NmbFVHYTdKTXBIbzV3RC9WM2VJVTB2NFBiOUJmYXhOQTVNdHlGeW1qMG5kWSthbkY5V0VlNlppdUhkd0tzNHRiNDYwWkZiQ0xMT1c3WTlMSkV1ZVc5NVVtZUdZWTNKc1VpTmltTWxzRGZYYkoyZm9BVmxId1dPdDMrMWRZL0RtN21Ga0lodWp3T3lQOE9yMlB0VVVmb0NHQkpMbVFlTklBclkzUWtrTEVmenVGWnhKYThFcEpOQVhvZlRERGZKOVJnL2JVTEEyZzMrNGdlOGZ4c0h2WHREb0xZWEtHOWwvL09NTThBMm1lcmpjaThpeXlYNTdJa0RUVEErUHpVWDJ5c09VbHBtN0hoTGtxMlpJTW4zU21UVFE3alFkdFVNUjRkOWZXR2lRK2wzeUtKdTExOEYrTDBtamxnYXVLWE1nZWRZeVN1UEFtVi9mUGFqS3lIOUN3SjRKT0xtbE5QcWNkaVl0dFArcmUzUVBoYWhuUFRNS0lhMVV6bW9qQUhxUkpxRUJLci84dkcvOWk1dzF2MWN6UWJ3dHlib0lHSHRXK3BPU3pQZlpKUlJwdDVZRXpGL2hTd01odDFSNXJLdmhjZHdhVnRJRStySk00a0cvNHlUcWJDeXZGRzY5bkxTenorbjNuRFI4SDJtWkE5NCtmaS83YUVpODFwREFUSXBIRWpEMTd3MVdQcWFvVVo2VVB3R3FuSWJrSkZ0T0wyL3RRZTVhUHhDalo4bzhqTFh0U1ZMbnd1djdSMVczM2oyL3J0Nm5wdlF4SklCa1F4ck1oUGk5UmlDeFpRMDJ6eEE0a1gxN2tqUzVVYWpWTXJLUENDUEdQa3A0TjZYT3VNNWpsa0R0NUphQ2pNOS9Kck9OQWZBbXdUbHBtbnhJbnEwTVhqODRScDE3aTdRRm0rRGFwdkRwRWxNN29IRjBwaCtvS3oya2c5VFVDWS82K0dMd0tJYzJUSzFHOGdrQkhRRTJ6UWoyOTBhS2JPVklNMzJZdE0yRmtJU21uYzZ2YWtjRHZ3NUtZTlpsam1TREg1YmVOM2ZoT3RuUlNSSUNRdUE5QVJxQThqTTY0bk9hRlNnT0RvYXZsYlFGbStITi9lTnEyanQvbzFtcUF2L1g5K25sNkViVHdsWHgrTlFTd1dwbEJJdzlLeDJjM1Vqck9wT3VyeU9aZmt4UjcrVjN6MjlhV2NzdDA1eGcvMWR3UzU2TkZIUlB5UFFnTlprRmtpbkNIODAvcWx4cFM4c053T1gxUFpYU3NHQ3pCUi9sMGU3Z2Q0bGpCSWRHM25lRGZOSGVlcDNWWnJQcFQ5WklheHhja2E1Z1U1cVZtcTc2d2dvckp6Sng0YVJ4SkxtT0J0dXhTaVFQc2puTitaV3RkSnIrV05WbndjS0dUejRUS3c0SmVFUGE0SGZ3ckRFYVBnOVBrQURkbEtaKzJFbUZWUDYzOTVPS3Z3MzRnV25LYU1zdFpWWmtMa0ZtSFR4Njg3NUJtdVluTkxKN1NOT0pYNUxHa0xUTlpESVNRSFZKRWdMbUVIaHdkQjVwbHplcG9qeVQ0WklpS3pMUVZCMDcwbmpmM2h0dGxUNlB6eXFIbEF4RjJ5aHpKTlpjUDczOGQ3VGxKSU1RU013RWd1ZytNUGFjNW9GcnRncGY0QTI5Rjl4U2V5b0UvTDVJU1U3ckdRUGUwdUMyREo2YytVTzlWTitRQW9aOWFnTDVPUzhwUVFtd1RXL3F2TFZJSThnenlyN0tweVRpczlLTlRCTHkxSitDaHljV0tITTZiakFyMEp6ZDA1SHBUakg0ZUoxTDBENVk4dVJzYnBDRDdNTWZuMTZHVko0VjFic2lsTXhUUDBvOEV4TWNnSFNGbXROc1puWVNHSjAveXFMZHdWcmFyT1VIcUh1RDdZdzVlZC9aVC9mTFFIaGRYRWVhMjlKNGVIU09UZDhQckFSOTgrQTQwaFpxQXQ4bkYxUWZYMTdmUWJOUll4QkN5bEkyLy9BNnQwcnQxLzduVDA3UEdVbkJ4WU56MXZ4SGw5aml3ZC83Rm5IN2tzekZMcEtaVEVFeW01bWlGTERSbFkzcjQ0NU9UaW5HbUhPU2x6ZDJ3NWtNNmZsSDlPVDBVb0o0VEZYanhPWVpkRk8rdW5lUWhHSCtGd2FmSitkVVoxbDk3K3QxZ1hlVFU4TmJzcXU1VHJiV0Q4S25CZ25tL1NPenFLZy9hUVIzSzFzdDFsamYyZitUbXFwbndkclArNDZhaWpmV1hyNFlHWXZVaThJWjhlUFFMY2Jxa1gyMlQ0Q24xOWlHbjUxaFdVUE5qbENzcldZN2YvL1hkOVZ2NitubERUUkY5d0wrTCsrb2FTV0QzK1dMNjFTRGhyUVRUL0h1eFRWeXNqMUkzc3ZGMWJUYzh5dWI2TGNjWlB1UXBBZENJSVlFZE05dHVqODRHWHRPYzJRRUYvZTBTcG5DZHRMK1pGLzc5c2xwTlZYTG11dm4xN2FBVFFkNFlPcEt2amRzWi8zMjhla1l0a1N5VzVJQVgxZWVTbmNtWHlXWHBPbmdTTzlkbm5tTytLeDg4K2drM2oyOVRJT2dUMmc2Zno5ZVh0K3VoRzkyVU9USWFQNnY3bHF5V1FsYWx6L0pHdjR2YjhNalUzSGxsUGlJSE45WVlSaFJudkh4T2srekwwZklVYk93TWdjTWVQMkFUR0V1MG9BeFRBbVVySUVtZ1VnTk50N2NQNkc3TjF3OE1wQWZ3UjR5amYxWERXS1MwaG9icis4ZG92ZlV0UVR0dHlWT3pnNysvTjVreDBST2JQcnlqdDYveVdqUTllTDZQL1RjMk1Nb2RlL2R0elQ0VGtwK0ZYNHZiK0lkT1lEeXdJejUrZEZ6SnBnRzQ1eFlPTmRueWM4V053cm55Yi9YNTFjMnFuZTV5cGpBLzJsYzNiSlpMS2FKUi9xaU5Lb2JqcnNIcHNUN2FKVUY2Z3hLb040U0NWSitiRmlzcTVHY1EzWUxBU0VnQklSQWRBUTRpa0tPeXNOeFkvdFhaRmVhZUFTeDZQb3R4KzJYUU1vY2xjaWVPRGNwWnZ5UjZkUHU1TWpJem9tKzlnc2tFZmJjb2dKMXFweFZWUGc4amoxb2ZVa0VhdXU3SnRJaUlTQUU3SkVBaDl4akp5T2UvWkVrQk95QkFNKzRweVAvTXVlazZVbXJ1b2xtQU83WlE3ZnRxbzhXRmFpdG01d0kxTlo5ZmFSMVFrQUlDQUVoSUFTRWdCQ3dUUUpteDZHMnplNUtxNFdBRUJBQ1FrQUlDQUVoSUFTRWdHVUppRUJ0V1o1U214QVFBa0pBQ0FnQklTQUVoSUNkRVJDQjJzNHV1SFJYQ0FnQklTQUVoSUFRRUFKQ3dMSUVSS0MyTEUrcFRRZ0lBU0VnQklTQUVCQUNRc0RPQ0loQWJXY1hYTG9yQklTQUVCQUNRa0FJQ0FFaFlGa0NJbEJibHFmVUpnU0VnQkFRQWtKQUNBZ0JJV0JuQkVTZ3RyTUxMdDBWQWtKQUNBZ0JJU0FFaElBUXNDd0JUWkZtSysxaytVQ0pRMjNabjQ3VUpnU0VnQkFRQWtKQUNBZ0JJY0FFbk5JVmJpa2toSUFRRUFKQ1FBZ0lBU0VnQklTQUVEQ1RnSmg4bUFsT2lna0JJU0FFaElBUUVBSkNRQWdJQVNiZ2RQL3d6SGduRVJMd0JzSDBGNzlKVEQ3aWw3ZWNUUWdJQVNFZ0JHSkVnRlZjb3VZeURWa29aZU0vU1VJZ0VnS3V5Yk5HY2lSdWRtdGMzYktKRFhYY3NKVmFoWUFRRUFKQ1FBaVlUb0NGYVVmVHM5dDF6aERxdlFqVWR2MFRzTGJPeTFqWTJxNkl0RWNJQ0FFaElBU0VnQkFRQWtMQXBnaUlRRzFUbDBzYUt3U0VnQkFRQWtKQUNBZ0JJV0J0QkVTZ3RyWXJJdTBSQWtKQUNBZ0JJU0FFaElBUXNDa0NJbERiMU9XU3hnb0JJU0FFaElBUUVBSkNRQWhZR3dFUnFLM3Rpa2g3aElBUUVBSkNRQWdJQVNFZ0JHeUtnQWpVTm5XNXBMRkNRQWdJQVNFZ0JJU0FFQkFDMWtaQUJHcHJ1eUxTSGlFZ0JJU0FFQkFDUWtBSUNBR2JJaUFDdFUxZExtbXNFQkFDUWtBSUNBRWhJQVNFZ0xVUkVJSGEycTZJdEVjSUNBRWhFQU1DdzRiMng5bzFpNUEyVGVvWWxKS3NRa0FJQ0FFaFlFa0NqazVPS2NaWXNrTHJyWXVYSHBja0JJU0FFRWc4QkR3OFBMQjA2VXlVS0ZFTTFhcFZ4TE5uTDNEMTJrMnI2V0NPN05rd2NzUVg4UForaGNlUHZheW1YVmJiRUg1Tmlackx0TXZEYXp6YnlUclBwZ0dSWEFsTlFKWWVUK2dySU9jWEFrSkFDSmhCb0hpeFFwZzFheUtXTEZrTkh4OGY3Tmx6RU1PRzlVZUZDcVV4YnR4VTdOaTUxNHhhVFN2aTV1YUsxcTJhNE55NWl6aDc3cElxbENWTEp1VEluaFU1Y3ZCZk51VE83YW5ha2p0M0RuaDVQY2ZGaTFkdzkrNkQ5My8zY2ZQbUhiWHQ5ZlFadUd5TjZwV3diZHR1UEgveDByUkdKTVpjTEV6TDB1T21YVmxaZXR3MFRwSXIzZ2hZclVCZHIyNTFsQ3IxQ1ZhdC9nczNidHlPRklnblBiZzdkbXlGQ3hjdTRlK04yeVBOQi9EUVg0YXpVUUNTUTNaSUlMcjc1OEg5TXlTcythSkF3WW9KU2lmOGVmQXBObTc4QitmT2h3dHdDZHFnQkQ3NXdBRTlVYWRPZGZUdE54d1BIancyYUUzR0RPbVZZSjAvZjI3OC9QTWM3RDl3eE9DNEpiNDBhVndYYTlZc3hJc1gzcmgwNlJvY0hSM3g4T0ZqSlNUZnUvY1FkKzdjdzkxN0QrRHI4dzRqUmd6RTRzV3JjSkh5NWNpUkJibHplY0xUTXh1eXZ4ZStNMlpNaDF5MEwwdVdqRmkrL0UvMDZqM0VFazIwelRxc1NLQjJkWE5CMjFiTmNQVFlTVnk3L3ZHc1I4TUd0ZkJKc1NJSURRM0Y0U01uc00rRTMxbnFWQ25Rb1gwcnBFeVJISThlUGNFZnE5Y2h3RC9RNEZwbHk1WVpiVm8xaFp1cks2NWN2WUYxR3pZYkhOZDlpUWVCT2l4akVCeHlCaUVzaUNTSXkwa1E1bXZDVERkZnc0TCswS1FNUmVnelIyaHV1QUtodWxhSGJ6alRSeUUvYU56REVQcllDWm83TGpZbm5nem8zeE1wVTZhSTBMSHdyM3ovTC8valQvWEZ5Y2tSYmRzMFE4NmMyZFc3Wk5XcXYvREU2NmxCT1ZlNjFoMDd0RVRtekJuaDUrZFBzdHkyS09VK0xzenZoRTgvTFFZSEI0M0t1Mjc5WmdRSDg0L2lRMnJab2hFS0ZNZ0xmLzhBZWw3OWpmc1BIbjQ0R0dHcmNhTTZLRjY4Q1A3NVp6ZitPM2syd2xIVHZscXRRSDN3d0NZU3FJdVRwbVVheG8yZkZtbHZCbjM1T1NaTitwYTBIOWRRc2xTdFNQT0pRQjBGR2psa3R3U2l1MytzUmFDZU5uVXMrdmJ0aWw2OUJ0T0RlcDNkWGkrMmsxNjRjQ29PSHo2QmFkTVgwQXVFM3ZTUkpCYXNSNUM1QlF2V0V5Zk9KS0huUHpnNU9haVhTeVJGVE43TkE3RkRoelpqNU1qeFdMcHNqY25sSXN2WW9INU45TzdkV1dtcytRVThhUEIzVWZZdHNucHNmcjhWQ05Rc1NIZnAyQWJEaC9SSDlteFowS3BkRDJ6ZXVzc0E3Ymd4SXpCMGNGLzFXK0xCbEtPakEwYU9ub0Nac3hjYTVOUC9rb1dFcFYzYi9sU0NWVkJRRUp5ZG5kVmdyM25yYnZCOTU2ZXlmbEs4TVA3WnRBb3BTT0FPRGdtQnM1TVRmbDI4QXYyL0hLRmZWZmgySEF2VW1rLzk0RnFIQk40M1lYQWdtWmlUMzBwWGFMeWN3cjhZKzU4RVphZDJ2bkRLQklSNDAyUkRLaUQ0WmhpQ04zaDhFS3Jkd3VEYzZSMGNVOUt1TjJUaGswcURvQXRoQ05ucWJsTkNOY3RvMmJObk1hREF2NE0wOUl6YXRHa0hXcmZwUmM4YlI2eFp2UWdOR3RSRVVGQ3crdjc0OFZQVXJOVVN0Mi9mVTJYZDNaTml3L3JGcUZLbFBONis5WVc3ZXhMNCtyNUR3NFlkY2Z6RWFZUDZ0VjltVEIrUHp6N3JSSFVHSVNRa0ZFbVN1R0hEaHEzbzNLVy9UcWhlUk0vSlRwMWE2Yzc3NnRWcjFLclZtZ2IyVjdYVjZEN1RwMHVMRXllMkkwT0dkQmcwYURUbXpmOWRkeXdtRzN6N1dsMHFWREFmQ2hmT3A5clZyRm45S052WG9rVURkVHh2WGsrVUpEdENTVUpBQ0poT1FPNGYwMWtsZEU0MmlWaFBMNTVKazJiaTV5bHpvaFU0V1FzMGFQQW9EQmc0RWwyNnRJSFhrL080ZStjazJPNDZ0cWx5NVhLcUhaWVFwcmt0VzhuVW8zbUxicXE5VjBrcnVXenBiSHI1c2hwUFVud1N5Sjh2RHk2YzJvOVoweWFRWUVUU29KSEVlZnArM2czbkxseEc3b0psVWJCWVJUeDYvQVJEdit5RDFLbU5sK0ZxUm44elJKa0NEZnY2QjZSS254ZkxWL3lKS3BYTG8xdlg5cnF6VEpzeWxvU2pKR2hHUW5hMlhKL2kySWxUNk5xbExXclhyS3JMRXk4YlNjTGdVaVVVUWFmQ0VEalBIZjV6M1pYdzYxelpQMXczRjBrak5FWDg0SlNlQk8rbExnaGE2QTYvOVU1d3lrMWE3VndCdWhLYVVuNXdwRnZRNzFjM0JDNmd1cmM0d0xrd3lkS1pJaDhjNndwYjBVYWx5bzJSUFVjSmc3OUprMlloTEN3TUsxYXNWeTFsRFhIOStqWHdCeWxCVXFYT2krSERmd1RQU1AwMGFiU3VKNDBhMWdZL1QzNzdiU1hTcFMrSXhvMDd3OFhGQldQR0ROZmwwZCtvWGFzcWV2YnNRQVA2NHlUUWw2QUJXaW1jUEhrT1RadldBeC9qVktkMk5iUnYzd0xidCs5RnhreEYwS1BISUNSTDVvR1pNOGZyVjZYYkhqaXdseEttZFR2TTNMQktnWnBIS2p3RndGcVlQSGx5NGhOU3d4dExmS3h3NGZ3cW42T2pFMnJXckdJc20rd1RBa0xBQ0FHNWY0eEFzYkpkR2RLblU0TGxwSW1qNktYUUFVMmFkTWF4NDZkaTFFcTJWZTdWZXpEWk1UOGpZZG9kblR1MWpsRjVZNW5idEdtS2xTczNHRHNVNjMyelp2K0t0V3YveHNvVjh5d2kvTWU2UVhaVVFVYlMwTEZOZTVzT3ZiRjB1ZkdaaDdKbFNwQVdNU25tTDF5S2x5Kzk4WkJNTjlhdTI0ejA2ZE9pZE1uaWtkS3FXYU1LSGp4OGhOOSsvNE8wejZHWU5uTyttdDV2MmF5aEtwTW50eWVLRnkyRUV5ZFBZL3VPZjhFYXhVbVRaOEZCbzBHTFp1R0tzMGdydC9DQnNHeUIwSkJXT3ZpMFc3aldtT1Rob1BNT2NNcEt3ckZyNUthakR2bElDSDhZQnMyVDhNR2c1cFlyUWxsVG5UczR2SVVrY1RubG9UeTNTQzczZm04c2Y5VU5vZTlJVTUzTHRnUnFZOGc3ZDI2dG5qUC8vbnRJSFc3VnFySFNFTStkdTBScGp1Zk5YMExtR1hkUXFWSlpwRXBKS25wS0xWczJVbmtXTDE2cHZ1L2VjNEFzRHE2U28zVlJwRXVYUnUzVC82OXg0enBxUnVTWFgrYmkxZXMzNm0vZXZOL0o5TU1CaFFybFYxbFp1S2FmRFFuUUM1VzJlK1dxRFRoOStnS1ppQlJGM2p5NTlLdFRNeWE5ZTNmRW5UdjNEZmFiODhVcUJlcFdyUnJoK2ZPWFlFZ3VMczdLZTkxWTUvZ0dUWm8wQ2ViUFg0b25UN3pvWlZQWFdEYlpKd1NFZ0JFQzV0dy9xVk9seEcrL1RvZjN5MnZ3OTd1SEo0OHZVQlNITHcxcVoxdTRHOWVQcWVOdlh0L0UrbldMa1MxclpvTThQTVYvL3R4ZStMMjdDNSszdC9IUHRsWEtvYzBnVXhSZldLdkI1NTgvYndyVnMwOXRlejI1Z042OU9obVUrdnFyZ1hqMDhKdzYvdnJWRFN4WlBCUGNCMXRJczhuaDhPN2RremgxY2lldVhidUZUcDM3cVplSHVXMHZWcndHMlNrWFIrdldqYzJ0UXBYTGs4ZFQyVUxHcGZQZ2VwcStYYmx5blpvS3RvUkdQVllkdHFQQ2JBZGRxVnBqYk55OFBkSmVmL3BKVWFXRjFMZEh2WFRwQ2drd0dtVEpiSGlmYXl0aFIxVzJtMzd3NEJIZXZTTXRMeVdlZW45Q2c3eWNudG5WOXl5Wk01RWl6WTNzdFVuYWZKOHVYN2xLK2QraFVNRndRVW03UDY0L0hWS0ZBb0VhYU42K0YzcnBoS0V2YWR1VjVPdGtobmE2dXJhUU5PV1lncjdwKzlSU05TR3ZTQURYeW9WVWhVTnlEVUpma0xTblRTUkhoN0hwUnpyS2JNT3BYTm1TS0Znd0x6a1cwMkRvOVd2Vms2ejAzUGYxOWRWRkhtSWI1M1BreEp3OGVUSmxpc2FaMkplQ3I3SCtkYjkxNjQ0YVRPZjB6UEVSa1YyNzl1Tzc3eVlibUc3NCtZV2JETEg5TlNmMnllQnQ5dWZRcHYvK082dE1ROWlXV3o4Tkh0UkhhY1RYcjkrcXY5dXNiYXNUcU5uYnUxaXh3amgyN0JTMi9iTkhqWGEwMDlJUmU4aWprSmN2WDRFQjc5MTdSSm1Kc0xtSUpDRWdCS0luWU03OU0yUEdlSnBLYTQ0dFczYlM5TjBQNE9uNTBhT0g2TFNlYlZvM29RSHVGTEpyQ3lINzNYRktpMW1YbkVkV3IxNm9Cci9jS3JhVFhMWnNqcHJhWlJ0Y25oN2tXYWxmZnZraCtrWkh5TUVha2JObkwyRHExUG4wUW5jZ240dVJLbUlFWit2WHR6dE5HdzdEclZ0MzhkVlhQK0t2djdhQk5hdVQ5S1liSTFSbkZWOVo4R0NOZEkwYWxSQVFFS2c0L2taMnBMRk5iRy9OR3AzangwK3JLVkZ6NitNcCtpVkxWcHBiM09SeUxGU1BHVE9aWW13dkJOdURTN0lPQW1uSkZDUTBsRXdoQWo5b1ZMVUNGQ3ZBb2tvYTBpTHFwOWNrZUxFdHRYNWlUYU0yM2FHb01QN2t0T2pxU2s1NzhaZzBTVU1RUm4wMGNDWjg5MTRJZG9wRVEwM0Nzb1lWMmgrd2hMZllUd01INS9kbG5FT2g0ZTYrVjFocnV4VHFSOGVqTU0zVzVyUG1UOVpHODdWYnZYcURRVE41b0tWL1RUbTBKKzlqS3dST0tWT1N2VHdKMnEvcDJhUk56NTY5VkhuWU5qcGkycmhwdXpKNTB4ZVdhOVdxcHVvNHIrZXd6dWZnUDIzaWR4Vi8xLytORmkxU2tPeXNXOUtNMkNaeXJyNml6V3IyNTRkZnJ0bFZXTFpnZFlxbG1qeTVoK3JnMjdjK09IcjBsRExyNE9scC9aUTVVd1p5V2l4R2h1Um44SUttbmRqNzM4M05UYjJZOWZQSnRoQVFBaDhUTU9mKzRhbXloZzFyNGRTcDg2UXQ3UStlbXUvWmF4QnBBdnpRb1VNTGRSSzJSUXNPRHFiSU8vMHdmY1lDZk41bkdEMWcvNmFwdGlJNis3YUdwRjNtbCtpSUVXTlZubjc5djZLQjgxTWFTQmY2dUtIUjdObStmWTlxeXpmZmpsZDJlaWxTSkVOeEdwQno2dFdySXoyazN5cm5tSm16RnFGcnQ0RzRmUG1hc3VsamV6cHJTeXhJai9wMkNEMzdmbFZtYklVS1YwYUtsSG5Jdm5pWFJaczZiOTRTY3VqcGJGYWRiTmRjdFdwNTdONXp5S3p5TVMxMGlNeitPQVFnMjQ1Yldxam0wSCs4SU02eXBYUEVYanVtRnlhRytUbGNJZy9tY3BFMk9nVnBKemx4aEloMGFiV3FXNURweUdNYVFQcWpHSmw5YUZQQkF2bDBBM0h0UHZtMFBnS3NjVzdSb3FGU1hodzhkRXpYUUo2UjRCbW1Za1VMNnZaRjFCRHJEcGk1d2IrWDFxMGI0Y3laOHpod01QemNyT0ZtWVR4ZnZseTZXa3NhTVVmNjl0dkJTaENmOU5OTVhiN1liRmlkUU0yam5EZHZmSERvOEhIVnIzVmttOFgyV2p3OXJaOHFWU3FucGczV3I5K2lkaDhra0s5ZXZRR2JpMGdTQWtJZ2FnTG0zRC84SU9TSDFObXpGM1dWc3owY2UwVXZYTGhNZWVibnpadFQyYUw5ZC9LTUxzOG0waWl3WnFBc1RRbHlHajloT3BLbnlJMC82ZDdteE5vSjFzU3krVlpNMDUwN0QzUkZXQVBCS1JXRjVrcVpJZ1dGWU1wQW9keWVHQ3dvd2xPRjMzMzNrNjZNTld4b0JlbU5HNWVydU02MTY3UUdhMkhpS3QyNWUxOU4yZWZPN1JualU5U3BYVlhGdTQ0cXVraU1LNDJtQUF2VjNidC9TYk1hczVFL1grNW9ja2QvbUFjRmJISzArTGNaNUFCVlI1bkExS2hlTWZxQ2tpTldCSGJ1M3FjY3Y3NGFOcEJNUXpKaXhpL2pkTE5KWFBFTnN2VS9UYk5OeFVocitIbXZMc2hGejV0NXMzOHk2N2tRcTRaSzRSZ1RxRm1qTWpKbFNvOVZxLzVXejNOdEJXdldiRlQyemlQSUxKQ3ZPWnNIMXFwbEtNdHA4NXJ6eWJMaDNMbVRhVURzcEdieXRIWHdiQ1JIL3hnNThrc3lOOHhDczVYZDBMWnRFKzFoOVZtK1hDbUtQbEpEaGVyVVJod3h5R0RHRjZ1YVpFaERIc0pseTVhZ2wyc0F1bmRycjdyRFJ1bXM4ZUxwNmZrTGZ0ZDFzVjI3WmlyK1pmbnlwWlFORGg5Z1RSbWJpN0RaQ01kRWxTUUVoSUJ4QXViY1B6eFZ4b0l4QzcvNmFkbnl0ZW9yaDFMakVGb2M4MU0vc1ZtV05yU1JkbitYem0zb1lmZUZXZ1JFT3gzSWZoT1dTRHpMeDlPSTNCWU9xNlNmdG16ZHFmODFRYmF6WnMyRTV1Umt4WkV0V0xCanpRN0hhYTVSc3lVOTZ3emJHMWNOWlArVTNyMDZZOFRJc1RFNkJadllqQnc1TGtabExKSDU2clViR0REZ0d3ckh0WXpzdDk5UkNNWGg1Sng1MnVTcVdZaXVVcmtzQ2M5TmFNYXpBSGJ1M0l0Um95ZGhPb1VlWkUwMVJ4VFlRNDVVOGNYZjVJWW5vb3pqSnZ5Q1NoWEtZQ2paclBJZk96TStmdktVVEVjK1BFKytHUHd0dG05WmpSbFR3MzlqRjJrYW5rT292YUhaYWtuV1M2QmJ0N2JxdmJCNTh3NkRSbTc0YXd1WjJqVkE4K1lOS0ViOWNXWFhmSWxzNXprMjlKczNIMHc4REFyRjRNdllINzlHeVpMRjhOTlBzM0dRb241bzA4NWQrOGdzYlpXS0JuTDkraEhsOUhpQm90SVVKM05EL2oxeCt2Nzc0V1M3N1VjenJZdTB4V0w5YVZVQ05VOGxhdTFwdnZxcXY2NXpiQnZKNWgwOFRmMklscTlscHlJV3ZDazZDMDB0dDlUTHA2R3BaQ2V3MllnMnFManVvR3dJQVNHZ0NNVDMvY09DT0FmZjF5WjJXcHczYjdMeXV1WTQ4N3h3RTl0VW02T2gxdFpwUzUrOWVwSWdPMklBQ1lnOU1YNzhkTlN1MHpiZUJUbjJwQjgxYXJBU0ppTU9nQ0pqeVRHd1BUeVNnalhjQ1pGWXFPWVpCMWFpakJvMWhHWXUzV21BQnhXN2xrMEs3dEZDTW5lcGJleXR6NHZlOEFxTkN4Y3VWK0d6K0VYNjc3OEhsYVA3V1ZyZFVaczRBZ3FualJ0M2tCS25MUll1V3E2K3kzK1JFMkJIUXI2ZjlXMVJ0UkViOU8ycUk5YndpT0lQVjY3ZUJBMGJoSnQ4SFQzMkgvYnQva3N0QnFUTnk0NktKY3ZXUXYxNnRXakJsd0E4ZmZZY2Y2LzduWnh5YjJxenhNdG5xQTh0eU9KQUFvYitITDc3ZTZmQjRBL1BNb1BHaEpESk5mbkdLUnRwL1FOSmFYL1ErekpCRGdqajhVTUV5Y3VCODhSZXZ0US9hN3h0NThuamlZb1Z5K0Q4K2N1MGF1cUhlNHNid0xPUDdUdjBvV3RlU3kzYXdwWUU3R1BESzd2ZWVoK0htaFV1TFBkeDdIR3RIWFg2OUduVUxKcld5ZEJZWjlxMWJVcW1hMTJ3ZS9jQmpCMzN5MGRaT0Z3b2E2cDVadlcvLzg0b0FWbzVLdDUvaUhKbFMxR2JTeXQ1OGZLbGd3WmxwMDhmUzdPdW41bTFtRm1FeTJwUWI3eC9hZDI2cVJwSlZLL2VIQ2RQbmRPZGY4amdQcGd3NFJzS3RWSU9heWljRXNjc1RKMDZKWDc0NFJmbzI3NndnZm1CQTMrVDJVZGpFYWgxOUdSRENCZ1NNUGYrWVEweVB5QXpaalIwRU9OSUc5N2VyNVcyazgydU9NNG8yOVM5ZWZOV25aaFh2MkxOTnR1MWNXclpzckhTV0gvNTVTaGFrU3JjTklSWFc3TmtZcUdQVjNoazh3Lzl4Rk9PQlFya3dkQ2gzOGRvaVdzT0o4WTJvS1lLbi9ybmpMZ2RFaEpNejZtakpCUk9pbkVJdkloMXhlWTdoNzNqRUhxbUNwSHNqTHB5NVYreE9XV3N5N1p1M1V0RkJ6aDIvSXh1RU1JYTVoelpzNm5aanR5NWMxSzRyV0swU0V3blpTcklOdlRzUUtuL1BqSFdDUFlIMkxQN1Q3SmYzNml1czdFOHNpK2N3Qmt5eStEN09YL2UzR0JOSUtlQ0ZJV0Q0dzgvZlBRb1BGTWsvNyttWjhLS1ZldlYwZTVkMjVFOWRYSnMzbVk0YStUMTlEbVdMRjJsOGt6NDhSc1MzaDJ4OVIvTCtoRkUwcndQdTFWRUQxb2hNVVV3TkUvRHhTUVYrWU1tMy9RamYzd29RRnYwQ0F1amlCNmFkQ1E4cy96TWZvZ2trSFBrajVCNzczTUdVellLZ09HUVBoUWtmNGNuY2xMVUpLUElIemZmQzkzYS9UYnkyYWhoWFJwb3V5dlRpY2lhdk9YOXdrQkZhSGFvU0pFQ0tvYTBWbmhtcC9GaXhRcWlJR210ZVZWT1RqbHo1bEJDOSswN2Q0MVd5VDUxVTJteHJ5YzB3OUdiVmxibDk1S3h0R3YzZnJXYnJSYktsdjJVZkdpdXF3RWNDOVpEaG55bmZzZmFjcnlRSU1mclp6T1ZyVnQzYTNmSDZGTi8vQldqZ3BiT3pDL2dDaFZLcVRBbkVSOStITUNicDI1NW1wcFRDd29XemxQSVBOclJUK2RKcGM4MmxheTladk1SU1VKQUNIeE13Tno3aDdWSGJFcFZtYWJPQytUUG95cHVTMUV6ZUphSW5RRTU3ZHk1VHduY0hJcUlFenVTRFJ6WVUwMnRhV09UaG9XRktyczZyYU54aC9ZdFZReGJWY0NDL3gwbm9Zc2ZwSjA2dGxLMTVzcVZBLzM3ZDBkUmNwRGhrRys4aXRkbnREcGZ1N2JOb3p3cmEyQjI3RmhENGV0aS8xSm5IaHk5bzM2RGpna3FUSE9IVjVCQXJYVW1qUkxBKzRNY0lXVjlaTXRBbTFLQkJmTHdkV09iYW4zVERCN2tzUFo2eDg2OW1EdHZNUTNzeHFsNDNUMTZERllMeFVSOG54aHJCdGZIaTFLd3JhZWtxQW13dG8rbnpYdDI3d2lPK01HMnNXM0psT1lwQ2NJbjNpL1p6SVBxSWJUUVM4WHlwVCtxeklsVzArdlFyZ1VtamgybEZvUlp2V2JEUjNuY3laOWkrSkIrR05DdkIwNmZPWWU5KytQSENWYlhrRWZPQ0tNSWJFNGxXWUttdlJTUXdybFlLSUlma0pRYzhGN3c1WGpVeFVrbHJSZVhPdVNHbzFvbEVWbkNUYmZDYUVFWEJ4SkZRbTYrMTExU2tXQVNuSjA5TlFoTFM5STFwd0wrVUJycVd5UloyMkRpMVFoNTRMcVpJajlGbFNyUWI0Rm5Jdm01eXpHa3RZbFhPR1R6dko0OU82cGp2RGhMa1NMNWxmTTdSd1RoeE05cFh0V1h0ZGhzTi8zN2tsbktuNmNiT1pxejFVSlVpY004cmxvNW54WjJTYWJpVW5OZVh2YWVGUWtMeVBkSCs3ZC8veEZWRGE5L3NpcENwSktvNnRjL1pqVUNkY1VLcFNtSWQxb1ZMaysvZ2J4OTh0UlpBdUNsQk9VY0ZMT3dTcFd5RktmNkJVNmQvcURGMXBiWnQrK0ltajVnOHhGSlFrQUlHQkxnNkJibTNqOGNkWWZ0Wi9tQmR1clVMangrZEk2MGZ6UFZjdEVzakhEaWlBdzg5VGR5NUVCYW1lOGlUZFVlVWZaeVk4ZE94WVdMNFdHSkZpeFlTZ0pSTUpXZGdiZHZicEZUeVU5SzRHYkhFdTNVc1dHcnpmdjJ6YmZqNkNYL0RJc1dUVlh4c3MrZC9WZUYzeG8xYXFLcXNHU0o0aXBVMzZ4WjQ2T01nUjBjRks3OVlFM29RRExUaUUxaVc5MHhZMzQyRUFoalUxOXN5dkswSzY4d1ZxTjY1V2lyNFZWbzJSblZFaHI2YUU5bWdRd3NkSytnT05ZeFNSeE5oVmZvTmNkWk15Ym5zZlc4VjYvZnhPeTV2NmxCOWZWTHgzRHA3QUUxY1A1cHlpeTEwQXYzcjBIZFdwZ3c5aHRNK2VrSGcrNytQT2w3dkhwMkE3OHRtSzVpRDdmdDhKbXlvOWJQdEhuRGNqeDlkQmxqYVhuemEzU3VqbDM3VXQ3dytNTDYrZUowbTBMZEJlNm5GUXlMQWk1OWZPSFcxeGNhanpBRTdlTzRlT0ZuMWhUeWgxczlDb05YL0VQYndpNGtRZkFUd0sxRElKeDcrU0JKaTJBRVhhY0N0TUNMTm9XZFRJSVFNdTlJMGkwQUxyMnA3Z2EwMEF1Sk1wckh0aWRRVnlTYitBSUZjaXZsWm1SK2F3M3ExNkxuL0UxeVpsNEhUODlzYXJYRXZmc09hM0ZRZU9UZFlMbXRjK2RXdEdiQWVUTFQrSjFzclFNTW5NZUhET21EYjcvOWt0NFBLY0NoV2RsdW1tZEpWdERpVC9mdW50TDluVDcxUWJOY2hTd1pYbmxmeDVFalc4aDJ1cEN5YUZoRE0xQnhtYXpHNUlQWGVaOHdZUVlpR3JWejUxbWR6eThoRHRiTkYyVGh3aitVcG93TnlpTW1mbG56cUNhaTQxVEVmUEpkQ05nakFUYUJpTW45dy9HZDlaMkdPRGJ3MWFzM1VhOWVUYVVoWURPUU5Xdit3a3Z2VndvbmF3dXFrY2xXYXpLNzRxRCtmRi92M1h2SVFCdTdmY2RlMUs3ZEJ0VnBLVzErS082amgydmV2TG1VTnBsdGRMMWZoZGVsZjMwNFBONkxGOTRVQmVPeTJzMExuWXdiTjUxczQwN3JzckhtalBkcDg5eThlUmRseXRSVHNhZDVTV1NlNXZ0NzR6WmxzODJGZUVicm0yL0dxLzEzeWY0MnNzVG1JOFdLVnlmdGlUTzJiVjFCMnVwOVNpTWFXZjdJOXJOUXl2M2I5MTRURWxtKytOdy9kOTRTakJzN2toenlEa1I1MnU3ZDI1TjJLZHo1Tk1xTU5uNlFZNmR6RFBEV2JYclplRTlpMzN4ZXJaRHZ1V3ZYYjM5VTJmYy9Uc2FSby8raEJLMDh4NlllaDQrY0FDOEtvMDI3OXV6RG1MRS80NHhlUkNBK3RudlBmdldzdUUvMzI0YS90OExYeUR0ODFkcS9jSUJDcjEyNWVoMWJ0dTVRcXlwcTY0M1B6N0RUU2VEM0lCZ091UU1SUnNwa3plV2swUGkrMTA1elE2NjVJY0NGWkpCTEg0UmxrR0k2ZUlVN2d2UDdRNU02RklIUHlCYjdCaDNYdDJqejF5Qm9xVHVDT0UveVVJUStkb0xtRHNYWmZpK294MmNmWTNzdTFpeFBtalNiNUxidGtWYkZQaktzY0dGYjZiLyszbVlRZFlrTHNSelh0RmxYOEd4bjl1eFpsREN0LzV6bVBLeHNlZnZXVi9sdnNNS0duL1BHa3I1TXlIR3FKMCtlbzB3UCtYZDArM2JVdmgvODNnaC9wNXd4VnJWSit6U3VidGxzOERLYTFMY0ltZmhHc0pPdVJ1aTVmQlVDUXNBeUJGaDdPZmQvUDZOQnd3NHgxakx2M0xHV1ltTVB3ZDE3VVQvWUxkTlMwMnZoV015RGg0eW1WZXdlR3kzRW12bHRXMWVpZW8wV1JvOG50cDI4UWlXSFk5MURUb3p4bm5qTzJESGV6MnFiSitTSkkzMUIxVFo3SWEyT2hrRFZLaFZvSWJFL1NISHpOM3IwSEJSTjdvUTk3T2prbEdKTXdqWWh2czZ1TjdLTXIxUEtlWVNBRUVoVUJMeEpFODhMRlhBODV2MTZHcm5vT3NuT2YreUVFNWZ4cGFOclEyVEgzMUM3V3Jab0hLa0EyYVoxTXhWZDR5aHBKTzBoOFVxU3MyZFBwSVdDMXF2UXJQSGFaMzVOV1kwaFpyejJQT1luWS8yWTZNaGl6czNHU2pSdFVoZnNiOVA3c3lIS1Z0dWFteThhYW11K090STJJU0FFckpMQWh2VmtLa0gyNHFZNHZQSENMUnMzTGtPZHVtMnMxZ1o1Lzc2TjFMN1dSdHZIMnVuT3RESW1Pd1RhUzJLbldyWXhOelVDaXNXNGlJYmFkSlNpb1RhZGxlU01Gd0l5Rm80WHpISVNJU0FFRWhPQmdWK01wRVZCeHFvNHp0SDFhOWl3L3FUeC9OV29zQnBkMmZnNnZwYkNrYlp2OXlHbXYvYTh2RmdQaDBLMEoyR2ErODVoOUhnUkd4NE14VVhpTUl5U2hJQVFTRndFUktCT1hOZFRlaU1FaEVBOEVHQjc0MW16ZmxVT2ZWR2RqbTJ1MmNNOHJyM0xvMnFES2NmWTRiQkxsL0R3Z3ZyNVdhaTBCMmRFL1Q3emRseUcwUnRPQTZ3N2QwNWkxTGRESXA1V3Znc0JJV0REQkVTZ3R1R0xKMDBYQWtJZzRRaXdrTXpMaUZldEVubUl6aWsvajZIWXh1TVNycEVtbnBrWHJUbDc5aExLbGlsaFVLSk9uV29VMzNtZndUNTcrV0xwTUhvYzVXWHhiek5vSFlVR0NpR3Y3Q2hKQ0FpQnhFTkFCT3JFY3kybEowSkFDTVF6Z1FFRFJxb2xiWTJaQnRTcFhVM0Y2T1lGY1d3aHpaMjdSQzJIcm0wcnQ1L2p3K292b3FJOVppK2Z2Sm9saDlFek4zR29SWTZidTJQN1duVHYzZ0ZUcHZ3UDVTczBoRnVTN0ZpNmJJMjUxVW81SVNBRXJKQ0FDTlJXZUZHa1NVSkFDTmdHQWJZdG5qSmxEdjJOTVdnd2g1b2JOV293eGMrZmJMRGZtci93YW9POGhEQ3Y1c2lKelQyVy9MN1NtcHNjNTIwN2UrNmlpc1ZjZzJLbVI1ZFllQzVUK2xNVkJTWkQrblFZUFdvSS9xWEZMSGkxempadGVtTEF3Qkd3bGNGVmRIMlY0MEpBQ0h4TVFLSjhmTXhFOWdnQklTQUVZa1JnK3JSeHRCTFlBVjFZUExhVGZmWHFkZnhIaVloUnF6L08zS1J4WFpTZ0ZTUm56MTZrbGdtdTM2RDl4NW5zYkErdnFMbGp4MnFzSlJPZkZTdldxOTd6Z0NuRCs0RUhEMExTcEVtTi9QbHpvM1hyeHZEeWVrYUxDMTJpQlpTV1krdTJQVEhUOExPS1MrSlFtL1lMa3lnZnBuR1NYUEZHd0NuZXppUW5FZ0pDUUFna1VnS2pSaytpYWYzVk9FeExYdk9xWGcwYTFFVHRPbTF0cnJjN2R1NmxwZUFubzJ6WlQ3Rnk1UWFiYTM5Y05Oakp5Ukh1N2tsUmhXemxIenlnZGFVcEJRUUVLTUdadDcyOG51TGl4YXU0ZGV1T2NrQ2RPM2NwNXM1YnpJY2tDUUVoWUVjRVJFTnRSeGRidWlvRWhFRGNFZWpRdmlVV0xKaENpNkE4Um84ZVgrSVFDZGUybHZMbnkwUE9pWHRJWUF4RWxxeWZxRmpNdHRhSHVHZ3ZPMnMrZlBRNDB0VWtMWFpPMFZDYmpsSTAxS2F6a3B6eFFrQTAxUEdDV1U0aUJJUkFZaWZ3K3ZWcjBrNDc0dEtsYXpZcFRQUDFZVHZxSGowR0s3dGZYdGhFVWppQlk4ZFBDUW9oSUFTRVFKUUVSRU1kSlI0NUtBU0VnQkF3blFCcmVIM2YrY2E5SnRQMEpwbVZrMjJFL2YwRHpDb3JoV0pCUURUVXBzTVREYlhwckNSbnZCQVFnVHBlTU10SmhJQVFFQUpDUUFoRVEwQUU2bWdBNlIwV2dWb1BobXhhQXdHSzlNTjNzQjBrQncwUUdtWUhIWlV1Q2dFaElBU0VnRTBTNE5jeHZhb2ttVUNBV1lXYWtFK3lDQUVMRUFnSkNVTllOREtrVTNDUXZmd2krU2tsQXJVRmZsZFNoUkFRQWtKQUNBZ0JJU0FFaElBZUFUdFJUK3YxV0RhRmdCQVFBa0pBQ0FnQklTQUVoSUFGQ1loQWJVR1lVcFVRRUFKQ1FBZ0lBU0VnQklTQS9SRVFnZHIrcnJuMFdBZ0lBU0VnQklTQUVCQUNRc0NDQkVTZ3RpQk1xVW9JQ0FFaElBU0VnQkFRQWtMQS9naUlRRzEvMTF4NkxBU0VnQTBReUozYkV3TUg5SVNIaDRjTnRGYWFLQVNFZ0JDd2J3S3lVcUo5WDMvcHZSQVFBbFpLWU1yUFkxQy9mZzBsVUUrY05NTktXeW5ORWdKQ1FBZ0lBU1lnR21yNUhRZ0JJU0FFb2lCQXdmcVZwcmhHOVVwUjVMTDhvWWNQSCtQQWdhTktxTFo4N1ZLakVCQUNRa0FJV0pLQUNOU1dwQ2wxQ1FFaGtPZ0lsQ3hSRkUyYTFNV0dEWXZCUzNMSFIwcVpJamxLbENpRytnMDZZdi8rbzZoVHUxcDhuRmJPSVFTRWdCQVFBbVlTRUlIYVRIQlNUQWdJQWZzZ2NQYmNSVnk5ZWhNYk4rNUE3MTZkNHFYVEF3YjB3cng1dnlNNE9BaUxGaTNIWjU5MWpwZnp5a21FZ0JBUUFrTEFQQUlpVUp2SFRVb0pBU0ZnSndUOC9RTXdZT0JJZE84eENDMWFOSXh6TFRWcnB4czBxSWtWS3pjb3duZnUza2RZV0JpeVpzMWtKOFNsbTBKQUNBZ0IyeVBnNk9TVVlvenROZHVjRnZQUzQ1S0VnQkFRQXVZUkNBME5SVmhvR0NwVUtJM2p4MCtiVjRrSnBZWU42NC9kdXcvZzlKbnp1dHkrUHUvUXZIbEQ3UG4zb0c2ZlBXNnc2Y3ZBZ1QxeDlPaEorQWNFMkNNQzZiTVFFQUpXU2tBMDFGWjZZYVJaUWtBSVdCOEIxaHJIcFpZNm9uWmFTMkRydGwyb1dyVTgyRUhTbnRPb1VZUFJwMDlYZE83YzJwNHhTTi9qZ0FDcjNQS0doc1JCelRHck1oZTF3VEZtUlNTM2xSQVFnZHBLTG9RMFF3Z2tkZ0s5ZW5ZRS85bHlZcHZteFl0WHhaa3R0Yjd0ZEVST0d6ZHVSNVBHZFNQdXRwdnZMWm8zd0lzWDNoZy9manFaeE5TeW0zNUxSK09IUU5ld0FFeDJDRVpDejJYM2NnakNqd2hJOEhiRUQvWEVkWlo0RmFnUEg5cUN0Mjl1b215WkVsRlM3TlN4RmZ6OTdtSCt2Q2xHOHoyNGZ3YXZ2SytqeEtmRkRJNVhyVklCdmo1M3NHenBISVA5OGtVSTJCT0JpUk8rVmZkUHY3N2RyYXJidmNpaHIydlhkbWExYWRyVXNhcFBuVHEyTkt1OEpRdkZsWlk2TXUyMHR1M0xscTFGOSs3bThkUFdZYXVmTEV3M2I5NElyZHYweHRoeFUvSDgrVXZreWVNWjYrNTA3OVlPYlZvM2lYVTlYQUV2d0RQaTZ5OVF1RkIraTlTWFVKWFVyVk1ONTgvdGhkKzd1L1ErdlkzOSt6WWlYOTdjQnMzNS9MT3U2bjdrOTdUK1gzVDM1NWRmZklZbmp5K29NcmR1SGtlenB2VU02dFgvVXJ4WVlYaS92SVpuVHkvQk0wYzIvVU1XMzg2TEVJeHdjc1RYb1U0SWUxOTdCdHBhb2ZISEsrZFEzSE1Ld2Fnd2Y3aEVjMmJXTFBjaHdmd2lDZVkrVk82b1F5QWFoQVlhbE9JNlJsQmRkNmhPcm5zakNjLzU5RFRqVStDS0pnNk9xQkdobkVFbE52Umw2aTgvR3Z4R3RMK1hSZzFyRy9TaVlvVXkyTGxqTGQ2OHZvR2pSN1laSEl2NGhjdHE2OUgvNVBlRU51WFBsd2NzYzJwL3gvOXNXNFVjMmJOcUQ2dFBVOXRtVUNpS0wvRzJzQXMvWkFvV3pBdG5aMmZVcWxVRng0NmZpclJaYmRxRVArQ3FWNitJcEVtVDROMDd2NC95Y3ZpcTRjUDdvWDJIUGg4ZGt4MUN3SjRKTkdvVS9xQnEwYUlCL2pkM3NWV2g4UFY5WjFYdE1hY3grbHJxV2JOL05hY0tvMlc2ZCsrZ2kreGhMTU1UcjZkNDllbzErRVZ4OWRvTlkxa1M1VDZ0TU4yOXg1Y3E2Z2wzY3UzYWpXamRxaWxpcytCTnhnenBNSGZ1Wk1YczRzV3J1SGpwYXF6NGRlN1VHbVBHREVQZnZsMnhiTm1mRk83d01BNGZPUWtmSDU5WTFSdWZoVXQ4V2hRclZzeFQ3OXp2dnB1TUhEbXlxa0hjMnJXTFVMbEtFN3g1ODFZMUozLyszQWdKQ2NWdnY2MkFsOWR6WFJQUG5idXMyNDY0MGI1ZGMweWMrQTB1WExpQ21UUC9VWngrL1hVNjd0MXJqVk9uUC9nTGFNdU5IUGtsa2lSeHc5dTNjY3VQTmRLak5jSFlIQnlLYXc1SjFPbFpNSjZQUU9UU09LRnZRREN5YUVJeHdzVVpid1A4TWNQQlRkdkVqejc3aEFaZ2dxc3paZ1VGNFFUVjE5MGhERXRkblZDYjZqanRFQzV1alNSaHVnL1ZOVGtnQ0hkcEtaQitqaHBzY0NMZmpGRGdOZFg0a25UVDgwSkNNTlpKZzRPMHo5WTlCZEttVFkzQXdFQXNXTENjbmw5dmRNeXVYYnVsMithWnQ5OS9ud1gyVS9uOTk3WDQ3Nzh6dW1QR05sS1E0emFuTldzMlFyK2UvLzRMOTIxaHVYSFZxdm53OU15R3FWUG5xY0Z1ejU0ZHFBMi9vRzY5dHJvcVRXbWJMck1KRy9FbVVGZXRXZ0d1cmk0S2FOT205VEYrd25TanpVdVRPaFZLbC80VUwxKytRcFlzbVpRMis5KzloNHptNVdrLzFuWkhKWndiTFNnN2hVQWlKY0QzQXo5RXZMMWZvM2p4SXNpWk16dHUzNzVuTmIxOThlS0YxYlFsTmcxaExmWE9IYXV4a0VMYWNSU1EyQ1pXRURScFVnZTE2M3g0MkJ1cmM5NjhKU1NJZE1PZ3dhT01IVTUwK3pxMGIwRUwyOVNpQ0NzZmhHbnU1STZkZXpGNDhPZXhFcWlmZUQzRDA2ZlBzWkt1NVpRcFk5QzRTUmVkd0c0T3lKUXBrMlBuem4wa3BDOEJEeHlyVkNsUGJleERkUVlySjlaOSt3N2orSW5UNnZlU1AxOXVHaFRkTk9jMGNWcW1mLytlU29qdDJuVWdObS9acWM3RlFuWE5tcFZSdXRRbjJMM25nTnJIZ29pL3Z6OEp4b3R3L2NZSHdTaXF4dlhyMXgxK2Z2NWsvejVBRFFpdlhMbUI1Y3ZuZ00vWnM5Y2dnNktzcmVSSU41YTR0d3dxTnZJbEYybW42em81b1dZQTZhYmYyM3NVQ0ExR0RSS01Xd1VHWTRkRHVGNDZjNUEvdXBBV2V5NEp1WVk2NS9CS2s5SkhQMmRITEFvTUlBRTlDY0pvL3Y4d2FibFBob1dpTFdtc1Q4TUpMQVoyb1hQTkRnekN0UGVDK1JVU25vKzdhbEErSkJEL2FNTFB0WTQrUnp1R29tSklFUFpvbkkyMDJuWjJwVXVYVnQwUFAvdzR4ZWpnaUlYZkNUU3JHa0JPeG5YcnRzWFpjNWVpN1J6UEJvV1NnL2pTcFd1d2EvZitqL0pYcFhzdmYvNDg2bDc4ZHRSRWRkelRNeXVxVmF0SWxnMUZkUU80Nk5yMlVjWFI3SWczZ2JwbHk0WjQ5dXdGdG03ZGpmYnRtNk5ZMFVJNGQvNWpjRldyVmdRL21PYk1XVUt4Vnp1aFRwMXFNQ1pRODRQUXc4T2R0TlQ5MGFwMXoyaTZLWWVGZ0gwUXFGMjdLalFhQjlJeXJVZS9mdDNBTHlaakFqVS9jQ3JRTVFjSERXN2N1STExNnpmVGl6OUVRV0k3NStUSmsrUDA2WE1xejhhTi8rRDhoWERORTArMUZhT3BXRTRYTDE3QjMzUk1tMHFWTEk1NjlXcmluMzkya3pCZkdKa3laY0NqUjE3NFk4VTY5YkRrZU1vdlgzcHJzNnZwM3NLRkM2Z0g0d2tTTkl3OUdIV1pJMnp3RkhTYk5rMUpnTm1yQmhCNTgrYkM2OWR2OE1jZjYvRFMrNVV1ZDlvMHFWVysxRFJRNXdmMlAvL3MwZlZGbDhtTURVdHJxVG0rTmR0bWM3MVJwVU9IVDJEY3VKRXFkRjk4Q0J0UnRTV3VqdzBjMEZQOS9qcDNHZkFSRis0N3h3Wm5zd0NPRTI1T0tra0w1N0JkK3RjanhxSnZuKzVrcmpFUTQ4WlBOYWNxWmVaUnBVbzVBNkY4My80anFpNGVMRldwWEo2RWhlb1lQWG9JTW1SSWozejVjdEYxbkc3MitjeHFwQW1GMkl5R3RZaXNSZGFtUTRlT2c1OHJ5WklsMCs1Qyt2VHBsTmFSWjAxTVNheFJ6SnMzcDNyV2FHZFhkdTdhU3pieEwwbUJWdnlqS3I3N2JxaVNGMWd4a0NOSGxvK09XM0pIZzdCZ1BBeHhJTzMwQjhHMUJBblovaVJkbjlVVFp2OE5kVUEzRXBqVGtpRDNTQ3Q1NnpVa0ZXbFhIVW0xdlQvTUVXSHZCZk1YbE84Mm1YT2tlNStQYld4L3BRSFdYMkVrZXIzUDg4ejJUbFdTQUFCQUFFbEVRVlRCQVc4UkNnOEtqYW5kNTBVYi85SHp1RFZweHZmZ1E3djBUbWN6bTZsU3BTQ0IycytvTU0yZDRIZFJybHc1YUZEN1A1T0VhUzVUb0VBZW1pRWhreG1hc1RPV1B2bWtxSHEzSFR4NFRIZDR5NVpkNmg3TW5kdFRKMUJIMXpaZFlSTTM0a1dnWmkwWnY0UTVGTlRmZjI4ak84bzJxRkdqa2xHQnVuWHJ4bW8wTStkL3Y1SXdYUVU4ZlQzeW0vRWZkWWZOUUxadjM0dDI3WnFTMEZBYS9LS1JKQVRzblVDVEp2WEFTMWIvL1BNY2RPellnb1RKSmxqK3g1OEdXSDc4NFdzTUc5WVBRVUhoZWhaWFYxZmw1TlcxMjBDVmoyMmQrWUhGd3JhTGl3dnUzcjJIeTFldVllNy9KcXZvQ2l5WWN1Snk2OVp0QnBkallid1VhYkJHalJxRWJ0M2FLbUdhOHpnNk9wQ21yaHk2ZGY4Q2kzNzlnM2VwOUw4NVA2RkhqL1pxYXRtSk5EYjh4MjMrZmt6NEZMdzJYMlNmTEpEd3VYcjBhSWVNR2RNcm9keUp0RWR0MnpaRHRlck5WSHY0SWMwMmVWbXlaRlJUMWU3dVNmSE5OMS9TODJjZ05tN2FIbG5WSnUrM2xKYWFCUzZPSEJLZGRscmJzRFZyTm9ITkMxZzdIaGVKWHppdlNhaDZUc0pPUXFXb2hHbHRtOWpzZzdtWksxQjM3OTZlQmpFclZYVno1eTNHcG8zTFNVQXZaUEpMWGRzT2pyd3lhOVpFTW8wdzFLSnJqN1B3enhwMS91UFVwWE1iK3ExL1QxUFYxbWUyVTdWYU05VkcvZi95MHVDVjcrL256ei9NTHJIU2k3WE5IZHEzUkxwMHFmSDRzUmZXL3JsSlp4S2lYNTYzVTZWTVFjOENSNW81K3pEbHo2WWNUNSsrb0FGR1dvUHNQR2l2V0xFMDJPU0VCODF4bldxUUVIeUJ0TWo2V3VkTW1qQzhKc0g1clZiQ3BVWThwVzFYK2t4SDJ1dEhlc0szdG4wUFNUQXVRSUk1V1hIb0V1ZFBTenQyVXYxY0ZRLzFKMmpJWk9TOU1NMFpDNU5BNzA1eFBXN3F4ZllnMFJwSFNVQnZSYzgwRjlKejZMZU55OWhTNHQrS2o0OHZCdEJNQkcvZnUvY1FxOWY4clJRYzNJOFNKWXFURWdqMDNucUNZVVA3cVhmT3FWTm44Yy8yZnlQdEpzK1FCSkZaRFZzKzFLdFhReWxUMlB6RDYra3pWU1pYcnV6S0pJa3RIYlNKSFpvNXBTRWxpelpGMXpadFBsTS85UzY5cVVWaW5xOXlwWEkwdW5YSG4zVERIVDd5bnhwNU5tdFcvNk9LVXFaSW9XNGtIaDJ6Vm8xSEZEeDlIWmtUSTl2R0JBUUVnbTJ0SkFrQmV5ZndDWmw0c0tDNWQrOWhzT2JvNU1senlueUt6YWkwcVdpUlFoVEh0eGZPbnIxSW1wK1N5SmE5QkM1ZHVvYkdqZXVRazFkT2JUYWxBVjI2OUUrVUs5Y0FtemZ2UXZObURVaEFiNlhxNWpMOHQyM2JiaVhRZE96UVNsZU9OMWlybERkZk9lVE9YWWFFOFFjMFpWOFRtVWpvMWFaUFB5bENkYlhFNGNQL0lWUG1ZaWhZcUJJOVRCK3AxUUF6cERkOHVXckxSUGJwUU00N3BVclZRZVlzeFZSOW4xRGQ1Y3FXVXRrblRoaEZMK3QwWkNJeEF1a3pGRWJKa3JYVlEveTc3NFpGVmwyTTl1dHJxV05VTUVKbVU3WFQybUlyVjY2TE0wR0RGNCs1ZUdFLy9YWjJZampGdzJiQnZRNXBKMW1ieXc0OTJyQjlQQWpnZHJNQWF1bGtpakRONTl4SFM3S3puNDA1aWFlTWVVcjQ1S2x6dXVKOSt3M0g3TmtUWTd4d3o2aHZCNUc5NWdiY3ZYZGZWMWRVRzB1WHJVR0dqSVd4aGdZRTFwNTRscWwyN1NyS1R2WG9zZjkweldYTlh1Yk1HVEZqeGxnYTJBNm1HZVZKK0pQc3JIblFhaXg1a3lhUk5Zb1JoV2UybWRWUFBDam1RZStEQjQvSlBqdDhzS04vM05MYmJBMmRtd1RaU3lRODY2ZHdTMnI5UFNDTmRjeFRkWElzekV4S2hYVjZtbTZ1aFNrTkkxdnE4VlRyVW1jSFRDTWI0elB2YmF5MVo3bE9hdTZzOUh4THJYT1QxQjZ4blUrK25zbVNlU2dGelpRcDM2dmZ5b0lGVTdDVTdLWDVHS2RDaGZLcWhhc21UQmlKTVdPR0swWEordldMTVlUTXBTSkw2ZWs5d2FZaTQ4ZVBWSFh5QUhYMzduWElUTDlYVG01dWZHVU5rMVlScE4xclN0dTBlVTM5akJlQnVsV3JSalNDZUl0RGg0NnBFZXl4WTZkUXRHaEJneGM0TjdoOCtaSkltemFObW9iajc3dDI3VmVqV3A1dU1wWllhOGJPSHp4S1lhRmRraEN3WndMVnFvWDdLYkNKQmlkZUtwdEg0R3hHcFUxKy9uN2tHRFNEcHA0bjRSV1pTTENURVR0a3NTWTZQZG02YVJQYmdFNmJQZzluemw2Z2ZLK1ZBTWN2di9IanA2a3lYRzdTcEZta3VRcFdRclcySEgvT25MbUFURDJlS0tIKzFLbno5SkpOZ216WlBremJ1cmk0a3ZiYmdWNnd3YW9ZYTlRSERmcE90VWxyZHFKZlgxVGJQT04xNmZJMTFhWXRaUFBKRDBrV29qbVZLZk9KMHRZdlhySkNmYjl5OVFZNWloMGpHMUZYSlF5b25iSDhMN1lSUDdUYWFhN0gxTVRYN1NyMWhZVmNTeWVlZFdEQmg1M0wyS1JIUTZxamtpVS9RV3VLaERGcTFCRFM0aTdGdjN2VzQ4RCtqYVNWblVCT1FZdDBRblpzMnNLempDdkpHVzdjMkpGMHZ1SXdadVlSc1g0ZTBQQUNPMnpXRk5QVXZsMHo1ZGlvWDQ2RnVGbXpmc1dZNzcvUzN4M2xOaXQ3Q2hmT2p3VUxsMFdaejFZUGp2bCtPTDJUVTJQYXRMbEtTNjN0Qnl1N3RtM2JRNFBoaXNpVHR4ejRQcTlDVS9mTnlEL0tXR0p6ck92WGJ5dWZEbTEwcnVwa3o1by9meTZEN08zYU5nZFAxMCtmdmxBOWR3d094c0dYcENTc3BxYVp1TmRhR3cwTG5pTWwxVDJKSEF2L0pFM3FGVDN0TTUrQ0xhVXJrVE5pQ3hLaW5VazdlMDlmWmYyK0Rhd1JaOEUrcFY0RWtQZUhiT2JEM2QyZEZESTdsVEkxWjY3U0pQZFZVNE16VnVEVUl4TW9UbW5TcEZIdkExWUVzV0trV1BIcXlvZHU2TkMrTlB1UnhtaGZXVFk4Y09BWW1ZUTFvbWQ1TWJxWE42bW9QNndzTWpXWjBqWlQ2OUxtaTNPQm1vR1VLZk9wMG9nOWZ2SlVuZmZQUHplcmtXeWxpb1lQd3BZdEc2c1hORHR2Y0dJSGppZFVocWV4STBzelp5MmtxU2MvZlB2dDRNaXl5SDRoWUJjRWVQcWJwN1VPSFFvM2Z6cHc0SWh5SEdJekttMWllK25KUDg5V0Q3Q3Z2eHFJVWQ4T1VRSUJDMDRjZ1VlYldIZ09lVzlUemZ1eVpzMnM3clA3OXg5cHN5Z2JWaGE4dFFLczlnQXZrNjFOTEhDelRYZVNKQjkwUGlkUG5TRk45eUZVcmx3T2x5N3VWNkhHamgwN3FVeENYdWpaV0d2cmlPcVRIVk8wU1J0QmhBVm1EclBGUGhhc0xkZFBiZHIyUXVFaVZaVEFyNy9mM08zWWFxbGpxcDNXdG5QaHd1WEtPVkg3M1ZLZkxOQTJhTkNCYklFN1lTdk5RTEEybFNOcGpCZzVEcjAvRzRMNkRkcWplbzBXTktQUldiM0VXS0R0MjZkTHJFL2ZucHdQbTFOb3ZJd1oweW56b09oc3liVW4zTEJocXlxbi9XN3FKNXNTR0J2RXNOYVluWmZZcmpPNnhGcnVTWk5HWWZDUTBkRmx0Y25qUFh0MFVETkpiRnE1YkxtaDJkaVFvZCtoZVl0dU5KTjhuN1RKajlSZ21KOFpUYU1JZ3pkckZnKytuT2gzczBpWmovRmdqQ09GYUFmUnlaTW53OWRreDM3bnpqMjZOdXZpaFJrTFFQd1hiaWhndVZPeTd2VW5pcytSaEo2cjM1SDQvT0VwRlg0T05rUm9GdXFLUWhTbTd6dHlVSnhLVVQ5S2h3WVpOT0RkZXlIYjlhUFNCdG1zK2dzUHBEN3ZNd3lkT3ZkWFprSHN3RHFHelByNGZjUCtOdG9VRkJSTWlwNlpTakhDN3loV2pxUk9uUktsYURCdkxQMDhaUTZaeUhGMG1IUEtaK2FISDM5V3BzSjE2bFF6bHQzb1BsUGJaclJ3SkR2alhLQ3VYS2s4MkNHQjdTaTE4UUtYTHAybG10T21UVE5kczFoOVg3VnFPZEtVT1pOQXNGbmw1ZmlUUEszRTA5ZzhuVzBzc1duSTh1WHJVS2xTYVdXWGJTeVA3Qk1DaVowQW0ydXdwb3kxU1UrZW5GZjN6NmxUdTVRZ3kvYUliRTdGaVRXNHExYk9KKzMxVXVXMFdLMWFlWk9tdVBrQkdER3g1bHI3TW94NExLcnZYS1pWNjE0WU11Ujc1Y1hQb2NZdVh6NklibDJqam5BUlZaMEplY3hjTGJVNTJtbHRQOWx1bUtNdmNPeHFTNlVXRk9mWml5SmZhSjNwb3FxWFRZbzZkK2xQMFRjR0tmdjdqT1JvRjV2RUVaMSsrT0VYMG9KUGlsRTFodzRmUjlteUpXS2tKV2ZOL3QyNzl5TU5aemRnd0VoOFQ1cFpGcGlqU3VQR2ppQ045bS9LUENHcWZMWjRqTVBjc3ZNcm0yejE3LzkxdEYyNGRmdXU4b2VJT0xqV0w4aURsYUZEeHlpekt3NmR5MDVvYk9PcWRWUm0yM0oyWE9UWnJTOEc5bGFEZmZhUDRPaGdBOGhCbFoyZTR5b2xqZkI0ZTJma1JCUzN3OGhlNDd1NlVDenFWczR1NkJVVWhzZEd0TS9hVWx6alNyS3Bma3lEa1JvYU1wYldTdzR4T0o5ZU1hdmZ2SG56RHRrL1V5aEN1dWM1c1FLRy8vUk5NbmlnenUrY05HbFNtdFNmR3pmdXFOajBMSVJ6aWl6VWNuU1ZSV3hiZFBrakhvOXpnYnB0MnliS2VIenExUG5LeVlBZERmanYrdlZiWkl4ZVZHZGJXYjVjS1JLZU15a3ZmRzBlL2x5MmJKMTY0Zk4wZG1ScHhvd0Z5dWlkTlJ5U2hJQTlFcWhabzdLYTlWbXhZb1BCZmJacDB3NWxSc1htVkp3YU5xaXR0RWhzS3BVN1R4blVxdDFhMlZwSHg0d2RxOWlwaUUxRHRJbWQvamhPTEQ4Y1k1cjQ0Y2t4c2xsYjNJVUVNell6WURzNGZUdnVtTmFwbjU4akZYQ2QrbHAzUHA2Tk5PMHNMR2p0OS9UTG1Mdk4ydFQxNjdmRWFQVkViZ05IbGpBbHNrZGs3VnE4ZURVNXduV0k3SENNOW5NMGxHSEQrbUlVbVFMRkpISGZ4NHo1bWJSTDVvZng0NFZWcmxFSU9kYUVteG8xUXIrTmUvWWNKSTJ5NlNaLzdJeklHdjdJRWp0alRpRU4yUFJwUDBhV0JYeS9wVTJiQ3VzM2JJNDBqNjBlU0owcUpmMHVaeWpsMXVlZkQ4VWpjampVVHdVTDVGWENycjZTeTRWbXQvajV3STZLVWFYNUMzNUhvY0tWbFkvRmJncDN4alBZcDA5ZlVFVjRuUXFPM3BXUFFncHloQy8rWTF0dDFtcTNiZHVVRkFZRm9xcmFyR01jeWNPUGhMbVVlck5xWE5GOU1nRkpSV1pweWZXRVdqWWtZM2ZzWnhGc25UbS9mdnFFbkJZbnVEaGhJdGxGNzQvZ3ZKaUo2aHRIdHRQNlM1eXpYdHFmenM4T2pQcUpoOG9zY0wrT1lDNmluOGZhdC9rM3dyT2cvSnZSSmxkWE56VkQ2dXZycTNieDRKYWQxN1hDTU85TVNVNnNuUGk5RXpGbElTWHJOK1EzRjNGaEdIN1dzMDhkSnhhTXVVNVdNR2tUUjNyaXhKRmxPSm5TTnBVeEJ2L0ZxVUROV3JIeTVVdmgxcTE3K09iYjhXcXFtYWViK2UrUFA5WXIrODdLRkU2SUU2dnFXUW4ydi84dE5zZzNZZUkwSlN6emRIWms2ZTY5QjhxQmdUWFpERkdTRUxBM0FoemJuVWZsa3lmUE1yaC8rSDdpeHpLYlUzRmlKeU1lK1I4NGNGU25YV2JUaU9nU2h4L2lXU1NPUjZ0TkhMS01UVGxPbmp5cjNXWFNaLzkrUFdrMXJKdms4TlpLNVY5RDltOGNBU2hwMHFUZ2g2VWxFbXZQT1dRZlIvalF0dzFmdlhvaGhkcGJBdy8zcUxXUE1XMERSOXpvM0xsMXROcCsxaWhQK1htTWN2cnIzYnVqVWJNRFU4L053aHpiSWxvaWNaU0trV1RXWWM0aUpMd09BQStRMkE0NnBvbDVEQnIwT2ExK09DMm1SWFg1ZVRERE50Nm1KSjRWNEpDTzBhMWR3T1l1L0RKdlFBNjFFUk8zK2Z2dmg1SFdkR1RFUTRuaU8ydW1peFFwU1A0U00zQ1FRdVpGVE9HbUdmMUoyOXhQZDRqZjg4ejJsSjZUcCs2Z2tRMjIxUjh4NGdzbFdMRkRKNmYrQTBZZ2U0NFNCbitYTDE5WFUvbVZLemZCNzB0WEc2a3BkcnY4cVBoRGlzQ1JQWUxZY0laaVJyUHFRTjhNb3lhRnNMdE5nL1RuVVdpYzJXNTZrVk1vRHBCL3lFelNQRWZVYWZQM3owa3BVVi96d2J3akk0WG95MEtEa2VzY3VGb3ZjYVNSNXlSb2U1TmdiNnNwZmZvMDVHVDZCWHBTS0ZadHFseTVyRkpvc04wOXArMFV6WU45YXBxUjQ3czJjZVFPRm81Wk1JNlkrTDVrVzJsMmh0VXFSdGlQZ3FQTnNMa0lwek5uenF0RlltclhycWErODMvOHJOU3YwNVMyNlFxYnVPRmtZajZ6c2xXb1VFcHB4elpzMlBaUmVYNUI4OVF2MjNmeWk0R0R1UFAwei9Ialp3enlza25IMWF1MzFIUTJhNiswd0F3eTBaZlpjMzZqY0ZodGFZb2dmQlFTOGJoOEZ3S0psUUI3TnZOc3o4MmJkOEdPZC9ycFB4SjJPZjQ3bTFPeFFIei8va1Axb0JreFlxQVNyc3VWSzBteE9hdlJsSnQrcVkrM0Z5OVpxY0xjL2ZqalZ5cE1IV3VpQmd6b1FjN0dyMmtRL052SEJhTFljK2pRVVRWcnhjSDhPU1l2YXhacTFxeEM3WHlPOCtjdlIxRXlab2NXTGZvRHYvd3lobXcyZjZXL2pjb1JtcU9BTENkN1VCYTRzMmZQZ24xNy95WTdhMit5QzI2cFFpL0Y3QXdmY3ZORG5wY0daMjNNcEo5bUtjR1VJMklVSmc5Mmp2ZGRnc3dNOHVRSmovSEwyblBsOURsdFBqMERQN3hZUDlSbTJoYWZrNmRHYTFTdmpEMy9IakN0a0pGY01USDFNRkpjN1JwRml5ZXdiU3lIL290Sm55Wk5HcTAwM09ZSTh0cTJzUGtMcjl6SEFoMHppU3ExYnRXRVlyU0hDM0JSNWVOakkwYU94NDd0cXhWai9SQ0MwNmVQSS9PVUtjcXBON282Yk8wNEw4WE9ZVzIxSmpHZjllNnM2d0tIelZ0UE51czhHTmxQRVZhYU42K1BtVFBHcTRIcm9FRzlsZUpyeVpKVktqODduUEdLaTMvOXRRMDllZzdTMVZHTDduTis1clJzMlVpdG5QenJyeXV3YzljKzNmSDQzbUFqaTlNa1VCY2lQdytTWDNVQzhIV0tyckU3S0FDVHlVVE9JemdRbVVpWTdrVG1xR05veGNQQTkvSnRSYko1WGtoT2h3T0N3N0NITk5GYXUra2NqaTZZUVBuS3dmRGUvby95Y0h6cHRWVHZDSHJtaFFYNjR5RjkvNExxZUVyaDlyYThYMEJHeStBVGFoQXYrdkxXaGpYVVBDRGpHUWllYldCL21uQmh1S2Q2SjNIb1BFNGNUcEtkb0h2MmJLOWltM05naW9ya1g3ZGp4MTZjUGhNK2UzSHU3RjRsMjFXbzBKQ2k2VHhRNnl6MDc5OGRTeGJQb3Z2ekZKa2w5VkNLb2pra0IzTGk4L0xDUVIwNk5GUFBkNTVKclY2OWtsSWthVmZsTktWdHFySVkvQmVuQWpWcnhWanIvTysvaHo1cUVodVRlNUVkSG85czY5V3RBVS9QN0RoQ0lmWDRSUmN4YmQrK2h6eS9pNnBwdHNnRWFyYTc0aGZvMTE4UGlGaGN2Z3VCUkUyZ1dyVkthclpuOWVyd0I1Uitaem5XSzRmUHEwc3ZPRGFyMnJKMUY1bFcvSThlUU4xSktCaE90c3ZYU0JEYXBLWlVNMmZPb0YvVVlKczFCZXlJTm1mT1JGcE1LVnd6eGVIMkJnNzhCdGZJZkNzbTZReUY3T3ZRb1E5cDA3L0gyTEZmSy9zNWJWMzZpN0xFcEU1amVkbWtoRU0yZmZsbGI1ckMvMTVOUi85S3NiQzFLMmNsb2RCS0xJU3h0N2NtQ3EyVHNicU43YnQxNjY0eVcyRk5DRCtQdUc1bXo1cVlTVC9OTk5DMnNIMXVkTUtmc1hORTNMZHcwVElWR2NOY2dWcHI2bEdIVmlpTFRXS0JreGNUWWdkRlU1ZGpaOGMvWnFTTnp4eWI4Ky9Zc1kvQysxV0xOcjU0bHk1dFNJblQwNlJUc1pBL2ZQZ1lGV082ZllmUFZSa2VmUENBU0x0aW9Fa1YyVkNtR21US3dxWWJ2SGJFekpuakRWcCs1c3hGSlZEenpwNDlCOU5BT2p5V1BPZm45L0xnd2QvcG5nVnVia21VeVFocnMvVlRRNG94L2Rsbm5kWEFmdGl3SHpCdi9oTDl3d215dlpVV2JQbU5GbXhKUllJeEwvdk5pUVh0ejBsSC9SUFpRczhtRzI1ZjBqajhRczZEOC9XV0hVOUtBbTlhbWhGUFNrdU1jMktUalJxT1Rpb2szakphYmp4aUtoZ1FpbnVraVIwR04zZ0grMk00Q2VqSlNVRGFUb1BxWGlFVWFVUlBFZTFNaGN0UjNwWGt0QmthM3FTSTFkbkVkNTQxNVdmOS9QbFQ2RjNSVTJtaU9hcFUzNzVmcVFoTTNBbFdMclJyL3hsK1h6Skw1V0huVmc3SjJxL2YxN28rc204ZFd4OXd0RGhPMzMzL2svcDlkYUpaVG80aTkvanhVM3p4eFNoc280VzdPUEY1MjdYN25HVENhZXI1enpiYUhCWGtzOCtHcXVQYVBORzFUWmZaeEEyTnExdTJhSFJUSnRaazlkbjRWMmtuWGJYNmF5RU5GQUtKandDYndHemN1RXhwcW5uRlBVc0l6S1pRMnJCK0NRbDlpMGhMZmRDVTdBWjVWcTZZRDE3TzNCUkhSSU9DUnI2d1JwN0Q2dkVDSjlIWlFyTWd2WFBIR3RKeWRyZklBakljMVlYdHVMV0NyNUhtS2R0NVhxNjhWKzhoeGc1SHV1OG4wcUw3K1FYUVMzNlhpdXJCUzVUSFJxTWU2WW5rUUlJUVNFcG5QZW9ZaExGQm9WanJ3R0p4d3FjaVpJZTl3MFdETXNFYVBOQmZLU2JobXhidkxXQ1R2WFBuOXFvRlljcVVyUnZ2NTQvSkNmWEdSREVwSm5tRmdCQVFBa0pBbjRDS3ZPRlpnaHo3SnNhYk1NM25aenZ4clZ0WFlQQ2dQbVJUeUxvdDB4SnJXKy9SOUtrbGhHaytZMHdjRkljTjdVK09nWDlZUkpqbWM5OGh4eWFPdVI1VlpJN2VaTDRRbFRNaTEyTXM4ZkxrSTBZTXdKNDk2K2pUUER0elkvWEtQdXNnd0JFOXBwS1d1UitaWG54d3VVNjR0ckhxcjU5RE1KWlEvR3A3RjZiNUt2REt2Y21UZTVEU1lHSENYUlFUenl3Q3RZbWdKSnNRRUFKQ3dCb0o3Tmx6U0ptVmNNaXlQYnYvUkpQRzBXdHgyTlJqNE1BZUppLzFibXEvVFhGUXpKOHZqMW9SbDJOY1d6SnRKWE9teVByT0duRzJZNC9PR2RGWWUrN1NDb2hzdHNNREFIUEtHNnRUOWxrWGdSVWFWekxySU9HTlREd1Myc0tpV2xnZ3lwSU45eFJxa3lTb0diL2V2WWQrRkF2ZEd0bUl5WWMxWGhWcGt4QVFBa0xBREFJY2dZSTk0RG51UDYvNnQzSFRkcU8xTEZzNmg1YlovalZPQkVRVzFxTnlVTnk1WTYyS2tISDFtcUVEcmRHR3htQW54OEpldUhDcVdwUW1ZakZlUXAyZG5YajFUMGxDd0JpQmpHUVMybzlDMm4ydmlVbkVhV00xeFc3ZkVHckQ5akJuWENTaFdwSnRFUkFOdFcxZEwybXRFQkFDUWlCU0Fyd3MrZGh4VThueHJwZUtMckovMzBibHJLZGZnRTA5MkdreXJyU3QrZzZLK3VmbGJWNFprdU5HVzFxWTVyckQ3YmJKVVl3RStvaXBRNGNXcE9teXJFWTg0am5rdTIwVGVFSzY2ZThTV0pobWdsTXAzSjRJMDdiNVd4SU50VzFlTjJtMUVCQUNRaUJhQXF5MUhUYXN2d29yeCtHbE9HNXJGWXF1d1V1SXg2WFRwREVIeGF4Wk00R2RJRGxFWVV4QzYwWGJTYjBNUFdpaEc0NEd3SEhCdFlsTlREaG1MYS9zS0VrSUNBRWhFRmNFUktDT0s3SlNyeEFRQWtMQVNnaXdNSHYxeW1FVkVxMXExV1p4cHAzVzcyN1pNaVhRcDA4M1dwNzhDN1diaGVucDArZkg2Ym5aS1hIdG1vVnF3S0J0eTZTSm8xV0VEa3M1WDJycmxVOGhJQVNFZ0Q0Qk1mblFweUhiUWtBSUNJRkVTT0RCZzhmbzNYc1lyWVk0UGs0RlduMTBXZ2ZGdmlSVTgvTGlYbDdQNHZ6Y0hNN094OGNYUElEZ3hNNklaY3QrYXJGSUp2cjlrMjBoSUFTRWdENEJSeWVuRkdQMGR5VGU3WVQyM1UyOFpLVm5Ra0FJV0QrQjh4Y3U0K2pSay9IYVVGNGc1SmRmZmtBWjBsWjNvTVZSL0dtSjhyaE9JUlFDamMxYURoOCtnUmJORzZwRkg0NGUvUyt1VHl2MUN3RWhZT2NFUkVOdDV6OEE2YjRRRUFKQ0lLNEluRHQzaVJabHVJVHg0NmZIMjFMZFc3ZnRSSU1HTlZXWHVuZHZMODZJY1hWeHBWNGhJQVFNQ0lnTnRRRU8rU0lFaElBUUVBSzJUbURiMXBVNFMwdmM1NkFWRktOYVBkSFcreW50RndKQ3dIb0lmTHpndlBXMFRWb2lCSVNBRUJBQ1FpREdCSGdSbCtyVks2SnAweTR4TGlzRmhJQVFFQUxtRUJBYmFuT29TUmtoSUFTRWdCQ3dXZ0pQdlo0aklDQVFQMCtaWTdWdGxJWUpBU0dRdUFpSXlVZml1cDdTR3lFZ0JJU0FFQ0FDSE9FakxtTnRDMlFoSUFTRWdENEJjVXJVcHlIYlFrQUlDQUVoa0NnSWlEQ2RLQzZqZEVJSTJBd0JXdERLVG1ScUJ3cWJGeHBtTXhkR0dpb0VoSUFRRUFKQ1FBZ0lBU0dROEFSQ1FzSVFGbzBNNlJRY0ZKcndMWTJYRm5BY2FoR280d1cxbkVRSUNBRWhJQVNFZ0JBUUFuWkV3RTdVMDNaMFJhV3JRa0FJQ0FFaElBU0VnQkFRQXZGS1FBVHFlTVV0SnhNQ1FrQUlDQUVoSUFTRWdCQkliQVJFb0U1c1YxVDZJd1NFZ0JBUUFrSkFDQWdCSVJDdkJFU2dqbGZjY2pJaElBU0VnQkN3TlFJZUhoNjIxbVJwcnhBUUF2Rk1RQloyaVdmZ2Nqb2hJQVNFZ0JDd0hRSjU4bmppNnBWRGFGQy9Gb0tEUTVBMlRXcGt5NWFabGpYUENpZG5KeVJQNW9HVUtaSWpiZHJVbVByTER3Z0tETUwxRzdkdHA0UFNVaUVnQkN4Q1FKWWV0d2hHcVVRSUNBRWhJQVFTSXdGWEYxZTR1cnBDbzlHb3Y3SmxTOExSMFZGMU5XdldqTFFkL2hvdFdiSVlDaFhLaDdKbFMyRHJ0dDJKRVlYMFNRZ0lnU2dJaUVBZEJSdzVKQVNFZ0JDd0p3SzBNQUVXTHBpQ3UzY2ZZTXdQUDl0VDF5UHRhNE1HdFRCOCtJK1lOWHRScEhuNEFHdXBPM2R1allvVnk2QnNtUkk0ZHZ4VWxQbmxvQkFRQW9tTGdDdzlucml1cC9SR0NBZ0JJV0EyQVRadnVIQitQMEpDUXJCanh6NHNYTGpNcnJXdGJONnhkdTBpMUs3VGxzdzlna3ppV3JKRU1YVHYzaDREQm80MEtiOWtFZ0pDSUhFUUVLZkV4SEVkcFJkQ1FBZ0lnVmdUcUYrdkpwWXNXWTA2ZGRwZzRCY2pVYUZDR2V6Zjl6Y0dEdWlwTkxDeFBvR05WVEJxMUJCTW5EalRaR0dhdTNmeTFEa1VMcHdmYm02dU50WmJhYTRRRUFLeElTQUNkV3pvU1ZraElBU0VRQ0loVUx4WUliQjV3NENCMytEUTRSTjQ4T0F4Um8yZWlEcDEyOERYMXc4Yk5pekJ0S2xqa1Q5ZjdrVFM0Nmk3a1R1M3AzSTgzTEZ6YjlRWmpSemR1SEVIbWpTdWErU0k3QklDUWlDeEVoQ1RqOFI2WmFWZlFrQUlDQUVUQ1hCWXVFMGJsNkp6bC81S2tJNnNXTVVLcFRGZ1FDOTRlQ1JGR2pLSDJMcDFOOGFObnhwWmRwdmV2M2JOSW93Wjh6TXVYcm9hNDM1a3pKQWVjK2RPUnZNVzNXSmNWZ29JQVNGZ213UkVRMjJiMTAxYUxRU0VnQkN3R0lIcDAzN0V0R256b3hTbStXU3N1VzdmNFhNc1c3WVdKVW9VeFlnUkE5R2llUU9MdGNOYUtxcFN1VHhldlBBMlM1am1Qanp4ZXFxNmtqVnJKbXZwa3JRakdnSWFPcDQzTkNTYVhIRi9PQmUxSVR5R1ROeWZTODVnV1FJaVVGdVdwOVFXQndTR0RPNkxYajA3eGtITlVxVVFFQUp0V2plQmo4ODdiTnkwM1dRWWE5WnVSTjI2YlZIOGsrcm8yN2Q3b2hPcWYvaGh1TkpPbXd6RVNNYkZpMWVpYzZjMlJvN0lMbXNrMERVc0FKTWRnc0dDZFVLbVhnNUIrQkVCQ2Q2T2hHUmdxK2VPZDRINjl5V3o0ZTkzRDYxYU5vNlNXYU9HdGVIMzdpN1dyMXRzTk4vUkk5dFVQVnlYOXUrcDEwWDhQUGw3SkUrZXpHZ1oyWm53QklvVkxZUlgzdGR4NXZRZWt4c3paTWpuNk5Xcms4bjVyVDFqNWt3WndML1ZtemVPSVduU0pBbmEzSCsycmRiZFA5cjc2TVh6SzVqN3Y4bHFBWXNFYlp6ZXlkbDJsOXZYcVdOTHZiMnlHVnNDT2JKblE1OCszVEJpNU5nWVY3VnYveEhjdkhtSHpCcTZvM2Z2em1CemtNU1FPbmRxalQxN0R1cTB6T2IyYWV1MlBhaGZ2NGE1eGVPMFhOTW05WERpK0hiMCtienJSK2ZKbnk4UERoL2FvdDYvdmo2MzhjKzJWY2lSUGV0SCtiSmx6WUlsaTJmaTJkTkw2czh6UjdhUDhtaDNWSzFTQWI0K2R6NTYxbWlmT2NidTYrTEZDc1A3NWJWbzY5YWVJemFmZVJHQ0VVNk8rRHJVQ1dGNkZiRndYU2MwRUpzY0FwSFc0SWhlcGdpYmpTbi9HUktLZlp4RHNaL0tWUTQxakE3RGRYWU1EY0JsRXQ3ZlVwNGRta0I4cXBkbkNselJ4TUVSTmFpZXhKYTJibG1oZmdQR2ZuZmNWNWJkenAvYnAvS3dER2dzR1h0bmFYOUhWeTRmMGhVcFhlb1RuRDYxVy8yTytYYzBhZUpvT05FMTFrK3RXelhHdGF0SFZCNmZ0NUgvMXZYTFJMVWRyM0dvazlHS1VsV3FsRlh0YWRPbUNmNWN0eW5TdGpWdjN2QjlFUDBTU0owcUpWNTZ2L29vYjBCQUlPYk1XWXhYcjE2cnZNMmExY2ZBZ1QyUklVTTZkT2s2NEtQOHNpUGhDZFNvVVVsNXYrZktsUU9sU2hiSGZ5ZlBKbnlqNHJrRmxTdVhVdzhPRHc5M2xDOVhDcnYzSEloeEMvaWhVckprVVpRdVhSZDM3dDZQY1huOUFpRWhvWmczNzNkNGVUMmozUnJTUEZhanNGL3RrRDE3RmpSc0ZMdVpBWDdKbmppeEhTZFBua2U5K20zMVQydlgyNFVMNWNmVmE3ZGlGRDNDMHNCVXpPbUZVMG5EL0JYOC9RUE1ydDdIeHdldDIvVEd5aFh6TUduU0RHVVdZblpsQ1Z5UUkzUDA3ZHNOTldxMmlIVkxPTXplOGVPbmFhQlJocGdjajNWOWxxaUF6WE5HanZ3U1JZc1dORm9kRC9CWHJab1BUODlzbURwMUh0bktlNkJuenc1WXNPQVgxSzMzNGY3bGdkaWVQZXVRTVdNNi9QUFB2emh3NEJpODZUMGNXYnArNHhZR0RScWwzdFA2ZWJwMmJhdmFjbzN1aFlpSjI1a2tpUnZldnZXSmVNaWkzMW5BSGEwSnh1YmdVRnh6Q0Zkdy9MKzlxNENQNm5qQ2t4Q2svWmZpVG9HVzRoUjNkeWU0ZTVFaVJZSkxnRkMwUUFzdDdoN2NDeWtPb1ZoeGR5Z3V4UXN0RXZuUE44bTczRjN1TG5lWHkrVkNkbjZFZTdLN2I5LzNiSGIybXhsWUdpdXpRanVJTmFUQ25BM3paVENyMlVFUkgvYWJvQUJhRUQ4T3JmOFFRTU1DZ3FtMWV6QXRqK2RPUmJqdCt4Uml2eXpGeXZPMCtIRnB3WWYzdEMvQW5UcXpqcmNpcmhzVlpiWUp0SnhuL0E2ZXlXRXJSM3E0MFI5OFRQdWZ6SWo3Njh3U2xTcVdZZjJ2bU1WRHRtN1ZtTEprK2RKaW1TbFQ1dEs2ZGI4WmxFbVhMZzMxNmRPWnpwMjdKTnZUcGszTjRTN255ZjB6WWNKMEtsV3FLTjkvSGVuVnEzOW96TmpKVXFaYzJSSTBiOTRrZXZ6NEtRMGVQSVlqODJTbjVzM3IwOUtsMDZsOGhYcVNGZFhnSUZhc09GV2hMbDZzb0NpN3o1NjlvT0xGQzNFWXBrVDA0bVg0aHhBUGRibHl4UW5sa2laTlRGQkFObTc2UGR6cHZILy9uaC8weFRxRkFqRlREeDdjUXJWclZ5RjhzT3h4SmdsM0VMWEJvUWhnMElPYituLy8rNVFxOGdNV0d4WHFKazNxMHIvLy9pZWo1ZG9jQ2NBZWhkcVJGd1V4aHhjdVhFRm56MTJVWnFkTm4wZDc5Nnluc21XTFU0bmloZW5nb2FPT1BGeXNiUXNLYkxhc1g0bkMxcUZEQzVvOGVZNWRsbUZIQVRocTVFQldudGF6WW44dDBrMUNxVzdXdkhPTVY2cDc5ZnhPQnBlUkdXRG9nd211T1JSMFYxQ29NYmlkTld1aWZGZlhydDFLRFJyVTBPK3FMSmN0VTV5eVpmdWFIU29YMGhEdnNiSXRVNmIwL0QwdVNRWHlmME1uVHA2VmJTTkhEaEJsdW1kUGI1bzdiMW00ZG93MzNMLy9rT2JNWFdxd0dkLy93WU43MHFWTFYrblBveWNOOW1FUVVxTkd4VWdOOUF3YXRMRHlGVnVucTNwNFVNVjNyRFJEdTJaSkh4UkVLK043a0M4cnZjY0MzMUh6dVBGQ2RrVHdmenUyT3Q4S2pFUGQyY3I4bHZYblA5aXFmWW8xOFFiQkgyaUtXMGdZeFU1eGd1ZzRLOXY5S0FHeFBrM0hnNFBvQlA5VysvQ09WcmlIbEZuckZvK0djcm1TZ1I5b3QxdmNDSTdxK3J0aEdSNCt2SzhvcVI2TXRTbEJ6SGN2cisva21sc0tPYmxsNjQ1dzFmdjI2U3JaUy9HOFFVQmp3MkN2WDc4Um5KQnBIcVZNa1p5T0hkdk9NMmt0SkVFVEJtbTllM2VXQVY2Yk50MTF6MmVPSEZrb2I5NWNsRC9mTjNUMDJLbHd4NGxvZytremk2aVduZnM5UGFzVGxHQmYzM1hVclZzN0hqVVVvZCsyaEFjSEgvRTBQQzArZGVvQ0hoMDNvL3IxYTVsVXFJMjdBU3YyM3IwSHFXM2JKdlRsbHhtVVFtME1VRFN2Zi8zMWwyS04yTEpsSnhYandWV2RPdFhveC9GVHd2VUtMM1hFdncxbXE4RE9uZnNNOXRldlY0dXlaLythbmFKVzBaMjc5MlVmUnI3RjJOSzdldlZHVmc2dXk3YTYzRFpHbkVGQndYVHk1Qm42ZmRzZVhUdmdZMy8rK2VmTUdmMmQ2dGFwVHZIaXhhUERoNC9SN2oxLzZNcGdBUitRU3BYS3l2NG5UNTdScWxVYkRHWktrQm10Y2VNNmxESmxDbjRKdkNVL1RqY2MwU0F1V2RJa2twcjRJRHQzNFI2dlZLbU1LTllCQVdIT01PQ012M3IxU3ZlaFNzWHRmL3R0YzdwOCtTcWRPSEdXV3JSb0tCYWsrUEhqY2NTRjlvS1JkbjVmZlpXQjZualdrQUhMYzM0ZTFxelpUSThldy9Kc3ZieDU4eStIU1BPVGE0WG5TRk9vY2YzcThETU1xNUV4SHBodHFNWXhqQSt5SmE0UVQ3WGR1L2VBbmJxZUNYN29KeXhlUXdaNzBiSmxhM1FEWVAxcmRKUS9xRHQzK1Z2ZHlheFpNZ3YyTzNic2xiYXpaUG1LWHI1OHhlMnZOYmhHZUVuakdpVmwzTis5ZThmV3ROMjZnWVBWQjdPeUlCelFjSTZibVl0OC92eGxlVEZET2NuRDRlandjb2Rjdm54ZFBpcHdlUFAwckVKVHA4Mk4wQkhReXNQYlZLeHFsWEtFdE5uMlVEM01IVWhUcXJkdlc4a2ZNcDhZWjZsR1pJNktGVXRUOVJyTnpaMml6ZHRQbnpuUENtcG1tWlZ6bEpKdWN5ZENLN3g0OFlxVit3RzBZZU5XYXNxRGVsTUtkVDVXSk56ZDJUTDZ4eEhkWWZDK3JscTFQQ0dNSUJUcU5LbFRjcHp5Y3ZJdXNrYVoxalZrdEZDK2ZFa3hzRTJhTk50b0Q5R3dZWDNvNzcrZjB2UG5MemwwWWJwdyt4MjVvVVp3QU4wTGRHZnJkSmppK3NMZG5mSjhDS0xiclBSMkRYNXIxZUZZSjZaQ1hPOGtPeFcrcFpDMm5yT0dmall3Z0lxd3BScU1FYWpMZWJuTVpqWmlCSVMyK29BdDExY0MzMU5oOXlCYUVicnRFZGM3eHQrRVJtNUJ0RHUwcmRCZE1mSUgzdzA0TVlOS1ZibHlXWlBuMExsekcwcVJJaG50MjNmUWJCbVRGWGxqMDZiMTZNR0R4N1JuN3dFcEFpTXNHQXo3OXgrVzljZC9QeUYvLzhNRWd4Nk1yWWVQSEtjdnZrZ3YzN0VqZng3WE5YdjY5SG5Lbno4M2dVMWhqemhOb2NZSXBWS2wwblQxNmw4MGY3NnZLTXFnZFpoU3FHdlZxaUlmblpVcjE3T2lWRUJvSWpqQnFKNzZzUWRBVmNkNkJFcHhTbDdNUHF4YnQ1VUhWaC80aFY0ejNFekNkNTFhODFUakNINnB1L005RUVBREJueHZNRTBJeFdUWXNONTArL1pkV3NyS0dhUlBueTZpcEs1WnMwbVUweVdMcDFFOW50cUVZZ2hsTGs2Y09EUnExR1FhUFdhU2xBY2ZPeXRiQ3Z2Mzc4cUs1LytrRG1nUExWcDAwUTNjb0hSUG1qUlNQaTVvQjl5dXJsM2JTc0lMZVBDREIvMzc3eXVsSFZqY1FkK0F0YVZSb3c0V0xjNlllc0tzQ3hUZEw3L01LTk5VUlFvWDBDbXQ2Q0E0NDRnQnJIMnNVcVpNenRPMFBXamp4dC81cGZFMzg4bGJVT0xFbjNPL1BhaEprenBpN1laQ1hZMC9la3VXVEpPK3ZINzlSbDRLd0s5NjlXWVJLdm9DaklYL3dMbGN1UEJYSGx6RXBmLytleXZINk5LbE5aVXZYMThVV0NqUjN0NjltSDcxU3ZxMmQrOGhudTQrSWYxRFAxT2xTaTc5eGdzVkZKWHAwMzdrUVVLelVFdTloNXpMaEFuVGFMalBlQXU5Q051RjY0ZmpmZnR0VTFaV1U4ckFDZThZV1AvTGxhOHI3dy9RaW5ac1gwM3AwcVhXellyZ0dzRWlZWXNEWHRoUkxTOVZxVnhlcURLZW5sVkRCbGZucjdCaWZZbVdyMWdYVG1udTVlVXQ2YW5IanZHV1VIV1dXM2JzWGlpT3c0ZjM0L2pTWVZQNGpqb0NsT3I2ektsZXQyNUJqRk9xdmIyOU9JbkxMM3p2ZkhBVUhOTE91blZicUZGRFQxcXlOTVI2NXRER2JXZ01zOEdXYUpab0NnTnl2QXN4TzZ3SkJuOFFoRW1FNU02ZGd4SWxTaWgwbGk2ZDI4cDJ2STlYcnRvb2cxWXBaTVYvN2ZrZGkzZXJzY1VSM05tU0pRdnplMzY4RElhdGFDcFNSU293NWVJY1c0bjFHY3V2dU1WWG9SUU5heHVIRFRzSks4SjNXSEhtSHhFc3dweVJQclF0RUVvU3ViblRQVVFUZ1FiT0FzWDZLUnQrdnRBcThUcnFIV1lyZVVOK3A4WGpvdnA5NDEweFNqQWJqUVJKb1BWczJyVE5wTElNeWdhK3J6dDMrdE90VzNkTmxqRjMwcVg1bXdvakcyWlo4UzJHNExzTzR5MitSNXFjNHhuWWhnMXJVZkxrSWZkeC9nSVZ0RjI2WC9RRDlUQ1lzMGRDTDZrOVZXMnJVNko0RVI0UnBCWHJ6WVdMVitqaXhXc0VXb2V4VXhZK2lsV3FsS1ViTjI1Snhxa05HMzZYVVN6b0loRUp1TmJseXBXUUQvN05tN2NqS3E3Mk94bUJ4bzNyeWcyK2YvOGgyckJocTFodHlqS1BTUk1NbXFBQTRpVmJwa3dkU3ZoNVpob3laS3dvVzFvWmpEaGhEY2FnQzRJNnVYTm5sL3ZwMHVWcnJGUldZTXQzZFZxN2RndWxTcDJMc21VdktSOEh6RnJvQys2N0pVdldVcEtrV2FoVnEyNnlxMlBIbHZLTFViS1BUejkrcUo2d2xic01wVXlWaXhYYU1jTHR3a2NBTW1SSWI0TEZ0bGV2WWJLL1FvVUdvdmhEVWJFa2pYZ3FDZ3JwNGNQSFE2M3ZibUtsdGxSSGY5K2h3MGZweTY4SzBaRWpKd1duMHFVOWFkandIMFhobnp4NXRBeEVFSDBoUmNxY1BMM1ZtNUx3TXpGenBuVktxblljdkFEcjFhc3VBeG84UjNnbVI0OGVKQi9MdlBrcVVQSVVPWmg3dGx5bWhzdVZLNlZWazE5WXBwRmxyMHZYdnRJdjlBL1hFLzFGdjlILy9QbHk4K0NsQVZ1emoxR2F0SGtvUjg1U2JORytUNTA2dGFKVVBIaXdSZHpaZWFkUW9TcVVObDBlYVM4ZnQxMnNhQ0ZwQXNvcS9DbTZkQmtvMTZoZ3djcHlEc09HOWJYbEVGYVh2Y3ozSCs1UFQ4OVcxSUd4bnpSNXBxVHR4dURJbEJ6aEFRZXM1czV5NW9ObHBtaVIvSnhPL0dmMk5SbkVrVDFlbStwV3BMZGh3QW1sZXV4WTd4aVRCQWFPZUxoWGpHZXBJZzBHTjdCOCtYcW5LSWFPNkd1Q0JBbkNOWU43VkY5ZzFIQnpjK1AzWmlQNjZTY2ZDWjA0ZS9aRVdyUXcvR3lqZmozOVpTUUhLbDY4SUw4SFQ5QzFhemQxdS9DdXdhQVh6OHo4K2N0MTI2TnFBV2VibVlQVVhXQ0ZOcklDWlNvQjQySXM3OEMvRGhXNFBJYlp3Yld0eEJidHNETGExcXZCYnBTZTMyOUpUZXpUeXNTRTN4Yk5HNGpoQ1Z6bS8vNzd6MlNYdlhwOXg3cmdwektnTlZuQXdzYm0zRDVrNWNvTnVsSnYzcnhoL1NJQnp4NkhmVTgrTUsvZGttVE9uSWxueGd2empQWTV1MmN4bmFaUVk0b0k5eFVzVkpBdFRQWEFsRGZvSGZvQ2F4MmNvYlp1M1NtYi9mMFBpclVKZEJGajBhYTh2Vm01R1R0bUNCMDQ4SnRNLzJJVUZOSFV1M0ZiYWoxcUVjQTBJYVo4anJNVDR0Tm56MW41T1NxS0xxelVtdVQ1Sm9mUUovYnRPNlRqTDAyZkVlSjBxcFVCenhlekhJVUs1UlZGRDdRTVdIeTNodktxN3QxN3lNcndoRkJMVTZCUUQrN2N1YzhLNTJkaVZkYmFnUVYzK296NWNtOXRaYW9HS0JZWW5VTEFuMHFXTEFuOTl0c09IVDFoL2ZvdE1uSUd4d3BTb1VKSmRtYjRteFl2V1Nucm1FSzZlUEdxdkRoQU16QWxVUDVoZWNGZ0Vzby9VaFNEVzRnQlFHUUZIczBaTXFUbFB1OGsvOUJwcmlWTDF3amVzQ2hCbVRJbnNPQkRtY1Z6TlBLSGdYVGdqOStFN2dINkZPZ2VHTzNQbmV2TGc1MVJ1by9mb1VOL1NuTkpreVl5YVBhWFgrYkk4Vy9lTk84b0dTOWVmRkg4QTNrcUZBSWxIQU9Ub1VQSHlmVXdhRENDbFkwYi9RZ0RkRmdtOEU3QkJ4bUtFYVJJa1JEcXlZS0Z2cklPelAzOWp6QmxKVDdCYWNYUmdwbVB2bjFIeUhXMXRtMXY3M0V5ZUFPL09xckYzMzhqVDZkdWxIY3c3cjJvRkNqVmpkbFJjZXJVc1RScTVDQ1hWNnpIamZObUs5cTRLSUhrQ1ZPZjhMNnhGQVVqU2c0Y1JZM2lmUUFCN1N0bnp0Sk1IY29yMW1yNExsVm1pcHcxVXJkdURUR21MZVYzbEw0MGJWS1BRRHVCZjRFcC95cjlzbzVZL3BTVjFhUk1jWG5KeXF1cnlXTzJXSC9DblVyc0FyR3g3Y1VHUFBtK2ZidUtzK0NxMVdFS3IzNTdPYkpuRlpvdWtrVFp5bHVHRVJWYys2dFhiN0t4NXBpdVdSZzI0c2IxWUV0M09kbUdjbkNBTlNmNGJreWM0Q1BmaHZIanA1b3JGdUYycDFFK3dCZkVoL1B3a1pDVGhtSTljR0FQc1RUcWN5ZkIxY0owLzQ0ZElkeFpPSzM5OWRkdG9ZdmdwUFc1cHVDK1FoR0FnRzhMNVdURWlKL281MGt6SXp4eFZjQzVDSlRtUkFtZ0tZRHFBQUhmL2VqUlU2eGdGaEcrT3l5aHNLYmlHcHV6NkdrOXhtQUx0SWlDQmZJeTFhT2dETlNnaEVOT25qckxvOHNMVkk5ZjJIRDRnN0lJU2dEdUtkd3ZtdUIrQ1E2MVNzQkJFRnhyY0lNaEtWTW1Fd3ZNaFF0WHRPS2lXR2ZQVVZMVzBVZFFRSUo0U2c1OFowM0EwNFhsR3dORmZFU05CWlpJS0h1elppMlJYVGd1ZUYyTkd0VTJjUGd4cm1mTnVuYU9oNHdjQ01IWkxWdzRQMDl6SlRQYlRKdzQ3cnFYRFhCNS9QZ0pnWDR4WWVKMHFRTnU4dVJmWnRFM3JKaDc5ZW9zL093OGVYTElQbU1Ia3lBclh2N0hUNXlpdmN4MUE1ZnV3bmwvdHBndVk0VjlxVW5NekhZNmRBZXVteWF3aEVPZ01FTjVBUTNuK3ZWYjJtNzViZHlrZzhHNm8xWkFvNERsRHB4Wld3U0s1L2J0KzZnZHo2QVlPMjNaMGs1RVpXRjlBYWNkVVNmZ3BPTU0wYzROemtpdFdqWGthN3lNQnowN21ZY2J0Y3E4dGVjbVVVN1lzcG80Y1NMNU5qbkNPZFBjc2VFc0JZdnV5RkVmVDFiSm4zK2VvVE00L1ByckhJbU9BQTc2RGlPL0YxT1lnS29HS3NuMjdYdDB1L0ZPSFRDZ3UzenZmWmV2MVcyUHlnVllGUEVIV29hcnliK2hGSkQ0TWRoQzNibHpXeDV3cFdGZGI2U0I3cWFQTlpKRDRUc3lNZlI3bzc4dm91WHk1VXVKRlJyZlZIM2RFUFFqUkh3Yk1LQ2JHR2hoeUFMMUQ5ODMvWEphKzcxNmRoWS9nY1dMVjVFZis5bllLMDVScUdFOXk1UXBnL0F2RWV0UFgwRHYwRmVVTVpVUDVjZlB6M0M2QjVFSVFCdnhaN3FBSnVCVU95SnNtTmFlK28wNkJLQTBRbWJPbkNCLytrY3FYYW9ZMlVMUjJiVnJQNDk2dTdBRk1yODRFZWtQMU9ETnUzNzlRZzRwbDRkNTF2ZkVvb3I3eTVHU1BsMWF1WmREQm5RdERab0dUUVRjYjFOU3ExWlZ1YmQ5ZlBxeVZkS1FkZ0RuUjgyRDNsVGRpTGFabUdtVUtsRGFJeEx3MlV1V3JHVnhtcXRmMzI3aXBRMjZ5aFYyL01SZ3dsN0JDNjBoYzgzYnM2TWxuSk9CQlVJZXdTTjc0YUtWOWpZYnJmWGF0V3Nta1JIczZjU2t5Yk5wOTY0MTdGUzdpYTF5cit4cHdtSWRoRDVidU9BWEhtQzJka2hFRDRzSE05cTVqbWQyOENGYnYzNnJERzVidDI0c05JRkxsNjRKL2MrZnc2MUZGZlhFcUN2aFZoTXpEN2haczNwTXUzblA5S1V3NmxtNGdnN1lzSjBOUkZBY1hGMmhOdlcrTUk2NHdEcUpDS2gzbXNBSWd1ZGFtK1hUdHB2NmhkTjVWcVo4ckZxMXljQ0JXQXVaQm9mSUh0MDdTbFVZQ3JTWmFFU2tpYXFvVUo4NndFQ05OK0ovWWVONzNhbC9vdmR5L3NCS3NpbUcvaWU4L1Q4anhkbmRhRjNYWUF4WmdHR3BTNWMyTWp1VGgyT0s1OHlablIyMFF3d3gxYXBWRUNYNkNNL3NJamdCT01zMWFsU1N2OEtGODhrWndwa2NnMTNOVjhyVWFTT2tJNXg5NFYra0x3OGVQR0xhMmJjODB6R1NuZVVyRUF4TnAwK2ZaenBlTlRFczZKZUZiOWVnUWQzWmluNlI2VWFqOVhmWnZPd1VoUnBtZDVqZjU4OWZJYU5QclpkVnE1WVRaekxOS2F0Z2dUek1VODNFZk1zVFlzblF5b0VDQWdlbUtsWEtHU2pVMm43MTY5b0lZTG9GWVJKdjNMZ3RqZ05hYnhNbVRFZzllbndyamdLTE9Xb0hGRHVNSVBFQ3RTVEhqcCtpaHc4ZnM3TmRSZVk0WjVNNHFOcW9FNG9ObE9rZmZ2aFpGMjhTU1lBeVo4NW9xVW1EZlpvM1BpenErcElqZXhaNisrNHRLLzkzNUNOOCsvWjlLbGlva240UnM4dXdYRmV1WElhZENoK3g0clhJb0Z6Ly90MGsxT1A0Q2ZaUE5XbDlocFZjWDJBUkI2WWZQcGg2amV1WE5MK01TQi85KzMvUDAybzMrQndhaVNVWmlSaTBGNS81bXViM2dKY0pPZy8rR3ZOZzY5ZGZ4N0JWZkRqOWNlQlBIYTNFZk8ySTk4QVpCWVB3dUhFTnFSUmZwRThyc3d1d1JtcjNUTVN0V1M0QmhRUFRqcHBGMzNMcDhIdmhCRGRxMUNUK0cwVGZNN2Zaa1FJcjdKTEZVM25RTXRIcHlqVE9BNGxmZW5rTjFaMlN4bEVHQlFrZnQrN2RPL0M5R1VBWExseVdHTFVZVkNHOXVUT2tmdjJhYkZWZHk0NVN2MGM2aVV0RS9jVTFoczhBbEVra3hIRlZ3ZlhDakpYbXVJVithdThVekhCQW5qNE5jZGhLblRxVnJPTS92TjhRSGNTVVFxNHJGTHJRckZsOW1RRmN2bnlkd1M3UTZUQTdCbVViZjVCRUhFbEpjNzQrZS9haXd4WHF0MUJrK2YyWUdLT0VTQ3JWNzdtL1R6aEVYa2FZdkVNVmF6U0p1Y0VIb1VHc1lkNTR3c1lJS2NQTEVDaGhvSjNBQ1ZGZjhQVkJNeTlqYUNMeVRCa3ppT0VGM3lib2J4QTR0VU5LbENnazk5akRoNCtFcm9kdmZxZE9JY1lwM0VzUVJNQ0t5K0VLelNuVThIc29XclNBY0o3UFg3Z2tkZlQvdzJ4aCtRcjFkWnVPSDl2Qk5LV25RcmZVTmlLNHdLeFpQNG51MGE1ZFQ0TUJubGJHbGw5Y3l5Z1hlTDNqQXpkMDZGamh6Mm9IaE5jblNPQ2dlWUNyaWJqRXNQcE5tVExQd0JzWlBCeUVPd0Z0eEp2YlVCS3pFRUJrQzNDU1o4OWVRc1pLWTdWcTVjWFNERWRBV0tsaEFVWEVDRzNXQWx4WFl3VWJMKzM5Ky8rVSt3SDNDOEtVYVFJSFJWaFBFUVlQZ25hTUxTeGFXWE8vOERLR2NvOUJnQ2JJOEFnT0txaElqUnAzNENuaWgrSVJqd3hpdDlqREhZSnAvMDgrVFdEUzJsNm9ZRDZaK3NJSDNCZ0R2RGdLRjg1TE9YTmtGVDR3amczNkFGNHNPRmNveGFDdUdBdG1jalNGRWZ4dFlJZlIvdmdKVTBSWmhITmh2bnljYll6cE5mcjBGZU4ySWxyUHdPR0YwQmRZRlRVcVMrTEVpU09xWnJCZmU1RmlZN2V1N1pualBwaXQwd000OHNFYVdyVjZzL0RJd2F0TXg5ZGIzMG5Kb0JFYlZzQy92SC8va1ZoSE1XdUJzRW1RbFN2bjhHeFplcmFXbEhFWVI3TmUzVm9TdVNZeTBTRzI3OWdyOFlxaGFEclMvMlBjMkNIaWp4TGRzYzZOTHgzT0VYOWpPUkVNZkE1bXpCalBQaFo1YUNUenJSMlJWTVg0ZU1icmVUbVVJU0lCMWZac3pjK0svWU5ONDNZdHJTUFVaNzkrM1Z4YW9UN0ZsRG04UDJFRVd4dWFQQVBjYUZqeG9XeERUckdsRDV4d09GaURDb2FCYWNtU1JXWDJEUTdubGdUR0ZXU1BSRlFRNDlqYzNiNGZTUGpURjgwWUF1Zm15Q2F3MG05WFc0YUNlNDhqZkdTQUVoeEpnVHA4bkxHckdzZURQZzBrQWdFTjJSVy80ZlVKY0loajdScEs5NWxnbm0zSHU1c3I0TTVMeDNHd3MzS1pLUnliV292OHdac3BqVnN3UFdGRi96azdKc1pFMFJ6bzlmc09ROHpjdVpNa2dzdk1XU0dHcFRWcmY5TXZRc2lLQzh0MnAwNTlURWFCMHdwREo4UTN6bmhncHUzWC8rM0VtVnd4WUZ1NGNKVXVXaHgwZzhtVFIzRll4dlRpcE8ySTk2NERiaVA5Ym9kZnpzVm1mc1RoeE9nU3ptajZjb1Q1MUs5ZXZkWkZiSURpalFmMStJblQrc1hrdzNmcTFEbWhqWUErb2lSbUlRQkZDVlpTT0FvWUMrSUl3d3BSdWxSeFFqYXRQWHNPeUxUUWl1V3pxWDgvRG0rMmNiSEptSkFiTnZnSjV4bTBILzJZcVNjNVRpb1V6UkVqK3RPQS90MTVLbjJkaE5ReFBxNmxkVGhHSERwMFRFYklTTUhkcmV1M1FsT0JwV1JlYUJJRGNIN2huTE9SKzllelJ5Y0NKUUlLOXhyT3poUS9mdnh3eldQZ0VFSmwyaDF1SDJJamYvTEpKMnloS3k3N3dDM0hWT2Njems0R0owR0VxNFBWU0Y5QWM0R1NDK3QyRmY3NDRXVUFaOXk4ZVhQU3loVnpwYzlyMTh4bnBUOGpjNVNYUmtwNXZIcjF1cnlFd0k4Y00zb0lUWjB5bGhXZkFmcmRNYnNNUlJiYzV0eTVzOUdnZ1QwNWhmRVg3RHg4V0N6bVk5aVJHQUg1c1IyRGFkQmw4SjV3bElDemkvQmV5SmoxZmJmMk5Hdm1SQjVnNUJiSFRTamNtUG02ZWVNWW5UaStRKzVCZTQvYnFWTUxXckFneFBIUjNqWlFyeS9IYmg0M0xzeWFHNW0yVVBmYmRzMWxNQm1WM096STloSDFNVWhEUkJwRUJzSFVMS2IrbzFKQWdZR3paTWRPdloybVRPTjg4SXppNDQzanU2cGdoZ2dENStiTjY0cWovMlFPSFFxZUtweklOVW9hQnJ5K3Z1dmxYYk53d1JRYXpUTXJYbDZkQ003ZjhBZUFJSVRuczZlWGFmNjh5UWFuV3FWS2VlRzhydVpCdERYV2JJUEtVYkRDZWkrZFpJVTZKNGV5Z3pYWkZpbkpHUTh2Y0NLWENucHB3eGR6NnZLMGJHMmU3dmFPYW5HbXhSbWhBZS9XNmlWbm1jZUpYL0t3QXYwengvWkFtdkpaYm9IMGhFTVYrcmtiZmpmeXNVSjlpV2ZaL3JHbFV4OXAyVE9uOTlLOXU2ZjUrNUZlemhES01HSlB3MUJyVFBmUUlNRDdIZDlsZkFjblRmcEJac2hIamZwSjI4MjBvazR5TXd3L0l4aW1vSFJyZnpWclZOYVZzMlhCOEN0dFMwMHJ5OEw2Qm1jdkxicUhmclVIUEcxL2tUMzBRZlBBU3hUVDk1aE9OOFduaFFjb3JGd1lPU3VKT1FqQTBRU2hEQkhYRk9Gb2pBWE9hVkMybXpUeGxGMEk1N1Z0MjE2eFlnd2I1aVhldTNoUkc4dUJnMGNra2NjSmpsYWdQMUNieFpremtUZ0lpaVdjb1REZEJNYy9LSi9wZWJyZldrR3NZa1Q1YU5HaXZuQSt3UWY3L3Z0QnVnUXhVRklRMGcrVzl4OS85T1lwOWI3U254NDloa2dvTlAzajRPR0hid0FVeTlObndtTndnRDlpb0dRMGFGQkxxaUhaeHZIaloxakJxRWs5ZTNhUUFZTkc2ZERhaFVNUWFDOHRXemFVRHg2MmQrOHhtS2V2RmpQZXhhWFBVQjVIai81RlIzM1I2dHI2ZTU5cEtqMTdEcEgrd3hrVVZ2QkZpMWJMZGNNTWt5WEJSeE1lKzVnbEFJY1VmRnBZdUpwelZqM2NFMURNaHc3MVlrZlUrOHhuNVcxc1RYZVVnRTRDcWdOUzJVNmNPSnlqVG5qS2dBaUtLK1FURHF1RWZtRmc1R2J6NTFTYWtGalNwMDlmY0FqM0dSYkFNenhOaVN4ZmtSVlFDMkNCN2VVMUxMSk5PYVUrdU9PSXRnT09zY1JaNTBGMlZNbU02VDhLeFNZaTUrZW9PRDVDNkNFbXRhc0tudGVtVGIralU2Y3U4RFBma1FjNkxlWDlBMnVodm1DbWVObXlkVEpMaUl4enVIY3hJTkptZ2hJaytFUysxM2ovNjB2cjFvM2tYUWVhamF2STFpQjN5c3N6Z0VrMG5vYVZIZnVVRmQ3a2Nkd0lrVUkwT2V2dVFhM2ZCWXFDdm9JekxhWms1YnJwKzdDMDR5aDNnQlBJZEhyM2djcXc1ZG1YeTBBSmE4SUc3SmRhSS93TFlrUXhOZ3o1c2NVYmx1L1lMdEQ5WUZSNitUSmtlSUZNbW5pdit6TjlTcnZuakRINk1sTkcwUUhna0xobzBTcU91OStZOEMzVHBFcVZja0k5eXBVcksxTU9SeHY4Z1lwbWo3akZUL0JGMk4xZ1R3c3hwZzdHbjdIa1ZHUE1OVkVkVlFqRWJBU1crODVpcFgyQ3cvakpzRjV1M2JKTVh2N0dneWhya2NxY09SUFBidnpNQ2s1Ymh5ajYxaDdYVWVVcXNFVVVEa21kdS9SelZKTzZkcnB6WmxGRXZMRTJnWkN1b29NV2tGMTErZkpabkkweGhGUHFvR1pWTTVGQTRGT3VlempPQnhySm1SRlhHMW1KSTlGc3BLcm1EZ3FnN2ZIY3FFaUFHOTNWNTRGRXF0V1lXUm1VdlRObjlrcVFnU0pGcTdyMFNVUzVoZHFsejE1MVRpR2dFRkFJMklrQXdrSEJ3dTNJY0d1SWVERno1bUttd25TenExZFF5T2R5NHBZdVhmckhTR1VhSnczSHhjOCsrMVNzLzNhQllLWVNuTjVCT1JqSkRxRFJKYkRFSTM3ejExOW5pcTR1cU9NYUlRQ3U4ODhCUWRUVnc0MHN1OE1iVll5aVZaait1aktWWkNIUFdzWjJaUm9RSTc0LzhraE1tVEluaWhCM1hMTktvWFljbHFvbGhZQkNJQlloMFBtN3RzSlBkL1FwSXdadjJiTEZoVzl1Uzl0aEVUMGNaekczNWZpT0xJc0VPVWkyNHFpRU43QU1UMkkrTUxqYXpuSkNOSWNISEp1blR4dlB5VzYrTmxkRWJYY3lBcjV1OGVrTlQyQjNDSDVuSi9uTGNSMHVGL3llaWpJZFpDTDNTUWx4UnVQVi9OejJFUWQyVjhkREtkU3Vmb1ZVL3hRQ0NnR1hRd0NXYVRpUmJ2WGJHU1Y5UXlJRUtKVFdDQ0pXdEd2YmxDYXo0ODNtemR0ZE9vcUVOZWVETWtnS3MyclZaazRrMU1uYUtoYkx6Wmd4Z1IyVkowWjVlRHlMblFqZGlXZ21aY29VazZndTFwUlhaYUllQVVUZjZCQWNsMUs3QUdNNVAvZWhkWUE3UFl0MjFUN3FjYmZtQ0hmdTNxTmx2bXV0S1JydFpSU0hPdG92Z2VxQVFrQWhFTk1RNk1qVGtMQ2V6cGk1SU1xNnZtVHhOSEdxUll6cU4yL2VVQ0tPaTQ2d2dvZ0FnOGc0cVRoTUkwSXFObTVjVzlhblRwMHZrVUtpckVOT2JoajQrbTMxNVNuZjNoeWE4bzdkUndkdkdna2lYQ1dwQ2l6VGNQWkRlTmpJbkpmZGdLaUtDZ0dGUUpRZ29CVHFLSUZWTmFvUVVBaDh6QWpzMmIxT1loaEhaWmEvMWF2bVNsZ254T3MvZi80eWU3aS81R2dvRHlWbE01SnJQSHo0TnoxNjlEZnpnc3R5UFA4aUVrdFZpeFArc1dBUDNuTmZEbjNWclBsM2RwMFM2dnY0OUtkNkhJRWl1cWtlZHAyQXFxUVFVQWpFR0FROERpMWFFUUFBSWxWSlJFRlVZa3hQVlVjVkFnb0JoWUFMSUZDaGZHa0pheGlWeWpST0U5RkRUcHc0UzFPbXpyT1luaHRPa1Nqek1jcHhEb3VKUVlObjdhcTBTUytCVTBUbk9taGdEOG0yaDRnbmpSdDNWTXAwUklDcC9Rb0JoVUNrRVZBVzZraERxQnBRQ0NnRVloTUNLempzMlJEdnNick1jYkhwM0tQalhPRlF1R25URXFwUnM0WEZnWVhXdHpLbG1kdk9WQkhFZjYvSmRWd3RTNlRXVC9XckVGQUlmRndJS0F2MXgzVTkxZGtvQkJRQ1VZZ0FMSjVJQTYrbFlZN0NRNm1tUXhGQXFMbXBiSUVmT0tBN0lhR0lPWUZ6SnVnZFQ1OCtsOFJCQ0NHb2xHbHphS250Q2dHRmdLTVJVQXExb3hGVjdTa0VGQUlmTFFKZE9yZmxPTkdMUHRyemM5VVRXN1Y2RTdWcTFZaHk1Y3dtS2J6MSt3bEZlaUNucjBjbVVtVEJWSU1kZlhUVXNrSkFJZUFzQkJUbHcxbElxK01vQkJRQ01Sb0JXRHczYjFwTTVTdlVqOUhuRVZNN2o5bUJxVlBHVWlQbVJJTy9qdlZ4WTBOQ0MzcDdqM05vZ3AyWWlwSHF0MEpBSVJCOUNDZ0xkZlJocjQ2c0VGQUl4QUFFRUhONnduZ2ZRbWJFSlV2V3hJQWVmNXhkaE9VWnZPaUhEODZTbjk4dWRqUU1KSVFVUEgzbS9NZDV3dXFzRkFJS2dSaUZnRktvWTlUbFVwMVZDQ2dFbkkxQTNqeTVLSHYyekpTVDZRYjJobTl6ZHA4LzF1TTllZktjM0RnMzg1dzVTMm43anIwZjYybXE4MUlJS0FSaUlBS0s4aEVETDVycXNrSkFJZUE4QkpCZ3BHT0hGaFFZR0VpejV5eHgzb0hWa1V3aWdLZ2ZjRlJVb2hCUUNDZ0VYQWtCdHdTZlp1QU05ckZCMkt4QnNlUlVZOFBsVk9lb0VGQUlLQVFVQWdvQmhZQkN3QmtJQkFjVC83TW9IdTV4TE81WE94VUNDZ0dGZ0VKQUlhQVFVQWdvQkJRQ3NSYUJvSUNJamJJZWdSOGlVTGsvS3ZoaTA3bCtWQmRPbll4Q1FDR2dFRkFJS0FRVUFnb0JsMFhBM1dWN3BqcW1FRkFJS0FRVUFnb0JoWUJDUUNHZ0VJZ0JDQ2lGT2daY0pOVkZoWUJDUUNHZ0VGQUlLQVFVQWdvQjEwVkFLZFN1ZTIxVXp4UUNDZ0dGZ0VMQURnUVFtUVdKZUpRb0JCUUNDZ0ZuSWFBVWFtY2hyWTZqRUZBSXhGZ0VLcFF2SlpuNUhIRUNSWXNVb0ZVcjUxTEpFb1VkMFZ5c2FpTmR1alJVcFhKWlR2QVNOOXg1Wjh5UW5wQ0d2RXpwWW5UaStIYTZkL2VrdzY1WnVJT3BEUW9CaFlCQ3dBZ0JsZGpGQ0JDMXFoQlFDQ2dFOUJFb1dDQXYrZmowWitVc0kyWE1WSWd6OUgzUTMyM3pzcWRuVmZMMHJFSmZmNTJKU3BTc1NXL2Z2ck81amRoWUFVcjBjdCtaVktSSWZ2TDNQeXdRdUNITEM0ZERSVGlyZS9jZTB0T256K2pGaTFlTTZYdkJkY0g4WDJqaXhPbTBhZk8yMkFpWk9tZUZnRUxBaVFpb3hDNU9CRnNkU2lHZ0VJaDVDSUE2c0hyVkhFbDd2WDM3UHBvd2NWcWtUbUxxbExHaTlEMTY5RGRseTVhWnZ1OCtLRkx0UlVkbHBHR2ZQZXNuU1FFK1plcThLTzFDOG1SSnFWMjdaandJcVVyWHJ2MGxBNXZ1M1FkSG1ISWNLZU9oaEUrY01KeVY2N2MwY05Bb05YaUowaXVsR2xjSXhHNEVsRUlkdTYrL09udUZnRUxBU2dTZ25QbHQ5YVYyMy9hZ3UzY2ZXRm5Mc0ZndVRsL3U0OU9QR2pYdUlEdWdYUHY3SDZKVnF6Y1pGblR4dFVFRGU5THc0WDNZSXZ5Y3JseTV6bGI3QUJrazNMcDFsMjdkdXNOL2QrbjY5YjlZb2ZWZ1piZ3BMVisrbm83OGVjS21zeXBZSUE5MTd0eVdvTHpQbWJOTXJNejJ6ZzQwYnVSSkhUdTJwRjY5aHRMNUM1ZHQ2a2VtakYvUWtTTitZaFhYcnB0TkRhakNDZ0dGUUt4QVFDblVzZUl5cTVOVUNDZ0VISUVBK00vZmY5K2VXclh1Wmxkem16Y3RwVjVlM3FKc29nRllVVGR0WEVwZXZNMVdSYyt1RGtTeUV0SitUNXpvSTVTSzNidjk2Zno1SzNUNXlqVnBGZnN5c3ZLWk1XTjZ0aUoveWIvcHFFU0pJcFFuVHc1NjlPZ0pLOTdYWkNCeS9mcXRVS1U3UlBHK2Rmc3VnZjljbzBZbFdyOStLNVVwVTR3NmRHaEZOMjc4UlRObUxJelFFbTN0S1dYTThBWE5uRG1lMXEzYlFuUG1MbzJ3R2l6anpaclY0Ny82VktEQU4xSythTkhxRHV0UGhCMVFCUlFDQ29FWWhZQlNxR1BVNVZLZFZRZ29CS0liZ1prekp0Q3FWUnRwOTU0L2JPb0tyS1I1OCthaUlkNWpEZXBCMFZ1NDhCZXE3ZG1hWHI5K2JiRFBsVmJLbEM1T28wWU5wSEhqZnFXdGZydXM2bHJxVkNsbEFMSmt5V3BSdktFNFErbk9sT2tMeXNETG1UTm5vblRwVXV0K3dZT2VPWE1STFZpd25KNHdIOXJSZ2xtR0VUNTk1ZGpkbVdyejR1VXJnME5nZjRYeUpjV3EvdGxuLzJQTCtnWmF0LzQzU3B3b0VTVkxsc1JnZHNHZ29scFJDQ2dFWWowQ1NxR085YmVBQWtBaG9CQ3dCUUZZTHRldlgwRGxLelMwMmtFUmx1amR1OVpSbGFwTlRDck5uclhocUZpVk9uVHNiVXRYbkZJV0hQSlJJd2RRNnRRcG1ZTFJMNXdTNm9oT2xDMVRYT2dkbzBiOTdCUkxmY1VLcFduSUVDL2F6TTZLb0tnY1AzNkd2djIyR1ZYZzdidDMveUVLL1YrODNWam16dm1aRmk5ZVRmNzdEeG52VXVzS0FZVkFMRWRBS2RTeC9BWlFwNjhRVUFqWWprREhEaTBwY2VKRVZqc28rZ3p2TDF4ajMrVnJ6UjVzNGdRZk9uUG1BaTFlc3Nwc0dXZnZBTVZsN0Zodm1qcDF2bGhxblgzOHFEd2UrT3pIaisvZ1FWRWdLOWJiUlluZXZlZUF4VUVTWmhPbVRoM0xzd2t0bzdKcnFtMkZnRUlnQmlLZ0ZPb1llTkZVbHhVQ0NvSG9SY0FXQjBXTnUxdTlSak9MblVhYlc3ZjRSanVmZXREQUVLZkxiTm0rNWlna1g1TlhiMis3blRBdG5yQUw3QncxY2pDOWZQblM2b0VSdW95Qno2Wk4yNVNWMmdXdW55TzdrSnJETDNZT2ZrY2ozQkx3VXZTSlY5QmIyazV4NmJ4N25PanJoRHF5WFFoRWkwTGRvWDBMU3BJa01jMmN0WWorK2NlUU0xaW9ZRjZxVnEyaXdjbThldldLclNOYithVitYN2U5Wll1R3pNUExvRnNQNWtDazkrOC9vTFhzY1BMcTFUKzY3V0VMSWZGS3c5YlZra0pBSVdBTkF1Q1BkdXJVaXA0OGVVYnpGL2lHcTJMdHM0am5QblhxVkxyNndjRkJkSnNkMGxhdDNrenYzcjNUYlRkZTZPM1ZoZDYvZjA5VHAwVXVQRnV0bXBWcHpacDVFdWtCNzU3SWlyVU9pa3VYVEtkSmsyYlM4Uk5uSWp4a2RQT3BjK1hNemxiYjdYdzkzaE5DMDdtU3RUeEM4SnhVQUx6dzFhdm5VdWt5bms0Nll2UWNKbjc4K05Ta2NSMDZmUGc0WGJsNjNXUW5jbVRQUWxXcWxLZjQ4ZVBSN05sTG1BNzAwbVE1VXh1LzY5U0draWRQU3N1V3JTRjllbzFYcjg3MHYvOTlhbERseFl1WGtYNytEUm8wV29uSDYrdmQzdEdlb0dENlNVK2gvaVlvZ0txN0JkQ3JZRGRhNng2UC9pYm9FZGJKNTF3c2I5QUgydThlbG9Rb1UxQWdOWGN6SGNmK05XdnhNOXdUVU1XZzl6VE93NDBxQkhuUU14dU9aMTJ2SEZ2S3d5TU9OYWhmaTJQcWYwbEJqTjNKazJmbzkyMTdEQTZDTWswYTE2VXZ2OHpBZExjM3RHTEZCbnI0NkxGQkdXMEZkTHBHN0d1Q3FFRFcza3M1c21lbEJnMXEwVjkvM2FhbGZDOFppNlg3MkphK0diZHJhdDNwQ25YYU5Lbm94SWxkOVBubm56Rm5zRFh0M09WdjBLL08zN1doeVpOSDBvY1BBUnlzUDVnUXR6OXUzTGhzUlhoRmRlcTBvY05Iamt2NTMvMVdVcmx5eGZsREczSnp1cnU3UzV6WWl4ZXZVdlhxelV4Y01LVlFHd0N0VmhRQ1ZpSlFvM3BGVmtUbjAvUG5MemhpUXpsNit1eTVRVTFybjhYRGgvd29YNzVjdW1jMlRoeDNpaE1uRGgwOWVvcHExMjVsOWdWNjk4NHBlUkZuejFIUzRMamFpcWJ3MzcvLzBPUUxWU3ZuYUlVYTdVYmtvSWdNaTQxWktlbmNwWi9XalFoL3dhZXVWNittaE9lTHNMQ0RDMlRMK2pWL3pHYnlPM2kyVXFZdFlEdDYxQ0FPcFhmaW8wd1lBd1drZGF0RzFLOWZOM2JlVEVjTkc3YW4zN2JzQ0llR3ovQisxS2RQRi80K3MrTEg3NFRpeFdzU0lyWllJK1hMbFdTYXpSTCt2cnR6ZEpmbXRNLy9vRlJMeEpGaUxsODZJSFFxL1hiKyt1c09tWHYrOWN2WnUvd3RXNmJieG5HanlrSHhTQnZhdCtWdFUrTEZwWnVCUVpUWVBVU1JydkUrbU02NWUxZzhEQlRwcnNGdnFUdmo4aHVIay95T0V1aktGMklGZTNTYzhQYnZMS3kvL01OMjhTS0JjZWs5bDE3TXl2MERWbEQ3czNMdnFvSkJ6OG9WYzZoU3BkTDA3Ny8veVgyQU1Ka1RKODZnb2NQR1NiZWhzQ0lyYkkwYUZVV253L3FEQjQrcFlxVUdkUFBtYmQycFFaSHUyYk1UKzFHMDRXM0JWTGh3VllOQmxxNmdpUVh0KzdOMzd5R3FWcjJKcmtSRTk3RzFmZE0xYU1XQzAxT1BseXBWakIrV3p3a0tjSjA2MWMxMnNRdC9nRDVQbEprU2ZwNlordmYvZ1JJbVRFZ2pSdlEzS0E5bHVtVEpXbEl1V2ZMc1BOSmRSemx5WktFMmJjSkFOYWlnVmhRQ0NnR2JFYWpQRmdoMy9xQWtUWnFZUTVvVk4xbmYybWNSTTFKUXl2RnNwMG1iaDdadjM4c3Z6M3hVdDI0MWsrMWFzeEh2azM3OXVsTExsbzJzS2U3UU10NGNzV1BFaUg2U1FNUzRZVkE0aGc3dFRTaGppeUNySDJiYk9uVnNaVXMxaDVSRlNMeG16VG9yWlRvQ05DZE1tTVlXL1BZUmxJcDV1ekdnT25kMkgwMlpNa2FpbXBnN2cvYmZOdWZ2OHZkMDZ0UTVVYVRUcHN0cnRUS05Ob2NQN3lzeHlvM2JUNVV5QmNXTEYwK3NtQWsreVVEYVgxUXEwN0NGOS9Kd3B5a0J3VHBsT2pGdkc4YkszNVFQNzluSzdFRTVBK0xRSGJZdWU4Y0p0R2d6cnN2VzVZc2VBZFNCRlV0M3llSnBlSWJIMkZwZE5UaWV3Vjh0WHIvSHMzV2JXWEdITWc5MWUzcWdPN1ZtWlQ0OUJSazI0RUpyYmRzMEUyVjYwYUtWbERKVlRzcVpzelMvdHg1UnQyN3RDUDRKRUZpdnExZXZ3THJaV2txU05BdS9wMy9nV2NvVTlPTzRvYm96cWNuaE1pL3hJS3BQbjg1aUZOWHRzR0toV3RVS1ZLcFVrWEFscmJtUHJlbGJ1SVlqMk9CMGhicFJvOXFjQU9DbHhDK3RXTEdVVlFBdVdyeUthUnl2SkxTU3VmUEJsUEdLRmV2RnFsMlFhU05LRkFJS2djZ2o4T21ubjFEWnNzWDR3M21lcmNUL3l0UmFSSzFhK3l5Q21yVm9VWWdEWGhGMmZvdUpndEJ1aVByZzFhdFR1TzUzNmR4YVloN2JFLzV0dU05RWlZR00xTm1nZ1RoREVOYnZ6Sm56dXJqU3pqaG1URDBHd3UwaC9YbXJhQmpFUlNWbVVIYVF3Yk54NDQ1eVg1czZGaXg3M2JxMWx6VHZUWnAyb3BPbnpwb3FablpiM1RyVlpCQjk4MmI0S0NwdzlJVkMvZmZmVDgzV2QvU09Vc0h2S1JsYnluY3hwVU9Ub3J3dE9SdjlGZ1RGRlFVWHhOVEZyUEFXaitOQmliUkNKbjVUdWdXUjk0ZEF5aGZvUVhlNHZEVUNXa2tlYm5kVlVCaG4raVFyM2crNGZnUHVoNnRLblRwVkpRUHBsQ256eExIM0RsTnl0L0JNQnI0Wm9JQkFHamFzTFpicEdUTVdTcG1ac3haS3R0TlNwWXBTa3NRWXRoQ2xZZGJDenAzN3FYUnBUN3A4MlRTMVNBb2EvWWY3Y05pdzN2VHc0V001aHY1dWErNWphL3FtMzZZMXkwNVZxSk15YjdwRWljSk0rVGhIR3pmNnlYUlMwU0lGSSt4bkF1Wm53YUtOOUxHV0JBQkQzcng1WTZtWTJxY1FVQWhZaVVEeFlvVTRUbkFhVVF6UG43L0VNMEtGbWE2Vk1NTGExajZMV2puVGZnOFJIb1ltL1R4U3JCc0pFMzVHb0lDOWVmMFhsUzFUUWlyQzhuSGw4aUY2Kzk5dGV2VHdQRFZ2WGovaUJ1MG9zV0RoU3VhUmxwT01mbHAxVEdHQzZqRmo1bUp0azAyL3lBajQ0c1VyVWFwaGZZOXFRV2c4Skt3Wk8yNUtWQi9xbzJsL3lwUzVrbjBSTXhFZmkrempySjJsU3RlMlNHWEpsemMzSzB5WmFOZXVQOWdpK2RDbVU0ZXloWENGU0NGL3dvUlBBV2FiUUFXN2V2V0dUZTFHcG5CTjl5QTZIUmhJei9Wc3o1bVpidnFNL3g3ck9RWmVDWTVEeWRucW5Jb3QxZVprTmxNMEZyakYxMW02elpYVDM5N01QWURPQkFiUUJUMHFDVFNkSTN5YzZxejNPRlZKMCs5WUJNdXdPdnY0L0VSUXBEVjUvUGlKTENKeURpUjkrclNpajEzbWJLb1FiRWNrSTN4RHNtWExMTnZtemx0R1RadDFzc3JIUkNxRS90ZTRVVjJPNjUrYlZxN2NLSVpVL1gzVzNNZlc5RTIvVFd1V25YcXRNQ3JCdFBHbVRiL3ppTVJmK29jUGtTV0JFajVzV0YrNUFMNis2ODBXelpvbHN6eW9IejU4WUt2WFNyUGwxQTZGZ0VMQWVnVHdmT0lsdUllVG1Helk0RWVwVXFXZ0VzVUxXV3pBMm1jeGI1NWNOSkFqU3J4NTg2OGtTckhZcUptZGE5WnM0dW5qQ1RMWXZuanhHanNjZXRQVmF6ZkVBV1lPeHd4T2tTSVpUMS9QbzNuemZIbDZzb3laVmlLM0djb3ZhQjFqeDNqckdobzFhaEQzYXp4akYrTGpvZHRodzhMQWdhTjRpblNFUk5xQXdodVZNbkJBZHc0SE44OWtqT3lvUEc1TWJodFc2dFdjTXI1WjA3b3grVFJzN2p1UzhzUmpPZ0lTM2R5N2Uxb0dyQmk0VnFvWThmUFZ0RWs5eXBVckc0RXlFeFFVM29JTDN5bzNWbHA3OSs3TWcrT2I5UHFmRzdSbTlUeUNIaEFWQWhOY2ZyWk9YMkRLaFQ2ek9ZVmJNSDFnaFZyLzZkWFNEQ1Z3SUEwRGZHdFBXS2ZaR2gxZ2RJSW51RVBaV0tHTzJpZmY2S0EyckM1YXZKSW0vekpML051MGFuakh2bno1RDUwNmZVN2JKTmNUQmxGTk1QdUFhd3lPczcwQy92YkFnZDNabUhKTjlFbDcyMEUvSE5tM3NMTzB0MGMyMUd2UW9MWjgrUHg1RlB6bjBSTVNpcWxXclNvbVc1ZzdkNUk4cVBmdm42SDI3WnZUZ1FOLzB2Z0podFlUUE5SSGoyNlRjbWZPN0tGQ2hmSnlxdHJGdEhmZlFaTnRxbzBLQVlXQTlRakFlbHlUSTJQQWUvcm9zVk04eFgxSXB0WnExYW9hcmhGcm4wVllrc0dYZzlYNHlCRS95cDc5YXhvejVoYzZjZkpzdURhdDJYRGc0RkcyVUd5UWZtR3FHaW1sWVRXcnpwR0NNSGlmT0hFNjllcy9nZ1lQR1UyREJvMjJwa203eWh6NTg0UU1ERUFCS01temNIamgyNXBKMGZqQVNPazloWlZjZUx5M2F4dDFmaUhnRytiTm01T2pyV3d5N29KYWp3QUIzRzlkdXJTVkZQSVJGTlh0enBZMU15ZktHV1NSd3FncjdJSUxjQnlFVktoUVNxYjQ0Y0NLYUIwTEYvNUthZE9tTnR0ak9BOWp0dVhjdWN1MFlxVnA0OWpubjRlMGphZytFeVpNcCt2WC82SmF0U3JUVHorTk1OdHVaSGFBUDUyZUZlcmI0WFg3eURScmRkMEt6TGxPeHY0cEc5ekM2Q1phNWJ2QjdwU0NGZEhFSmdZZVdobFgrcTNOdWx5aFF2bmtucmgzNzRGMERaSFpZQXpJODAwT1hWY1I3U095MHE1dE01a2xHVE5tc2poRTJ0TmVWUFROc3J1cVBiMDBVd2NmMHRLbGl6Qkg1Z1pkdUhoRlN1M2JkMGltTkJFcTc5angwd1kxMTY3ZFFxZFBuNWR0ZUhETGxTdEJRNzM3MEhDZjhicHlnVHlxUTVwYWZFZ3gwbWpkdWhHLzNGcHpwaXQvMnNiT1Rrb1VBZ29CK3hFb1hDZy9wNGxPVDlPbkw1QkdvUFRDTTd0S2xiTENrNE5udHliV1Bvc0l4elp0MmdMeG80QkhlUHYyeldqdzRKNjBmLzloSG1TZjFKcUw5Ry8rL0xrbGpCTWlNV2lDOTBSVXl2YnQrOGpYZDdvbzFnVUtWSGJZb1pBTVp2dTJWYUpjTzZ4UnZZYmdpTmkzcjQvZUZyVm9MUUp2Mzc2akpVdldFQkw5WVBCampmajQ5T2NvTHRWRkNlL2J6OGVhS2k1VkJsRzNJUFBuKzFMM0hvTmxHVGpBWWxpWEF3MU1ueEh5dnBBZGV2OTE2TkJDM2ljdFczYVZXUys5WGJyRnhVdFcwbzBiZndrdDRCbEhGY0s3NS9EaHJSd2xvaEtsNFV5ZEQ1Z3Y2MGlKejNicEJLdzd2T0EvWnd1TzJNb2ptUHlaN25HWHdsdHIvMlVLQ3Nva29VQzY3YkxFanhEVUVMME4wZGtRamMxbnhBUWRsS3RXYlpJQjBjQ0JQZWxHcDk2c296V0o5RXdoNkhTOWVuV2tzMmN2MHNaTmZvU3dlZlpJVlBUTmFRcDE4V0lGSlhVdE9EYmVRM3JMK1lOSEE4c1cwcjBhSzlSK2ZqczVCRlpJVnJGcDArZlRTUTYxMTZGRGMvcjExem02c0YyQnpIdGF1SEFGblQxM1VkcmJzMmMvVTBuVzhpajRlNlZRMjNPSHFUb0tBVDBFS2xjdUs2R1F3RFhUbmxsUXF0S2wrNUlLRmN4bmtOakMybWNSbHFmWnN4ZnJRaUw5eVpiZFRac1dzMExYbFJvMzZhaDM5TWd0SmtqQXlSa3daY3ZoTjUwbHQyN2RGbVY2d1lJVkhQSGdqc01PQzJVRkRuQTFxbGVpcmZ4ZWRLUW9SOFRJb3drcjlZN3RLMlYyQk5mS25KUXBYWnc1cC8zb0lNK3FJUFBrbkRsTHpSV05FZHVQaElhd1JXZi8rT01JRDJDL0p3eGtUVW5LRk1rbEtncWlnaUNLalRrQnZVeC9odm54MzA4SWhqZjRJMlJseTc2akZXcXRILytDNytGa25Sb1JQTXJFaVV0ZDMzMGdOa2FIa3hmaHRyam1Cc3hrZ2w2WGl1T3pkK25TbjNNTDNOTjFkUDJHTFV3VnJNRUR5Qm84Mi9Bbi9mZmZXN3B3NFRMUFRHYVJRQk82Z2pZc2ZNZWhsVEVUQWlPQXh0VzJvYnF1YUZUMHpXa0t0YWRuTmVHcTVPUndLdmpUQkIrOXVuV3JNNTFqcXJZcDNDODRsckNNRldmdUpvQTBqb09yVllBRkRXRzUwcWRQbzIxU3Z3b0JoWUNkQ05SaGIzendIR3ZYcmlKL1dqT0lIWTFRU1A3N0QybWJ3djFhK3l4ZVoyc1VMTjBaTXFRUDEwWk0yNERFTFFqZm1TQkJlR3RUWk04Ri9PWVpNOFk3VktIV0hCRnIxR3dSMmU3RjZ2cmd5V01RMWF2bmR6VHV4MS9EWVNFVUQrYlVQMzM2bkIxak81dklrUkN1aWt0djBKSXd1ZXM1N0NGaEI5NFZHTWlhRWxBNzRYK0J2OWYvM0RRb3NtM2JDdWFpYjZaV3Jic1piTmRXNEp5THNKMlI0ZHhxYlJuL0JyQVdqU0YzQ3FNZEQzZzlMbHV0UTJ6eElUdVRoYktzM3pySVdseWZJM2o4Rnh6WElMcUlmamVTaEI3dmc3TTFmZjFPV0xFOGNFQVBxbGl4Tk04bUxLUWxTMWNiMUlEQzI0enZlVGlJUTNmRHdHdldySW5pcTNGREx3NjFRYVVJVmtBQkJ1OTV4WXJaQmlYaGxQN3E1WFVKcGF3WldRMEtHSzFFUmQrY29sQmpCQU95K3ExYmR5bFg3dElHbzRyZk5pK1Z5QUU1YzJUVlVVR016bHRXUVJuQkF3dExtRGxKa1R5WkpJRnhwbFhLWEYvVWRvVkFURWFnUVA1dkpQVFJwazNieFFOYk94YzhoNGhUVzdObUpSbzBlTFMyT2R5dnRjOWlRdWJYZ2ZyaDZHY1dVUVFRTFNBWlR3ODZXeXhaS2UzdEN6S0xRV2xCZk5memJPRnhoQ2hIUkVlZ0dOS0dML1BjL2ZkdFlBcmlRazVROUVvMklxWXk0cEFqU2c2Y1ZoMTEzUnpYYS90YWduRUwzK0t5WlV2bzRwVWpBeXFlTnppSm1SSllzM3YwR0dLd3F4VW5qMEdJMjE5L25VczdkdXlWZlFjUGJLRXZ2a2pMZWtJWlhjYmpyNzdLS084SEpJOXh0Q0NheGd0T29KS0luUkQxNVNxRlJQUkl5NUUyWG9ZT0hMSndTTHduYkFCOHBEZVEwSzlqeXpJVTlTYU1seDhQeHA3cEpYN1JieU1KcjZCL3p4MXdQUDEySGJrTVI5VCsvYnRKY2k0dG1ZdXA5cmRzRFpsWnk1MHJPK1hPblYxODRrQVBzVWZnN1AzSkoyRUR0OVJNQlVKTTlLdFhiektkY0o3TmtXY2MyVGNURXczMm5LTGxPZ2k5aFdualE0ZU9HeWpUcUxWMTZ5NEc1eFBtU0pjMDIwZ2I1dDE4dzZUMkd6ZHVtMDJCaXRGcjM3N2RKQU1qSEJpVktBUVVBdllqVUs1Y0tVa25qUENXK29JWm9PUEh6MGdVRGFUZU5pWFdQb3R3M092WnM2TllkSGNaWlV3MTFhNjViYUNSNEFPZk9uVnlYVno3Z3dmLzVNRjNrRXd6STBJQTZHVnRqUno3TU5CSDhoUkVIb2dKQWlzMUhPQWNJY29SMFJFb2hyVUJLL1hreWJOazZydGdnVHdFcTkzU3BkTWwzR1M5K20wL0dtVWFad3hmQnd4WVBUMnJVTjQ4T1NreE95bDZlWDBueHE3OW9iTldTTS9lMjZ1TE9PaWlEZ1lUcytjc01maEQ5a1BNVVB2NTdhSmR1L2VqbUN6RHdiRnI2SDFldGt4eDlyMHFLalBVK3BFanBMQUQvb1BDZXAwNXlqbERNeUZxVFo1MGkwdVArWjNTaWRPRVEwbENwSTIyckFBZllyN3p5OUJDaWZpM1pkQTdpM0dwUTR1Rys4bkhHUk1SZTlwWEwvYTBjYUd2V1lGSE1obU9pV0c4eXlYV1lYR0d0Zm41ODFmVXVzMzNRbmV6MUxFU3hRdXp2OEUwZVVmLzlOTU1TMFhEN2NON0dqTkFjSWlGRlZ6L1hscS9mcXU4LytFamd4Qjg1aGdNNFJyVjJ4Q1p2dWsxUTA2eFVGZmxiRGI0ZUlFWGJTd1l1U0xMV3YzNk5ReWNHV2JNbU1CVENPT2xPSGpXK0pCN2VYa2JLT1RZZnVEQWIxSUdUb2xJZ1hydDJrMGFNM2F5OFdIVXVrSkFJV0FEQW5DYUF0OE5NVU9OQldFdmtVb1dzMDZJYmdHeDlsbUVoZnZNbWIxU0I5TjJlQzhnYVl6bStDZzdUUHdINTBoTTUra0xQc2g1OHBhait3OGUwY1dMVjZrWSsyazgrZnNTWjJCdFF6dDI3dVBVeHRzbEErT2RPeWY1dzAyU0hoa2ZjRTBLRnNncjBRTVEzLzdRb2FNMlpYclQybkRtTDdBZU44NWJGQmpOQ21ydjhaVWpvcjNJbWE4SENnM29VV1hLRkpPTWNOVTVwWFprd2lhYVAxTDA3Z0ZGcTJmUEliUm16VHptZzIrUmJ6S2UvMW16bGpBTjdMQjBEazZFWThZTW9wTW5PWk5paVJwV2QzamF0UGxNSjZzb1hIT0V6dnZzcy8vSmU4akxhNmpCdDkvcUJxMG91Q2N3bUpYbE9CU1BYdzN2UTh1RHYrekRkSVVwbkdTbVl1QUgrcHpmVmNSVzYzWmNRT003MStIVTVEUGl4NldFbkZSdWhydHROSy9tN29GMGd5T0wvTWtKWEV3SlZPaWluQXI5RU0vSXZ6Y2ducGdxSFQzYmhuTTQ0M1RwVXN2TTJiNjlHd3c2Y2U3Y0phcFJzN2xzZysvSHlwV3poRDJBYndxeUplcno1QTBxbWxuQnZZQXdqUnMyYkRVSTAyZW11TldiSGRFMy9ZTTVSYUcrZWZNVy9mRERUOEtmMFQ4NGxzRTdIRFpzdkV3WEllajdNUTdQTldxVW9VTDgrdlZyOGViVXo2eTBsRWNwNE9PRVNiQmt6Rm16WnJOdXlpMXNuMXBTQ0NnRXJFVUExdHhObTdaSmpGMVQwOVM3ZHUzbjUvbG5EbnQ1WDVxMDlsbWN5ODVibUJyV0JNcnRuVHYzYU8yNjN5eGFOMzcrZVpaRUZkSHFhYi9JdUtwSnkxYmRxSG16K2hMdDV4ckhvWWEwYk5XRm1qU3VLOVowVEM4ZVBueWNJNVNVbDNjTTlvTm5ONWhwSzNqSjM3cDlGNXRjWHBCeHJGMjc1alJwOGt5Nys2b2NFZTJHem1MRnJUeXREU2Q1OElFMWk2dkZDaTYrYzl1MjNjTDd2bklsNUhuUzcrNmV2UWQ0VnJtZUtMOHdaQ0hwMDRhTnYrdUs3TnkxajVYaWlUeFlOaDhPYy8zNkxVSVJ1WFVyeklFWGtUMnFWVzlLalRqRFhwbzBxZVhaUkNRSEdNcWlTcmF3TlhvSUI2VE9HaEJBNS9TU3F5em1CQzEvdmd1Z0dtNEI5RytBTzYzbFRJcC82MW15L1RqVTNSQldwdGVaVUtaWlY2WTVySkEvaEgzYmlBZkFoNkpMWEdBUFUwMytNOXFublNQNDA0VzVMMjE1bHMxRkRkU0UrK1BPblpCdmdOWnY3ZmZodzBmYW9seTdjWnd3NnRtekYzeVArTkVETm9DWUUzd2praVpOSWttdDlNdUFGdmpQUDI5MHp1ejYreERvWXV6WVgrVmJvcjlkVzdaMEgrTytzclp2V251V2Z0M2lKL2dpekdSanFXU00zNGN4WHl3NTFSaC9yZFFKS0FRVUFxWVFRRlkrY0hYTGxLMXJzL1VUOGJIaEZOYXIxM2RzUFdxaGtyaVlBbGh0aTNVSVFETlk1UGFPSHZBQWY0QVpQck96UVduTzhhbTdzcm16WWxBOG03SXVPcnVmempnZU10OXUyYkpNa245OTI3NlhNdzVwOXpITWpJL3NiazlWVkFnb0JCUUNDb0VvUWdBVUFsQlpQR3RYdGVrSVVNUzNjU3hyWDkrWktpT2lUY2lwd2g4N0FqQ3ovUkRzUVo1c0VjN0NmT3JvbG9UY0FTOFBOeHJLNFVmZVJYZG5YT0Q0U0RxRldRejkrTll1MEMyVFhWQVdhcE93cUkwS0FZV0FRc0ExRVlERDE0SUZ2MUQxR3MyczdpQ3MwL0JMdVhMbE9qVnMxTjdxZXFxZ1FpQzJJTkNHT2RIVjJjVFlQRGkrQTVPTDI0N2VLSTd0Z1pRdTNwenNSYzJwMjQ1ZmROWndDb2M2T2s5UUhWc2hvQkJRQ0h4TUNDQ0VIa0tRNXMyVGkwNmZDY2ttYStuOG9Fd1BIOTZmU3BTc3BXZ2Vsb0JTKzJJMUF1Qk1IMlFud0tCb25yZGZHQlNYYm5Lb1BLVk14N3piTVpwdm5aZ0htT3F4UWtBaG9CQ0liZ1RnbkFndWRFU0NwQ0pqeDNwenl0OXVTcG1PQ0N5MVAxWWpBQVgycWd2RWZMN0dmWWgrNGttc3ZoWHNQbm1sVU5zTm5hcW9FRkFJS0FTaUJ3RllwbE9uVGtHZ2Y1Z1RLTk5JQ2R5NGNjY1luNTNQM0RtcTdRb0JoWUJDd0ZVUWlPUGhrY2pIVlRvVHRmMXd6ZURvVVh2T3FuV0ZnRUxnWTBYZ24xZXZKUXlnWWZqUWtMT0ZvbzBrQ2gwNzl1R1FnR0ZoeVQ1V0xOUjVLUVFVQWdxQjZFWkFXYWlqK3dxbzR5c0VGQUlLQVRzUTJPcTNXeExzSkVoZ21GUUN5dlRxMVhORW1iNTh4WFFxYURzT3A2b29CQlFDQ2dHRmdBVUVsSVhhQWpocWwwSkFJYUFRY0ZVRWtHNDljYUpFOUVYNjlIU09rOVJBa0sxdjJiTHBuQ3pyUnpwNTZweXJkbDMxU3lHZ0VGQUlmSFFJS0F2MVIzZEoxUWtwQkJRQ3NRV0JCUXQ4cVZPbkZuSzZVS2JYcjF2QW1iOStwUU1IajhZV0NOUjVLZ1FVQWdvQmwwQkF4YUYyaWN1Z09xRVFVQWdvQk94RFlQV3F1ZlQyN1R0S2tDQUJMVisrbHRhdDMycGZRNnFXUWtBaG9CQlFDTmlOZ0lwRGJUZDBxcUpDUUNHZ0VJaCtCREpuemtRNWMyYWxybDBIS21VNitpK0g2b0ZDUUNFUVN4RlFGdXBZZXVIVmFTc0VGQUlmQndKRml4U2dBZ1h5MElLRnk4VlMvWEdjbFRvTGhZQkNRQ0VRc3hCUUNuWE11bDZxdHdvQmhZQkNRQ0dnRUZBSUtBUVVBaTZHZ0VlY3VMRWxQbk5zT1U4WHU4TlVkeFFDQ2dHRmdFSkFJYUFRVUFqRVlBU0NBb2lDZ3kwbmhQY0lVamt1WS9BbFZsMVhDQ2dFRkFJS0FZV0FRa0Fob0JDSVdnUXNLOU00dGtkd1VNU0ZvcmFUem13OU5wMnJNM0ZWeDFJSUtBUVVBZ29CaFlCQ1FDRVFleEZRY2Foajc3VlhaNjRRVUFnb0JCUUNDZ0dGZ0VKQUllQUFCSlJDN1FBUVZSTUtBWVdBUWtBaG9CQlFDQ2dFRkFLeEY0SC9Bd291eDlpV00vQ1pBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCJjYWxlbmRhclwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBb0FBQUFLQ0FZQUFBQ05Ncys5QUFBQWMwbEVRVlI0bklYUXdRa0NNUlNFNFU5WkxNQ1Q5WGphcTJBZk5oZllVNW9RTE1BT3RvTjQ4RVdlaTVpQklSUGUveVlRM3FyaGYxbEZHN2lLY0VhSnhTZnVrVXZNV2dkSGF2dDB1V0h0ZzJRd3hYbkFuSloydU9MeVZadHlienpoZ1dObWZvRmwwL1lCODdOYnpSMWNqUDl4ZVFIU0RDNm1jTDF4RlFBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXHR9LFxuXHRcImNoZWNrZWRcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTBBQUFBUENBWUFBQUEvSTBWM0FBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dnQUFEc0lCRlNoS2dBQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBWUpKUkVGVU9FK05rc3RMZ2xFUXhmMGZhaEcwaUZyVXhtMkVsRkRZTG9oQ3FDRGFDQWtXUGF4SVJiRkZFSkVhR0VLTERDb01FVFJGVUFNTHlhSUhCVUc2c1NLSU10S0ZxRWhMVDgxOFpVZ21EaHp1M0RQbjl6MHVWMVJybVV3bXlHUXlxTlZxZkZ2Vml3Qnh1NVJGUFp1TFN5R01LaHovcWxFc1JWMTlLOHhtNnkrdzdicEJQRm5BZmVyamozYmRRWDZEcEhjQVV3YXZBSFVOMlJHSVp4QkpaSEgybUMvVFVleWR3d1RadkJlZ0xFTk5ndzdzWDZXaDFGc3dObVBFbWpQQ0R5R1JSd0N0VzlFM3RNZ2RBdFF3N0daalljTlgrZ3phMndKM1pYc1NaVXVRMHZXQ09WOFNIZkpKL3VsdWhiSFVqMXY4UEtOTXN6SW9RTlJNSENTaEQ2V2g4enlocmJPUHd6OHcrU1RLbENDSjdvUk5VelFINjNrQnM1dGhCZ2hlUFh4bGoyYVVvU3hEUGN1WFBOaUxBYzVFRVo2SElrYm1WMkRZaVhCUEhzMG8wNzkrSzBEVFZqL3MxMW1FMDBBMEwrZzRWY0RwMTBxS1pNQXp5dEJoTWFUUmFQbVlnODg1RGxjU3pTaWowZW9FaUlvdW9VcWxxcXFhTDJybEVvaytBZDR2bGZ6UG9WRHNBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCJkaWFsb2dcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSDRBQUFBVUNBTUFBQUI4a25tR0FBQUFYVkJNVkVYbjR0Zm00ZGZuNHRqbjQ5bm81TnJwNWR6cDVOdm00ZGJpM05EZzJzM281TnZsNE5UaDI4N2szOVBwNWR2aDNNL2ozZEhrMzlUbDROWGcyODdrM3RQaTNkSGgzTkRtNHRmajN0TGgyOC9vNDlybzQ5bmcyczdsNGRibDROYjZWYkV5QUFBQzFFbEVRVlI0QVhWVjBZS0RLQXdFNEFBVks2U3dDOWJ0LzMvbW5ZSjJ0Rjdld01FSnlXUmdqSE11aEZUL25FTWIyNjFoeGJycWgyM2hSb21ZaHhMcllmWEFUVG02RFR2MDYwcTB2eGg5K2IrU1lqM011ajNjNUlPUkFGTUJFdEQwcktnb0FISUpMV0xsZnBJRzhxQUFJazN3azl0Skt6MkU4NEdySFV2YlZoTGJ5dncwaUEyLzZvdGEvUWJidnYrWWJVZWtiVVY2Ui9EZzNZV04rWnl6VC9hOFg2S3BCTHBXM2N0YTJGQ09MRk1rTHVaZTk3UGdGSk03am9hRzliVUhsVnlaV002M3RHbGxacCt5ekl3aXBHRkpRd0o1cnFnWDJlNy93OUtyd3VZTUF0QmtnVGJTNzN6MHI5SkQ5SUp5eTJHSkVqU1FEOWtKd2lJZVRTTnh5QzlEejJWY0dpS1Q2SUhwbHI3VnluYkErVXBWQStieFFZaS9rTlBrbkp0U0RuOUNmZWJCTlBTclpkSzByKzZJbUU4cDVSekRtNHN6Z0Z0SVFOcW1lM1prY0JzUDFyUnZKWkJiZnI2YzRPOFFjMDRwZ2ZKclk1cnM0ZEo1aGhaMHo5ejYreDB2eXM4T3lqNW5LRU1UUDhvTEJ3KzdPQWg5VGtDZEo4LzVObm80ZHQ2ZDUwNmR5YlVZYmhURG1GanR4d3hqVHZqVkRoSVRpSlZOb2U1THlvR0lRazRGdGQrUUVjbmxZUEYrS1krRFdjMVdnUFNxSmVYalh4UHBUOXVYb0JxR3g2bTdqeWx5dlJ2bThoR0FwdU5BeVdpczk4clhZdmV2WlZTZ3V6Z2Z3OGtHZjNhUjRnZDJETlVjUVgxcVhIYXZ2TEZycHY2TC9udC9kKzlSWFY4T0ZEQ0ZFQWhIQnQrcVNyNi9GTiszN0pWUzdCQzl6d09YajYvSlcwNEpMQjdtOTg0di9ISWlYNzdtN2lINWtMMTE5OG92OE9JMHppWDAxYjMyRm85YzNWSHpjZTl4ZGNzK0xDMFRlSFBLUmZtdWxPTGNaZlR5VzJJQ3o2RHI1Rmw0RjQxbzFxMW5ZZUF0czZidWhpZVN5M2Ura3F6TTdQUDg4NUF0ZkIwRkpPQ29VWm5VUVN5bGxBVTNrbWs0Y2tBdVJxQzJPWEFoMWIzeWxhQmo5S2EzUGlkUVF4SmNCRXRHcldSbmN2MmVqckVqVkNuU1g5dFlPdUJrMDdZSTRKNk1ZcHBjQlUwcEVnT3ZEdHYreENDVHJ0d0w1bDg3d1ZPM08vZzVHUUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cdH0sXG5cdFwiZG93bi1yZWN0YW5nbGVcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQWtBQUFBRUNBWUFBQUJjRHhYT0FBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBYWRFVllkRk52Wm5SM1lYSmxBRkJoYVc1MExrNUZWQ0IyTXk0MUxqRXhSL05DTndBQUFCcEpSRUZVR0ZkamdJTC9lREFLSUtnQUJnZ3FnQUUwQlF3TUFQVGxEL0ZwaTBKZkFBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcImZpbHRlci1vZmZcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBTUNBWUFBQUJTZ0l6YUFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBWWRFVllkRk52Wm5SM1lYSmxBSEJoYVc1MExtNWxkQ0EwTGpBdU5XV0ZNbVVBQUFDaFNVUkJWQ2hUelpIQkNvVWdGRVQ5VHFFaXNrZ3lXb3V0UXZSTFJJcitjUjdYUUFqaUpXLzFCZ1ptTVVldlhzWTV4eTlPb0RFR01jWWlVemVCNjdxaWJWdXdRalZOQTYzMTFWK1dCZU00dnNMRE1FQXBkZS8xZlk5cG10STQ1M25lSEVLQWxCSmQxejBmWHRjMTZQYmpPREswN3p2bWVVWlZWZDhub29jNzV6SklPWDNHbTZpMGJWc0dLZjh4S0lSSXV5SlRMZ0pKM252UXpzalcyZ2VJc1EvcHI5aE1WclNuY0FBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXHR9LFxuXHRcImZpbHRlci1vblwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFNQ0FZQUFBQlNnSXphQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUFZZEVWWWRGTnZablIzWVhKbEFIQmhhVzUwTG01bGRDQTBMakF1TldXRk1tVUFBQUNvU1VSQlZDaFRZM0JxZlAyZkhBeldtRGJqN2Y4cDI5NFJoVk9CYXNFYTAyZSsvZS9WQm1RUUNUeGFYLzlQbnZZR29qNXl3cHYvUWQyRU5mdDN2djRmMWdmVkJBUCtuVy8raC9hK0FUdG4xcTczS0hqeXR2ZGdnMzA3MERUQmdIdkw2LzhnMjJmc1FHaWFEbVNIQTIxeGF5YmdJcERIaXhhOGhXc3NuQThOREVJQXBDaDNMa0lqaUQySU5ZSkNMMlg2VzNCOGdkaEVhUVFCVU9DQTRneUU4K2U5eGFLSmdRRUEvNzRCTkUzY0Vsa0FBQUFBU1VWT1JLNUNZSUk9XCJcblx0fSxcblx0XCJ1bmNoZWNrZWRcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTBBQUFBUENBWUFBQUEvSTBWM0FBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dnQUFEc0lCRlNoS2dBQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBUkJKUkVGVU9FKzlrcnR1ZzFBUVJQbGRTaW83RlExdFpJbU9rb0tPQm9tR1QwRVVSQzVpbm81NHlUdzkwV3l3UWhUa0lrVldHb0YyenV4ZHJsRCt0MHpUaEtacFQwVm14YjhDUVJDZzZ6cjBmYjhyZXI3dmZ3Y1B4eGRjcngrWXBnbnpQR05abGg5aWJ4eEhsR1VKc2hMU2RWMGF0OXROcGc3RElCclg1K09rUE05QlZrS0dZU0JKRXRSMWpiWnJCZGlxYlZ0VVZZVTBUVUZXUXErbkUrSTR4dnZsSW1HYVc3Rkhqd3haQ1ZtV2hiZnpHVm1Xb1NnS1dYVXI5dWlSSVNzaHgzRmtFbGRvbXViWGF1elJJME5XUXA3bnlVUitORy9yZnIvalVYeG5qeDV2bUt5RWJOdVdveDlYdmlkNlpNaEs2SEE0d25WZGhHR0lLSXAyUlk4TVdRbXgrSnVvcXZwVVpGYjhMNlVvbnlZTDN1T3RyRkgrQUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwidXAtZG93bi1zcGluXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQVBDQVlBQUFEVUZQNTBBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93UUFBRHNFQnVKRnI3UUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQUdKSlJFRlVPRStsa3dFS0FDRUlCSDJaYi9Qbkhzb0dlYVZKRFVqR09nUlJwS3BraUlqK3k0TU1FM2VEUjdrYUtPVk5zSnlNTmpJSHpHeTlZblc2SjdxSWNycmlRaW1lQ3FPUk5BQmQwZnBSVGt0OHVWVWo3RXN4QzZ2cy9xM2UvUTZpRDJid25CeWpQWEhOQUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwidXAtZG93blwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFQQ0FZQUFBRFVGUDUwQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd1FBQURzRUJ1SkZyN1FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1DNDFaWVV5WlFBQUFHRkpSRUZVT0UrbGtrRUtRQ0VJUkQyWkozUGgzaU40V0Q5R2ZscFloajBZWW93cEdnSm1iaWtkM2dqTURGb2t3YnVUMWlBaXVyRzVub21ncW81UWFQbzlFUlFSSTZKZjdzZkdqdWR5MmplMjMraTBXbDJvUTg1VE9kbGZySlFPYXpGOGJyK3JxVFhRS24wQUFBQUFTVVZPUks1Q1lJST1cIlxuXHR9LFxufTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpO1xuXG52YXIgaW1hZ2VzID0gcmVxdWlyZSgnLi9pbWFnZXMnKTsgLy8gdGhpcyBpcyB0aGUgZmlsZSBnZW5lcmF0ZWQgYnkgZ3VscGZpbGUuanMgKGFuZCBpZ25vcmVkIGJ5IGdpdClcblxuXyhpbWFnZXMpLmVhY2goZnVuY3Rpb24oaW1hZ2UsIGtleSkge1xuICAgIHZhciBlbGVtZW50ID0gbmV3IEltYWdlKCk7XG4gICAgZWxlbWVudC5zcmMgPSAnZGF0YTonICsgaW1hZ2UudHlwZSArICc7YmFzZTY0LCcgKyBpbWFnZS5kYXRhO1xuICAgIGltYWdlc1trZXldID0gZWxlbWVudDtcbn0pO1xuXG5pbWFnZXMuY2hlY2tib3ggPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiBpbWFnZXNbc3RhdGUgPyAnY2hlY2tlZCcgOiAndW5jaGVja2VkJ107XG59O1xuXG5pbWFnZXMuZmlsdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gaW1hZ2VzW3N0YXRlID8gJ2ZpbHRlci1vbicgOiAnZmlsdGVyLW9mZiddO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbWFnZXM7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiogQG1vZHVsZSBhdXRvbWF0ICovXG5cbnZhciBFTkNPREVSUyA9IC8lXFx7KFxcZCspXFx9L2c7IC8vIGRvdWJsZSAkJCB0byBlbmNvZGVcblxudmFyIFJFUExBQ0VSUyA9IC9cXCRcXHsoLio/KVxcfS9nOyAvLyBzaW5nbGUgJCB0byByZXBsYWNlXG5cblxuLyoqXG4gKiBAc3VtbWFyeSBTdHJpbmcgZm9ybWF0dGVyLlxuICpcbiAqIEBkZXNjIFN0cmluZyBzdWJzdGl0dXRpb24gaXMgcGVyZm9ybWVkIG9uIG51bWJlcmVkIF9yZXBsYWNlcl8gcGF0dGVybnMgbGlrZSBgJHtufWAgb3IgX2VuY29kZXJfIHBhdHRlcm5zIGxpa2UgYCV7bn1gIHdoZXJlIG4gaXMgdGhlIHplcm8tYmFzZWQgYGFyZ3VtZW50c2AgaW5kZXguIFNvIGAkezB9YCB3b3VsZCBiZSByZXBsYWNlZCB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudCBmb2xsb3dpbmcgYHRleHRgLlxuICpcbiAqIEVuY29kZXJzIGFyZSBqdXN0IGxpa2UgcmVwbGFjZXJzIGV4Y2VwdCB0aGUgYXJndW1lbnQgaXMgSFRNTC1lbmNvZGVkIGJlZm9yZSBiZWluZyB1c2VkLlxuICpcbiAqIFRvIGNoYW5nZSB0aGUgZm9ybWF0IHBhdHRlcm5zLCBhc3NpZ24gbmV3IGBSZWdFeHBgIHBhdHRlcm5zIHRvIGBhdXRvbWF0LmVuY29kZXJzYCBhbmQgYGF1dG9tYXQucmVwbGFjZXJzYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbn0gdGVtcGxhdGUgLSBBIHRlbXBsYXRlIHRvIGJlIGZvcm1hdHRlZCBhcyBkZXNjcmliZWQgYWJvdmUuIE92ZXJsb2FkczpcbiAqICogQSBzdHJpbmcgcHJpbWl0aXZlIGNvbnRhaW5pbmcgdGhlIHRlbXBsYXRlLlxuICogKiBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoIGB0aGlzYCBhcyB0aGUgY2FsbGluZyBjb250ZXh0LiBUaGUgdGVtcGxhdGUgaXMgdGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLlxuICpcbiAqIEBwYXJhbSB7Li4uKn0gW3JlcGxhY2VtZW50c10gLSBSZXBsYWNlbWVudCB2YWx1ZXMgZm9yIG51bWJlcmVkIGZvcm1hdCBwYXR0ZXJucy5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdGV4dC5cbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmF1dG9tYXRcbiAqL1xuZnVuY3Rpb24gYXV0b21hdCh0ZW1wbGF0ZSwgcmVwbGFjZW1lbnRzLyouLi4qLykge1xuICAgIHZhciBoYXNSZXBsYWNlbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMTtcblxuICAgIC8vIGlmIGB0ZW1wbGF0ZWAgaXMgYSBmdW5jdGlvbiwgY29udmVydCBpdCB0byB0ZXh0XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmNhbGwodGhpcyk7IC8vIG5vbi10ZW1wbGF0ZSBmdW5jdGlvbjogY2FsbCBpdCB3aXRoIGNvbnRleHQgYW5kIHVzZSByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICBpZiAoaGFzUmVwbGFjZW1lbnRzKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoYXV0b21hdC5yZXBsYWNlcnNSZWdleCwgZnVuY3Rpb24obWF0Y2gsIGtleSkge1xuICAgICAgICAgICAga2V5IC09IC0xOyAvLyBjb252ZXJ0IHRvIG51bWJlciBhbmQgaW5jcmVtZW50XG4gICAgICAgICAgICByZXR1cm4gYXJncy5sZW5ndGggPiBrZXkgPyBhcmdzW2tleV0gOiAnJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKGF1dG9tYXQuZW5jb2RlcnNSZWdleCwgZnVuY3Rpb24obWF0Y2gsIGtleSkge1xuICAgICAgICAgICAga2V5IC09IC0xOyAvLyBjb252ZXJ0IHRvIG51bWJlciBhbmQgaW5jcmVtZW50XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiBrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaHRtbEVuY29kZXJOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgICAgICAgICAgICAgaHRtbEVuY29kZXJOb2RlLnRleHRDb250ZW50ID0gYXJnc1trZXldO1xuICAgICAgICAgICAgICAgIHJldHVybiBodG1sRW5jb2Rlck5vZGUuaW5uZXJIVE1MO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeSBSZXBsYWNlIGNvbnRlbnRzIG9mIGBlbGAgd2l0aCBgTm9kZXNgIGdlbmVyYXRlZCBmcm9tIGZvcm1hdHRlZCB0ZW1wbGF0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbn0gdGVtcGxhdGUgLSBTZWUgYHRlbXBsYXRlYCBwYXJhbWV0ZXIgb2Yge0BsaW5rIGF1dG9tYXR9LlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtlbF0gLSBOb2RlIGluIHdoaWNoIHRvIHJldHVybiBtYXJrdXAgZ2VuZXJhdGVkIGZyb20gdGVtcGxhdGUuIElmIG9taXR0ZWQsIGEgbmV3IGA8ZGl2Pi4uLjwvZGl2PmAgZWxlbWVudCB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7Li4uKn0gW3JlcGxhY2VtZW50c10gLSBSZXBsYWNlbWVudCB2YWx1ZXMgZm9yIG51bWJlcmVkIGZvcm1hdCBwYXR0ZXJucy5cbiAqXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gVGhlIGBlbGAgcHJvdmlkZWQgb3IgYSBuZXcgYDxkaXY+Li4uPC9kaXY+YCBlbGVtZW50LCBpdHMgYGlubmVySFRNTGAgc2V0IHRvIHRoZSBmb3JtYXR0ZWQgdGV4dC5cbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmF1dG9tYXRcbiAqL1xuZnVuY3Rpb24gcmVwbGFjZSh0ZW1wbGF0ZSwgZWwsIHJlcGxhY2VtZW50cy8qLi4uKi8pIHtcbiAgICB2YXIgZWxPbWl0dGVkID0gdHlwZW9mIGVsICE9PSAnb2JqZWN0JyxcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICBpZiAoZWxPbWl0dGVkKSB7XG4gICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgICAgIGFyZ3MudW5zaGlmdCh0ZW1wbGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJnc1swXSA9IHRlbXBsYXRlO1xuICAgIH1cblxuICAgIGVsLmlubmVySFRNTCA9IGF1dG9tYXQuYXBwbHkobnVsbCwgYXJncyk7XG5cbiAgICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgQXBwZW5kIG9yIGluc2VydCBgTm9kZWBzIGdlbmVyYXRlZCBmcm9tIGZvcm1hdHRlZCB0ZW1wbGF0ZSBpbnRvIGdpdmVuIGBlbGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IHRlbXBsYXRlIC0gU2VlIGB0ZW1wbGF0ZWAgcGFyYW1ldGVyIG9mIHtAbGluayBhdXRvbWF0fS5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gW3JlZmVyZW5jZU5vZGU9bnVsbF0gSW5zZXJ0cyBiZWZvcmUgdGhpcyBlbGVtZW50IHdpdGhpbiBgZWxgIG9yIGF0IGVuZCBvZiBgZWxgIGlmIGBudWxsYC5cbiAqXG4gKiBAcGFyYW0gey4uLip9IFtyZXBsYWNlbWVudHNdIC0gUmVwbGFjZW1lbnQgdmFsdWVzIGZvciBudW1iZXJlZCBmb3JtYXQgcGF0dGVybnMuXG4gKlxuICogQHJldHVybnMge05vZGVbXX0gQXJyYXkgb2YgdGhlIGdlbmVyYXRlZCBub2RlcyAodGhpcyBpcyBhbiBhY3R1YWwgQXJyYXkgaW5zdGFuY2U7IG5vdCBhbiBBcnJheS1saWtlIG9iamVjdCkuXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTphdXRvbWF0XG4gKi9cbmZ1bmN0aW9uIGFwcGVuZCh0ZW1wbGF0ZSwgZWwsIHJlZmVyZW5jZU5vZGUsIHJlcGxhY2VtZW50cy8qLi4uKi8pIHtcbiAgICB2YXIgcmVwbGFjZW1lbnRzU3RhcnRBdCA9IDMsXG4gICAgICAgIHJlZmVyZW5jZU5vZGVPbWl0dGVkID0gdHlwZW9mIHJlZmVyZW5jZU5vZGUgIT09ICdvYmplY3QnOyAgLy8gcmVwbGFjZW1lbnRzIGFyZSBuZXZlciBvYmplY3RzXG5cbiAgICBpZiAocmVmZXJlbmNlTm9kZU9taXR0ZWQpIHtcbiAgICAgICAgcmVmZXJlbmNlTm9kZSA9IG51bGw7XG4gICAgICAgIHJlcGxhY2VtZW50c1N0YXJ0QXQgPSAyO1xuICAgIH1cblxuICAgIHJlcGxhY2VtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgcmVwbGFjZW1lbnRzU3RhcnRBdCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICBkaXYgPSByZXBsYWNlLmFwcGx5KG51bGwsIFt0ZW1wbGF0ZV0uY29uY2F0KHJlcGxhY2VtZW50cykpO1xuXG4gICAgd2hpbGUgKGRpdi5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQucHVzaChkaXYuZmlyc3RDaGlsZCk7XG4gICAgICAgIGVsLmluc2VydEJlZm9yZShkaXYuZmlyc3RDaGlsZCwgcmVmZXJlbmNlTm9kZSk7IC8vIHJlbW92ZXMgY2hpbGQgZnJvbSBkaXZcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFVzZSB0aGlzIGNvbnZlbmllbmNlIHdyYXBwZXIgdG8gcmV0dXJuIHRoZSBmaXJzdCBjaGlsZCBub2RlIGRlc2NyaWJlZCBpbiBgdGVtcGxhdGVgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSB0ZW1wbGF0ZSAtIElmIGEgZnVuY3Rpb24sIGV4dHJhY3QgdGVtcGxhdGUgZnJvbSBjb21tZW50IHdpdGhpbi5cbiAqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IFRoZSBmaXJzdCBgTm9kZWAgaW4geW91ciB0ZW1wbGF0ZS5cbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmF1dG9tYXRcbiAqL1xuZnVuY3Rpb24gZmlyc3RDaGlsZCh0ZW1wbGF0ZSwgcmVwbGFjZW1lbnRzLyouLi4qLykge1xuICAgIHJldHVybiByZXBsYWNlLmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZmlyc3RDaGlsZDtcbn1cblxuLyoqXG4gKiBVc2UgdGhpcyBjb252ZW5pZW5jZSB3cmFwcGVyIHRvIHJldHVybiB0aGUgZmlyc3QgY2hpbGQgZWxlbWVudCBkZXNjcmliZWQgaW4gYHRlbXBsYXRlYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbn0gdGVtcGxhdGUgLSBJZiBhIGZ1bmN0aW9uLCBleHRyYWN0IHRlbXBsYXRlIGZyb20gY29tbWVudCB3aXRoaW4uXG4gKlxuICogQHJldHVybnMge0hUTUxFbGVtZW50fSBUaGUgZmlyc3QgYEhUTUxFbGVtZW50YCBpbiB5b3VyIHRlbXBsYXRlLlxuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6YXV0b21hdFxuICovXG5mdW5jdGlvbiBmaXJzdEVsZW1lbnQodGVtcGxhdGUsIHJlcGxhY2VtZW50cy8qLi4uKi8pIHtcbiAgICByZXR1cm4gcmVwbGFjZS5hcHBseShudWxsLCBhcmd1bWVudHMpLmZpcnN0RWxlbWVudENoaWxkO1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5IEZpbmRzIHN0cmluZyBzdWJzdGl0dXRpb24gbGV4ZW1lcyB0aGF0IHJlcXVpcmUgSFRNTCBlbmNvZGluZy5cbiAqIEBkZXNjIE1vZGlmeSB0byBzdWl0LlxuICogQGRlZmF1bHQgJXtufVxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6YXV0b21hdFxuICovXG5hdXRvbWF0LmVuY29kZXJzUmVnZXggPSBFTkNPREVSUztcblxuLyoqXG4gKiBAc3VtbWFyeSBGaW5kcyBzdHJpbmcgc3Vic3RpdHV0aW9uIGxleGVtZXMuXG4gKiBAZGVzYyBNb2RpZnkgdG8gc3VpdC5cbiAqIEBkZWZhdWx0ICR7bn1cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAbWVtYmVyT2YgbW9kdWxlOmF1dG9tYXRcbiAqL1xuYXV0b21hdC5yZXBsYWNlcnNSZWdleCA9IFJFUExBQ0VSUztcblxuYXV0b21hdC5mb3JtYXQgPSBhdXRvbWF0OyAvLyBpZiB5b3UgZmluZCB1c2luZyBqdXN0IGBhdXRvbWF0KClgIGNvbmZ1c2luZ1xuYXV0b21hdC5yZXBsYWNlID0gcmVwbGFjZTtcbmF1dG9tYXQuYXBwZW5kID0gYXBwZW5kO1xuYXV0b21hdC5maXJzdENoaWxkID0gZmlyc3RDaGlsZDtcbmF1dG9tYXQuZmlyc3RFbGVtZW50ID0gZmlyc3RFbGVtZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF1dG9tYXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKiogQG5hbWVzcGFjZSBjc3NJbmplY3RvciAqL1xuXG4vKipcbiAqIEBzdW1tYXJ5IEluc2VydCBiYXNlIHN0eWxlc2hlZXQgaW50byBET01cbiAqXG4gKiBAZGVzYyBDcmVhdGVzIGEgbmV3IGA8c3R5bGU+Li4uPC9zdHlsZT5gIGVsZW1lbnQgZnJvbSB0aGUgbmFtZWQgdGV4dCBzdHJpbmcocykgYW5kIGluc2VydHMgaXQgYnV0IG9ubHkgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdCBpbiB0aGUgc3BlY2lmaWVkIGNvbnRhaW5lciBhcyBwZXIgYHJlZmVyZW5jZUVsZW1lbnRgLlxuICpcbiAqID4gQ2F2ZWF0OiBJZiBzdHlsZXNoZWV0IGlzIGZvciB1c2UgaW4gYSBzaGFkb3cgRE9NLCB5b3UgbXVzdCBzcGVjaWZ5IGEgbG9jYWwgYHJlZmVyZW5jZUVsZW1lbnRgLlxuICpcbiAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoZSBuZXdseSBjcmVhdGVkIGA8c3R5bGU+Li4uPC9zdHlsZT5gIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGNzc1J1bGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW0lEXVxuICogQHBhcmFtIHt1bmRlZmluZWR8bnVsbHxFbGVtZW50fHN0cmluZ30gW3JlZmVyZW5jZUVsZW1lbnRdIC0gQ29udGFpbmVyIGZvciBpbnNlcnRpb24uIE92ZXJsb2FkczpcbiAqICogYHVuZGVmaW5lZGAgdHlwZSAob3Igb21pdHRlZCk6IGluamVjdHMgc3R5bGVzaGVldCBhdCB0b3Agb2YgYDxoZWFkPi4uLjwvaGVhZD5gIGVsZW1lbnRcbiAqICogYG51bGxgIHZhbHVlOiBpbmplY3RzIHN0eWxlc2hlZXQgYXQgYm90dG9tIG9mIGA8aGVhZD4uLi48L2hlYWQ+YCBlbGVtZW50XG4gKiAqIGBFbGVtZW50YCB0eXBlOiBpbmplY3RzIHN0eWxlc2hlZXQgaW1tZWRpYXRlbHkgYmVmb3JlIGdpdmVuIGVsZW1lbnQsIHdoZXJldmVyIGl0IGlzIGZvdW5kLlxuICogKiBgc3RyaW5nYCB0eXBlOiBpbmplY3RzIHN0eWxlc2hlZXQgaW1tZWRpYXRlbHkgYmVmb3JlIGdpdmVuIGZpcnN0IGVsZW1lbnQgZm91bmQgdGhhdCBtYXRjaGVzIHRoZSBnaXZlbiBjc3Mgc2VsZWN0b3IuXG4gKlxuICogQG1lbWJlck9mIGNzc0luamVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNzc0luamVjdG9yKGNzc1J1bGVzLCBJRCwgcmVmZXJlbmNlRWxlbWVudCkge1xuICAgIGlmICh0eXBlb2YgcmVmZXJlbmNlRWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocmVmZXJlbmNlRWxlbWVudCk7XG4gICAgICAgIGlmICghcmVmZXJlbmNlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgJ0Nhbm5vdCBmaW5kIHJlZmVyZW5jZSBlbGVtZW50IGZvciBDU1MgaW5qZWN0aW9uLic7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZmVyZW5jZUVsZW1lbnQgJiYgIShyZWZlcmVuY2VFbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgICAgdGhyb3cgJ0dpdmVuIHZhbHVlIG5vdCBhIHJlZmVyZW5jZSBlbGVtZW50Lic7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRhaW5lciA9IHJlZmVyZW5jZUVsZW1lbnQgJiYgcmVmZXJlbmNlRWxlbWVudC5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblxuICAgIGlmIChJRCkge1xuICAgICAgICBJRCA9IGNzc0luamVjdG9yLmlkUHJlZml4ICsgSUQ7XG5cbiAgICAgICAgaWYgKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjJyArIElEKSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBzdHlsZXNoZWV0IGFscmVhZHkgaW4gRE9NXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgIGlmIChJRCkge1xuICAgICAgICBzdHlsZS5pZCA9IElEO1xuICAgIH1cbiAgICBpZiAoY3NzUnVsZXMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBjc3NSdWxlcyA9IGNzc1J1bGVzLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICBjc3NSdWxlcyA9ICdcXG4nICsgY3NzUnVsZXMgKyAnXFxuJztcbiAgICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NSdWxlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3NSdWxlcykpO1xuICAgIH1cblxuICAgIGlmIChyZWZlcmVuY2VFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgIH1cblxuICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoc3R5bGUsIHJlZmVyZW5jZUVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIHN0eWxlO1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5IE9wdGlvbmFsIHByZWZpeCBmb3IgYDxzdHlsZT5gIHRhZyBJRHMuXG4gKiBAZGVzYyBEZWZhdWx0cyB0byBgJ2luamVjdGVkLXN0eWxlc2hlZXQtJ2AuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQG1lbWJlck9mIGNzc0luamVjdG9yXG4gKi9cbmNzc0luamVjdG9yLmlkUHJlZml4ID0gJ2luamVjdGVkLXN0eWxlc2hlZXQtJztcblxuLy8gSW50ZXJmYWNlXG5tb2R1bGUuZXhwb3J0cyA9IGNzc0luamVjdG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQG5hbWVzcGFjZSBleHRlbmQtbWUgKiovXG5cbi8qKiBAc3VtbWFyeSBFeHRlbmRzIGFuIGV4aXN0aW5nIGNvbnN0cnVjdG9yIGludG8gYSBuZXcgY29uc3RydWN0b3IuXG4gKlxuICogQHJldHVybnMge0NoaWxkQ29uc3RydWN0b3J9IEEgbmV3IGNvbnN0cnVjdG9yLCBleHRlbmRlZCBmcm9tIHRoZSBnaXZlbiBjb250ZXh0LCBwb3NzaWJseSB3aXRoIHNvbWUgcHJvdG90eXBlIGFkZGl0aW9ucy5cbiAqXG4gKiBAZGVzYyBFeHRlbmRzIFwib2JqZWN0c1wiIChjb25zdHJ1Y3RvcnMpLCB3aXRoIG9wdGlvbmFsIGFkZGl0aW9uYWwgY29kZSwgb3B0aW9uYWwgcHJvdG90eXBlIGFkZGl0aW9ucywgYW5kIG9wdGlvbmFsIHByb3RvdHlwZSBtZW1iZXIgYWxpYXNlcy5cbiAqXG4gKiA+IENBVkVBVDogTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggVW5kZXJzY29yZS1zdHlsZSAuZXh0ZW5kKCkgd2hpY2ggaXMgc29tZXRoaW5nIGVsc2UgZW50aXJlbHkuIEkndmUgdXNlZCB0aGUgbmFtZSBcImV4dGVuZFwiIGhlcmUgYmVjYXVzZSBvdGhlciBwYWNrYWdlcyAobGlrZSBCYWNrYm9uZS5qcykgdXNlIGl0IHRoaXMgd2F5LiBZb3UgYXJlIGZyZWUgdG8gY2FsbCBpdCB3aGF0ZXZlciB5b3Ugd2FudCB3aGVuIHlvdSBcInJlcXVpcmVcIiBpdCwgc3VjaCBhcyBgdmFyIGluaGVyaXRzID0gcmVxdWlyZSgnZXh0ZW5kJylgLlxuICpcbiAqIFByb3ZpZGUgYSBjb25zdHJ1Y3RvciBhcyB0aGUgY29udGV4dCBhbmQgYW55IHByb3RvdHlwZSBhZGRpdGlvbnMgeW91IHJlcXVpcmUgaW4gdGhlIGZpcnN0IGFyZ3VtZW50LlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB5b3Ugd2lzaCB0byBiZSBhYmxlIHRvIGV4dGVuZCBgQmFzZUNvbnN0cnVjdG9yYCB0byBhIG5ldyBjb25zdHJ1Y3RvciB3aXRoIHByb3RvdHlwZSBvdmVycmlkZXMgYW5kL29yIGFkZGl0aW9ucywgYmFzaWMgdXNhZ2UgaXM6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIEJhc2UgPSByZXF1aXJlKCdleHRlbmQtbWUnKS5CYXNlO1xuICogdmFyIEJhc2VDb25zdHJ1Y3RvciA9IEJhc2UuZXh0ZW5kKGJhc2VQcm90b3R5cGUpOyAvLyBtaXhlcyBpbiAuZXh0ZW5kXG4gKiB2YXIgQ2hpbGRDb25zdHJ1Y3RvciA9IEJhc2VDb25zdHJ1Y3Rvci5leHRlbmQoY2hpbGRQcm90b3R5cGVPdmVycmlkZXNBbmRBZGRpdGlvbnMpO1xuICogdmFyIEdyYW5kY2hpbGRDb25zdHJ1Y3RvciA9IENoaWxkQ29uc3RydWN0b3IuZXh0ZW5kKGdyYW5kY2hpbGRQcm90b3R5cGVPdmVycmlkZXNBbmRBZGRpdGlvbnMpO1xuICogYGBgXG4gKlxuICogVGhpcyBmdW5jdGlvbiAoYGV4dGVuZCgpYCkgaXMgYWRkZWQgdG8gdGhlIG5ldyBleHRlbmRlZCBvYmplY3QgY29uc3RydWN0b3IgYXMgYSBwcm9wZXJ0eSBgLmV4dGVuZGAsIGVzc2VudGlhbGx5IG1ha2luZyB0aGUgb2JqZWN0IGNvbnN0cnVjdG9yIGl0c2VsZiBlYXNpbHkgXCJleHRlbmRhYmxlLlwiIChOb3RlOiBUaGlzIGlzIGEgcHJvcGVydHkgb2YgZWFjaCBjb25zdHJ1Y3RvciBhbmQgbm90IGEgbWV0aG9kIG9mIGl0cyBwcm90b3R5cGUhKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXh0ZW5kZWRDbGFzc05hbWVdIC0gVGhpcyBpcyBzaW1wbHkgYWRkZWQgdG8gdGhlIHByb3RvdHlwZSBhcyAkJENMQVNTX05BTUUuIFVzZWZ1bCBmb3IgZGVidWdnaW5nIGJlY2F1c2UgYWxsIGRlcml2ZWQgY29uc3RydWN0b3JzIGFwcGVhciB0byBoYXZlIHRoZSBzYW1lIG5hbWUgKFwiQ29uc3RydWN0b3JcIikgaW4gdGhlIGRlYnVnZ2VyLiBUaGlzIHByb3BlcnR5IGlzIGlnbm9yZWQgdW5sZXNzIGBleHRlbmQuZGVidWdgIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGEgdHJ1dGh5IHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7ZXh0ZW5kZWRQcm90b3R5cGVBZGRpdGlvbnNPYmplY3R9IFtwcm90b3R5cGVBZGRpdGlvbnNdIC0gT2JqZWN0IHdpdGggbWVtYmVycyB0byBjb3B5IHRvIG5ldyBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZS4gTW9zdCBtZW1iZXJzIHdpbGwgYmUgY29waWVkIHRvIHRoZSBwcm90b3R5cGUuIFNvbWUgbWVtYmVycywgaG93ZXZlciwgaGF2ZSBzcGVjaWFsIG1lYW5pbmdzIGFzIGV4cGxhaW5lZCBpbiB0aGUge0BsaW5rIGV4dGVuZGVkUHJvdG90eXBlQWRkaXRpb25zT2JqZWN0fHR5cGUgZGVmaW5pdGlvbn0gKGFuZCBtYXkgb3IgbWF5IG5vdCBiZSBjb3BpZWQgdG8gdGhlIHByb3RvdHlwZSkuXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVidWddIC0gU2VlIHBhcmFtZXRlciBgZXh0ZW5kZWRDbGFzc05hbWVgIF8oYWJvdmUpXy5cbiAqXG4gKiBAcHJvcGVydHkge29iamVjdH0gQmFzZSAtIEEgY29udmVuaWVudCBiYXNlIGNsYXNzIGZyb20gd2hpY2ggYWxsIG90aGVyIGNsYXNzZXMgY2FuIGJlIGV4dGVuZGVkLlxuICpcbiAqIEBtZW1iZXJPZiBleHRlbmQtbWVcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGV4dGVuZGVkQ2xhc3NOYW1lLCBwcm90b3R5cGVBZGRpdGlvbnMpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcHJvdG90eXBlQWRkaXRpb25zID0ge307XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcHJvdG90eXBlQWRkaXRpb25zID0gZXh0ZW5kZWRDbGFzc05hbWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3RvdHlwZUFkZGl0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnU2luZ2xlIHBhcmFtZXRlciBvdmVybG9hZCBtdXN0IGJlIG9iamVjdC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXh0ZW5kZWRDbGFzc05hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRlbmRlZENsYXNzTmFtZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3RvdHlwZUFkZGl0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVHdvIHBhcmFtZXRlciBvdmVybG9hZCBtdXN0IGJlIHN0cmluZywgb2JqZWN0Lic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICdUb28gbWFueSBwYXJhbWV0ZXJzJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKHByb3RvdHlwZUFkZGl0aW9ucy5wcmVJbml0aWFsaXplKSB7XG4gICAgICAgICAgICBwcm90b3R5cGVBZGRpdGlvbnMucHJlSW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdGlhbGl6ZVByb3RvdHlwZUNoYWluLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgaWYgKHByb3RvdHlwZUFkZGl0aW9ucy5wb3N0SW5pdGlhbGl6ZSkge1xuICAgICAgICAgICAgcHJvdG90eXBlQWRkaXRpb25zLnBvc3RJbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBDb25zdHJ1Y3Rvci5leHRlbmQgPSBleHRlbmQ7XG5cbiAgICB2YXIgcHJvdG90eXBlID0gQ29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG4gICAgcHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG5cbiAgICBpZiAoZXh0ZW5kZWRDbGFzc05hbWUgJiYgZXh0ZW5kLmRlYnVnKSB7XG4gICAgICAgIHByb3RvdHlwZS4kJENMQVNTX05BTUUgPSBleHRlbmRlZENsYXNzTmFtZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvdG90eXBlQWRkaXRpb25zKSB7XG4gICAgICAgIGlmIChwcm90b3R5cGVBZGRpdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvdG90eXBlQWRkaXRpb25zW2tleV07XG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxpemVPd24nOlxuICAgICAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGNhbGxlZCBhYm92ZTsgbm90IG5lZWRlZCBpbiBwcm90b3R5cGVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYWxpYXNlcyc6XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGFsaWFzIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoYWxpYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZUFsaWFzKHZhbHVlW2FsaWFzXSwgYWxpYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlWzBdID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VBbGlhcyh2YWx1ZSwga2V5LnN1YnN0cigxKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm90b3R5cGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG5cbiAgICBmdW5jdGlvbiBtYWtlQWxpYXModmFsdWUsIGtleSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNoYWRvd1xuICAgICAgICBwcm90b3R5cGVba2V5XSA9IHByb3RvdHlwZUFkZGl0aW9uc1t2YWx1ZV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBCYXNlKCkge31cbkJhc2UucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBCYXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcixcbiAgICBnZXQgc3VwZXIoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtcbiAgICB9XG59O1xuQmFzZS5leHRlbmQgPSBleHRlbmQ7XG5leHRlbmQuQmFzZSA9IEJhc2U7XG5cbi8qKiBAdHlwZWRlZiB7ZnVuY3Rpb259IGV4dGVuZGVkQ29uc3RydWN0b3JcbiAqIEBwcm9wZXJ0eSBwcm90b3R5cGUuc3VwZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgcHJvdG90eXBlIHRoaXMgY29uc3RydWN0b3Igd2FzIGV4dGVuZGVkIGZyb20uXG4gKiBAcHJvcGVydHkgW2V4dGVuZF0gLSBJZiBgcHJvdG90eXBlQWRkaXRpb25zLmV4dGVuZGFibGVgIHdhcyB0cnV0aHksIHRoaXMgd2lsbCBiZSBhIHJlZmVyZW5jZSB0byB7QGxpbmsgZXh0ZW5kLmV4dGVuZHxleHRlbmR9LlxuICovXG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSBleHRlbmRlZFByb3RvdHlwZUFkZGl0aW9uc09iamVjdFxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2luaXRpYWxpemVdIC0gQWRkaXRpb25hbCBjb25zdHJ1Y3RvciBjb2RlIGZvciBuZXcgb2JqZWN0LiBUaGlzIG1ldGhvZCBpcyBhZGRlZCB0byB0aGUgbmV3IGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlLiBHZXRzIHBhc3NlZCBuZXcgb2JqZWN0IGFzIGNvbnRleHQgKyBzYW1lIGFyZ3MgYXMgY29uc3RydWN0b3IgaXRzZWxmLiBDYWxsZWQgb24gaW5zdGFudGlhdGlvbiBhZnRlciBzaW1pbGFyIGZ1bmN0aW9uIGluIGFsbCBhbmNlc3RvcnMgY2FsbGVkIHdpdGggc2FtZSBzaWduYXR1cmUuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbaW5pdGlhbGl6ZU93bl0gLSBBZGRpdGlvbmFsIGNvbnN0cnVjdG9yIGNvZGUgZm9yIG5ldyBvYmplY3QuIFRoaXMgbWV0aG9kIGlzIGFkZGVkIHRvIHRoZSBuZXcgY29uc3RydWN0b3IncyBwcm90b3R5cGUuIEdldHMgcGFzc2VkIG5ldyBvYmplY3QgYXMgY29udGV4dCArIHNhbWUgYXJncyBhcyBjb25zdHJ1Y3RvciBpdHNlbGYuIENhbGxlZCBvbiBpbnN0YW50aWF0aW9uIGFmdGVyIChhbGwpIHRoZSBgaW5pdGlhbGl6ZWAgZnVuY3Rpb24ocykuXG4gKiBAcHJvcGVydHkge29iamVjdH0gW2FsaWFzZXNdIC0gSGFzaCBvZiBhbGlhc2VzIGZvciBwcm90b3R5cGUgbWVtYmVycyBpbiBmb3JtIGB7IGtleTogJ21lbWJlcicsIC4uLiB9YCB3aGVyZSBga2V5YCBpcyB0aGUgbmFtZSBvZiBhbiBhbGllYXMgYW5kIGAnbWVtYmVyJ2AgaXMgdGhlIG5hbWUgb2YgYW4gZXhpc3RpbmcgbWVtYmVyIGluIHRoZSBwcm90b3R5cGUuIEVhY2ggc3VjaCBrZXkgaXMgYWRkZWQgdG8gdGhlIHByb3RvdHlwZSBhcyBhIHJlZmVyZW5jZSB0byB0aGUgbmFtZWQgbWVtYmVyLiAoVGhlIGBhbGlhc2VzYCBvYmplY3QgaXRzZWxmIGlzICpub3QqIGFkZGVkIHRvIHByb3RvdHlwZS4pIEFsdGVybmF0aXZlbHk6XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2tleXNdIC0gQXJiaXRyYXJ5IHByb3BlcnR5IG5hbWVzIGRlZmluZWQgaGVyZSB3aXRoIHN0cmluZyB2YWx1ZXMgc3RhcnRpbmcgd2l0aCBhIGAjYCBjaGFyYWN0ZXIgd2lsbCBhbGlhcyB0aGUgYWN0dWFsIHByb3BlcnRpZXMgbmFtZWQgaW4gdGhlIHN0cmluZ3MgKGZvbGxvd2luZyB0aGUgYCNgKS4gVGhpcyBpcyBhbiBhbHRlcm5hdGl2ZSB0byBwcm92aWRpbmcgYW4gYGFsaWFzZXNgIGhhc2gsIHBlcmhhcHMgc2ltcGxlciAodGhvdWdoIHN1YnRsZXIpLiAoVXNlIGFyYml0cmFyeSBpZGVudGlmaWVycyBoZXJlOyBkb24ndCB1c2UgdGhlIG5hbWUgYGtleXNgISlcbiAqIEBwcm9wZXJ0eSB7Kn0gW2FyYml0cmFyeVByb3BlcnRpZXNdIC0gQW55IGFkZGl0aW9uYWwgYXJiaXRyYXJ5IHByb3BlcnRpZXMgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG5ldyBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZS4gKFVzZSBhcmJpdHJhcnkgaWRlbnRpZmllcnMgaGVyZTsgZG9uJ3QgdXNlIHRoZSBuYW1lIGBhcmliaXRyYXJ5UHJvcGVydGllc2AhKVxuICovXG5cbi8qKiBAc3VtbWFyeSBDYWxsIGFsbCBgaW5pdGlhbGl6ZWAgbWV0aG9kcyBmb3VuZCBpbiBwcm90b3R5cGUgY2hhaW4uXG4gKiBAZGVzYyBUaGlzIHJlY3Vyc2l2ZSByb3V0aW5lIGlzIGNhbGxlZCBieSB0aGUgY29uc3RydWN0b3IuXG4gKiAxLiBXYWxrcyBiYWNrIHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gYE9iamVjdGAncyBwcm90b3R5cGVcbiAqIDIuIFdhbGtzIGZvcndhcmQgdG8gbmV3IG9iamVjdCwgY2FsbGluZyBhbnkgYGluaXRpYWxpemVgIG1ldGhvZHMgaXQgZmluZHMgYWxvbmcgdGhlIHdheSB3aXRoIHRoZSBzYW1lIGNvbnRleHQgYW5kIGFyZ3VtZW50cyB3aXRoIHdoaWNoIHRoZSBjb25zdHJ1Y3RvciB3YXMgY2FsbGVkLlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJPZiBleHRlbmQtbWVcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZVByb3RvdHlwZUNoYWluKCkge1xuICAgIHZhciB0ZXJtID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZWN1cih0ZXJtKTtcblxuICAgIGZ1bmN0aW9uIHJlY3VyKG9iaikge1xuICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgaWYgKHByb3RvLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHJlY3VyKHByb3RvKTtcbiAgICAgICAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnaW5pdGlhbGl6ZScpKSB7XG4gICAgICAgICAgICAgICAgcHJvdG8uaW5pdGlhbGl6ZS5hcHBseSh0ZXJtLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHRlbmQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHNbJ2NvbHVtbi1DUUwtc3ludGF4J10gPSBbXG4nPGxpPicsXG4nXHQ8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImNvcHlcIj48L2J1dHRvbj4nLFxuJ1x0PGRpdiBjbGFzcz1cImZpbHRlci10cmVlLXJlbW92ZS1idXR0b25cIiB0aXRsZT1cImRlbGV0ZSBjb25kaXRpb25hbFwiPjwvZGl2PicsXG4nXHR7MX06JyxcbidcdDxpbnB1dCBuYW1lPVwiezJ9XCIgY2xhc3M9XCJ7NH1cIiB2YWx1ZT1cInszOmVuY29kZX1cIj4nLFxuJzwvbGk+J1xuXS5qb2luKCdcXG4nKTtcblxuZXhwb3J0c1snY29sdW1uLVNRTC1zeW50YXgnXSA9IFtcbic8bGk+JyxcbidcdDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY29weVwiPjwvYnV0dG9uPicsXG4nXHQ8ZGl2IGNsYXNzPVwiZmlsdGVyLXRyZWUtcmVtb3ZlLWJ1dHRvblwiIHRpdGxlPVwiZGVsZXRlIGNvbmRpdGlvbmFsXCI+PC9kaXY+JyxcbidcdHsxfTonLFxuJ1x0PHRleHRhcmVhIG5hbWU9XCJ7Mn1cIiByb3dzPVwiMVwiIGNsYXNzPVwiezR9XCI+ezM6ZW5jb2RlfTwvdGV4dGFyZWE+Jyxcbic8L2xpPidcbl0uam9pbignXFxuJyk7XG5cbmV4cG9ydHMuY29sdW1uRmlsdGVyID0gW1xuJzxzcGFuIGNsYXNzPVwiZmlsdGVyLXRyZWVcIj4nLFxuJ1x0IDxzdHJvbmc+PHNwYW4+ezJ9IDwvc3Bhbj5jb2x1bW4gZmlsdGVyIHN1YmV4cHJlc3Npb246PC9zdHJvbmc+PGJyPicsXG4nXHQgTWF0Y2gnLFxuJ1x0IDxsYWJlbD48aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJmaWx0ZXItdHJlZS1vcC1jaG9pY2VcIiBuYW1lPVwidHJlZU9wezF9XCIgdmFsdWU9XCJvcC1vclwiPmFueTwvbGFiZWw+JyxcbidcdCA8bGFiZWw+PGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwiZmlsdGVyLXRyZWUtb3AtY2hvaWNlXCIgbmFtZT1cInRyZWVPcHsxfVwiIHZhbHVlPVwib3AtYW5kXCI+YWxsPC9sYWJlbD4nLFxuJ1x0IDxsYWJlbD48aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJmaWx0ZXItdHJlZS1vcC1jaG9pY2VcIiBuYW1lPVwidHJlZU9wezF9XCIgdmFsdWU9XCJvcC1ub3JcIj5ub25lPC9sYWJlbD4nLFxuJ1x0IG9mIHRoZSBmb2xsb3dpbmc6JyxcbidcdCA8c2VsZWN0PicsXG4nXHRcdCA8b3B0aW9uIHZhbHVlPVwiXCI+TmV3IGV4cHJlc3Npb24maGVsbGlwOzwvb3B0aW9uPicsXG4nXHQgPC9zZWxlY3Q+JyxcbidcdCA8b2w+PC9vbD4nLFxuJyA8L3NwYW4+J1xuXS5qb2luKCdcXG4nKTtcblxuZXhwb3J0cy5jb2x1bW5GaWx0ZXJzID0gW1xuJzxzcGFuIGNsYXNzPVwiZmlsdGVyLXRyZWUgZmlsdGVyLXRyZWUtdHlwZS1jb2x1bW4tZmlsdGVyc1wiPicsXG4nXHQgTWF0Y2ggPHN0cm9uZz5hbGw8L3N0cm9uZz4gb2YgdGhlIGZvbGxvd2luZyBjb2x1bW4gZmlsdGVyczonLFxuJ1x0IDxvbD48L29sPicsXG4nIDwvc3Bhbj4nXG5dLmpvaW4oJ1xcbicpO1xuXG5leHBvcnRzLmxvY2tlZENvbHVtbiA9IFtcbic8c3Bhbj4nLFxuJ1x0IHsxOmVuY29kZX0nLFxuJ1x0IDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgdmFsdWU9XCJ7Mn1cIj4nLFxuJyA8L3NwYW4+J1xuXS5qb2luKCdcXG4nKTtcblxuZXhwb3J0cy5ub3RlID0gW1xuJzxkaXYgY2xhc3M9XCJmb290bm90ZXNcIj4nLFxuJ1x0PGRpdiBjbGFzcz1cImZvb3Rub3RlXCI+PC9kaXY+JyxcbidcdDxwPlNlbGVjdCBhIG5ldyB2YWx1ZSBvciBkZWxldGUgdGhlIGV4cHJlc3Npb24gYWx0b2dldGhlci48L3A+Jyxcbic8L2Rpdj4nXG5dLmpvaW4oJ1xcbicpO1xuXG5leHBvcnRzLm5vdGVzID0gW1xuJzxkaXYgY2xhc3M9XCJmb290bm90ZXNcIj4nLFxuJ1x0PHA+Tm90ZSB0aGUgZm9sbG93aW5nIGVycm9yIGNvbmRpdGlvbnM6PC9wPicsXG4nXHQ8dWwgY2xhc3M9XCJmb290bm90ZVwiPjwvdWw+JyxcbidcdDxwPlNlbGVjdCBuZXcgdmFsdWVzIG9yIGRlbGV0ZSB0aGUgZXhwcmVzc2lvbiBhbHRvZ2V0aGVyLjwvcD4nLFxuJzwvZGl2Pidcbl0uam9pbignXFxuJyk7XG5cbmV4cG9ydHMub3B0aW9uTWlzc2luZyA9IFtcbidUaGUgcmVxdWVzdGVkIHZhbHVlIG9mIDxzcGFuIGNsYXNzPVwiZmllbGQtbmFtZVwiPnsxOmVuY29kZX08L3NwYW4+JyxcbicoPHNwYW4gY2xhc3M9XCJmaWVsZC12YWx1ZVwiPnsyOmVuY29kZX08L3NwYW4+KSBpcyBub3QgdmFsaWQuJ1xuXS5qb2luKCdcXG4nKTtcblxuZXhwb3J0cy5yZW1vdmVCdXR0b24gPSBbXG4nPGRpdiBjbGFzcz1cImZpbHRlci10cmVlLXJlbW92ZS1idXR0b25cIiB0aXRsZT1cImRlbGV0ZSBjb25kaXRpb25hbFwiPjwvZGl2Pidcbl0uam9pbignXFxuJyk7XG5cbmV4cG9ydHMuc3VidHJlZSA9IFtcbic8c3BhbiBjbGFzcz1cImZpbHRlci10cmVlXCI+JyxcbidcdCBNYXRjaCcsXG4nXHQgPGxhYmVsPjxpbnB1dCB0eXBlPVwicmFkaW9cIiBjbGFzcz1cImZpbHRlci10cmVlLW9wLWNob2ljZVwiIG5hbWU9XCJ0cmVlT3B7MX1cIiB2YWx1ZT1cIm9wLW9yXCI+YW55PC9sYWJlbD4nLFxuJ1x0IDxsYWJlbD48aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJmaWx0ZXItdHJlZS1vcC1jaG9pY2VcIiBuYW1lPVwidHJlZU9wezF9XCIgdmFsdWU9XCJvcC1hbmRcIj5hbGw8L2xhYmVsPicsXG4nXHQgPGxhYmVsPjxpbnB1dCB0eXBlPVwicmFkaW9cIiBjbGFzcz1cImZpbHRlci10cmVlLW9wLWNob2ljZVwiIG5hbWU9XCJ0cmVlT3B7MX1cIiB2YWx1ZT1cIm9wLW5vclwiPm5vbmU8L2xhYmVsPicsXG4nXHQgb2YgdGhlIGZvbGxvd2luZzonLFxuJ1x0IDxzZWxlY3Q+JyxcbidcdFx0IDxvcHRpb24gdmFsdWU9XCJcIj5OZXcgZXhwcmVzc2lvbiZoZWxsaXA7PC9vcHRpb24+JyxcbidcdFx0IDxvcHRpb24gdmFsdWU9XCJzdWJleHBcIiBzdHlsZT1cImJvcmRlci1ib3R0b206MXB4IHNvbGlkIGJsYWNrXCI+U3ViZXhwcmVzc2lvbjwvb3B0aW9uPicsXG4nXHQgPC9zZWxlY3Q+JyxcbidcdCA8b2w+PC9vbD4nLFxuJyA8L3NwYW4+J1xuXS5qb2luKCdcXG4nKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG52YXIgcG9wTWVudSA9IHJlcXVpcmUoJ3BvcC1tZW51Jyk7XG5cbnZhciBGaWx0ZXJUcmVlID0gcmVxdWlyZSgnLi9qcy9GaWx0ZXJUcmVlJyk7XG5GaWx0ZXJUcmVlLk5vZGUgPSByZXF1aXJlKCcuL2pzL0ZpbHRlck5vZGUnKTsgLy8gYWthOiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRmlsdGVyVHJlZS5wcm90b3R5cGUpLmNvbnN0cnVjdG9yXG5GaWx0ZXJUcmVlLkxlYWYgPSByZXF1aXJlKCcuL2pzL0ZpbHRlckxlYWYnKTsgLy8gYWthOiBGaWx0ZXJUcmVlLnByb3RvdHlwZS5lZGl0b3JzLkRlZmF1bHRcblxuLy8gZXhwb3NlIHNvbWUgb2JqZWN0cyBmb3IgcGx1Zy1pbiBhY2Nlc3NcblxuRmlsdGVyVHJlZS5Db25kaXRpb25hbHMgPSByZXF1aXJlKCcuL2pzL0NvbmRpdGlvbmFscycpO1xuXG4vLyBGT0xMT1dJTkcgUFJPUEVSVElFUyBBUkUgKioqIFRFTVBPUkFSWSAqKiosXG4vLyBGT1IgVEhFIERFTU8gVE8gQUNDRVNTIFRIRVNFIE5PREUgTU9EVUxFUy5cblxuRmlsdGVyVHJlZS5fID0gXztcbkZpbHRlclRyZWUucG9wTWVudSA9IHBvcE1lbnU7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXJUcmVlO1xuIiwiLyoqIEBtb2R1bGUgY29uZGl0aW9uYWxzICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCdleHRlbmQtbWUnKS5CYXNlO1xudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG52YXIgcmVnRXhwTElLRSA9IHJlcXVpcmUoJ3JlZ2V4cC1saWtlJyk7XG5cbnZhciBJTiA9ICdJTicsXG4gICAgTk9UX0lOID0gJ05PVCAnICsgSU4sXG4gICAgTElLRSA9ICdMSUtFJyxcbiAgICBOT1RfTElLRSA9ICdOT1QgJyArIExJS0UsXG4gICAgTElLRV9XSUxEX0NBUkQgPSAnJScsXG4gICAgTklMID0gJyc7XG5cbnZhciB0b1N0cmluZztcblxudmFyIGRlZmF1bHRJZFF0cyA9IHtcbiAgICBiZWc6ICdcIicsXG4gICAgZW5kOiAnXCInXG59O1xuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDb25kaXRpb25hbHMgPSBCYXNlLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzcWxJZFF0c09iamVjdH0gW29wdGlvbnMuc3FsSWRRdHM9e2JlZzonXCInLGVuZDonXCInfV1cbiAgICAgKiBAbWVtYmVyT2YgQ29uZGl0aW9uYWxzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGlkUXRzID0gb3B0aW9ucyAmJiBvcHRpb25zLnNxbElkUXRzO1xuICAgICAgICBpZiAoaWRRdHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3FsSWRRdHMgPSBpZFF0czsgLy8gb25seSBvdmVycmlkZSBpZiBkZWZpbmVkXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc3FsSWRRdHM6IGRlZmF1bHRJZFF0cyxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHMucHJvdG90eXBlXG4gICAgICovXG4gICAgbWFrZVNxbElkZW50aWZpZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNxbElkUXRzLmJlZyArIGlkICsgdGhpcy5zcWxJZFF0cy5lbmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHMucHJvdG90eXBlXG4gICAgICovXG4gICAgbWFrZVNxbFN0cmluZzogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAnXFwnJyArIHNxRXNjKHN0cmluZykgKyAnXFwnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtYWtlTElLRTogZnVuY3Rpb24oYmVnLCBlbmQsIG9wLCBvcmlnaW5hbE9wLCBjKSB7XG4gICAgICAgIHZhciBlc2NhcGVkID0gYy5vcGVyYW5kLnJlcGxhY2UoLyhbX1xcW1xcXSVdKS9nLCAnWyQxXScpOyAvLyBlc2NhcGUgYWxsIExJS0UgcmVzZXJ2ZWQgY2hhcnNcbiAgICAgICAgcmV0dXJuIHRoaXMubWFrZVNxbElkZW50aWZpZXIoYy5jb2x1bW4pICtcbiAgICAgICAgICAgICcgJyArIG9wICtcbiAgICAgICAgICAgICcgJyArIHRoaXMubWFrZVNxbFN0cmluZyhiZWcgKyBlc2NhcGVkICsgZW5kKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtYWtlSU46IGZ1bmN0aW9uKG9wLCBjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VTcWxJZGVudGlmaWVyKGMuY29sdW1uKSArXG4gICAgICAgICAgICAnICcgKyBvcCArXG4gICAgICAgICAgICAnICcgKyAnKFxcJycgKyBzcUVzYyhjLm9wZXJhbmQpLnJlcGxhY2UoL1xccyosXFxzKi9nLCAnXFwnLCBcXCcnKSArICdcXCcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtYWtlOiBmdW5jdGlvbihvcCwgYykge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWtlU3FsSWRlbnRpZmllcihjLmNvbHVtbikgK1xuICAgICAgICAgICAgJyAnICsgb3AgK1xuICAgICAgICAgICAgJyAnICsgYy5tYWtlU3FsT3BlcmFuZCgpO1xuICAgIH1cbn0pO1xuXG52YXIgb3BzID0gQ29uZGl0aW9uYWxzLnByb3RvdHlwZS5vcHMgPSB7XG4gICAgdW5kZWZpbmVkOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgbWFrZTogZnVuY3Rpb24oKSB7IHJldHVybiAnJzsgfVxuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyT2YgQ29uZGl0aW9uYWxzLnByb3RvdHlwZVxuICAgICAqL1xuICAgICc8Jzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIDwgYjsgfSxcbiAgICAgICAgbWFrZTogZnVuY3Rpb24oYykgeyByZXR1cm4gdGhpcy5tYWtlKCc8JywgYyk7IH1cbiAgICB9LFxuICAgIC8qKiBAdHlwZSB7cmVsYXRpb25hbE9wZXJhdG9yfVxuICAgICAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHMucHJvdG90eXBlXG4gICAgICovXG4gICAgJzw9Jzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIDw9IGI7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMubWFrZSgnPD0nLCBjKTsgfVxuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyT2YgQ29uZGl0aW9uYWxzLnByb3RvdHlwZVxuICAgICAqL1xuICAgICc9Jzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhID09PSBiOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihjKSB7IHJldHVybiB0aGlzLm1ha2UoJz0nLCBjKTsgfVxuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyT2YgQ29uZGl0aW9uYWxzLnByb3RvdHlwZVxuICAgICAqL1xuICAgICc+PSc6IHtcbiAgICAgICAgdGVzdDogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSA+PSBiOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihjKSB7IHJldHVybiB0aGlzLm1ha2UoJz49JywgYyk7IH1cbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICAnPic6IHtcbiAgICAgICAgdGVzdDogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSA+IGI7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMubWFrZSgnPicsIGMpOyB9XG4gICAgfSxcblxuICAgIC8qKiBAdHlwZSB7cmVsYXRpb25hbE9wZXJhdG9yfVxuICAgICAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHMucHJvdG90eXBlXG4gICAgICovXG4gICAgJzw+Jzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhICE9PSBiOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihjKSB7IHJldHVybiB0aGlzLm1ha2UoJzw+JywgYyk7IH1cbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBMSUtFOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHJlZ0V4cExJS0UuY2FjaGVkKGIsIHRydWUpLnRlc3QoYSk7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMubWFrZShMSUtFLCBjKTsgfSxcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICAnTk9UIExJS0UnOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuICFyZWdFeHBMSUtFLmNhY2hlZChiLCB0cnVlKS50ZXN0KGEpOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihjKSB7IHJldHVybiB0aGlzLm1ha2UoTk9UX0xJS0UsIGMpOyB9LFxuICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyT2YgQ29uZGl0aW9uYWxzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIElOOiB7IC8vIFRPRE86IGN1cnJlbnRseSBmb3JjaW5nIHN0cmluZyB0eXBpbmc7IHJld29yayBjYWxsaW5nIGNvZGUgdG8gcmVzcGVjdCBjb2x1bW4gdHlwZVxuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBpbk9wKGEsIGIpID49IDA7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMubWFrZUlOKElOLCBjKTsgfSxcbiAgICAgICAgb3BlcmFuZExpc3Q6IHRydWUsXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfSxcblxuICAgIC8qKiBAdHlwZSB7cmVsYXRpb25hbE9wZXJhdG9yfVxuICAgICAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHMucHJvdG90eXBlXG4gICAgICovXG4gICAgJ05PVCBJTic6IHsgLy8gVE9ETzogY3VycmVudGx5IGZvcmNpbmcgc3RyaW5nIHR5cGluZzsgcmV3b3JrIGNhbGxpbmcgY29kZSB0byByZXNwZWN0IGNvbHVtbiB0eXBlXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGluT3AoYSwgYikgPCAwOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihjKSB7IHJldHVybiB0aGlzLm1ha2VJTihOT1RfSU4sIGMpOyB9LFxuICAgICAgICBvcGVyYW5kTGlzdDogdHJ1ZSxcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBDT05UQUlOUzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBjb250YWluc09wKGEsIGIpID49IDA7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMubWFrZUxJS0UoTElLRV9XSUxEX0NBUkQsIExJS0VfV0lMRF9DQVJELCBMSUtFLCAnQ09OVEFJTlMnLCBjKTsgfSxcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICAnTk9UIENPTlRBSU5TJzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBjb250YWluc09wKGEsIGIpIDwgMDsgfSxcbiAgICAgICAgbWFrZTogZnVuY3Rpb24oYykgeyByZXR1cm4gdGhpcy5tYWtlTElLRShMSUtFX1dJTERfQ0FSRCwgTElLRV9XSUxEX0NBUkQsIE5PVF9MSUtFLCAnTk9UIENPTlRBSU5TJywgYyk7IH0sXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfSxcblxuICAgIC8qKiBAdHlwZSB7cmVsYXRpb25hbE9wZXJhdG9yfVxuICAgICAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHMucHJvdG90eXBlXG4gICAgICovXG4gICAgQkVHSU5TOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgYiA9IHRvU3RyaW5nKGIpOyByZXR1cm4gYmVnaW5zT3AoYSwgYi5sZW5ndGgpID09PSBiOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihjKSB7IHJldHVybiB0aGlzLm1ha2VMSUtFKE5JTCwgTElLRV9XSUxEX0NBUkQsIExJS0UsICdCRUdJTlMnLCBjKTsgfSxcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICAnTk9UIEJFR0lOUyc6IHtcbiAgICAgICAgdGVzdDogZnVuY3Rpb24oYSwgYikgeyBiID0gdG9TdHJpbmcoYik7IHJldHVybiBiZWdpbnNPcChhLCBiLmxlbmd0aCkgIT09IGI7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMubWFrZUxJS0UoTklMLCBMSUtFX1dJTERfQ0FSRCwgTk9UX0xJS0UsICdOT1QgQkVHSU5TJywgYyk7IH0sXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfSxcblxuICAgIC8qKiBAdHlwZSB7cmVsYXRpb25hbE9wZXJhdG9yfVxuICAgICAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHMucHJvdG90eXBlXG4gICAgICovXG4gICAgRU5EUzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IGIgPSB0b1N0cmluZyhiKTsgcmV0dXJuIGVuZHNPcChhLCBiLmxlbmd0aCkgPT09IGI7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMubWFrZUxJS0UoTElLRV9XSUxEX0NBUkQsIE5JTCwgTElLRSwgJ0VORFMnLCBjKTsgfSxcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICAnTk9UIEVORFMnOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgYiA9IHRvU3RyaW5nKGIpOyByZXR1cm4gZW5kc09wKGEsIGIubGVuZ3RoKSAhPT0gYjsgfSxcbiAgICAgICAgbWFrZTogZnVuY3Rpb24oYykgeyByZXR1cm4gdGhpcy5tYWtlTElLRShMSUtFX1dJTERfQ0FSRCwgTklMLCBOT1RfTElLRSwgJ05PVCBFTkRTJywgYyk7IH0sXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfVxufTtcblxuLy8gc29tZSBzeW5vbnltc1xub3BzWydcXHUyMjY0J10gPSBvcHNbJzw9J107ICAvLyBVTklDT0RFICdMRVNTLVRIQU4gT1IgRVFVQUwgVE8nXG5vcHNbJ1xcdTIyNjUnXSA9IG9wc1snPj0nXTsgIC8vIFVOSUNPREUgJ0dSRUFURVItVEhBTiBPUiBFUVVBTCBUTydcbm9wc1snXFx1MjI2MCddID0gb3BzWyc8PiddOyAgLy8gVU5JQ09ERSAnTk9UIEVRVUFMIFRPJ1xuXG5mdW5jdGlvbiBpbk9wKGEsIGIpIHtcbiAgICByZXR1cm4gYlxuICAgICAgICAudHJpbSgpIC8vIHJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZSBjaGFyc1xuICAgICAgICAucmVwbGFjZSgvXFxzKixcXHMqL2csICcsJykgLy8gcmVtb3ZlIGFueSB3aGl0ZS1zcGFjZSBjaGFycyBmcm9tIGFyb3VuZCBjb21tYXNcbiAgICAgICAgLnNwbGl0KCcsJykgLy8gcHV0IGluIGFuIGFycmF5XG4gICAgICAgIC5pbmRleE9mKChhICsgJycpKTsgLy8gc2VhcmNoIGFycmF5IHdob2xlIG1hdGNoZXNcbn1cblxuZnVuY3Rpb24gY29udGFpbnNPcChhLCBiKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKGEpLmluZGV4T2YodG9TdHJpbmcoYikpO1xufVxuXG5mdW5jdGlvbiBiZWdpbnNPcChhLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcoYSkuc3Vic3RyKDAsIGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGVuZHNPcChhLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcoYSkuc3Vic3RyKC1sZW5ndGgsIGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIHNxRXNjKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvJy9nLCAnXFwnXFwnJyk7XG59XG5cbnZhciBncm91cHMgPSB7XG4gICAgZXF1YWxpdHk6IHtcbiAgICAgICAgbGFiZWw6ICdFcXVhbGl0eScsXG4gICAgICAgIHN1Ym1lbnU6IFsnPSddXG4gICAgfSxcbiAgICBpbmVxdWFsaXRpZXM6IHtcbiAgICAgICAgbGFiZWw6ICdJbmVxdWFsaXRpZXMnLFxuICAgICAgICBzdWJtZW51OiBbXG4gICAgICAgICAgICAnPCcsXG4gICAgICAgICAgICAnXFx1MjI2NCcsIC8vIFVOSUNPREUgJ0xFU1MtVEhBTiBPUiBFUVVBTCBUTyc7IG9uIGEgTWFjLCB0eXBlIG9wdGlvbi1jb21tYSAo4omkKVxuICAgICAgICAgICAgJ1xcdTIyNjAnLCAvLyBVTklDT0RFICdOT1QgRVFVQUxTJzsgb24gYSBNYWMsIHR5cGUgb3B0aW9uLWVxdWFscyAo4omgKVxuICAgICAgICAgICAgJ1xcdTIyNjUnLCAvLyBVTklDT0RFICdHUkVBVEVSLVRIQU4gT1IgRVFVQUwgVE8nOyBvbiBhIE1hYywgdHlwZSBvcHRpb24tcGVyaW9kICjiiaUpXG4gICAgICAgICAgICAnPidcbiAgICAgICAgXVxuICAgIH0sXG4gICAgc2V0czoge1xuICAgICAgICBsYWJlbDogJ1NldCBzY2FucycsXG4gICAgICAgIHN1Ym1lbnU6IFsnSU4nLCAnTk9UIElOJ11cbiAgICB9LFxuICAgIHN0cmluZ3M6IHtcbiAgICAgICAgbGFiZWw6ICdTdHJpbmcgc2NhbnMnLFxuICAgICAgICBzdWJtZW51OiBbXG4gICAgICAgICAgICAnQ09OVEFJTlMnLCAnTk9UIENPTlRBSU5TJyxcbiAgICAgICAgICAgICdCRUdJTlMnLCAnTk9UIEJFR0lOUycsXG4gICAgICAgICAgICAnRU5EUycsICdOT1QgRU5EUydcbiAgICAgICAgXVxuICAgIH0sXG4gICAgcGF0dGVybnM6IHtcbiAgICAgICAgbGFiZWw6ICdQYXR0ZXJuIHNjYW5zJyxcbiAgICAgICAgc3VibWVudTogWydMSUtFJywgJ05PVCBMSUtFJ11cbiAgICB9XG59O1xuXG4vLyBhZGQgYSBgbmFtZWAgcHJvcCB0byBlYWNoIGdyb3VwXG5fKGdyb3VwcykuZWFjaChmdW5jdGlvbihncm91cCwga2V5KSB7IGdyb3VwLm5hbWUgPSBrZXk7IH0pO1xuXG4vKipcbiAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHNcbiAqL1xuQ29uZGl0aW9uYWxzLmdyb3VwcyA9IGdyb3VwcztcblxuLyoqIERlZmF1bHQgb3BlcmF0b3IgbWVudSB3aGVuIGNvbnNpc3Rpbmcgb2YgYWxsIG9mIHRoZSBncm91cHMgaW4ge0BsaW5rIG1vZHVsZTpjb25kaXRpb25hbHMuZ3JvdXBzfGdyb3Vwc30uIFRoaXMgbWVudSBpcyB1c2VkIHdoZW4gbm9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIG90aGVyd2lzZSBkZWZpbmVkOlxuICogKiBUaGUgYG9wTWVudWAgcHJvcGVydHkgb2YgdGhlIGNvbHVtbiBzY2hlbWEuXG4gKiAqIFRoZSBlbnRyeSBpbiB0aGUgbm9kZSdzIGB0eXBlT3BNYXBgIGhhc2ggY29ycmVzcG9uZGluZyB0byB0aGUgYHR5cGVgIHByb3BlcnR5IG9mIHRoZSBjb2x1bW4gc2NoZW1hLlxuICogKiBUaGUgbm9kZSdzIGB0cmVlT3BNZW51YCBvYmplY3QuXG4gKiBAdHlwZSB7bWVudUl0ZW1bXX1cbiAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHNcbiAqL1xuQ29uZGl0aW9uYWxzLmRlZmF1bHRPcE1lbnUgPSBbIC8vIGhpZXJhcmNoaWNhbCBtZW51IG9mIHJlbGF0aW9uYWwgb3BlcmF0b3JzXG4gICAgZ3JvdXBzLmVxdWFsaXR5LFxuICAgIGdyb3Vwcy5pbmVxdWFsaXRpZXMsXG4gICAgZ3JvdXBzLnNldHMsXG4gICAgZ3JvdXBzLnN0cmluZ3MsXG4gICAgZ3JvdXBzLnBhdHRlcm5zXG5dO1xuXG5cbi8vIE1lYW50IHRvIGJlIGNhbGxlZCBieSBGaWx0ZXJUcmVlLnByb3RvdHlwZS5zZXRTZW5zaXRpdml0eSBvbmx5XG5Db25kaXRpb25hbHMuc2V0VG9TdHJpbmcgPSBmdW5jdGlvbihmbikge1xuICAgIHJldHVybiAodG9TdHJpbmcgPSBmbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbmRpdGlvbmFscztcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcG9wTWVudSA9IHJlcXVpcmUoJ3BvcC1tZW51Jyk7XG5cbnZhciBGaWx0ZXJOb2RlID0gcmVxdWlyZSgnLi9GaWx0ZXJOb2RlJyk7XG52YXIgQ29uZGl0aW9uYWxzID0gcmVxdWlyZSgnLi9Db25kaXRpb25hbHMnKTtcblxuXG52YXIgdG9TdHJpbmc7IC8vIHNldCBieSBGaWx0ZXJMZWFmLnNldFRvU3RyaW5nKCkgY2FsbGVkIGZyb20gLi4vaW5kZXguanNcblxuXG4vKiogQHR5cGVkZWYge29iamVjdH0gY29udmVydGVyXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSB0b1R5cGUgLSBSZXR1cm5zIGlucHV0IHZhbHVlIGNvbnZlcnRlZCB0byB0eXBlLiBGYWlscyBzaWxlbnRseS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGZhaWxlZCAtIFRlc3RzIGlucHV0IHZhbHVlIGFnYWluc3QgdHlwZSwgcmV0dXJuaW5nIGBmYWxzZSBpZiB0eXBlIG9yIGB0cnVlYCBpZiBub3QgdHlwZS5cbiAqL1xuXG4vKiogQHR5cGUge2NvbnZlcnRlcn0gKi9cbnZhciBudW1iZXJDb252ZXJ0ZXIgPSB7XG4gICAgdG9UeXBlOiBOdW1iZXIsXG4gICAgZmFpbGVkOiBpc05hTlxufTtcblxuLyoqIEB0eXBlIHtjb252ZXJ0ZXJ9ICovXG52YXIgZGF0ZUNvbnZlcnRlciA9IHtcbiAgICB0b1R5cGU6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIG5ldyBEYXRlKHMpOyB9LFxuICAgIGZhaWxlZDogaXNOYU5cbn07XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gZmlsdGVyTGVhZlZpZXdPYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBjb2x1bW4gLSBBIGRyb3AtZG93biB3aXRoIG9wdGlvbnMgZnJvbSB0aGUgYEZpbHRlckxlYWZgIGluc3RhbmNlJ3Mgc2NoZW1hLiBWYWx1ZSBpcyB0aGUgbmFtZSBvZiB0aGUgY29sdW1uIGJlaW5nIHRlc3RlZCAoaS5lLiwgdGhlIGNvbHVtbiB0byB3aGljaCB0aGlzIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24gYXBwbGllcykuXG4gKlxuICogQHByb3BlcnR5IG9wZXJhdG9yIC0gQSBkcm9wLWRvd24gd2l0aCBvcHRpb25zIGZyb20ge0BsaW5rIGNvbHVtbk9wTWVudX0sIHtAbGluayB0eXBlT3BNYXB9LCBvciB7QGxpbmsgdHJlZU9wTWVudX0uIFZhbHVlIGlzIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9wZXJhdG9yLlxuICpcbiAqIEBwcm9wZXJ0eSBvcGVyYW5kIC0gQW4gaW5wdXQgZWxlbWVudCwgc3VjaCBhcyBhIGRyb3AtZG93biBvciBhIHRleHQgYm94LlxuICovXG5cbi8qKiBAY29uc3RydWN0b3JcbiAqIEBzdW1tYXJ5IEFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBjb25kaXRpb25hbCBleHByZXNzaW9uIG5vZGUgaW4gYSBmaWx0ZXIgdHJlZS5cbiAqIEBkZXNjIFRoaXMgb2JqZWN0IHJlcHJlc2VudHMgYSBjb25kaXRpb25hbCBleHByZXNzaW9uLiBJdCBpcyBhbHdheXMgYSB0ZXJtaW5hbCBub2RlIGluIHRoZSBmaWx0ZXIgdHJlZTsgaXQgaGFzIG5vIGNoaWxkIG5vZGVzIG9mIGl0cyBvd24uXG4gKlxuICogQSBjb25kaXRpb25hbCBleHByZXNzaW9uIGlzIGEgc2ltcGxlIGR5YWRpYyBleHByZXNzaW9uIHdpdGggdGhlIGZvbGxvd2luZyBzeW50YXggaW4gdGhlIFVJOlxuICpcbiAqID4gX2NvbHVtbiBvcGVyYXRvciBvcGVyYW5kX1xuICpcbiAqIHdoZXJlOlxuICogKiBfY29sdW1uXyBpcyB0aGUgbmFtZSBvZiBhIGNvbHVtbiBmcm9tIHRoZSBkYXRhIHJvdyBvYmplY3RcbiAqICogX29wZXJhdG9yXyBpcyB0aGUgbmFtZSBvZiBhbiBvcGVyYXRvciBmcm9tIHRoZSBub2RlJ3Mgb3BlcmF0b3IgbGlzdFxuICogKiBfb3BlcmFuZF8gaXMgYSBsaXRlcmFsIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdCB0aGUgdmFsdWUgaW4gdGhlIG5hbWVkIGNvbHVtblxuICpcbiAqICoqTk9URToqKiBUaGUge0BsaW5rIENvbHVtbkxlYWZ9IGV4dGVuc2lvbiBvZiB0aGlzIG9iamVjdCBoYXMgYSBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb24gb2YgX29wZXJhbmRfIHdoaWNoIGlzOiBUaGUgbmFtZSBvZiBhIGNvbHVtbiBmcm9tIHdoaWNoIHRvIGZldGNoIHRoZSBjb21wYXJlIHZhbHVlIChmcm9tIHRoZSBzYW1lIGRhdGEgcm93IG9iamVjdCkgdG8gY29tcGFyZSBhZ2FpbnN0IHRoZSB2YWx1ZSBpbiB0aGUgbmFtZWQgY29sdW1uLiBTZWUgKkV4dGVuZGluZyB0aGUgY29uZGl0aW9uYWwgZXhwcmVzc2lvbiBvYmplY3QqIGluIHRoZSB7QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvaW5kZXguaHRtbHxyZWFkbWV9LlxuICpcbiAqIFRoZSB2YWx1ZXMgb2YgdGhlIHRlcm1zIG9mIHRoZSBleHByZXNzaW9uIGFib3ZlIGFyZSBzdG9yZWQgaW4gdGhlIGZpcnN0IHRocmVlIHByb3BlcnRpZXMgYmVsb3cuIEVhY2ggb2YgdGhlc2UgdGhyZWUgcHJvcGVydGllcyBpcyBzZXQgZWl0aGVyIGJ5IGBzZXRTdGF0ZSgpYCBvciBieSB0aGUgdXNlciB2aWEgYSBjb250cm9sIGluIGBlbGAuIE5vdGUgdGhhdCB0aGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgZHluYW1pY2FsbHkgYm91bmQgdG8gdGhlIFVJIGNvbnRyb2xzOyB0aGV5IGFyZSB1cGRhdGVkIGJ5IHRoZSB2YWxpZGF0aW9uIGZ1bmN0aW9uLCBgaW52YWxpZCgpYC5cbiAqXG4gKiAqKlNlZSBhbHNvIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzdXBlcmNsYXNzOioqIHtAbGluayBGaWx0ZXJOb2RlfVxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2x1bW4gLSBOYW1lIG9mIHRoZSBtZW1iZXIgaW4gdGhlIGRhdGEgcm93IG9iamVjdHMgYWdhaW5zdCB3aGljaCBgb3BlcmFuZGAgd2lsbCBiZSBjb21wYXJlZC4gUmVmbGVjdHMgdGhlIHZhbHVlIG9mIHRoZSBgdmlldy5jb2x1bW5gIGNvbnRyb2wgYWZ0ZXIgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gb3BlcmF0b3IgLSBPcGVyYXRvciBzeW1ib2wuIFRoaXMgbXVzdCBtYXRjaCBhIGtleSBpbiB0aGUgYHRoaXMucm9vdC5jb25kaXRpb25hbHMub3BzYCBoYXNoLiBSZWZsZWN0cyB0aGUgdmFsdWUgb2YgdGhlIGB2aWV3Lm9wZXJhdG9yYCBjb250cm9sIGFmdGVyIHZhbGlkYXRpb24uXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9wZXJhbmQgLSBWYWx1ZSB0byBjb21wYXJlIGFnYWluc3QgdGhlIHRoZSBtZW1iZXIgb2YgZGF0YSByb3cgbmFtZWQgYnkgYGNvbHVtbmAuIFJlZmxlY3RzIHRoZSB2YWx1ZSBvZiB0aGUgYHZpZXcub3BlcmFuZGAgY29udHJvbCwgYWZ0ZXIgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFVzZWQgdG8gZGVzY3JpYmUgdGhlIG9iamVjdCBpbiB0aGUgVUkgc28gdXNlciBjYW4gc2VsZWN0IGFuIGV4cHJlc3Npb24gZWRpdG9yLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZT0nc3RyaW5nJ10gLSBUaGUgZGF0YSB0eXBlIG9mIHRoZSBzdWJleHByZXNzaW9uIGlmIG5laXRoZXIgdGhlIG9wZXJhdG9yIG5vciB0aGUgY29sdW1uIHNjaGVtYSBkZWZpbmVzIGEgdHlwZS5cbiAqXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBlbCAtIEEgYDxzcGFuPi4uLjwvc3Bhbj5gIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgVUkgY29udHJvbHMuIFRoaXMgZWxlbWVudCBpcyBhdXRvbWF0aWNhbGx5IGFwcGVuZWRlZCB0byB0aGUgcGFyZW50IGBGaWx0ZXJUcmVlYCdzIGBlbGAuIEdlbmVyYXRlZCBieSB7QGxpbmsgRmlsdGVyTGVhZiNjcmVhdGVWaWV3fGNyZWF0ZVZpZXd9LlxuICpcbiAqIEBwcm9wZXJ0eSB7ZmlsdGVyTGVhZlZpZXdPYmplY3R9IHZpZXcgLSBBIGhhc2ggY29udGFpbmluZyBkaXJlY3QgcmVmZXJlbmNlcyB0byB0aGUgY29udHJvbHMgaW4gYGVsYC4gQWRkZWQgYnkge0BsaW5rIEZpbHRlckxlYWYjY3JlYXRlVmlld3xjcmVhdGVWaWV3fS5cbiAqL1xudmFyIEZpbHRlckxlYWYgPSBGaWx0ZXJOb2RlLmV4dGVuZCgnRmlsdGVyTGVhZicsIHtcblxuICAgIG5hbWU6ICdjb2x1bW4gPSB2YWx1ZScsIC8vIGRpc3BsYXkgc3RyaW5nIGZvciBkcm9wLWRvd25cblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy52aWV3KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy52aWV3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W2tleV0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5vbkNoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB2aWV3LlxuICAgICAqIEBkZXNjIFRoaXMgbmV3IFwidmlld1wiIGlzIGEgZ3JvdXAgb2YgSFRNTCBgRWxlbWVudGAgY29udHJvbHMgdGhhdCBjb21wbGV0ZWx5IGRlc2NyaWJlIHRoZSBjb25kaXRpb25hbCBleHByZXNzaW9uIHRoaXMgb2JqZWN0IHJlcHJlc2VudHMuIFRoaXMgbWV0aG9kIGNyZWF0ZXMgdGhlIHZpZXcsIHNldHRpbmcgYHRoaXMuZWxgIHRvIHBvaW50IHRvIGl0LCBhbmQgdGhlIG1lbWJlcnMgb2YgYHRoaXMudmlld2AgdG8gcG9pbnQgdG8gdGhlIGluZGl2aWR1YWwgY29udHJvbHMgdGhlcmVpbi5cbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyTGVhZi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjcmVhdGVWaWV3OiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXG4gICAgICAgIGVsLmNsYXNzTmFtZSA9ICdmaWx0ZXItdHJlZS1lZGl0b3IgZmlsdGVyLXRyZWUtZGVmYXVsdCc7XG5cbiAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLmNvbHVtbikge1xuICAgICAgICAgICAgLy8gU3RhdGUgaW5jbHVkZXMgY29sdW1uOlxuICAgICAgICAgICAgLy8gT3BlcmF0b3IgbWVudSBpcyBidWlsdCBsYXRlciBpbiBsb2FkU3RhdGU7IHdlIGRvbid0IG5lZWQgdG8gYnVpbGQgaXQgbm93LiBUaGUgY2FsbCB0b1xuICAgICAgICAgICAgLy8gZ2V0T3BNZW51IGJlbG93IHdpdGggdW5kZWZpbmVkIGNvbHVtbk5hbWUgcmV0dXJucyBbXSByZXN1bHRpbmcgaW4gYW4gZW1wdHkgZHJvcC1kb3duLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2hlbiBzdGF0ZSBkb2VzIE5PVCBpbmNsdWRlIGNvbHVtbiwgaXQncyBiZWNhdXNlIGVpdGhlcjpcbiAgICAgICAgICAgIC8vIGEuIGNvbHVtbiBpcyB1bmtub3duIGFuZCBvcCBtZW51IHdpbGwgYmUgZW1wdHkgdW50aWwgdXNlciBjaG9vc2VzIGEgY29sdW1uOyBvclxuICAgICAgICAgICAgLy8gYi4gY29sdW1uIGlzIGhhcmQtY29kZWQgd2hlbiB0aGVyZSdzIG9ubHkgb25lIHBvc3NpYmxlIGNvbHVtbiBhcyBpbmZlcmFibGUgZnJvbSBzY2hlbWE6XG4gICAgICAgICAgICB2YXIgc2NoZW1hID0gdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEubGVuZ3RoID09PSAxICYmIHRoaXMuc2NoZW1hWzBdLFxuICAgICAgICAgICAgICAgIGNvbHVtbk5hbWUgPSBzY2hlbWEgJiYgc2NoZW1hLm5hbWUgfHwgc2NoZW1hO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52aWV3ID0ge1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLm1ha2VFbGVtZW50KHRoaXMuc2NoZW1hLCAnY29sdW1uJywgdGhpcy5zb3J0Q29sdW1uTWVudSksXG4gICAgICAgICAgICBvcGVyYXRvcjogdGhpcy5tYWtlRWxlbWVudChnZXRPcE1lbnUuY2FsbCh0aGlzLCBjb2x1bW5OYW1lKSwgJ29wZXJhdG9yJyksXG4gICAgICAgICAgICBvcGVyYW5kOiB0aGlzLm1ha2VFbGVtZW50KClcbiAgICAgICAgfTtcblxuICAgICAgICBlbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpKTtcbiAgICB9LFxuXG4gICAgbG9hZFN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSwgZWwsIGksIGIsIHNlbGVjdGVkLCBub3RlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFGaWx0ZXJOb2RlLm9wdGlvbnNTY2hlbWFba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXNba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGVsID0gdGhpcy52aWV3W2tleV07XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZWwudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT1cXCcnICsgZWwubmFtZSArICdcXCddJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsW2ldLmNoZWNrZWQgPSB2YWx1ZS5pbmRleE9mKGVsW2ldLnZhbHVlKSA+PSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdC1tdWx0aXBsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBlbC5vcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGIgPSBmYWxzZTsgaSA8IGVsLmxlbmd0aDsgaSsrLCBiID0gYiB8fCBzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHZhbHVlLmluZGV4T2YoZWxbaV0udmFsdWUpID49IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsW2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpbHRlck5vZGUuc2V0V2FybmluZ0NsYXNzKGVsLCBiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoRmlsdGVyTm9kZS5zZXRXYXJuaW5nQ2xhc3MoZWwpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3Rlcy5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2NvbHVtbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZU9wTWVudS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG11bHRpcGxlID0gbm90ZXMubGVuZ3RoID4gMSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzID0gdGhpcy50ZW1wbGF0ZXMsXG4gICAgICAgICAgICAgICAgICAgIGZvb3Rub3RlcyA9IHRlbXBsYXRlcy5nZXQobXVsdGlwbGUgPyAnbm90ZXMnIDogJ25vdGUnKSxcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIgPSBmb290bm90ZXMucXVlcnlTZWxlY3RvcignLmZvb3Rub3RlJyk7XG4gICAgICAgICAgICAgICAgbm90ZXMuZm9yRWFjaChmdW5jdGlvbihub3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb290bm90ZSA9IG11bHRpcGxlID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKSA6IGlubmVyO1xuICAgICAgICAgICAgICAgICAgICBub3RlID0gdGVtcGxhdGVzLmdldCgnb3B0aW9uTWlzc2luZycsIG5vdGUua2V5LCBub3RlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5vdGUubGVuZ3RoKSB7IGZvb3Rub3RlLmFwcGVuZENoaWxkKG5vdGVbMF0pOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSkgeyBpbm5lci5hcHBlbmRDaGlsZChmb290bm90ZSk7IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubm90ZXNFbCA9IGZvb3Rub3RlcztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2NvbnZlcnRlcn0gbnVtYmVyXG4gICAgICogQHByb3BlcnR5IHtjb252ZXJ0ZXJ9IGludCAtIHN5bm9ueW0gb2YgYG51bWJlcmBcbiAgICAgKiBAcHJvcGVydHkge2NvbnZlcnRlcn0gZmxvYXQgLSBzeW5vbnltIG9mIGBudW1iZXJgXG4gICAgICogQHByb3BlcnR5IHtjb252ZXJ0ZXJ9IGRhdGVcbiAgICAgKiBAcHJvcGVydHkge2NvbnZlcnRlcn0gc3RyaW5nXG4gICAgICovXG4gICAgY29udmVydGVyczoge1xuICAgICAgICBudW1iZXI6IG51bWJlckNvbnZlcnRlcixcbiAgICAgICAgaW50OiBudW1iZXJDb252ZXJ0ZXIsXG4gICAgICAgIGZsb2F0OiBudW1iZXJDb252ZXJ0ZXIsXG4gICAgICAgIGRhdGU6IGRhdGVDb252ZXJ0ZXJcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IHRoZSBwYXJlbnQgbm9kZSdzIHtAbGluayBGaWx0ZXJUcmVlI2ludmFsaWR8aW52YWxpZCgpfSBtZXRob2QsIHdoaWNoIGNhdGNoZXMgdGhlIGVycm9yIHRocm93biB3aGVuIGludmFsaWQuXG4gICAgICpcbiAgICAgKiBBbHNvIHBlcmZvcm1zIHRoZSBmb2xsb3dpbmcgY29tcGlsYXRpb24gYWN0aW9uczpcbiAgICAgKiAqIENvcGllcyBhbGwgYHRoaXMudmlld2AnIHZhbHVlcyBmcm9tIHRoZSBET00gdG8gc2ltaWxhcmx5IG5hbWVkIHByb3BlcnRpZXMgb2YgYHRoaXNgLlxuICAgICAqICogUHJlLXNldHMgYHRoaXMub3BgIGFuZCBgdGhpcy5jb252ZXJ0ZXJgIGZvciB1c2UgaW4gYHRlc3RgJ3MgdHJlZSB3YWxrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50aHJvdz1mYWxzZV0gLSBUaHJvdyBhbiBlcnJvciBpZiBtaXNzaW5nIG9yIGludmFsaWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mb2N1cz1mYWxzZV0gLSBNb3ZlIGZvY3VzIHRvIG9mZmVuZGluZyBjb250cm9sLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9IFRoaXMgaXMgdGhlIG5vcm1hbCByZXR1cm4gd2hlbiB2YWxpZDsgb3RoZXJ3aXNlIHRocm93cyBlcnJvciB3aGVuIGludmFsaWQuXG4gICAgICogQG1lbWJlck9mIEZpbHRlckxlYWYucHJvdG90eXBlXG4gICAgICovXG4gICAgaW52YWxpZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgZWxlbWVudE5hbWUsIHR5cGUsIGZvY3VzZWQ7XG5cbiAgICAgICAgZm9yIChlbGVtZW50TmFtZSBpbiB0aGlzLnZpZXcpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMudmlld1tlbGVtZW50TmFtZV0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb250cm9sVmFsdWUoZWwpLnRyaW0oKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgIGlmICghZm9jdXNlZCAmJiBvcHRpb25zICYmIG9wdGlvbnMuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tJbihlbCk7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnRocm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyB0aGlzLkVycm9yKCdNaXNzaW5nIG9yIGludmFsaWQgJyArIGVsZW1lbnROYW1lICsgJyBpbiBjb25kaXRpb25hbCBleHByZXNzaW9uLiBDb21wbGV0ZSB0aGUgZXhwcmVzc2lvbiBvciByZW1vdmUgaXQuJywgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDb3B5IGVhY2ggY29udHJvbHMncyB2YWx1ZSBhcyBhIG5ldyBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAgICAgICAgdGhpc1tlbGVtZW50TmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3AgPSB0aGlzLnJvb3QuY29uZGl0aW9uYWxzLm9wc1t0aGlzLm9wZXJhdG9yXTtcblxuICAgICAgICB0eXBlID0gdGhpcy5nZXRUeXBlKCk7XG5cbiAgICAgICAgdGhpcy5jb252ZXJ0ZXIgPSB0eXBlICYmIHR5cGUgIT09ICdzdHJpbmcnICYmIHRoaXMuY29udmVydGVyc1t0eXBlXTtcbiAgICB9LFxuXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLm9wLnR5cGUgLy8gdGhlIGV4cHJlc3Npb24ncyBvcGVyYXRvcidzIHR5cGUgKGJlY2F1c2Ugc29tZSBvcGVyYXRvcnMgb25seSB3b3JrIHdpdGggc3RyaW5ncylcbiAgICAgICAgICAgIHx8XG4gICAgICAgICAgICAodGhpcy5zY2hlbWEubG9va3VwKHRoaXMuY29sdW1uKSB8fCB7fSkudHlwZSAvLyB0aGUgZXhwcmVzc2lvbidzIGNvbHVtbiBzY2hlbWEgdHlwZVxuICAgICAgICAgICAgfHxcbiAgICAgICAgICAgIHRoaXMudHlwZSAvLyB0aGUgZXhwcmVzc2lvbiBub2RlJ3MgdHlwZVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBwOiBmdW5jdGlvbihkYXRhUm93KSB7IHJldHVybiBkYXRhUm93W3RoaXMuY29sdW1uXTsgfSxcbiAgICBxOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMub3BlcmFuZDsgfSxcblxuICAgIHRlc3Q6IGZ1bmN0aW9uKGRhdGFSb3cpIHtcbiAgICAgICAgdmFyIHAsIHEsIC8vIHVudHlwZWQgdmVyc2lvbnMgb2YgYXJnc1xuICAgICAgICAgICAgUCwgUSwgLy8gdHlwZWQgdmVyc2lvbnMgb2YgcCBhbmQgcVxuICAgICAgICAgICAgY29udmVydGVyO1xuXG4gICAgICAgIC8vIFRPRE86IElmIGEgbGl0ZXJhbCAoaS5lLiwgd2hlbiB0aGlzLnEgaXMgbm90IG92ZXJyaWRkZW4pLCBxIG9ubHkgbmVlZHMgdG8gYmUgZmV0Y2hlZCAmIGNvbnZlcnRlZCBPTkNFIGZvciBhbGwgcm93c1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gVE9ETzogVW5jb21tZW50IGZvbGxvd2luZyB0d28gbGluZXMgaWYgdmFsdWVzIGNhbiBiZSBmdW5jdGlvbnNcbiAgICAgICAgICAgIC8vKHAgPSB2YWxPckZ1bmModGhpcy5wKGRhdGFSb3cpKSkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgLy8ocSA9IHZhbE9yRnVuYyh0aGlzLnEoZGF0YVJvdykpKSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAocCA9IHRoaXMucChkYXRhUm93KSkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKHEgPSB0aGlzLnEoZGF0YVJvdykpID09PSB1bmRlZmluZWRcbiAgICAgICAgKVxuICAgICAgICAgICAgPyBmYWxzZSAvLyBkYXRhIGluYWNjZXNzaWJsZSBzbyBleGNsdWRlIHJvd1xuICAgICAgICAgICAgOiAoXG4gICAgICAgICAgICAgICAgKGNvbnZlcnRlciA9IHRoaXMuY29udmVydGVyKSAmJlxuICAgICAgICAgICAgICAgICFjb252ZXJ0ZXIuZmFpbGVkKFAgPSBjb252ZXJ0ZXIudG9UeXBlKHApKSAmJiAvLyBhdHRlbXB0IHRvIGNvbnZlcnQgZGF0YSB0byB0eXBlXG4gICAgICAgICAgICAgICAgIWNvbnZlcnRlci5mYWlsZWQoUSA9IGNvbnZlcnRlci50b1R5cGUocSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgPyB0aGlzLm9wLnRlc3QoUCwgUSkgLy8gYm90aCBjb252ZXJzaW9ucyBzdWNjZXNzZnVsOiBjb21wYXJlIGFzIHR5cGVzXG4gICAgICAgICAgICAgICAgOiB0aGlzLm9wLnRlc3QodG9TdHJpbmcocCksIHRvU3RyaW5nKHEpKTsgLy8gb25lIG9yIGJvdGggY29udmVyc2lvbnMgZmFpbGVkOiBjb21wYXJlIGFzIHN0cmluZ3NcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXRlID0ge307XG4gICAgICAgIGlmICh0aGlzLmVkaXRvcikge1xuICAgICAgICAgICAgc3RhdGUuZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMudmlldykge1xuICAgICAgICAgICAgc3RhdGVba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zY2hlbWEgIT09IHRoaXMucGFyZW50LnNjaGVtYSkge1xuICAgICAgICAgICAgc3RhdGUuc2NoZW1hID0gdGhpcy5zY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3IgYCdvYmplY3QnYCBhbmQgYCdKU09OJ2Agbm90ZSB0aGF0IHRoZSBzdWJ0cmVlJ3MgdmVyc2lvbiBvZiBgZ2V0U3RhdGVgIHdpbGwgbm90IGNhbGwgdGhpcyBsZWFmIHZlcnNpb24gb2YgYGdldFN0YXRlYCBiZWNhdXNlIHRoZSBmb3JtZXIgdXNlcyBgdW5zdHJ1bmdpZnkoKWAgYW5kIGBKU09OLnN0cmluZ2lmeSgpYCwgcmVzcGVjdGl2ZWx5LCBib3RoIG9mIHdoaWNoIHJlY3Vyc2UgYW5kIGNhbGwgYHRvSlNPTigpYCBvbiB0aGVpciBvd24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9J29iamVjdCddIC0gU2VlIHRoZSBzdWJ0cmVlIHZlcnNpb24gb2Yge0BsaW5rIEZpbHRlclRyZWUjZ2V0U3RhdGV8Z2V0U3RhdGV9IGZvciBtb3JlIGluZm8uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyTGVhZi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRTdGF0ZTogZnVuY3Rpb24gZ2V0U3RhdGUob3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgICBzeW50YXggPSBvcHRpb25zICYmIG9wdGlvbnMuc3ludGF4IHx8ICdvYmplY3QnO1xuXG4gICAgICAgIHN3aXRjaCAoc3ludGF4KSB7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOiAvLyBzZWUgbm90ZSBhYm92ZVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudG9KU09OKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdKU09OJzogLy8gc2VlIG5vdGUgYWJvdmVcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLCBudWxsLCBvcHRpb25zICYmIG9wdGlvbnMuc3BhY2UpIHx8ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnU1FMJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmdldFN5bnRheCh0aGlzLnJvb3QuY29uZGl0aW9uYWxzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIG1ha2VTcWxPcGVyYW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5jb25kaXRpb25hbHMubWFrZVNxbFN0cmluZyh0aGlzLm9wZXJhbmQpOyAvLyB0b2RvOiB0aGlzIHNob3VsZCBiZSBhIG51bWJlciBpZiB0eXBlIGlzIG51bWJlciBpbnN0ZWFkIG9mIGEgc3RyaW5nIC0tIGJ1dCB3ZSB3aWxsIGhhdmUgdG8gZW5zdXJlIGl0IGlzIG51bWVyaWMhXG4gICAgfSxcblxuICAgIGdldFN5bnRheDogZnVuY3Rpb24oY29uZGl0aW9uYWxzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuY29uZGl0aW9uYWxzLm9wc1t0aGlzLm9wZXJhdG9yXS5tYWtlLmNhbGwoY29uZGl0aW9uYWxzLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IEhUTUwgZm9ybSBjb250cm9scyBmYWN0b3J5LlxuICAgICAqIEBkZXNjIENyZWF0ZXMgYW5kIGFwcGVuZHMgYSB0ZXh0IGJveCBvciBhIGRyb3AtZG93bi5cbiAgICAgKiA+IERlZmluZWQgb24gdGhlIEZpbHRlclRyZWUgcHJvdG90eXBlIGZvciBhY2Nlc3MgYnkgZGVyaXZlZCB0eXBlcyAoYWx0ZXJuYXRlIGZpbHRlciBlZGl0b3JzKS5cbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHttZW51SXRlbVtdfSBbbWVudV0gLSBPdmVybG9hZHM6XG4gICAgICogKiBJZiBvbWl0dGVkLCB3aWxsIGNyZWF0ZSBhbiBgPGlucHV0Lz5gICh0ZXh0IGJveCkgZWxlbWVudC5cbiAgICAgKiAqIElmIGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgb3B0aW9uLCB3aWxsIGNyZWF0ZSBhIGA8c3Bhbj4uLi48L3NwYW4+YCBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHN0cmluZyBhbmQgYSBgPGlucHV0IHR5cGU9aGlkZGVuPmAgY29udGFpbmluZyB0aGUgdmFsdWUuXG4gICAgICogKiBPdGhlcndpc2UsIGNyZWF0ZXMgYSBgPHNlbGVjdD4uLi48L3NlbGVjdD5gIGVsZW1lbnQgd2l0aCB0aGVzZSBtZW51IGl0ZW1zLlxuICAgICAqIEBwYXJhbSB7bnVsbHxzdHJpbmd9IFtwcm9tcHQ9JyddIC0gQWRkcyBhbiBpbml0aWFsIGA8b3B0aW9uPi4uLjwvb3B0aW9uPmAgZWxlbWVudCB0byB0aGUgZHJvcC1kb3duIHdpdGggdGhpcyB2YWx1ZSwgcGFyZW50aGVzaXplZCwgYXMgaXRzIGB0ZXh0YDsgYW5kIGVtcHR5IHN0cmluZyBhcyBpdHMgYHZhbHVlYC4gT21pdHRpbmcgY3JlYXRlcyBhIGJsYW5rIHByb21wdDsgYG51bGxgIHN1cHByZXNzZXMuXG4gICAgICogQHBhcmFtIFtzb3J0XVxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJMZWFmLnByb3RvdHlwZVxuICAgICAqL1xuICAgIG1ha2VFbGVtZW50OiBmdW5jdGlvbihtZW51LCBwcm9tcHQsIHNvcnQpIHtcbiAgICAgICAgdmFyIGVsLCByZXN1bHQsIG9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb24gPSBtZW51LFxuICAgICAgICAgICAgdGFnTmFtZSA9IG1lbnUgPyAnU0VMRUNUJyA6ICdJTlBVVCc7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHRoZXJlIHdvdWxkIGJlIG9ubHkgYSBzaW5nbGUgaXRlbSBpbiB0aGUgZHJvcGRvd25cbiAgICAgICAgd2hpbGUgKG9wdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uLmxlbmd0aCA9PT0gMSAmJiAhcG9wTWVudS5pc0dyb3VwUHJveHkob3B0aW9uWzBdKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvblswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICAgICAgLy8gaGFyZCB0ZXh0IHdoZW4gc2luZ2xlIGl0ZW1cbiAgICAgICAgICAgIGVsID0gdGhpcy50ZW1wbGF0ZXMuZ2V0KFxuICAgICAgICAgICAgICAgICdsb2NrZWRDb2x1bW4nLFxuICAgICAgICAgICAgICAgIG9wdGlvbi5hbGlhcyB8fCBvcHRpb24ubmFtZSB8fCBvcHRpb24sXG4gICAgICAgICAgICAgICAgb3B0aW9uLm5hbWUgfHwgb3B0aW9uLmFsaWFzIHx8IG9wdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0LFxuICAgICAgICAgICAgICAgIHNvcnQ6IHNvcnQsXG4gICAgICAgICAgICAgICAgZ3JvdXA6IGZ1bmN0aW9uKGdyb3VwTmFtZSkgeyByZXR1cm4gQ29uZGl0aW9uYWxzLmdyb3Vwc1tncm91cE5hbWVdOyB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBtYWtlIGFuIGVsZW1lbnRcbiAgICAgICAgICAgIGVsID0gcG9wTWVudS5idWlsZCh0YWdOYW1lLCBtZW51LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgLy8gaWYgaXQncyBhIHRleHRib3gsIGxpc3RlbiBmb3Iga2V5dXAgZXZlbnRzXG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PT0gJ3RleHQnICYmIHRoaXMuZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaGFuZGxlIG9uY2hhbmdlIGV2ZW50c1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IHRoaXMub25DaGFuZ2UgfHwgY2xlYW5VcEFuZE1vdmVPbi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlKTtcblxuICAgICAgICAgICAgRmlsdGVyTm9kZS5zZXRXYXJuaW5nQ2xhc3MoZWwpO1xuICAgICAgICAgICAgcmVzdWx0ID0gZWw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKGVsKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0pO1xuXG4vL2Z1bmN0aW9uIHZhbE9yRnVuYyh2Zikge1xuLy92YXIgcmVzdWx0ID0gKHR5cGVvZiB2ZilbMF0gPT09ICdmJyA/IHZmKCkgOiB2Zjtcbi8vICAgIHJldHVybiByZXN1bHQgfHwgcmVzdWx0ID09PSAwID8gcmVzdWx0IDogJyc7XG4vL31cblxuLyoqIGBjaGFuZ2VgIGV2ZW50IGhhbmRsZXIgZm9yIGFsbCBmb3JtIGNvbnRyb2xzLlxuICogUmVidWlsZHMgdGhlIG9wZXJhdG9yIGRyb3AtZG93biBhcyBuZWVkZWQuXG4gKiBSZW1vdmVzIGVycm9yIENTUyBjbGFzcyBmcm9tIGNvbnRyb2wuXG4gKiBBZGRzIHdhcm5pbmcgQ1NTIGNsYXNzIGZyb20gY29udHJvbCBpZiBibGFuazsgcmVtb3ZlcyBpZiBub3QgYmxhbmsuXG4gKiBBZGRzIHdhcm5pbmcgQ1NTIGNsYXNzIGZyb20gY29udHJvbCBpZiBibGFuazsgcmVtb3ZlcyBpZiBub3QgYmxhbmsuXG4gKiBNb3ZlcyBmb2N1cyB0byBuZXh0IG5vbi1ibGFuayBzaWJsaW5nIGNvbnRyb2wuXG4gKiBAdGhpcyBCb3VuZCB0byB0aGlzIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNsZWFuVXBBbmRNb3ZlT24oZXZ0KSB7XG4gICAgdmFyIGVsID0gZXZ0LnRhcmdldDtcblxuICAgIC8vIHJlbW92ZSBgZXJyb3JgIENTUyBjbGFzcywgd2hpY2ggbWF5IGhhdmUgYmVlbiBhZGRlZCBieSBgRmlsdGVyTGVhZi5wcm90b3R5cGUuaW52YWxpZGBcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmaWx0ZXItdHJlZS1lcnJvcicpO1xuXG4gICAgLy8gc2V0IG9yIHJlbW92ZSAnd2FybmluZycgQ1NTIGNsYXNzLCBhcyBwZXIgZWwudmFsdWVcbiAgICBGaWx0ZXJOb2RlLnNldFdhcm5pbmdDbGFzcyhlbCk7XG5cbiAgICBpZiAoZWwgPT09IHRoaXMudmlldy5jb2x1bW4pIHtcbiAgICAgICAgLy8gcmVidWlsZCBvcGVyYXRvciBsaXN0IGFjY29yZGluZyB0byBzZWxlY3RlZCBjb2x1bW4gbmFtZSBvciB0eXBlLCByZXN0b3Jpbmcgc2VsZWN0ZWQgaXRlbVxuICAgICAgICBtYWtlT3BNZW51LmNhbGwodGhpcywgZWwudmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChlbC52YWx1ZSkge1xuICAgICAgICAvLyBmaW5kIG5leHQgc2libGluZyBjb250cm9sLCBpZiBhbnlcbiAgICAgICAgaWYgKCFlbC5tdWx0aXBsZSkge1xuICAgICAgICAgICAgd2hpbGUgKChlbCA9IGVsLm5leHRFbGVtZW50U2libGluZykgJiYgKCEoJ25hbWUnIGluIGVsKSB8fCBlbC52YWx1ZS50cmltKCkgIT09ICcnKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY3VybHlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFuZCBjbGljayBpbiBpdCAob3BlbnMgc2VsZWN0IGxpc3QpXG4gICAgICAgIGlmIChlbCAmJiBlbC52YWx1ZS50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgICBlbC52YWx1ZSA9ICcnOyAvLyByaWQgb2YgYW55IHdoaXRlIHNwYWNlXG4gICAgICAgICAgICBGaWx0ZXJOb2RlLmNsaWNrSW4oZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9yd2FyZCB0aGUgZXZlbnQgdG8gdGhlIGFwcGxpY2F0aW9uJ3MgZXZlbnQgaGFuZGxlclxuICAgIGlmICh0aGlzLmV2ZW50SGFuZGxlcikge1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcihldnQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0T3BNZW51KGNvbHVtbk5hbWUpIHtcbiAgICB2YXIgY29sdW1uID0gdGhpcy5zY2hlbWEubG9va3VwKGNvbHVtbk5hbWUpIHx8IHt9O1xuICAgIHJldHVybiAoXG4gICAgICAgIGNvbHVtbi5vcE1lbnVcbiAgICAgICAgICAgIHx8XG4gICAgICAgIHRoaXMudHlwZU9wTWFwICYmIHRoaXMudHlwZU9wTWFwW2NvbHVtbi50eXBlIHx8IHRoaXMudHlwZV1cbiAgICAgICAgICAgIHx8XG4gICAgICAgIHRoaXMub3BNZW51XG4gICAgKTtcbn1cblxuZnVuY3Rpb24gbWFrZU9wTWVudShjb2x1bW5OYW1lKSB7XG4gICAgdmFyIG9wTWVudSA9IGdldE9wTWVudS5jYWxsKHRoaXMsIGNvbHVtbk5hbWUpO1xuXG4gICAgaWYgKG9wTWVudSAhPT0gdGhpcy5yZW5kZXJlZE9wTWVudSkge1xuICAgICAgICB2YXIgbmV3T3BEcm9wID0gdGhpcy5tYWtlRWxlbWVudChvcE1lbnUsICdvcGVyYXRvcicpO1xuXG4gICAgICAgIG5ld09wRHJvcC52YWx1ZSA9IHRoaXMudmlldy5vcGVyYXRvci52YWx1ZTtcbiAgICAgICAgdGhpcy5lbC5yZXBsYWNlQ2hpbGQobmV3T3BEcm9wLCB0aGlzLnZpZXcub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLnZpZXcub3BlcmF0b3IgPSBuZXdPcERyb3A7XG5cbiAgICAgICAgRmlsdGVyTm9kZS5zZXRXYXJuaW5nQ2xhc3MobmV3T3BEcm9wKTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVkT3BNZW51ID0gb3BNZW51O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2xpY2tJbihlbCkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2ZpbHRlci10cmVlLWVycm9yJyk7XG4gICAgICAgIEZpbHRlck5vZGUuY2xpY2tJbihlbCk7XG4gICAgfSwgMCk7XG59XG5cbmZ1bmN0aW9uIGNvbnRyb2xWYWx1ZShlbCkge1xuICAgIHZhciB2YWx1ZSwgaTtcblxuICAgIHN3aXRjaCAoZWwudHlwZSkge1xuICAgICAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgICAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT1cXCcnICsgZWwubmFtZSArICdcXCddOmVuYWJsZWQ6Y2hlY2tlZCcpO1xuICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFtdLCBpID0gMDsgaSA8IGVsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUucHVzaChlbFtpXS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzZWxlY3QtbXVsdGlwbGUnOlxuICAgICAgICAgICAgZWwgPSBlbC5vcHRpb25zO1xuICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFtdLCBpID0gMDsgaSA8IGVsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbC5kaXNhYmxlZCAmJiBlbC5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKGVsW2ldLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFsdWUgPSBlbC52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIE1lYW50IHRvIGJlIGNhbGxlZCBieSBGaWx0ZXJUcmVlLnByb3RvdHlwZS5zZXRTZW5zaXRpdml0eSBvbmx5XG5GaWx0ZXJMZWFmLnNldFRvU3RyaW5nID0gZnVuY3Rpb24oZm4pIHtcbiAgICB0b1N0cmluZyA9IGZuO1xuICAgIHJldHVybiBDb25kaXRpb25hbHMuc2V0VG9TdHJpbmcoZm4pO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlckxlYWY7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtbWUnKSwgQmFzZSA9IGV4dGVuZC5CYXNlOyBleHRlbmQuZGVidWcgPSB0cnVlO1xudmFyIHBvcE1lbnUgPSByZXF1aXJlKCdwb3AtbWVudScpO1xuXG52YXIgY3NzSW5qZWN0b3IgPSByZXF1aXJlKCcuL3N0eWxlc2hlZXQnKTtcbnZhciBUZW1wbGF0ZXMgPSByZXF1aXJlKCcuL1RlbXBsYXRlcycpO1xudmFyIENvbmRpdGlvbmFscyA9IHJlcXVpcmUoJy4vQ29uZGl0aW9uYWxzJyk7XG52YXIgUGFyc2VyU1FMID0gcmVxdWlyZSgnLi9wYXJzZXItU1FMJyk7XG5cblxudmFyIENISUxEUkVOX1RBRyA9ICdPTCcsXG4gICAgQ0hJTERfVEFHID0gJ0xJJztcblxuLy8gSlNPTi1kZXRlY3RvcjogYmVnaW5zIF9hbmRfIGVuZHMgd2l0aCBlaXRoZXIgWyBhbmQgXSBfb3JfIHsgYW5kIH1cbnZhciByZUpTT04gPSAvXlxccyooKFxcW1teXSpcXF0pfChcXHtbXl0qXFx9KSlcXHMqJC87XG5cbmZ1bmN0aW9uIEZpbHRlclRyZWVFcnJvcihtZXNzYWdlLCBub2RlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xufVxuRmlsdGVyVHJlZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbkZpbHRlclRyZWVFcnJvci5wcm90b3R5cGUubmFtZSA9ICdGaWx0ZXJUcmVlRXJyb3InO1xuXG4vKiogQHR5cGVkZWYge29iamVjdH0gRmlsdGVyVHJlZVNldFN0YXRlT3B0aW9uc09iamVjdFxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3N5bnRheD0nYXV0byddIC0gU3BlY2lmeSBwYXJzZXIgdG8gdXNlIG9uIGBzdGF0ZWAuIE9uZSBvZjpcbiAqICogYCdhdXRvJ2AgLSBBdXRvLWRldGVjdDsgc2VlIHtAbGluayBGaWx0ZXJOb2RlI3BhcnNlU3RhdGVTdHJpbmd9IGZvciBhbGdvcml0aG0uXG4gKiAqIGAnb2JqZWN0J2AgLSBBIHJhdyBzdGF0ZSBvYmplY3Qgc3VjaCBhcyB0aGF0IHByb2R1Y2VkIGJ5IHRoZSBbZ2V0U3RhdGUoKV17QGxpbmsgRmlsdGVyVHJlZSNnZXRTdGF0ZX0gbWV0aG9kLlxuICogKiBgJ0pTT04nYCAtIEEgSlNPTiBzdHJpbmcgdmVyc2lvbiBvZiBhIHN0YXRlIG9iamVjdCBzdWNoIGFzIHRoYXQgcHJvZHVjZWQgYnkgdGhlIFtnZXRTdGF0ZSgpXXtAbGluayBGaWx0ZXJUcmVlI2dldFN0YXRlfSBtZXRob2QuXG4gKiAqIGAnU1FMJ2AgLSBBIFNRTCBbc2VhcmNoIGNvbmRpdGlvbiBleHByZXNzaW9uXXtAbGluayBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zMTczNTQ1LmFzcHh9IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFtjb250ZXh0XSBJZiBkZWZpbmVkLCB0aGUgcHJvdmlkZWQgaW5wdXQgc3RyaW5nIGlzIHVzZWQgYXMgYSBzZWxlY3RvciB0byBhbiBgSFRNTEVsZW1lbnRgIGNvbnRhaW5lZCBpbiBgY29udGV4dGAuIFRoZSBgdmFsdWVgIHByb3BlcnR5IG9mIHRoaXMgZWxlbWVudCBpcyBmZXRjaGVkIGZyb20gdGhlIERPTSBhbmQgaXMgdXNlZCBhcyB0aGUgaW5wdXQgc3RhdGUgc3RyaW5nOyBwcm9jZWVkIGFzIGFib3ZlLlxuICovXG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSBGaWx0ZXJUcmVlT3B0aW9uc09iamVjdFxuICpcbiAqIEBwcm9wZXJ0eSB7bWVudUl0ZW1bXX0gW3NjaGVtYV0gLSBBIGRlZmF1bHQgbGlzdCBvZiBjb2x1bW4gbmFtZXMgZm9yIGZpZWxkIGRyb3AtZG93bnMgb2YgYWxsIGRlc2NlbmRhbnQgdGVybWluYWwgbm9kZXMuIE92ZXJyaWRlcyBgb3B0aW9ucy5zdGF0ZS5zY2hlbWFgIChzZWUpLiBNYXkgYmUgZGVmaW5lZCBmb3IgYW55IG5vZGUgYW5kIHBlcnRhaW5zIHRvIGFsbCBkZXNjZW5kYW50cyBvZiB0aGF0IG5vZGUgKGluY2x1ZGluZyB0ZXJtaW5hbCBub2RlcykuIElmIG9taXR0ZWQgKGFuZCBubyBgb3duU2NoZW1hYCksIHdpbGwgdXNlIHRoZSBuZWFyZXN0IGFuY2VzdG9yIGBzY2hlbWFgIGRlZmluaXRpb24uIEhvd2V2ZXIsIGRlc2NlbmRhbnRzIHdpdGggdGhlaXIgb3duIGRlZmluaXRpb24gb2YgYHR5cGVzYCB3aWxsIG92ZXJyaWRlIGFueSBhbmNlc3RvciBkZWZpbml0aW9uLlxuICpcbiAqID4gVHlwaWNhbGx5IG9ubHkgdXNlZCBieSB0aGUgY2FsbGVyIGZvciB0aGUgdG9wLWxldmVsIChyb290KSB0cmVlLlxuICpcbiAqIEBwcm9wZXJ0eSB7bWVudUl0ZW1bXX0gW293blNjaGVtYV0gLSBBIGRlZmF1bHQgbGlzdCBvZiBjb2x1bW4gbmFtZXMgZm9yIGZpZWxkIGRyb3AtZG93bnMgb2YgaW1tZWRpYXRlIGRlc2NlbmRhbnQgdGVybWluYWwgbm9kZXMgX29ubHlfLiBPdmVycmlkZXMgYG9wdGlvbnMuc3RhdGUub3duU2NoZW1hYCAoc2VlKS5cbiAqXG4gKiBBbHRob3VnaCBib3RoIGBvcHRpb25zLnNjaGVtYWAgYW5kIGBvcHRpb25zLm93blNjaGVtYWAgYXJlIG5vdGF0ZWQgYXMgb3B0aW9uYWwgaGVyZWluLCBieSB0aGUgdGltZSBhIHRlcm1pbmFsIG5vZGUgdHJpZXMgdG8gcmVuZGVyIGEgc2NoZW1hIGRyb3AtZG93biwgYSBgc2NoZW1hYCBsaXN0IHNob3VsZCBiZSBkZWZpbmVkIHRocm91Z2ggKGluIG9yZGVyIG9mIHByaW9yaXR5KTpcbiAqXG4gKiAqIFRlcm1pbmFsIG5vZGUncyBvd24gYG9wdGlvbnMuc2NoZW1hYCAob3IgYG9wdGlvbnMuc3RhdGUuc2NoZW1hYCkgZGVmaW5pdGlvbi5cbiAqICogVGVybWluYWwgbm9kZSdzIHBhcmVudCBub2RlJ3MgYG9wdGlvbi5vd25TY2hlbWFgIChvciBgb3B0aW9uLnN0YXRlLm5vZGVzRmllbGRzYCkgZGVmaW5pdGlvbi5cbiAqICogVGVybWluYWwgbm9kZSdzIHBhcmVudCAob3IgYW55IGFuY2VzdG9yKSBub2RlJ3MgYG9wdGlvbnMuc2NoZW1hYCAob3IgYG9wdGlvbnMuc3RhdGUuc2NoZW1hYCkgZGVmaW5pdGlvbi5cbiAqXG4gKiBAcHJvcGVydHkge0ZpbHRlclRyZWVTdGF0ZU9iamVjdH0gW3N0YXRlXSAtIEEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBkZXNjcmliZXMgYSB0cmVlLCBzdWJ0cmVlLCBvciBsZWFmICh0ZXJtaW5hbCBub2RlKS4gSWYgdW5kZWZpbmVkLCBsb2FkcyBhbiBlbXB0eSBmaWx0ZXIsIHdoaWNoIGlzIGEgYEZpbHRlclRyZWVgIG5vZGUgY29uc2lzdGluZyB0aGUgZGVmYXVsdCBgb3BlcmF0b3JgIHZhbHVlIChgJ29wLWFuZCdgKS5cbiAqXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbZWRpdG9yPSdEZWZhdWx0J10gLSBUaGUgbmFtZSBvZiB0aGUgY29uZGl0aW9uYWwgZXhwcmVzc2lvbidzIFVJIFwiZWRpdG9yLlwiIFRoaXMgbmFtZSBtdXN0IGJlIHJlZ2lzdGVyZWQgaW4gdGhlIHBhcmVudCBub2RlJ3Mge0BsaW5rIEZpbHRlclRyZWUjZWRpdG9yc3xlZGl0b3JzfSBoYXNoLCB3aGVyZSBpdCBtYXBzIHRvIGEgbGVhZiBjb25zdHJ1Y3RvciAoYEZpbHRlckxlYWZgIG9yIGEgZGVzY2VuZGFudCB0aGVyZW9mKS4gKFVzZSB7QGxpbmsgRmlsdGVyVHJlZSNhZGRFZGl0b3J9IHRvIHJlZ2lzdGVyIG5ldyBlZGl0b3JzLilcbiAqXG4gKiBAcHJvcGVydHkge0ZpbHRlclRyZWV9IFtwYXJlbnRdIC0gVXNlZCBpbnRlcm5hbGx5IHRvIGluc2VydCBlbGVtZW50IHdoZW4gY3JlYXRpbmcgbmVzdGVkIHN1YnRyZWVzLiBUaGUgb25seSB0aW1lIGl0IG1heSBiZSAoYW5kIG11c3QgYmUpIG9taXR0ZWQgaXMgd2hlbiBjcmVhdGluZyB0aGUgcm9vdCBub2RlLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBbY3NzU3R5bGVzaGVldFJlZmVyZW5jZUVsZW1lbnRdIC0gcGFzc2VkIHRvIGNzc0luc2VydFxuICovXG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fHN0cmluZ30gRmlsdGVyVHJlZVN0YXRlT2JqZWN0XG4gKlxuICogQHN1bW1hcnkgU3RhdGUgd2l0aCB3aGljaCB0byBjcmVhdGUgYSBuZXcgbm9kZSBvciByZXBsYWNlIGFuIGV4aXN0aW5nIG5vZGUuXG4gKlxuICogQGRlc2MgQSBzdHJpbmcgb3IgcGxhaW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgZmlsdGVyLXRyZWUgbm9kZS4gSWYgYSBzdHJpbmcsIGl0IGlzIHBhcnNlZCBpbnRvIGFuIG9iamVjdCBieSB7QGxpbmsgRmlsdGVyTm9kZX5wYXJzZVN0YXRlU3RyaW5nfS4gKFNlZSwgZm9yIGF2YWlsYWJsZSBvdmVybG9hZHMuKVxuICpcbiAqIFRoZSByZXN1bHRpbmcgb2JqZWN0IG1heSBiZSBhIGZsYXQgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgdGVybWluYWwgbm9kZSBvciBhIGNoaWxkbGVzcyByb290IG9yIGJyYW5jaCBub2RlOyBvciBtYXkgYmUgYSBoaWVyYXJjaGljYWwgb2JqZWN0IHRvIGRlZmluZSBhbiBlbnRpcmUgdHJlZSBvciBzdWJ0cmVlLlxuICpcbiAqIEluIGFueSBjYXNlLCB0aGUgcmVzdWx0aW5nIG9iamVjdCBtYXkgaGF2ZSBhbnkgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqIEBwcm9wZXJ0eSB7bWVudUl0ZW1bXX0gW3NjaGVtYV0gLSBTZWUgYHNjaGVtYWAgcHJvcGVydHkgb2Yge0BsaW5rIEZpbHRlclRyZWVPcHRpb25zT2JqZWN0fS5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2VkaXRvcj0nRGVmYXVsdCddIC0gU2VlIGBlZGl0b3JgIHByb3BlcnR5IG9mIHtAbGluayBGaWx0ZXJUcmVlT3B0aW9uc09iamVjdH0uXG4gKlxuICogQHByb3BlcnR5IG1pc2MgLSBPdGhlciBtaXNjZWxsYW5lb3VzIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWQgZGlyZWN0bHkgdG8gdGhlIG5ldyBgRml0bGVyTm9kZWAgb2JqZWN0LiAoVGhlIG5hbWUgXCJtaXNjXCIgaGVyZSBpcyBqdXN0IGEgc3RhbmQtaW47IHRoZXJlIGlzIG5vIHNwZWNpZmljIHByb3BlcnR5IGNhbGxlZCBcIm1pc2NcIi4pXG4gKlxuICogKiBNYXkgZGVzY3JpYmUgYSBub24tdGVybWluYWwgbm9kZSB3aXRoIHByb3BlcnRpZXM6XG4gKiAgICogYHNjaGVtYWAgLSBPdmVycmlkZGVuIG9uIGluc3RhbnRpYXRpb24gYnkgYG9wdGlvbnMuc2NoZW1hYC4gSWYgYm90aCB1bnNwZWNpZmllZCwgdXNlcyBwYXJlbnQncyBkZWZpbml0aW9uLlxuICogICAqIGBvcGVyYXRvcmAgLSBPbmUgb2Yge0BsaW5rIHRyZWVPcGVyYXRvcnN9LlxuICogICAqIGBjaGlsZHJlbmAgLSAgQXJyYXkgY29udGFpbmluZyBhZGRpdGlvbmFsIHRlcm1pbmFsIGFuZCBub24tdGVybWluYWwgbm9kZXMuXG4gKlxuICogVGhlIGNvbnN0cnVjdG9yIGF1dG8tZGV0ZWN0cyBgc3RhdGVgJ3MgdHlwZTpcbiAqICAqIEpTT04gc3RyaW5nIHRvIGJlIHBhcnNlZCBieSBgSlNPTi5wYXJzZSgpYCBpbnRvIGEgcGxhaW4gb2JqZWN0XG4gKiAgKiBTUUwgV0hFUkUgY2xhdXNlIHN0cmluZyB0byBiZSBwYXJzZWQgaW50byBhIHBsYWluIG9iamVjdFxuICogICogQ1NTIHNlbGVjdG9yIG9mIGFuIEVsZW1lbnQgd2hvc2UgYHZhbHVlYCBjb250YWlucyBvbmUgb2YgdGhlIGFib3ZlXG4gKiAgKiBwbGFpbiBvYmplY3RcbiAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBzdW1tYXJ5IEEgbm9kZSBpbiBhIGZpbHRlciB0cmVlLlxuICpcbiAqIEBkZXNjcmlwdGlvbiBBIGZpbHRlciB0cmVlIHJlcHJlc2VudHMgYSBfY29tcGxleCBjb25kaXRpb25hbCBleHByZXNzaW9uXyBhbmQgY29uc2lzdHMgb2YgYSBzaW5nbGUgaW5zdGFuY2Ugb2YgYSB7QGxpbmsgRmlsdGVyVHJlZX0gb2JqZWN0IGFzIHRoZSBfcm9vdF8gb2YgYW4gX25fLWFyeSB0cmVlLlxuICpcbiAqIEZpbHRlciB0cmVlcyBhcmUgY29tcHJpc2VkIG9mIGluc3RhbmNlcyBvZiBgRmlsdGVyTm9kZWAgb2JqZWN0cy4gSG93ZXZlciwgdGhlIGBGaWx0ZXJOb2RlYCBjb25zdHJ1Y3RvciBpcyBhbiBcImFic3RyYWN0IGNsYXNzXCI7IGZpbHRlciBub2RlIG9iamVjdHMgYXJlIG5ldmVyIGluc3RhbnRpYXRlZCBkaXJlY3RseSBmcm9tIHRoaXMgY29uc3RydWN0b3IuIEEgZmlsdGVyIHRyZWUgaXMgYWN0dWFsbHkgY29tcHJpc2VkIG9mIGluc3RhbmNlcyBvZiB0d28gXCJzdWJjbGFzc2VzXCIgb2YgYEZpbHRlck5vZGVgIG9iamVjdHM6XG4gKiAqIHtAbGluayBGaWx0ZXJUcmVlfSAob3Igc3ViY2xhc3MgdGhlcmVvZikgb2JqZWN0cywgaW5zdGFuY2VzIG9mIHdoaWNoIHJlcHJlc2VudCB0aGUgcm9vdCBub2RlIGFuZCBhbGwgdGhlIGJyYW5jaCBub2RlczpcbiAqICAgKiBUaGVyZSBpcyBhbHdheXMgZXhhY3RseSBvbmUgcm9vdCBub2RlLCBjb250YWluaW5nIHRoZSB3aG9sZSBmaWx0ZXIgdHJlZSwgd2hpY2ggcmVwcmVzZW50cyB0aGUgZmlsdGVyIGV4cHJlc3Npb24gaW4gaXRzIGVudGlyZXR5LiBUaGUgcm9vdCBub2RlIGlzIGRpc3Rpbmd1aXNoZWQgYnkgaGF2aW5nIG5vIHBhcmVudCBub2RlLlxuICogICAqIFRoZXJlIGFyZSB6ZXJvIG9yIG1vcmUgYnJhbmNoIG5vZGVzLCBvciBzdWJ0cmVlcywgd2hpY2ggYXJlIGNoaWxkIG5vZGVzIG9mIHRoZSByb290IG9yIG90aGVyIGJyYW5jaGVzIGhpZ2hlciB1cCBpbiB0aGUgdHJlZSwgcmVwcmVzZW50aW5nIHN1YmV4cHJlc3Npb25zIHdpdGhpbiB0aGUgbGFyZ2VyIGZpbHRlciBleHByZXNzaW9uLiBFYWNoIGJyYW5jaCBub2RlIGhhcyBleGFjdGx5IG9uZSBwYXJlbnQgbm9kZS5cbiAqICAgKiBUaGVzZSBub2RlcyBwb2ludCB0byB6ZXJvIG9yIG1vcmUgY2hpbGQgbm9kZXMgd2hpY2ggYXJlIGVpdGhlciBuZXN0ZWQgc3VidHJlZXMsIG9yOlxuICogKiB7QGxpbmsgRmlsdGVyTGVhZn0gKG9yIHN1YmNsYXNzIHRoZXJlb2YpIG9iamVjdHMsIGVhY2ggaW5zdGFuY2Ugb2Ygd2hpY2ggcmVwcmVzZW50cyBhIHNpbmdsZSBzaW1wbGUgY29uZGl0aW9uYWwgZXhwcmVzc2lvbi4gVGhlc2UgYXJlIHRlcm1pbmFsIG5vZGVzLCBoYXZpbmcgZXhhY3RseSBvbmUgcGFyZW50IG5vZGUsIGFuZCBubyBjaGlsZCBub2Rlcy5cbiAqXG4gKiBUaGUgcHJvZ3JhbW1lciBtYXkgZXh0ZW5kIHRoZSBzZW1hbnRpY3Mgb2YgZmlsdGVyIHRyZWVzIGJ5IGV4dGVuZGluZyB0aGUgYWJvdmUgb2JqZWN0cy5cbiAqXG4gKiBAcHJvcGVydHkge0ZpbHRlck5vZGV9IFtwYXJlbnRdIC0gVW5kZWZpbmVkIG1lYW5zIHRoaXMgaXMgdGhlIHJvb3Qgbm9kZS5cbiAqXG4gKiBAcHJvcGVydHkge0ZpbHRlck5vZGV9IHJvb3QgLSBDb252ZW5pZW5jZSByZWZlcmVuY2UgdG8gdGhlIHJvb3Qgbm9kZS5cbiAqXG4gKiBAcHJvcGVydHkge21lbnVJdGVtW119IHNjaGVtYSAtIENvbHVtbiBzY2hlbWEgdXNlZCBieSBkZXNjZW5kYW50IGxlYWYgbm9kZXMgKGluY2x1ZGluZyB0aGlzIG5vZGUgaWYgaXQgaXMgYSBsZWFmIG5vZGUpIHRvIHJlbmRlciBhIGNvbHVtbiBjaG9pY2UgZHJvcC1kb3duLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZWRpdG9yXSAtIE5hbWUgb2YgZmlsdGVyIGVkaXRvciB1c2VkIGJ5IGRlc2NlbmRhbnQgbGVhZiBub2RlcyAoaW5jbHVkaW5nIHRoaXMgbm9kZSBpZiBpdCBpcyBhIGxlYWYgbm9kZSkuXG4gKlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2V2ZW50SGFuZGxlcl0gLSBFdmVudCBoYW5kbGVyIGZvciBVSSBldmVudHMuIFNlZSAqRXZlbnRzKiBpbiB0aGUge0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL2luZGV4Lmh0bWx8cmVhZG1lfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcHJvcGVydHkge21lbnVJdGVtW119IFt0cmVlT3BNZW51PUNvbmRpdGlvbmFscy5kZWZhdWx0T3BNZW51XSAtIERlZmF1bHQgb3BlcmF0b3IgbWVudSBmb3IgYWxsIGRlc2NlbmRhbnQgbGVhZiBub2Rlcy4gT25seSB1c2VkIGlmIHRoZSBsZWFmIG5vZGUgaGFzIG5vIGRlZmluZWQgYG9wTWVudWAgcHJvcGVydHkgX2FuZF8gdGhlcmUgaXMgbm8gbWVudSBkZWZpbmVkIGluIGB0eXBlT3BNZW51c2Aga2V5ZWQgdG8gdGhlIGNvbHVtbidzIGB0eXBlYC5cbiAqXG4gKiBAcHJvcGVydHkge29iamVjdH0gW3R5cGVPcE1hcF0gLSBBIGhhc2ggb2YgdHlwZSBuYW1lcy4gRWFjaCBtZW1iZXIgdGh1cyBkZWZpbmVkIGNvbnRhaW5zIGEgc3BlY2lmaWMgb3BlcmF0b3IgbWVudSBmb3IgYWxsIGRlc2NlbmRhbnQgbGVhZiBub2RlcyB0aGF0OlxuICogMS4gZG8gbm90IGhhdmUgdGhlaXIgb3duIG9wZXJhdG9yIG1lbnUgKGBvcE1lbnVgIHByb3BlcnR5KSBvZiB0aGVpciBvd247IGFuZFxuICogMi4gd2hvc2UgY29sdW1ucyByZXNvbHZlIHRvIHRoYXQgdHlwZS5cbiAqXG4gKiBUaGUgdHlwZSBpcyBkZXRlcm1pbmVkIGJ5IChpbiBwcmlvcml0eSBvcmRlcik6XG4gKiAxLiB0aGUgYHR5cGVgIHByb3BlcnR5IG9mIHRoZSB7QGxpbmsgRmlsdGVyTGVhZn07IG9yXG4gKiAyLiB0aGUgYHR5cGVgIHByb3BlcnR5IG9mIHRoZSBlbGVtZW50IGluIHRoZSBuZWFyZXN0IG5vZGUgKGluY2x1ZGluZyB0aGUgbGVhZiBub2RlIGl0c2VsZikgdGhhdCBoYXMgYSBkZWZpbmVkIGBvd25TY2hlbWFgIG9yIGBzY2hlbWFgIGFycmF5IHByb3BlcnR5IHdpdGggYW4gZWxlbWVudCBoYXZpbmcgYSBtYXRjaGluZyBjb2x1bW4gbmFtZS5cbiAqXG4gKiBAcHJvcGVydHkge3NxbElkUXRzT2JqZWN0fSBbc3FsSWRRdHM9e2JlZzonXCInLGVuZDonXCInfV0gLSBRdW90ZSBjaGFyYWN0ZXJzIGZvciBTUUwgaWRlbnRpZmllcnMuIFVzZWQgZm9yIGJvdGggcGFyc2luZyBhbmQgZ2VuZXJhdGluZyBTUUwuIFNob3VsZCBiZSBwbGFjZWQgb24gdGhlIHJvb3Qgbm9kZS5cbiAqXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBlbCAtIFRoZSBET00gZWxlbWVudCBjcmVhdGVkIGJ5IHRoZSBgcmVuZGVyYCBtZXRob2QgdG8gcmVwcmVzZW50IHRoaXMgbm9kZS4gQ29udGFpbnMgdGhlIGBlbGBzIGZvciBhbGwgY2hpbGQgbm9kZXMgKHdoaWNoIGFyZSB0aGVtc2VsdmVzIHBvaW50ZWQgdG8gYnkgdGhvc2Ugbm9kZXMpLiBUaGlzIGlzIGFsd2F5cyBnZW5lcmF0ZWQgYnV0IGlzIG9ubHkgaW4gdGhlIHBhZ2UgRE9NIGlmIHlvdSBwdXQgaXQgdGhlcmUuXG4gKi9cblxudmFyIEZpbHRlck5vZGUgPSBCYXNlLmV4dGVuZCgnRmlsdGVyTm9kZScsIHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBub2RlIG9yIHN1YnRyZWUuXG4gICAgICogQGRlc2MgVHlwaWNhbGx5IHVzZWQgYnkgdGhlIGFwcGxpY2F0aW9uIGxheWVyIHRvIGNyZWF0ZSB0aGUgZW50aXJlIGZpbHRlciB0cmVlOyBhbmQgaW50ZXJuYWxseSwgcmVjdXJzaXZlbHksIHRvIGNyZWF0ZSBlYWNoIG5vZGUgaW5jbHVkaW5nIGJvdGggc3VidHJlZXMgYW5kIGxlYXZlcy5cbiAgICAgKlxuICAgICAqICoqTm9kZSBwcm9wZXJ0aWVzIGFuZCBvcHRpb25zOioqIE5vZGVzIGFyZSBpbnN0YW50aWF0ZWQgd2l0aDpcbiAgICAgKiAxLiBDZXJ0YWluICoqcmVxdWlyZWQgcHJvcGVydGllcyoqIHdoaWNoIGRpZmZlciBmb3Igc3VidHJlZXMgYW5kIGxlYXZlcy5cbiAgICAgKiAyLiBBcmJpdHJhcnkgKipub24tc3RhbmRhcmQgb3B0aW9uIHByb3BlcnRpZXMqKiBhcmUgZGVmaW5lZCBvbiB0aGUgYG9wdGlvbnNgIG9iamVjdCAoc28gbG9uZyBhcyB0aGVpciBuYW1lcyBkbyBub3QgY29uZmxpY3Qgd2l0aCBhbnkgc3RhbmRhcmQgb3B0aW9ucykgYW5kIG5ldmVyIHBlcnNpc3QuXG4gICAgICogMy4gQ2VydGFpbiAqKnN0YW5kYXJkIG9wdGlvbnMgcHJvcGVydGllcyoqIGFzIGRlZmluZWQgaW4gdGhlIHtAbGluayBGaWx0ZXJOb2Rlfm9wdGlvbnNTY2hlbWF8b3B0aW9uc1NjaGVtYX0gaGFzaCwgY29tZSBmcm9tIHZhcmlvdXMgc291cmNlcywgYXMgcHJpb3JpdGl6ZWQgYXMgZm9sbG93czpcbiAgICAgKiAgICAxLiBgb3B0aW9uc2Agb2JqZWN0OyBkb2VzIG5vdCBwZXJzaXN0XG4gICAgICogICAgMi4gYHN0YXRlYDsgb2JqZWN0OyBwZXJzaXN0c1xuICAgICAqICAgIDMuIGBwYXJlbnRgIG9iamVjdDsgcGVyc2lzdHNcbiAgICAgKiAgICA0LiBgZGVmYXVsdGAgb2JqZWN0OyBkb2VzIG5vdCBwZXJzaXN0XG4gICAgICpcbiAgICAgKiBOb3RlczpcbiAgICAgKiAxLiBcIlBlcnNpc3RzXCIgbWVhbnMgb3V0cHV0IGJ5IHtAbGluayBGaWx0ZXJUcmVlI2dldFN0YXRlfGdldFN0YXRlKCl9LlxuICAgICAqIDIuIFRoZSBgcGFyZW50YCBvYmplY3QgaXMgZ2VuZXJhdGVkIGludGVybmFsbHkgZm9yIHN1YnRyZWVzLiBJdCBhbGxvd3Mgc3RhbmRhcmQgb3B0aW9ucyB0byBpbmhlcml0IGZyb20gdGhlIHBhcmVudCBub2RlLlxuICAgICAqIDMuIFRoZSBgZGVmYXVsdGAgb2JqZWN0IGNvbWVzIGZyb20gdGhlIGBkZWZhdWx0YCBwcm9wZXJ0eSwgaWYgYW55LCBvZiB0aGUge0BsaW5rIEZpbHRlck5vZGV+b3B0aW9uc1NjaGVtYXxzY2hlbWEgb2JqZWN0fSBmb3IgdGhlIHN0YW5kYXJkIG9wdGlvbiBpbiBxdWVzdGlvbi4gTm90ZSB0aGF0IG9uY2UgZGVmaW5lZCwgc3VidHJlZXMgd2lsbCB0aGVuIGluaGVyaXQgdGhpcyB2YWx1ZS5cbiAgICAgKiA0LiBJZiBub3QgZGVmaW5lZCBieSBhbnkgb2YgdGhlIGFib3ZlLCB0aGUgc3RhbmRhcmQgb3B0aW9uIHJlbWFpbnMgdW5kZWZpbmVkIG9uIHRoZSBub2RlLlxuICAgICAqXG4gICAgICogKipRdWVyeSBCdWlsZGVyIFVJIHN1cHBvcnQ6KiogSWYgeW91ciBhcHAgd2FudHMgdG8gbWFrZSB1c2Ugb2YgdGhlIGdlbmVyYXRlZCBVSSwgeW91IGFyZSByZXNwb25zaWJsZSBmb3IgaW5zZXJ0aW5nIHRoZSB0b3AtbGV2ZWwgYC5lbGAgaW50byB0aGUgRE9NLiAoT3RoZXJ3aXNlIGp1c3QgaWdub3JlIGl0LilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZU9wdGlvbnNPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBub2RlIHN0YXRlOyBvciBhbiBvcHRpb25zIG9iamVjdCBwb3NzaWJseSBjb250YWluaW5nIGBzdGF0ZWAgYW1vbmcgb3RoZXIgb3B0aW9ucy4gQWx0aG91Z2ggeW91IGNhbiBpbnN0YW50aWF0ZSBhIGZpbHRlciB3aXRob3V0IGFueSBvcHRpb25zLCB0aGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZnVsLiBTZWUgKkluc3RhbnRpYXRpbmcgYSBmaWx0ZXIqIGluIHRoZSB7QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvaW5kZXguaHRtbHxyZWFkbWV9IGZvciBhIHByYWN0aWNhbCBkaXNjdXNzaW9uIG9mIG1pbmltdW0gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqICogQG1lbWJlck9mIEZpbHRlck5vZGUucHJvdG90eXBlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCBvcHRpb25zLnBhcmVudCxcbiAgICAgICAgICAgIHJvb3QgPSBwYXJlbnQgJiYgcGFyZW50LnJvb3Q7XG5cbiAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICByb290ID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5zdHlsZXNoZWV0ID0gdGhpcy5zdHlsZXNoZWV0IHx8XG4gICAgICAgICAgICAgICAgY3NzSW5qZWN0b3Iob3B0aW9ucy5jc3NTdHlsZXNoZWV0UmVmZXJlbmNlRWxlbWVudCk7XG5cbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uYWxzID0gbmV3IENvbmRpdGlvbmFscyhvcHRpb25zKTsgLy8gLnNxbElkUXRzXG5cbiAgICAgICAgICAgIHRoaXMuUGFyc2VyU1FMID0gbmV3IFBhcnNlclNRTChvcHRpb25zKTsgLy8gLnNjaGVtYSwgLmNhc2VTZW5zaXRpdmVDb2x1bW5OYW1lcywgLnJlc29sdmVBbGlhc2VzXG5cbiAgICAgICAgICAgIHZhciBrZXlzID0gWyduYW1lJ107XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZXNvbHZlQWxpYXNlcykge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaCgnYWxpYXMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5maW5kT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiBvcHRpb25zLmNhc2VTZW5zaXRpdmVDb2x1bW5OYW1lcyxcbiAgICAgICAgICAgICAgICBrZXlzOiBrZXlzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcblxuICAgICAgICB0aGlzLmRvbnRQZXJzaXN0ID0ge307IC8vIGhhc2ggb2YgdHJ1dGh5IHZhbHVlc1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUob3B0aW9ucy5zdGF0ZSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKiBJbnNlcnQgZWFjaCBzdWJ0cmVlIGludG8gaXRzIHBhcmVudCBub2RlIGFsb25nIHdpdGggYSBcImRlbGV0ZVwiIGJ1dHRvbi5cbiAgICAgKiA+IFRoZSByb290IHRyZWUgKHdoaWNoIGhhcyBubyBwYXJlbnQpIGlzIGluc2VydGVkIGludG8gdGhlIERPTSBieSB0aGUgaW5zdGFudGlhdGluZyBjb2RlICh3aXRob3V0IGEgZGVsZXRlIGJ1dHRvbikuXG4gICAgICogQG1lbWJlck9mIEZpbHRlck5vZGUucHJvdG90eXBlXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgbmV3TGlzdEl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KENISUxEX1RBRyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm5vdGVzRWwpIHtcbiAgICAgICAgICAgICAgICBuZXdMaXN0SXRlbS5hcHBlbmRDaGlsZCh0aGlzLm5vdGVzRWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMua2VlcCkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMudGVtcGxhdGVzLmdldCgncmVtb3ZlQnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnJlbW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBuZXdMaXN0SXRlbS5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ld0xpc3RJdGVtLmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5lbC5xdWVyeVNlbGVjdG9yKENISUxEUkVOX1RBRykuYXBwZW5kQ2hpbGQobmV3TGlzdEl0ZW0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9IHN0YXRlXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyTm9kZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRTdGF0ZTogZnVuY3Rpb24oc3RhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9sZEVsID0gdGhpcy5lbDtcblxuICAgICAgICBzdGF0ZSA9IHRoaXMucGFyc2VTdGF0ZVN0cmluZyhzdGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5taXhJblN0YW5kYXJkT3B0aW9ucyhzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubWl4SW5Ob25zdGFuZGFyZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY3JlYXRlVmlldyhzdGF0ZSk7XG4gICAgICAgIHRoaXMubG9hZFN0YXRlKHN0YXRlKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcblxuICAgICAgICBpZiAob2xkRWwpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbCA9IHRoaXMuZWw7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgJiYgb2xkRWwucGFyZW50RWxlbWVudC50YWdOYW1lID09PSAnTEknKSB7XG4gICAgICAgICAgICAgICAgb2xkRWwgPSBvbGRFbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIG5ld0VsID0gbmV3RWwucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9sZEVsLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0VsLCBvbGRFbCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ29udmVydCBhIHN0cmluZyB0byBhIHN0YXRlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBkZXNjIFRoZXkgc3RyaW5nJ3Mgc3ludGF4IGlzIGluZmVycmVkIGFzIGZvbGxvd3M6XG4gICAgICogMS4gSWYgc3RhdGUgaXMgdW5kZWZpbmVkIG9yIGFscmVhZHkgYW4gb2JqZWN0LCByZXR1cm4gYXMgaXMuXG4gICAgICogMi4gSWYgYG9wdGlvbnMuY29udGV4dGAgaXMgZGVmaW5lZCwgYHN0YXRlYCBpcyBhc3N1bWVkIHRvIGJlIGEgQ1NTIHNlbGVjdG9yIHN0cmluZyAoYXV0by1kZXRlY3RlZCkgcG9pbnRpbmcgdG8gYW4gSFRNTCBmb3JtIGNvbnRyb2wgd2l0aCBhIGB2YWx1ZWAgcHJvcGVydHksIHN1Y2ggYXMgYSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxJbnB1dEVsZW1lbnQgSFRNTElucHV0RWxlbWVudH0gb3IgYSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxUZXh0QXJlYUVsZW1lbnQgSFRNTFRleHRBcmVhRWxlbWVudH0uIFRoZSBlbGVtZW50IGlzIHNlbGVjdGVkIGFuZCBpZiBmb3VuZCwgaXRzIHZhbHVlIGlzIGZldGNoZWQgZnJvbSB0aGUgRE9NIGFuZCBhc3NpZ25lZCB0byBgc3RhdGVgLlxuICAgICAqIDMuIElmIGBvcHRpb25zLnN5bnRheGAgaXMgYCdhdXRvJ2AsIEpTT04gc3ludGF4IGlzIGRldGVjdGVkIGlmIGBzdGF0ZWAgYmVnaW5zIF9hbmRfIGVuZHMgd2l0aCBlaXRoZXIgYFtgIGFuZCBgXWAgX29yXyBge2AgYW5kIGB9YCAoaWdub3JpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGUgc3BhY2UpLlxuICAgICAqIDQuIElmIEpTT04gc3ludGF4LCBwYXJzZSB0aGUgc3RyaW5nIGludG8gYW4gYWN0dWFsIGBGaWx0ZXJUcmVlU3RhdGVPYmplY3RgIHVzaW5nIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9KU09OL3BhcnNlfEpTT04ucGFyc2V9IGFuZCB0aHJvdyBhbiBlcnJvciBpZiB1bnBhcnNhYmxlLlxuICAgICAqIDUuIElmIG5vdCBKU09OLCBwYXJzZSB0aGUgc3RyaW5nIGFzIFNRTCBpbnRvIGFuIGFjdHVhbCBgRmlsdGVyVHJlZVN0YXRlT2JqZWN0YCB1c2luZyBwYXJzZXItU1FMJ3Mge0BsaW5rIFBhcnNlclNRTCNwYXJzZXJ8cGFyc2VyfSBhbmQgdGhyb3cgYW4gZXJyb3IgaWYgdW5wYXJzYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVN0YXRlT2JqZWN0fSBbc3RhdGVdXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9IFRoZSB1bm1vbGVzdGVkIGBzdGF0ZWAgcGFyYW1ldGVyLiBUaHJvd3MgYW4gZXJyb3IgaWYgYHN0YXRlYCBpcyB1bmtub3duIG9yIGludmFsaWQgc3ludGF4LlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIEZpbHRlck5vZGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBwYXJzZVN0YXRlU3RyaW5nOiBmdW5jdGlvbihzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgc3ludGF4ID0gb3B0aW9ucyAmJiBvcHRpb25zLnN5bnRheCB8fCAnYXV0byc7IC8vIGRlZmF1bHQgaXMgJ2F1dG8nXG5cbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQucXVlcnlTZWxlY3RvcihzdGF0ZSkudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN5bnRheCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bnRheCA9IHJlSlNPTi50ZXN0KHN0YXRlKSA/ICdKU09OJyA6ICdTUUwnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ludGF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0pTT04nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IEpTT04ucGFyc2Uoc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlsdGVyVHJlZUVycm9yKCdKU09OIHBhcnNlcjogJyArIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdTUUwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHRoaXMucm9vdC5QYXJzZXJTUUwucGFyc2Uoc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlsdGVyVHJlZUVycm9yKCdTUUwgV0hFUkUgY2xhdXNlIHBhcnNlcjogJyArIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlsdGVyVHJlZUVycm9yKCdVbmV4cGVjdGVkIGlucHV0IHN0YXRlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZWFjaCBzdGFuZGFyZCBvcHRpb24gZnJvbSB3aGVuIGZvdW5kIG9uIHRoZSBgb3B0aW9uc2Agb3IgYHN0YXRlYCBvYmplY3RzLCByZXNwZWN0aXZlbHk7IG9yIGlmIG5vdCBhbiBcIm93blwiIG9wdGlvbiwgb24gdGhlIGBwYXJlbnRgIG9iamVjdCBvciBmcm9tIHRoZSBvcHRpb25zIHNjaGVtYSBkZWZhdWx0IChpZiBhbnkpXG4gICAgICogQHBhcmFtIHN0YXRlXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBtaXhJblN0YW5kYXJkT3B0aW9uczogZnVuY3Rpb24oc3RhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzO1xuXG4gICAgICAgIF8oRmlsdGVyTm9kZS5vcHRpb25zU2NoZW1hKS5lYWNoKGZ1bmN0aW9uKG9wdGlvblNjaGVtYSwga2V5KSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvblNjaGVtYS5pZ25vcmUgJiYgKHRoaXMgIT09IHRoaXMucm9vdCB8fCBvcHRpb25TY2hlbWEucm9vdEJvdW5kKSkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb247XG5cbiAgICAgICAgICAgICAgICBub2RlLmRvbnRQZXJzaXN0W2tleV0gPSAvLyB0cnV0aHkgaWYgZnJvbSBgb3B0aW9uc2Agb3IgYGRlZmF1bHRgXG4gICAgICAgICAgICAgICAgICAgIChvcHRpb24gPSBvcHRpb25zICYmIG9wdGlvbnNba2V5XSkgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAob3B0aW9uID0gc3RhdGUgJiYgc3RhdGVba2V5XSkgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAhKG9wdGlvblNjaGVtYS5vd24gfHwgbm9kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG9wdGlvbiAhPT0gbnVsbCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShvcHRpb24gPSBub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudFtrZXldKSAmJlxuICAgICAgICAgICAgICAgICAgICAob3B0aW9uID0gb3B0aW9uU2NoZW1hLmRlZmF1bHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbm9kZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmRvbnRQZXJzaXN0W2tleV0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnc2NoZW1hJyAmJiAhb3B0aW9uLndhbGspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0dGFjaCB0aGUgYHdhbGtgIGFuZCBgZmluZGAgY29udmVuaWVuY2UgbWV0aG9kcyB0byB0aGUgYHNjaGVtYWAgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi53YWxrID0gcG9wTWVudS53YWxrLmJpbmQob3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5sb29rdXAgPSBwb3BNZW51Lmxvb2t1cC5iaW5kKG9wdGlvbiwgbm9kZS5yb290LmZpbmRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlW2tleV0gPSBvcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBtaXhJbk5vbnN0YW5kYXJkT3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gY29weSBhbGwgcmVtYWluaW5nIG9wdGlvbnMgZGlyZWN0bHkgdG8gdGhlIG5ldyBpbnN0YW5jZSwgb3ZlcnJpZGluZyBwcm90b3R5cGUgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAgICAgIF8ob3B0aW9ucykuZWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBpZiAoIUZpbHRlck5vZGUub3B0aW9uc1NjaGVtYVtrZXldKSB7XG4gICAgICAgICAgICAgICAgbm9kZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKiogUmVtb3ZlIGJvdGg6XG4gICAgICogKiBgdGhpc2AgZmlsdGVyIG5vZGUgZnJvbSBpdCdzIGBwYXJlbnRgJ3MgYGNoaWxkcmVuYCBjb2xsZWN0aW9uOyBhbmRcbiAgICAgKiAqIGB0aGlzYCBmaWx0ZXIgbm9kZSdzIGBlbGAncyBjb250YWluZXIgKGFsd2F5cyBhIGA8bGk+YCBlbGVtZW50KSBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudC5cbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyTm9kZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXZlcnQsXG4gICAgICAgICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlci5jYWxsKHBhcmVudCwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGVsZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkgeyBhdmVydCA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXZlcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5rZWVwIHx8IC8vIG5ldmVyIFwicHJ1bmVcIiAocmVtb3ZlIGlmIGVtcHR5KSB0aGlzIHBhcnRpY3VsYXIgc3ViZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID4gMSAvLyB0aGlzIG5vZGUgaGFzIHNpYmxpbmdzIHNvIHdpbGwgbm90IGJlIGVtcHR5IGFmdGVyIHRoaXMgcmVtb3ZlXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2NlZWQgd2l0aCByZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZSgpOyAvLyB0aGUgcGFyZW50IGlzIGFsd2F5cyB0aGUgY29udGFpbmluZyA8bGk+IHRhZ1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpLCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNlIHRvIHBydW5lIGVudGlyZSBzdWJleHByZXNzaW9uIGJlY2F1c2UgaXQncyBwcnVuZS1hYmxlIGFuZCB3b3VsZCBlbmQgdXAgZW1wdHkgKGNoaWxkbGVzcylcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBFcnJvcjogRmlsdGVyVHJlZUVycm9yLFxuXG4gICAgdGVtcGxhdGVzOiBuZXcgVGVtcGxhdGVzKClcbn0pO1xuXG4vKiogQHR5cGVkZWYgb3B0aW9uc1NjaGVtYU9iamVjdFxuICogQHN1bW1hcnkgU3RhbmRhcmQgb3B0aW9uIHNjaGVtYVxuICogQGRlc2MgU3RhbmRhcmQgb3B0aW9ucyBhcmUgYXV0b21hdGljYWxseSBhZGRlZCB0byBub2Rlcy4gRGF0YSBzb3VyY2VzIGZvciBzdGFuZGFyZCBvcHRpb25zIGluY2x1ZGUgYG9wdGlvbnNgLCBgc3RhdGVgLCBgcGFyZW50YCBhbmQgYGRlZmF1bHRgIChpbiB0aGF0IG9yZGVyKS4gRGVzY3JpYmVzIHN0YW5kYXJkIG9wdGlvbnMgdGhyb3VnaCB2YXJpb3VzIHByb3BlcnRpZXM6XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpZ25vcmVdIC0gRG8gbm90IGF1dG9tYXRpY2FsbHkgYWRkIHRvIG5vZGVzIChwcm9jZXNzZWQgZWxzZXdoZXJlKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW293bl0gLSBEbyBub3QgYXV0b21hdGljYWxseSBhZGQgZnJvbSBgcGFyZW50YCBvciBgZGVmYXVsdGAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyb290Qm91bmRdIC0gQXV0b21hdGljYWxseSBhZGQgdG8gcm9vdCBub2RlIG9ubHkuXG4gKiBAcHJvcGVydHkgeyp9IFtkZWZhdWx0XSAtIFRoaXMgaXMgdGhlIGRlZmF1bHQgZGF0YSBzb3VyY2Ugd2hlbiBhbGwgb3RoZXIgc3RyYXRlZ2llcyBmYWlsLlxuICovXG5cbi8qKlxuICogQHN1bW1hcnkgRGVmaW5lcyB0aGUgc3RhbmRhcmQgb3B0aW9ucyBhdmFpbGFibGUgdG8gYSBub2RlLlxuICogQGRlc2MgVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGJlYXIgdGhlIHNhbWUgbmFtZXMgYXMgdGhlIG5vZGUgb3B0aW9ucyB0aGV5IGRlZmluZS5cbiAqIEB0eXBlIHtwYmplY3R9XG4gKiBAbWVtYmVyT2YgRmlsdGVyTm9kZVxuICovXG5GaWx0ZXJOb2RlLm9wdGlvbnNTY2hlbWEgPSB7XG5cbiAgICBzdGF0ZTogeyBpZ25vcmU6IHRydWUgfSxcblxuICAgIGNzc1N0eWxlc2hlZXRSZWZlcmVuY2VFbGVtZW50OiB7IGlnbm9yZTogdHJ1ZSB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IERlZmF1bHQgY29sdW1uIHNjaGVtYSBmb3IgY29sdW1uIGRyb3AtZG93bnMgb2YgZGlyZWN0IGRlc2NlbmRhbnQgbGVhZiBub2RlcyBvbmx5LlxuICAgICAqIEBkZXNjID4gVGhpcyBkb2NzIGVudHJ5IGRlc2NyaWJlcyBhIHByb3BlcnR5IGluIHRoZSBGaWx0ZXJOb2RlIHByb3RvdHlwZS4gSXQgZG9lcyBub3QgZGVzY3JpYmUgdGhlIG9wdGlvbnNTY2hlbWEgcHJvcGVydHkgKGRlc3BpdGUgaXQncyBwb3NpdGlvbiBpbiB0aGUgc291cmNlIGNvZGUpLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyTm9kZS5vcHRpb25zU2NoZW1hXG4gICAgICovXG4gICAgb3duU2NoZW1hOiB7IG93bjogdHJ1ZSB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IERlZmF1bHQgY29sdW1uIHNjaGVtYSBmb3IgY29sdW1uIGRyb3AtZG93bnMgb2YgYWxsIGRlc2NlbmRhbnQgbGVhZiBub2Rlcy5cbiAgICAgKiBAZGVzYyA+IFRoaXMgZG9jcyBlbnRyeSBkZXNjcmliZXMgYSBwcm9wZXJ0eSBpbiB0aGUgRmlsdGVyTm9kZSBwcm90b3R5cGUuIEl0IGRvZXMgbm90IGRlc2NyaWJlIHRoZSBvcHRpb25zU2NoZW1hIHByb3BlcnR5IChkZXNwaXRlIGl0J3MgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBjb2RlKS5cbiAgICAgKiBAdHlwZSB7bWVudUl0ZW1bXX1cbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyTm9kZS5vcHRpb25zU2NoZW1hXG4gICAgICovXG4gICAgc2NoZW1hOiB7fSxcblxuICAgIC8qKiBAc3VtbWFyeSBUeXBlIG9mIGZpbHRlciBlZGl0b3IuXG4gICAgICogQGRlc2MgPiBUaGlzIGRvY3MgZW50cnkgZGVzY3JpYmVzIGEgcHJvcGVydHkgaW4gdGhlIEZpbHRlck5vZGUgcHJvdG90eXBlLiBJdCBkb2VzIG5vdCBkZXNjcmliZSB0aGUgb3B0aW9uc1NjaGVtYSBwcm9wZXJ0eSAoZGVzcGl0ZSBpdCdzIHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgY29kZSkuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyTm9kZS5vcHRpb25zU2NoZW1hXG4gICAgICovXG4gICAgZWRpdG9yOiB7fSxcblxuICAgIC8qKiBAc3VtbWFyeSBFdmVudCBoYW5kbGVyIGZvciBVSSBldmVudHMuXG4gICAgICogQGRlc2MgPiBUaGlzIGRvY3MgZW50cnkgZGVzY3JpYmVzIGEgcHJvcGVydHkgaW4gdGhlIEZpbHRlck5vZGUgcHJvdG90eXBlLiBJdCBkb2VzIG5vdCBkZXNjcmliZSB0aGUgb3B0aW9uc1NjaGVtYSBwcm9wZXJ0eSAoZGVzcGl0ZSBpdCdzIHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgY29kZSkuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyTm9kZS5vcHRpb25zU2NoZW1hXG4gICAgICovXG4gICAgZXZlbnRIYW5kbGVyOiB7fSxcblxuICAgIHR5cGU6IHsgb3duOiB0cnVlIH0sXG5cbiAgICBrZWVwOiB7IG93bjogdHJ1ZSB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IE92ZXJyaWRlIG9wZXJhdG9yIGxpc3QgYXQgYW55IG5vZGUuXG4gICAgICogQGRlc2MgPiBUaGlzIGRvY3MgZW50cnkgZGVzY3JpYmVzIGEgcHJvcGVydHkgaW4gdGhlIEZpbHRlck5vZGUgcHJvdG90eXBlLiBJdCBkb2VzIG5vdCBkZXNjcmliZSB0aGUgb3B0aW9uc1NjaGVtYSBwcm9wZXJ0eSAoZGVzcGl0ZSBpdCdzIHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgY29kZSkuXG4gICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJOb2RlLm9wdGlvbnNTY2hlbWFcbiAgICAgKi9cbiAgICBvcE1lbnU6IHsgZGVmYXVsdDogQ29uZGl0aW9uYWxzLmRlZmF1bHRPcE1lbnUgfSxcblxuICAgIHR5cGVPcE1hcDogeyByb290Qm91bmQ6IHRydWUgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBUcnV0aHkgd2lsbCBzb3J0IHRoZSBjb2x1bW4gbWVudXMuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIEZpbHRlck5vZGUub3B0aW9uc1NjaGVtYVxuICAgICAqL1xuICAgIHNvcnRDb2x1bW5NZW51OiB7fVxufTtcblxuRmlsdGVyTm9kZS5zZXRXYXJuaW5nQ2xhc3MgPSBmdW5jdGlvbihlbCwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdmFsdWUgPSBlbC52YWx1ZTtcbiAgICB9XG4gICAgZWwuY2xhc3NMaXN0W3ZhbHVlID8gJ3JlbW92ZScgOiAnYWRkJ10oJ2ZpbHRlci10cmVlLXdhcm5pbmcnKTtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5GaWx0ZXJOb2RlLmNsaWNrSW4gPSBmdW5jdGlvbihlbCkge1xuICAgIGlmIChlbCkge1xuICAgICAgICBpZiAoZWwudGFnTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGVsLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoJ21vdXNlZG93bicpKTsgfSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXJOb2RlO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8vIFRoaXMgaXMgdGhlIG1haW4gZmlsZSwgdXNhYmxlIGFzIGlzLCBzdWNoIGFzIGJ5IC90ZXN0L2luZGV4LmpzLlxuXG4vLyBGb3IgbnBtOiByZXF1aXJlIHRoaXMgZmlsZVxuLy8gRm9yIENETjogZ3VscGZpbGUuanMgYnJvd3NlcmlmaWVzIHRoaXMgZmlsZSB3aXRoIHNvdXJjZW1hcCB0byAvYnVpbGQvZmlsdGVyLXRyZWUuanMgYW5kIHVnbGlmaWVkIHdpdGhvdXQgc291cmNlbWFwIHRvIC9idWlsZC9maWx0ZXItdHJlZS5taW4uanMuIFRoZSBDRE4gaXMgaHR0cHM6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwb3BNZW51ID0gcmVxdWlyZSgncG9wLW1lbnUnKTtcbnZhciB1bnN0cnVuZ2lmeSA9IHJlcXVpcmUoJ3Vuc3RydW5naWZ5Jyk7XG5cbnZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpO1xudmFyIEZpbHRlck5vZGUgPSByZXF1aXJlKCcuL0ZpbHRlck5vZGUnKTtcbnZhciBGaWx0ZXJMZWFmID0gcmVxdWlyZSgnLi9GaWx0ZXJMZWFmJyk7XG52YXIgb3BlcmF0b3JzID0gcmVxdWlyZSgnLi90cmVlLW9wZXJhdG9ycycpO1xuXG5cbnZhciBvcmRpbmFsID0gMDtcblxuLyoqIEBjb25zdHJ1Y3RvclxuICogQHN1bW1hcnkgQW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcm9vdCBub2RlIG9yIGEgYnJhbmNoIG5vZGUgaW4gYSBmaWx0ZXIgdHJlZS5cbiAqIEBkZXNjIEEgbm9kZSByZXByZXNlbnRpbmcgYSBzdWJleHByZXNzaW9uIGluIHRoZSBmaWx0ZXIgZXhwcmVzc2lvbi4gTWF5IGJlIHRob3VnaHQgb2YgYXMgYSBwYXJlbnRoZXNpemVkIHN1YmV4cHJlc3Npb24gaW4gYWxnZWJyYWljIGV4cHJlc3Npb24gc3ludGF4LiBBcyBkaXNjdXNzZWQgdW5kZXIge0BsaW5rIEZpbHRlck5vZGV9LCBhIGBGaWx0ZXJUcmVlYCBpbnN0YW5jZSdzIGNoaWxkIG5vZGVzIG1heSBiZSBlaXRoZXI6XG4gKiAqIE90aGVyIChuZXN0ZWQpIGBGaWx0ZXJUcmVlYCAob3Igc3ViY2xhc3MgdGhlcmVvZikgbm9kZXMgcmVwcmVzZW50aW5nIHN1YmV4cHJlc3Npb25zLlxuICogKiB7QGxpbmsgRmlsdGVyTGVhZn0gKG9yIHN1YmNsYXNzIHRoZXJlb2YpIHRlcm1pbmFsIG5vZGVzIHJlcHJlc2VudGluZyBjb25kaXRpb25hbCBleHByZXNzaW9ucy5cbiAqXG4gKiBUaGUgYEZpbHRlclRyZWVgIG9iamVjdCBhbHNvIGhhcyBtZXRob2RzLCBzb21lIG9mIHdoaWNoIG9wZXJhdGUgb24gYSBzcGVjaWZpYyBzdWJ0cmVlIGluc3RhbmNlLCBhbmQgc29tZSBvZiB3aGljaCByZWN1cnNlIHRocm91Z2ggYWxsIHRoZSBzdWJ0cmVlJ3MgY2hpbGQgbm9kZXMgYW5kIGFsbCB0aGVpciBkZXNjZW5kYW50cywgX2V0Yy5fXG4gKlxuICogVGhlIHJlY3Vyc2l2ZSBtZXRob2RzIGFyZSBpbnRlcmVzdGluZy4gVGhleSBhbGwgd29yayBzaW1pbGFybHksIGxvb3BpbmcgdGhyb3VnaCB0aGUgbGlzdCBvZiBjaGlsZCBub2RlcywgcmVjdXJzaW5nIHdoZW4gdGhlIGNoaWxkIG5vZGUgaXMgYSBuZXN0ZWQgc3VidHJlZSAod2hpY2ggd2lsbCByZWN1cnNlIGZ1cnRoZXIgd2hlbiBpdCBoYXMgaXRzIG93biBuZXN0ZWQgc3VidHJlZXMpOyBhbmQgY2FsbGluZyB0aGUgcG9seW1vcnBoaWMgbWV0aG9kIHdoZW4gdGhlIGNoaWxkIG5vZGUgaXMgYSBgRmlsdGVyTGVhZmAgb2JqZWN0LCB3aGljaCBpcyBhIHRlcm1pbmFsIG5vZGUuIFN1Y2ggcG9seW1vcnBoaWMgbWV0aG9kcyBpbmNsdWRlIGBzZXRTdGF0ZSgpYCwgYGdldFN0YXRlKClgLCBgaW52YWxpZCgpYCwgYW5kIGB0ZXN0KClgLlxuICpcbiAqIEZvciBleGFtcGxlLCBjYWxsaW5nIGB0ZXN0KGRhdGFSb3cpYCBvbiB0aGUgcm9vdCB0cmVlIHJlY3Vyc2VzIHRocm91Z2ggYW55IHN1YnRyZWVzIGV2ZW50dWFsbHkgY2FsbGluZyBgdGVzdChkYXRhUm93KWAgb24gZWFjaCBvZiBpdHMgbGVhZiBub2RlcyBhbmQgY29uY2F0ZW5hdGluZyB0aGUgcmVzdWx0cyB0b2dldGhlciB1c2luZyB0aGUgc3VidHJlZSdzIGBvcGVyYXRvcmAuIFRoZSBzdWJ0cmVlJ3MgYHRlc3QoZGF0YVJvdylgIGNhbGwgdGhlbiByZXR1cm5zIHRoZSByZXN1bHQgdG8gaXQncyBwYXJlbnQncyBgdGVzdCgpYCBjYWxsLCBfZXRjLixfIGV2ZW50dWFsbHkgYnViYmxpbmcgdXAgdG8gdGhlIHJvb3Qgbm9kZSdzIGB0ZXN0KGRhdGFSb3cpYCBjYWxsLCB3aGljaCByZXR1cm5zIHRoZSBmaW5hbCByZXN1bHQgdG8gdGhlIG9yaWdpbmFsIGNhbGxlci4gVGhpcyByZXN1bHQgZGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gZGF0YSByb3cgcGFzc2VkIHRocm91Z2ggdGhlIGVudGlyZSBmaWx0ZXIgZXhwcmVzc2lvbiBzdWNjZXNzZnVsbHkgKGB0cnVlYCkgYW5kIHNob3VsZCBiZSBkaXNwbGF5ZWQsIG9yIHdhcyBibG9ja2VkIHNvbWV3aGVyZSAoYGZhbHNlYCkgYW5kIHNob3VsZCBub3QgYmUgZGlzcGxheWVkLlxuICpcbiAqIE5vdGUgdGhhdCBpbiBwcmFjdGljZTpcbiAqIDEuIGBjaGlsZHJlbmAgbWF5IGJlIGVtcHR5LiBUaGlzIHJlcHJlc2VudHMgYSBhbiBlbXB0eSBzdWJleHByZXNzaW9uLiBOb3JtYWxseSBwb2ludGxlc3MsIGVtcHR5IHN1YmV4cHJlc3Npb25zIGNvdWxkIGJlIHBydW5lZC4gRmlsdGVyLXRyZWUgYWxsb3dzIHRoZW0gaG93ZXZlciBhcyBoYXJtbGVzcyBwbGFjZWhvbGRlcnMuXG4gKiAxLiBgb3BlcmF0b3JgIG1heSBiZSBvbWl0dGVkIGluIHdoaWNoIGNhc2UgaXQgZGVmYXVsdHMgdG8gQU5ELlxuICogMS4gQSBgZmFsc2VgIHJlc3VsdCBmcm9tIGEgY2hpbGQgbm9kZSB3aWxsIHNob3J0LXN0b3AgYW4gQU5EIG9wZXJhdGlvbjsgYSBgdHJ1ZWAgcmVzdWx0IHdpbGwgc2hvcnQtc3RvcCBhbiBPUiBvciBOT1Igb3BlcmF0aW9uLlxuICpcbiAqIEFkZGl0aW9uYWwgbm90ZXM6XG4gKiAxLiBBIGBGaWx0ZXJUcmVlYCBtYXkgY29uc2lzdCBvZiBhIHNpbmdsZSBsZWFmLCBpbiB3aGljaCBjYXNlIHRoZSBjb25jYXRlbmF0aW9uIGBvcGVyYXRvcmAgaXMgbm90IG5lZWRlZCBhbmQgbWF5IGJlIGxlZnQgdW5kZWZpbmVkLiBIb3dldmVyLCBpZiBhIHNlY29uZCBjaGlsZCBpcyBhZGRlZCBhbmQgdGhlIG9wZXJhdG9yIGlzIHN0aWxsIHVuZGVmaW5lZCwgaXQgd2lsbCBiZSBzZXQgdG8gdGhlIGRlZmF1bHQgKGAnb3AtYW5kJ2ApLlxuICogMi4gVGhlIG9yZGVyIG9mIHRoZSBjaGlsZHJlbiBpcyB1bmRlZmluZWQgYXMgYWxsIG9wZXJhdG9ycyBhcmUgY29tbXV0YXRpdmUuIEZvciB0aGUgJ2BvcC1vcmAnIG9wZXJhdG9yLCBldmFsdWF0aW9uIGNlYXNlcyBvbiB0aGUgZmlyc3QgcG9zaXRpdmUgcmVzdWx0IGFuZCBmb3IgZWZmaWNpZW5jeSwgYWxsIHNpbXBsZSBjb25kaXRpb25hbCBleHByZXNzaW9ucyB3aWxsIGJlIGV2YWx1YXRlZCBiZWZvcmUgYW55IGNvbXBsZXggc3ViZXhwcmVzc2lvbnMuXG4gKiAzLiBBIG5lc3RlZCBgRmlsdGVyVHJlZWAgaXMgZGlzdGluZ3Vpc2hlZCAoZHVjay10eXBlZCkgZnJvbSBhIGxlYWYgbm9kZSBieSB0aGUgcHJlc2VuY2Ugb2YgYSBgY2hpbGRyZW5gIG1lbWJlci5cbiAqIDQuIE5lc3RpbmcgYSBgRmlsdGVyVHJlZWAgY29udGFpbmluZyBhIHNpbmdsZSBjaGlsZCBpcyB2YWxpZCAoYWxiZWl0IHBvaW50bGVzcykuXG4gKlxuICogKipTZWUgYWxzbyB0aGUgcHJvcGVydGllcyBvZiB0aGUgc3VwZXJjbGFzczoqKiB7QGxpbmsgRmlsdGVyTm9kZX1cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW29wZXJhdG9yPSdvcC1hbmQnXSAtIFRoZSBvcGVyYXRvciB0aGF0IGNvbmNhdGVudGF0ZXMgdGhlIHRlc3QgcmVzdWx0cyBmcm9tIGFsbCB0aGUgbm9kZSdzIGBjaGlsZHJlbmAgKGNoaWxkIG5vZGVzKS4gTXVzdCBiZSBvbmUgb2Y6XG4gKiAqIGAnb3AtYW5kJ2BcbiAqICogYCdvcC1vcidgXG4gKiAqIGAnb3Atbm9yJ2BcbiAqXG4gKiBOb3RlIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgYG9wZXJhdG9yYCBwZXIgc3ViZXhwcmVzc2lvbi4gSWYgeW91IG5lZWQgdG8gbWl4IG9wZXJhdG9ycywgY3JlYXRlIGEgc3Vib3JkaW5hdGUgc3ViZXhwcmVzc2lvbiBhcyBvbmUgb2YgdGhlIGNoaWxkIG5vZGVzLlxuICpcbiAqIEBwcm9wZXJ0eSB7RmlsdGVyTm9kZVtdfSBjaGlsZHJlbiAtIEEgbGlzdCBvZiBkZXNjZW5kYW50cyBvZiB0aGlzIG5vZGUuIEFzIG5vdGVkLCB0aGVzZSBtYXkgYmUgb3RoZXIgYEZpbHRlclRyZWVgIChvciBzdWJjbGFzcyB0aGVyZW9mKSBub2Rlczsgb3IgbWF5IGJlIHRlcm1pbmFsIGBGaWx0ZXJMZWFmYCAob3Igc3ViY2xhc3MgdGhlcmVvZikgbm9kZXMuIE1heSBiZSBhbnkgbGVuZ3RoIGluY2x1ZGluZyAwIChub25lOyBlbXB0eSkuXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBba2VlcD1mYWxzZV0gLSBEbyBub3QgYXV0b21hdGljYWxseSBwcnVuZSB3aGVuIGxhc3QgY2hpbGQgcmVtb3ZlZC5cbiAqXG4gKiBAcHJvcGVydHkge2ZpZWxkSXRlbVtdfSBbb3duU2NoZW1hXSAtIENvbHVtbiBtZW51IHRvIGJlIHVzZWQgb25seSBieSBsZWFmIG5vZGVzIHRoYXQgYXJlIGNoaWxkcmVuIChkaXJlY3QgZGVzY2VuZGFudHMpIG9mIHRoaXMgbm9kZS5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGU9J3N1YnRyZWUnXSAtIFR5cGUgb2Ygbm9kZSwgZm9yIHJlbmRlcmluZyBwdXJwb3NlczsgbmFtZXMgdGhlIHJlbmRlcmluZyB0ZW1wbGF0ZSB0byB1c2UgdG8gZ2VuZXJhdGUgdGhlIG5vZGUncyBVSSByZXByZXNlbnRhdGlvbi5cbiAqL1xudmFyIEZpbHRlclRyZWUgPSBGaWx0ZXJOb2RlLmV4dGVuZCgnRmlsdGVyVHJlZScsIHtcblxuICAgIC8qKlxuICAgICAqIEhhc2ggb2YgY29uc3RydWN0b3JzIGZvciBvYmplY3RzIHRoYXQgZXh0ZW5kIGZyb20ge0BsaW5rIEZpbHRlckxlYWZ9LCB3aGljaCBpcyB0aGUgYERlZmF1bHRgIG1lbWJlciBoZXJlLlxuICAgICAqXG4gICAgICogQWRkIGFkZGl0aW9uYWwgZWRpdG9ycyB0byB0aGlzIG9iamVjdCAoaW4gdGhlIHByb3RvdHlwZSkgcHJpb3IgdG8gaW5zdGFudGlhdGluZyBhIGxlYWYgbm9kZSB0aGF0IHJlZmVycyB0byBpdC4gVGhpcyBvYmplY3QgZXhpc3RzIGluIHRoZSBwcm90b3R5cGUgYW5kIGFkZGl0aW9ucyB0byBpdCB3aWxsIGFmZmVjdCBhbGwgbm9kZXMgdGhhdCBkb24ndCBoYXZlIHRoZWlyIGFuIFwib3duXCIgaGFzaC5cbiAgICAgKlxuICAgICAqIElmIHlvdSBjcmVhdGUgYW4gXCJvd25cIiBoYXNoIGluIHlvdXIgaW5zdGFuY2UgYmUgc3VyZSB0byBpbmNsdWRlIHRoZSBkZWZhdWx0IGVkaXRvciwgZm9yIGV4YW1wbGU6IGB7IERlZmF1bHQ6IEZpbHRlclRyZWUucHJvdG90eXBlLmVkaXRvcnMuRGVmYXVsdCwgLi4uIH1gLiAoT25lIHdheSBvZiBvdmVycmlkaW5nIHdvdWxkIGJlIHRvIGluY2x1ZGUgc3VjaCBhbiBvYmplY3QgaW4gYW4gYGVkaXRvcnNgIG1lbWJlciBvZiB0aGUgb3B0aW9ucyBvYmplY3QgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvciBvbiBpbnN0YW50aWF0aW9uLiBUaGlzIHdvcmtzIGJlY2F1c2UgYWxsIG1pc2NlbGxhbmVvdXMgbWVtYmVycyBhcmUgc2ltcGx5IGNvcGllZCB0byB0aGUgbmV3IGluc3RhbmNlLiBOb3QgdG8gYmUgY29uZnVzZWQgd2l0aCB0aGUgc3RhbmRhcmQgb3B0aW9uIGBlZGl0b3JgIHdoaWNoIGlzIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBrZXkgZnJvbSB0aGlzIGhhc2ggYW5kIHRlbGxzIHRoZSBsZWFmIG5vZGUgd2hhdCB0eXBlIHRvIHVzZS4pXG4gICAgICovXG4gICAgZWRpdG9yczoge1xuICAgICAgICBEZWZhdWx0OiBGaWx0ZXJMZWFmXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuIGV4dGVuc2lvbiBpcyBhIGhhc2ggb2YgcHJvdG90eXBlIG92ZXJyaWRlcyAobWV0aG9kcywgcHJvcGVydGllcykgdXNlZCB0byBleHRlbmQgdGhlIGRlZmF1bHQgZWRpdG9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5PSdEZWZhdWx0J10gLSBObWUgb2YgdGhlIG5ldyBleHRlbnNpb24gZ2l2ZW4gaW4gYGV4dGAgb3IgbmFtZSBvZiBhbiBleGlzdGluZyBleHRlbnNpb24gaW4gYEZpbHRlclRyZWUuZXh0ZW5zaW9uc2AuIEFzIGEgY29uc3RydWN0b3IsIHNob3VsZCBoYXZlIGFuIGluaXRpYWwgY2FwaXRhbC4gSWYgb21pdHRlZCwgcmVwbGFjZXMgdGhlIGRlZmF1bHQgZWRpdG9yIChGaWx0ZXJMZWFmKS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2V4dF0gQW4gZXh0ZW5zaW9uIGhhc2hcbiAgICAgKiBAcGFyYW0ge0ZpbGVyTGVhZn0gW0Jhc2VFZGl0b3I9dGhpcy5lZGl0b3JzLkRlZmF1bHRdIC0gQ29uc3RydWN0b3IgdG8gZXh0ZW5kIGZyb20uXG4gICAgICogQHJldHVybnMge0ZpbGx0ZXJMZWFmfSBBIG5ldyBjbGFzcyBleHRlbmRlZCBmcm9tIGBCYXNlRWRpdG9yYCAtLSB3aGljaCBpcyBpbml0aWFsbHkgYEZpbHRlckxlYWZgIGJ1dCBtYXkgaXRzZWxmIGhhdmUgYmVlbiBleHRlbmRlZCBieSBhIGNhbGwgdG8gYC5hZGRFZGl0b3IoJ0RlZmF1bHQnLCBleHRlbnNpb24pYC5cbiAgICAgKi9cbiAgICBhZGRFZGl0b3I6IGZ1bmN0aW9uKGtleSwgZXh0LCBCYXNlRWRpdG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gYGtleWAgKHN0cmluZykgd2FzIG9taXR0ZWRcbiAgICAgICAgICAgIEJhc2VFZGl0b3IgPSBleHQ7XG4gICAgICAgICAgICBleHQgPSBrZXk7XG4gICAgICAgICAgICBrZXkgPSAnRGVmYXVsdCc7XG4gICAgICAgIH1cbiAgICAgICAgQmFzZUVkaXRvciA9IEJhc2VFZGl0b3IgfHwgdGhpcy5lZGl0b3JzLkRlZmF1bHQ7XG4gICAgICAgIGV4dCA9IGV4dCB8fCBGaWx0ZXJUcmVlLmV4dGVuc2lvbnNba2V5XTtcbiAgICAgICAgcmV0dXJuICh0aGlzLmVkaXRvcnNba2V5XSA9IEJhc2VFZGl0b3IuZXh0ZW5kKGtleSwgZXh0KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUgbmFtZSBvZiB0aGUgZXhpc3RpbmcgZWRpdG9yIHRvIHJlbW92ZS5cbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyVHJlZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZW1vdmVFZGl0b3I6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoa2V5ID09PSAnRGVmYXVsdCcpIHtcbiAgICAgICAgICAgIHRocm93ICdDYW5ub3QgcmVtb3ZlIGRlZmF1bHQgZWRpdG9yLic7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuZWRpdG9yc1trZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJUcmVlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNyZWF0ZVZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmVsID0gdGhpcy50ZW1wbGF0ZXMuZ2V0KFxuICAgICAgICAgICAgdGhpcy50eXBlIHx8ICdzdWJ0cmVlJyxcbiAgICAgICAgICAgICsrb3JkaW5hbCxcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hWzBdICYmIHBvcE1lbnUuZm9ybWF0SXRlbSh0aGlzLnNjaGVtYVswXSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBBZGQgdGhlIGV4cHJlc3Npb24gZWRpdG9ycyB0byB0aGUgXCJhZGQgbmV3XCIgZHJvcC1kb3duXG4gICAgICAgIHZhciBhZGROZXdDdHJsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCc6c2NvcGU+c2VsZWN0Jyk7XG4gICAgICAgIGlmIChhZGROZXdDdHJsKSB7XG4gICAgICAgICAgICB2YXIgc3VibWVudSwgb3B0Z3JvdXAsXG4gICAgICAgICAgICAgICAgZWRpdG9ycyA9IHRoaXMuZWRpdG9ycztcblxuICAgICAgICAgICAgaWYgKGFkZE5ld0N0cmwubGVuZ3RoID09PSAxICYmIHRoaXMuZWRpdG9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGVkaXRvciBpcyB0aGUgb25seSBvcHRpb24gYmVzaWRlcyB0aGUgbnVsbCBwcm9tcHQgb3B0aW9uXG4gICAgICAgICAgICAgICAgLy8gc28gbWFrZSBpdCB0aCBlb25seSBpdGVtIGkgdGhlIGRyb3AtZG93blxuICAgICAgICAgICAgICAgIHN1Ym1lbnUgPSBhZGROZXdDdHJsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBhcmUgYWxyZWFkeSBvcHRpb25zIGFuZC9vciBtdWx0aXBsZSBlZGl0b3JzXG4gICAgICAgICAgICAgICAgc3VibWVudSA9IG9wdGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0Z3JvdXAnKTtcbiAgICAgICAgICAgICAgICBvcHRncm91cC5sYWJlbCA9ICdDb25kaXRpb25hbCBFeHByZXNzaW9ucyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhlZGl0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZWRpdG9yc1trZXldLnByb3RvdHlwZS5uYW1lIHx8IGtleTtcbiAgICAgICAgICAgICAgICBzdWJtZW51LmFwcGVuZENoaWxkKG5ldyBPcHRpb24obmFtZSwga2V5KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvcHRncm91cCkge1xuICAgICAgICAgICAgICAgIGFkZE5ld0N0cmwuYWRkKG9wdGdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25jaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25UcmVlT3BDbGljay5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyVHJlZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBsb2FkU3RhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSAnb3AtYW5kJztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSBgc3RhdGUuY2hpbGRyZW5gIChyZXF1aXJlZClcbiAgICAgICAgICAgIGlmICghKHN0YXRlLmNoaWxkcmVuIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHRoaXMuRXJyb3IoJ0V4cGVjdGVkIGBjaGlsZHJlbmAgcHJvcGVydHkgdG8gYmUgYW4gYXJyYXkuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIGBzdGF0ZS5vcGVyYXRvcmAgKGlmIGdpdmVuKVxuICAgICAgICAgICAgaWYgKHN0YXRlLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcGVyYXRvcnNbc3RhdGUub3BlcmF0b3JdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyB0aGlzLkVycm9yKCdFeHBlY3RlZCBgb3BlcmF0b3JgIHByb3BlcnR5IHRvIGJlIG9uZSBvZjogJyArIE9iamVjdC5rZXlzKG9wZXJhdG9ycykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBzdGF0ZS5vcGVyYXRvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUuY2hpbGRyZW4uZm9yRWFjaCh0aGlzLmFkZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJUcmVlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByYWRpb0J1dHRvbiA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignOnNjb3BlID4gbGFiZWwgPiBpbnB1dFt2YWx1ZT0nICsgdGhpcy5vcGVyYXRvciArICddJyksXG4gICAgICAgICAgICBhZGRGaWx0ZXJMaW5rID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuZmlsdGVyLXRyZWUtYWRkLWNvbmRpdGlvbmFsJyk7XG5cbiAgICAgICAgaWYgKHJhZGlvQnV0dG9uKSB7XG4gICAgICAgICAgICByYWRpb0J1dHRvbi5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIG9uVHJlZU9wQ2xpY2suY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiByYWRpb0J1dHRvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aGVuIG11bHRpcGxlIGZpbHRlciBlZGl0b3JzIGF2YWlsYWJsZSwgc2ltdWxhdGUgY2xpY2sgb24gdGhlIG5ldyBcImFkZCBjb25kaXRpb25hbFwiIGxpbmtcbiAgICAgICAgaWYgKGFkZEZpbHRlckxpbmsgJiYgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIE9iamVjdC5rZXlzKHRoaXMuZWRpdG9ycykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpc1snZmlsdGVyLXRyZWUtYWRkLWNvbmRpdGlvbmFsJ10oe1xuICAgICAgICAgICAgICAgIHRhcmdldDogYWRkRmlsdGVyTGlua1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcm9jZWVkIHdpdGggcmVuZGVyXG4gICAgICAgIEZpbHRlck5vZGUucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgbm9kZSBhcyBwZXIgYHN0YXRlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17c3RhdGU6e319XSAtIE1heSBiZSBvbmUgb2Y6XG4gICAgICpcbiAgICAgKiAqIGFuIGBvcHRpb25zYCBvYmplY3QgY29udGFpbmluZyBhIGBzdGF0ZWAgcHJvcGVydHlcbiAgICAgKiAqIGEgYHN0YXRlYCBvYmplY3QgKGluIHdoaWNoIGNhc2UgdGhlcmUgaXMgbm8gYG9wdGlvbnNgIG9iamVjdClcbiAgICAgKlxuICAgICAqIEluIGFueSBjYXNlLCByZXN1bHRpbmcgYHN0YXRlYCBvYmplY3QgbWF5IGJlIGVpdGhlci4uLlxuICAgICAqICogQSBuZXcgc3VidHJlZSAoaGFzIGEgYGNoaWxkcmVuYCBwcm9wZXJ0eSk6XG4gICAgICogICBBZGQgYSBuZXcgYEZpbHRlclRyZWVgIG5vZGUuXG4gICAgICogKiBBIG5ldyBsZWFmIChubyBgY2hpbGRyZW5gIHByb3BlcnR5KTogYWRkIGEgbmV3IGBGaWx0ZXJMZWFmYCBub2RlOlxuICAgICAqICAgKiBJZiB0aGVyZSBpcyBhbiBgZWRpdG9yYCBwcm9wZXJ0eTpcbiAgICAgKiAgICAgQWRkIGxlYWYgdXNpbmcgYHRoaXMuZWRpdG9yc1tzdGF0ZS5lZGl0b3JdYC5cbiAgICAgKiAgICogT3RoZXJ3aXNlIChpbmNsdWRpbmcgdGhlIGNhc2Ugd2hlcmUgYHN0YXRlYCBpcyB1bmRlZmluZWQpOlxuICAgICAqICAgICBBZGQgbGVhZiB1c2luZyBgdGhpcy5lZGl0b3JzLkRlZmF1bHRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mb2N1cz1mYWxzZV0gQ2FsbCBpbnZhbGlkKCkgYWZ0ZXIgaW5zZXJ0aW5nIHRvIGZvY3VzIG9uIGZpcnN0IGJsYW5rIGNvbnRyb2wgKGlmIGFueSkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RmlsdGVyTm9kZX0gVGhlIG5ldyBub2RlLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIEZpbHRlclRyZWUucHJvdG90eXBlXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciwgbmV3Tm9kZTtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMuc3RhdGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7IHN0YXRlOiBvcHRpb25zIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zdGF0ZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgQ29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQ29uc3RydWN0b3IgPSB0aGlzLmVkaXRvcnNbb3B0aW9ucy5zdGF0ZS5lZGl0b3IgfHwgJ0RlZmF1bHQnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMucGFyZW50ID0gdGhpcztcbiAgICAgICAgbmV3Tm9kZSA9IG5ldyBDb25zdHJ1Y3RvcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKG5ld05vZGUpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmZvY3VzKSB7XG4gICAgICAgICAgICAvLyBmb2N1cyBvbiBibGFuayBjb250cm9sIGEgYmVhdCBhZnRlciBhZGRpbmcgaXRcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IG5ld05vZGUuaW52YWxpZChvcHRpb25zKTsgfSwgNzUwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH0sXG5cbiAgICAvKiogQHR5cGVkZWYge29iamVjdH0gRmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0XG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdGhyb3c9ZmFsc2VdIC0gVGhyb3cgKGRvIG5vdCBjYXRjaCkgYEZpbHRlclRyZWVFcnJvcmBzLlxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FsZXJ0PWZhbHNlXSAtIEFubm91bmNlIGVycm9yIHZpYSB3aW5kb3cuYWxlcnQoKSBiZWZvcmUgcmV0dXJuaW5nLlxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ZvY3VzPWZhbHNlXSAtIFBsYWNlIHRoZSBmb2N1cyBvbiB0aGUgb2ZmZW5kaW5nIGNvbnRyb2wgYW5kIGdpdmUgaXQgZXJyb3IgY29sb3IuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWVWYWxpZGF0aW9uT3B0aW9uc09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxGaWx0ZXJUcmVlRXJyb3J9IGB1bmRlZmluZWRgIGlmIHZhbGlkOyBvciB0aGUgY2F1Z2h0IGBGaWx0ZXJUcmVlRXJyb3JgIGlmIGVycm9yLlxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJUcmVlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGludmFsaWQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gaW52YWxpZC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGVycjtcblxuICAgICAgICAgICAgLy8gVGhyb3cgd2hlbiB1bmV4cGVjdGVkIChub3QgYSBmaWx0ZXIgdHJlZSBlcnJvcilcbiAgICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIHRoaXMuRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWx0ZXIgYW5kL29yIHRocm93IHdoZW4gcmVxdWVzdGVkXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFsZXJ0KSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFsZXJ0KHJlc3VsdC5tZXNzYWdlIHx8IHJlc3VsdCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRocm93KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YVJvd1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJUcmVlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QoZGF0YVJvdykge1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSBvcGVyYXRvcnNbdGhpcy5vcGVyYXRvcl0sXG4gICAgICAgICAgICByZXN1bHQgPSBvcGVyYXRvci5zZWVkLFxuICAgICAgICAgICAgbm9DaGlsZHJlbkRlZmluZWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZmluZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgbm9DaGlsZHJlbkRlZmluZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBGaWx0ZXJMZWFmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9wZXJhdG9yLnJlZHVjZShyZXN1bHQsIGNoaWxkLnRlc3QoZGF0YVJvdykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9wZXJhdG9yLnJlZHVjZShyZXN1bHQsIHRlc3QuY2FsbChjaGlsZCwgZGF0YVJvdykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSBvcGVyYXRvci5hYm9ydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbm9DaGlsZHJlbkRlZmluZWQgfHwgKG9wZXJhdG9yLm5lZ2F0ZSA/ICFyZXN1bHQgOiByZXN1bHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgZmlsdGVycyAodGVybWluYWwgbm9kZXMpIGRlZmluZWQgaW4gdGhpcyBzdWJ0cmVlLlxuICAgICAqL1xuICAgIGZpbHRlckNvdW50OiBmdW5jdGlvbiBmaWx0ZXJDb3VudCgpIHtcbiAgICAgICAgdmFyIG4gPSAwO1xuXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgbiArPSBjaGlsZCBpbnN0YW5jZW9mIEZpbHRlckxlYWYgPyAxIDogZmlsdGVyQ291bnQuY2FsbChjaGlsZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuO1xuICAgIH0sXG5cbiAgICAvKiogQHR5cGVkZWYge29iamVjdH0gRmlsdGVyVHJlZUdldFN0YXRlT3B0aW9uc09iamVjdFxuICAgICAqXG4gICAgICogQHN1bW1hcnkgT2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBmb3IgcHJvZHVjaW5nIGEgc3RhdGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGRlc2MgU3RhdGUgaXMgY29tbW9ubHkgdXNlZCBmb3IgdHdvIHB1cnBvc2VzOlxuICAgICAqIDEuIFRvIHBlcnNpc3QgdGhlIGZpbHRlciBzdGF0ZSBzbyB0aGF0IGl0IGNhbiBiZSByZWxvYWRlZCBsYXRlci5cbiAgICAgKiAyLiBUbyBzZW5kIGEgcXVlcnkgdG8gYSBkYXRhYmFzZSBlbmdpbmUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzeW50YXg9J29iamVjdCddIC0gQSBjYXNlLXNlbnNpdGl2ZSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgZXhwZWN0ZWQgdHlwZSBhbmQgZm9ybWF0IG9mIGEgc3RhdGUgb2JqZWN0IHRvIGJlIGdlbmVyYXRlZCBmcm9tIGEgZmlsdGVyIHRyZWUuIE9uZSBvZjpcbiAgICAgKiAqIGAnb2JqZWN0J2AgKGRlZmF1bHQpIEEgcmF3IHN0YXRlIG9iamVjdCBwcm9kdWNlZCBieSB3YWxraW5nIHRoZSB0cmVlIHVzaW5nIGB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdW5zdHJ1bmdpZnl8dW5zdHJ1bmdpZnkoKX1gLCByZXNwZWN0aW5nIGBKU09OLnN0cmluZ2lmeSgpYCdzIFwie0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vc3RyaW5naWZ5I3RvSlNPTigpX2JlaGF2aW9yfHRvSlNPTigpIGJlaGF2aW9yfSxcIiBhbmQgcmV0dXJuaW5nIGEgcGxhaW4gb2JqZWN0IHN1aXRhYmxlIGZvciByZXN1Ym1pdHRpbmcgdG8ge0BsaW5rIEZpbHRlck5vZGUjc2V0U3RhdGV8c2V0U3RhdGV9LiBUaGlzIGlzIGFuIFwiZXNzZW50aWFsXCIgdmVyc2lvbiBvZiB0aGUgYWN0dWFsIG5vZGUgb2JqZWN0cyBpbiB0aGUgdHJlZS5cbiAgICAgKiAqIGAnSlNPTidgIC0gQSBzdHJpbmdpZmllZCBzdGF0ZSBvYmplY3QgcHJvZHVjZWQgYnkgd2Fsa2luZyB0aGUgdHJlZSB1c2luZyBge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vc3RyaW5naWZ5I3RvSlNPTigpX2JlaGF2aW9yfEpTT04uc3RyaW5naWZ5KCl9YCwgcmV0dXJuaW5nIGEgSlNPTiBzdHJpbmcgYnkgY2FsbGluZyBgdG9KU09OYCBhdCBldmVyeSBub2RlLiBUaGlzIGlzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzYW1lIFwiZXNzZW50aWFsXCIgb2JqZWN0IGFzIHRoYXQgcHJvZHVjZWQgYnkgdGhlIGAnb2JqZWN0J2Agb3B0aW9uLCBidXQgXCJzdHJpbmdpZmllZFwiIGFuZCB0aGVyZWZvcmUgc3VpdGFibGUgZm9yIHRleHQtYmFzZWQgc3RvcmFnZSBtZWRpYS5cbiAgICAgKiAqIGAnU1FMJ2AgLSBUaGUgc3ViZXhwcmVzc2lvbiBpbiBTUUwgY29uZGl0aW9uYWwgc3ludGF4IHByb2R1Y2VkIGJ5IHdhbGtpbmcgdGhlIHRyZWUgYW5kIHJldHVybmluZyBhIFNRTCBbc2VhcmNoIGNvbmRpdGlvbiBleHByZXNzaW9uXXtAbGluayBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zMTczNTQ1LmFzcHh9LiBTdWl0YWJsZSBmb3IgdXNlIGluIHRoZSBXSEVSRSBjbGF1c2Ugb2YgYSBTUUwgYFNFTEVDVGAgc3RhdGVtZW50IHVzZWQgdG8gcXVlcnkgYSBkYXRhYmFzZSBmb3IgYSBmaWx0ZXJlZCByZXN1bHQgc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbc3BhY2VdIC0gV2hlbiBgb3B0aW9ucy5zeW50YXggPT09ICdKU09OJ2AsIGZvcndhcmRlZCB0byBgSlNPTi5zdHJpbmdpZnlgIGFzIHRoZSB0aGlyZCBwYXJhbWV0ZXIsIGBzcGFjZWAgKHNlZSkuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGUgU1FMIHN5bnRheCByZXN1bHQgY2Fubm90IGFjY29tbW9kYXRlIG5vZGUgbWV0YS1kYXRhLiBXaGlsZSBtZXRhLWRhdGEgc3VjaCBhcyBgdHlwZWAgdHlwaWNhbGx5IGNvbWVzIGZyb20gdGhlIGNvbHVtbiBzY2hlbWEsIG1ldGEtZGF0YSBjYW4gYmUgaW5zdGFsbGVkIGRpcmVjdGx5IG9uIGEgbm9kZS4gU3VjaCBtZXRhLWRhdGEgd2lsbCBub3QgYmUgcGFydCBvZiB0aGUgcmVzdWx0aW5nIFNRTCBleHByZXNzaW9uLiBGb3IgdGhpcyByZWFzb24sIFNRTCBzaG91bGQgbm90IGJlIHVzZWQgdG8gcGVyc2lzdCBmaWx0ZXIgc3RhdGUgYnV0IHJhdGhlciBpdHMgdXNlIHNob3VsZCBiZSBsaW1pdGVkIHRvIGdlbmVyYXRpbmcgYSBmaWx0ZXIgcXVlcnkgZm9yIGEgcmVtb3RlIGRhdGEgc2VydmVyLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IGEgcmVwcmVzZW50YXRpb24gb2YgZmlsdGVyIHN0YXRlLlxuICAgICAqIEBkZXNjIENhbGxpbmcgdGhpcyBvbiB0aGUgcm9vdCB3aWxsIGdldCB0aGUgZW50aXJlIHRyZWUncyBzdGF0ZTsgY2FsbGluZyB0aGlzIG9uIGFueSBzdWJ0cmVlIHdpbGwgZ2V0IGp1c3QgdGhhdCBzdWJ0cmVlJ3Mgc3RhdGUuXG4gICAgICpcbiAgICAgKiBPbmx5IF9lc3NlbnRpYWxfIHByb3BlcnRpZXMgd2lsbCBiZSBvdXRwdXQ6XG4gICAgICpcbiAgICAgKiAxLiBgRmlsdGVyVHJlZWAgbm9kZXMgd2lsbCBvdXRwdXQgYXQgbGVhc3QgMiBwcm9wZXJ0aWVzOlxuICAgICAqICAgICogYG9wZXJhdG9yYFxuICAgICAqICAgICogYGNoaWxkcmVuYFxuICAgICAqIDIuIGBGaWx0ZXJMZWFmYCBub2RlcyB3aWxsIG91dHB1dCAodmlhIHtAbGluayBGaWx0ZXJMZWFmI2dldFN0YXRlfGdldFN0YXRlfSkgYXQgbGVhc3QgMyBwcm9wZXJ0aWVzLCBvbmUgcHJvcGVydHkgZm9yIGVhY2ggaXRlbSBpbiBpdCdzIGB2aWV3YDpcbiAgICAgKiAgICAqIGBjb2x1bW5gXG4gICAgICogICAgKiBgb3BlcmF0b3JgXG4gICAgICogICAgKiBgb3BlcmFuZGBcbiAgICAgKiAzLiBBZGRpdGlvbmFsIG5vZGUgcHJvcGVydGllcyB3aWxsIGJlIG91dHB1dCB3aGVuOlxuICAgICAqICAgIDEuIFdoZW4gdGhlIHByb3BlcnR5IHdhcyAqKk5PVCoqIGV4dGVybmFsbHkgc291cmNlZDpcbiAgICAgKiAgICAgICAxLiBEaWQgKm5vdCogY29tZSBmcm9tIHRoZSBgb3B0aW9uc2Agb2JqZWN0IG9uIG5vZGUgaW5zdGFudGlhdGlvbi5cbiAgICAgKiAgICAgICAyLiBEaWQgKm5vdCogY29tZSBmcm9tIHRoZSBvcHRpb25zIHNjaGVtYSBgZGVmYXVsdGAgb2JqZWN0LCBpZiBhbnkuXG4gICAgICogICAgMi4gKipBTkQqKiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuICAgICAqICAgICAgIDEuIFdoZW4gaXQncyBhbiBcIm93blwiIHByb3BlcnR5LlxuICAgICAqICAgICAgIDIuIFdoZW4gaXRzIHZhbHVlIGRpZmZlcnMgZnJvbSBpdCdzIHBhcmVudCdzLlxuICAgICAqICAgICAgIDMuIFdoZW4gdGhpcyBpcyB0aGUgcm9vdCBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlR2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuc3FsSWRRdHNdIC0gV2hlbiBgb3B0aW9ucy5zeW50YXggPT09ICdTUUwnYCwgZm9yd2FyZGVkIHRvIGBjb25kaXRpb25hbHMucHVzaFNxbElkUXRzKClgLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8c3RyaW5nfSBSZXR1cm5zIG9iamVjdCB3aGVuIGBvcHRpb25zLnN5bnRheCA9PT0gJ29iamVjdCdgOyBvdGhlcndpc2UgcmV0dXJucyBzdHJpbmcuXG4gICAgICogQG1lbWJlck9mIEZpbHRlclRyZWUucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0U3RhdGU6IGZ1bmN0aW9uIGdldFN0YXRlKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgICAgc3ludGF4ID0gb3B0aW9ucyAmJiBvcHRpb25zLnN5bnRheCB8fCAnb2JqZWN0JztcblxuICAgICAgICBzd2l0Y2ggKHN5bnRheCkge1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB1bnN0cnVuZ2lmeS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdKU09OJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLCBudWxsLCBvcHRpb25zICYmIG9wdGlvbnMuc3BhY2UpIHx8ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdTUUwnOlxuICAgICAgICAgICAgICAgIHZhciBsZXhlbWUgPSBvcGVyYXRvcnNbdGhpcy5vcGVyYXRvcl0uU1FMO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gaWR4ID8gJyAnICsgbGV4ZW1lLm9wICsgJyAnIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEZpbHRlckxlYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBvcCArIGNoaWxkLmdldFN0YXRlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IG9wICsgZ2V0U3RhdGUuY2FsbChjaGlsZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbGV4ZW1lLmJlZyArIHJlc3VsdCArIGxleGVtZS5lbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyB0aGlzLkVycm9yKCdVbmtub3duIHN5bnRheCBvcHRpb24gXCInICsgc3ludGF4ICsgJ1wiJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IHRoaXMub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgc3RhdGUuY2hpbGRyZW4ucHVzaChjaGlsZCBpbnN0YW5jZW9mIEZpbHRlckxlYWYgPyBjaGlsZCA6IHRvSlNPTi5jYWxsKGNoaWxkKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF8oRmlsdGVyTm9kZS5vcHRpb25zU2NoZW1hKS5lYWNoKGZ1bmN0aW9uKG9wdGlvblNjaGVtYSwga2V5KSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc2VsZltrZXldICYmIC8vIHRoZXJlIGlzIGEgc3RhbmRhcmQgb3B0aW9uIG9uIHRoZSBub2RlIHdoaWNoIG1heSBuZWVkIHRvIGJlIG91dHB1dFxuICAgICAgICAgICAgICAgICFzZWxmLmRvbnRQZXJzaXN0W2tleV0gJiYgKFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25TY2hlbWEub3duIHx8IC8vIG91dHB1dCBiZWNhdXNlIGl0J3MgYW4gXCJvd25cIiBvcHRpb24gKGJlbG9uZ3MgdG8gdGhlIG5vZGUpXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLnBhcmVudCB8fCAvLyBvdXRwdXQgYmVjYXVzZSBpdCdzIHRoZSByb290IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgc2VsZltrZXldICE9PSBzZWxmLnBhcmVudFtrZXldIC8vIG91dHB1dCBiZWNhdXNlIGl0IGRpZmZlcnMgZnJvbSBpdHMgcGFyZW50J3MgdmVyc2lvblxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHN0YXRlW2tleV0gPSBzZWxmW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSBjYXNlIHNlbnNpdGl2aXR5IG9mIGZpbHRlciB0ZXN0cyBhZ2FpbnN0IGRhdGEuXG4gICAgICogQGRlc2MgQ2FzZSBzZW5zaXRpdml0eSBwZXJ0YWlucyB0byBzdHJpbmcgY29tcGFyZXMgb25seS4gVGhpcyBpbmNsdWRlcyB1bnR5cGVkIGNvbHVtbnMsIGNvbHVtbnMgdHlwZWQgYXMgc3RyaW5ncywgdHlwZWQgY29sdW1ucyBjb250YWluaW5nIGRhdGEgdGhhdCBjYW5ub3QgYmUgY29lcmNlZCB0byB0eXBlIG9yIHdoZW4gdGhlIGZpbHRlciBleHByZXNzaW9uIG9wZXJhbmQgY2Fubm90IGJlIGNvZXJjZWQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIGEgc2hhcmVkIHByb3BlcnR5IGFuZCBhZmZlY3RzIGFsbCBmaWx0ZXItdHJlZSBpbnN0YW5jZXMgY29uc3RydWN0ZWQgYnkgdGhpcyBjb2RlIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTZW5zaXRpdmVcbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVydHJlZS5wcm90b3R5cGUucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0Q2FzZVNlbnNpdGl2aXR5OiBmdW5jdGlvbihpc1NlbnNpdGl2ZSkge1xuICAgICAgICB2YXIgdG9TdHJpbmcgPSBpc1NlbnNpdGl2ZSA/IHRvU3RyaW5nQ2FzZVNlbnNpdGl2ZSA6IHRvU3RyaW5nQ2FzZUluc2Vuc2l0aXZlO1xuICAgICAgICBGaWx0ZXJMZWFmLnNldFRvU3RyaW5nKHRvU3RyaW5nKTtcbiAgICB9XG5cbn0pO1xuXG5mdW5jdGlvbiB0b1N0cmluZ0Nhc2VJbnNlbnNpdGl2ZShzKSB7IHJldHVybiAocyArICcnKS50b1VwcGVyQ2FzZSgpOyB9XG5mdW5jdGlvbiB0b1N0cmluZ0Nhc2VTZW5zaXRpdmUocykgeyByZXR1cm4gcyArICcnOyB9XG5cbi8vIFNvbWUgZXZlbnQgaGFuZGxlcnMgYm91bmQgdG8gRmlsdGVyVHJlZSBvYmplY3RcblxuZnVuY3Rpb24gb25jaGFuZ2UoZXZ0KSB7IC8vIGNhbGxlZCBpbiBjb250ZXh0XG4gICAgdmFyIGN0cmwgPSBldnQudGFyZ2V0O1xuICAgIGlmIChjdHJsLnBhcmVudEVsZW1lbnQgPT09IHRoaXMuZWwpIHtcbiAgICAgICAgaWYgKGN0cmwudmFsdWUgPT09ICdzdWJleHAnKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2gobmV3IEZpbHRlclRyZWUoe1xuICAgICAgICAgICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGQoe1xuICAgICAgICAgICAgICAgIHN0YXRlOiB7IGVkaXRvcjogY3RybC52YWx1ZSB9LFxuICAgICAgICAgICAgICAgIGZvY3VzOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdHJsLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gb25UcmVlT3BDbGljayhldnQpIHsgLy8gY2FsbGVkIGluIGNvbnRleHRcbiAgICB2YXIgY3RybCA9IGV2dC50YXJnZXQ7XG5cbiAgICBpZiAoY3RybC5jbGFzc05hbWUgPT09ICdmaWx0ZXItdHJlZS1vcC1jaG9pY2UnKSB7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBjdHJsLnZhbHVlO1xuXG4gICAgICAgIC8vIGRpc3BsYXkgc3RyaWtlLXRocm91Z2hcbiAgICAgICAgdmFyIHJhZGlvQnV0dG9ucyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCgnbGFiZWw+aW5wdXQuZmlsdGVyLXRyZWUtb3AtY2hvaWNlW25hbWU9JyArIGN0cmwubmFtZSArICddJyk7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwocmFkaW9CdXR0b25zLCBmdW5jdGlvbihjdHJsKSB7XG4gICAgICAgICAgICBjdHJsLnBhcmVudEVsZW1lbnQuc3R5bGUudGV4dERlY29yYXRpb24gPSBjdHJsLmNoZWNrZWQgPyAnbm9uZScgOiAnbGluZS10aHJvdWdoJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZGlzcGxheSBvcGVyYXRvciBiZXR3ZWVuIGZpbHRlcnMgYnkgYWRkaW5nIG9wZXJhdG9yIHN0cmluZyBhcyBhIENTUyBjbGFzcyBvZiB0aGlzIHRyZWVcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wZXJhdG9ycykge1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKHRoaXMub3BlcmF0b3IpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd3MgZXJyb3IgaWYgaW52YWxpZCBleHByZXNzaW9uIHRyZWUuXG4gKiBDYXVnaHQgYnkge0BsaW5rIEZpbHRlclRyZWUjaW52YWxpZHxGaWx0ZXJUcmVlLnByb3RvdHlwZS5pbnZhbGlkKCl9LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mb2N1cz1mYWxzZV0gLSBNb3ZlIGZvY3VzIHRvIG9mZmVuZGluZyBjb250cm9sLlxuICogQHJldHVybnMge3VuZGVmaW5lZH0gaWYgdmFsaWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGludmFsaWQob3B0aW9ucykgeyAvLyBjYWxsZWQgaW4gY29udGV4dFxuICAgIC8vaWYgKHRoaXMgaW5zdGFuY2VvZiBGaWx0ZXJUcmVlICYmICF0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgIC8vICAgIHRocm93IG5ldyB0aGlzLkVycm9yKCdFbXB0eSBzdWJleHByZXNzaW9uIChubyBmaWx0ZXJzKS4nKTtcbiAgICAvL31cblxuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBGaWx0ZXJMZWFmKSB7XG4gICAgICAgICAgICBjaGlsZC5pbnZhbGlkKG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgaW52YWxpZC5jYWxsKGNoaWxkLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5GaWx0ZXJUcmVlLmV4dGVuc2lvbnMgPSB7XG4gICAgQ29sdW1uczogcmVxdWlyZSgnLi9leHRlbnNpb25zL2NvbHVtbnMnKVxufTtcblxuLy8gbW9kdWxlIGluaXRpYWxpemF0aW9uXG5GaWx0ZXJUcmVlLnByb3RvdHlwZS5zZXRDYXNlU2Vuc2l0aXZpdHkodHJ1ZSk7ICAvLyBkZWZhdWx0IGlzIGNhc2Utc2Vuc2l0aXZlIHdoaWNoIGlzIG1vcmUgZWZmaWNpZW50OyBtYXkgYmUgcmVzZXQgYXQgd2lsbFxuXG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyVHJlZTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0ZW1wbGV4ID0gcmVxdWlyZSgndGVtcGxleCcpO1xuXG52YXIgdGVtcGxhdGVzID0gcmVxdWlyZSgnLi4vaHRtbCcpO1xuXG52YXIgZW5jb2RlcnMgPSAvXFx7KFxcZCspXFw6ZW5jb2RlXFx9L2c7XG5cbmZ1bmN0aW9uIFRlbXBsYXRlcygpIHt9XG52YXIgY29uc3RydWN0b3IgPSBUZW1wbGF0ZXMucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuVGVtcGxhdGVzLnByb3RvdHlwZSA9IHRlbXBsYXRlcztcblRlbXBsYXRlcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjsgLy8gcmVzdG9yZSBpdFxuVGVtcGxhdGVzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih0ZW1wbGF0ZU5hbWUpIHsgLy8gbWl4IGl0IGluXG4gICAgdmFyIGtleXMsXG4gICAgICAgIG1hdGNoZXMgPSB7fSxcbiAgICAgICAgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICB0ZXh0ID0gdGhpc1t0ZW1wbGF0ZU5hbWVdLFxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIGVuY29kZXJzLmxhc3RJbmRleCA9IDA7XG5cbiAgICB3aGlsZSAoKGtleXMgPSBlbmNvZGVycy5leGVjKHRleHQpKSkge1xuICAgICAgICBtYXRjaGVzW2tleXNbMV1dID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMobWF0Y2hlcyk7XG5cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdGVtcC50ZXh0Q29udGVudCA9IGFyZ3Nba2V5XTtcbiAgICAgICAgICAgIGFyZ3Nba2V5XSA9IHRlbXAuaW5uZXJIVE1MO1xuICAgICAgICB9KTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShlbmNvZGVycywgJ3skMX0nKTtcbiAgICB9XG5cbiAgICB0ZW1wLmlubmVySFRNTCA9IHRlbXBsZXguYXBwbHkodGhpcywgW3RleHRdLmNvbmNhdChhcmdzKSk7XG5cbiAgICAvLyBpZiBvbmx5IG9uZSBIVE1MRWxlbWVudCwgcmV0dXJuIGl0OyBvdGhlcndpc2UgZW50aXJlIGxpc3Qgb2Ygbm9kZXNcbiAgICByZXR1cm4gdGVtcC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgdGVtcC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IHRlbXAuZmlyc3RDaGlsZFxuICAgICAgICA6IHRlbXAuY2hpbGROb2Rlcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGVtcGxhdGVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29uZGl0aW9uYWxzID0gcmVxdWlyZSgnLi4vQ29uZGl0aW9uYWxzJyk7XG52YXIgRmlsdGVyTGVhZiA9IHJlcXVpcmUoJy4uL0ZpbHRlckxlYWYnKTtcblxuLyoqXG4gKiBAc3VtbWFyeSBQcm90b3R5cGUgYWRkaXRpb25zIG9iamVjdCBmb3IgZXh0ZW5kaW5nIHtAbGluayBGaWx0ZXJMZWFmfS5cbiAqIEBkZXNjIFJlc3VsdGluZyBvYmplY3QgaXMgc2ltaWxhciB0byB7QGxpbmsgRmlsdGVyTGVhZn0gZXhjZXB0OlxuICogMS4gVGhlIGBvcGVyYW5kYCBwcm9wZXJ0eSBuYW1lcyBhbm90aGVyIGNvbHVtbiByYXRoZXIgdGhhbiBjb250YWlucyBhIGxpdGVyYWwuXG4gKiAyLiBPcGVyYXRvcnMgYXJlIGxpbWl0ZWQgdG8gZXF1YWxpdHksIGluZXF1YWxpdGllcywgYW5kIHNldHMgKElOL05PVCBJTikuIE9taXR0ZWQgYXJlIHRoZSBzdHJpbmcgYW5kIHBhdHRlcm4gc2NhbnMgKEJFR0lOUy9OT1QgQkVHSU5TLCBFTkRTL05PVCBFTkRTLCBDT05UQUlOUy9OT1QgQ09OVEFJTlMsIGFuZCBMSUtFL05PVCBMSUtFKS5cbiAqXG4gKiBAZXh0ZW5kcyBGaWx0ZXJMZWFmXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkZW50aWZpZXIgLSBOYW1lIG9mIGNvbHVtbiAobWVtYmVyIG9mIGRhdGEgcm93IG9iamVjdCkgdG8gY29tcGFyZSBhZ2FpbnN0IHRoaXMgY29sdW1uIChtZW1iZXIgb2YgZGF0YSByb3cgb2JqZWN0IG5hbWVkIGJ5IGBjb2x1bW5gKS5cbiAqL1xudmFyIENvbHVtbkxlYWYgPSB7XG4gICAgbmFtZTogJ2NvbHVtbiA9IGNvbHVtbicsIC8vIGRpc3BsYXkgc3RyaW5nIGZvciBkcm9wLWRvd25cblxuICAgIGNyZWF0ZVZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGB2aWV3YCBoYXNoIGFuZCBpbnNlcnQgdGhlIHRocmVlIGRlZmF1bHQgZWxlbWVudHMgKGBjb2x1bW5gLCBgb3BlcmF0b3JgLCBgb3BlcmFuZGApIGludG8gYC5lbGBcbiAgICAgICAgRmlsdGVyTGVhZi5wcm90b3R5cGUuY3JlYXRlVmlldy5jYWxsKHRoaXMpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGBvcGVyYW5kYCBlbGVtZW50IGZyb20gdGhlIGB2aWV3YCBoYXNoXG4gICAgICAgIHZhciBvbGRPcGVyYW5kID0gdGhpcy52aWV3Lm9wZXJhbmQsXG4gICAgICAgICAgICBuZXdPcGVyYW5kID0gdGhpcy52aWV3Lm9wZXJhbmQgPSB0aGlzLm1ha2VFbGVtZW50KHRoaXMucm9vdC5zY2hlbWEsICdjb2x1bW4nLCB0aGlzLnNvcnRDb2x1bW5NZW51KTtcblxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBvcGVyYW5kIGVsZW1lbnQgd2l0aCB0aGUgbmV3IG9uZS4gVGhlcmUgYXJlIG5vIGV2ZW50IGxpc3RlbmVycyB0byB3b3JyeSBhYm91dC5cbiAgICAgICAgdGhpcy5lbC5yZXBsYWNlQ2hpbGQobmV3T3BlcmFuZCwgb2xkT3BlcmFuZCk7XG4gICAgfSxcblxuICAgIG1ha2VTcWxPcGVyYW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uYWxzLm1ha2VTcWxJZGVudGlmaWVyKHRoaXMub3BlcmFuZCk7XG4gICAgfSxcblxuICAgIG9wTWVudTogW1xuICAgICAgICBDb25kaXRpb25hbHMuZ3JvdXBzLmVxdWFsaXR5LFxuICAgICAgICBDb25kaXRpb25hbHMuZ3JvdXBzLmluZXF1YWxpdGllcyxcbiAgICAgICAgQ29uZGl0aW9uYWxzLmdyb3Vwcy5zZXRzXG4gICAgXSxcblxuICAgIHE6IGZ1bmN0aW9uKGRhdGFSb3cpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFSb3dbdGhpcy5vcGVyYW5kXTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtbkxlYWY7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZU9wID0gL14oKD18Pj0/fDxbPj1dPyl8KE5PVCApPyhMSUtFfElOKVxcYikvaSwgLy8gbWF0Y2hbMV1cbiAgICByZUxpdCA9IC9eJyhcXGQrKScvLFxuICAgIHJlTGl0QW55d2hlcmUgPSAvJyhcXGQrKScvLFxuICAgIHJlSW4gPSAvXlxcKCguKj8pXFwpLyxcbiAgICByZUJvb2wgPSAvXihBTkR8T1IpXFxiL2ksXG4gICAgcmVHcm91cCA9IC9eKE5PVCA/KT9cXCgvaTtcblxudmFyIFNRVCA9ICdcXCcnO1xuXG52YXIgZGVmYXVsdElkUXRzID0ge1xuICAgIGJlZzogJ1wiJyxcbiAgICBlbmQ6ICdcIidcbn07XG5cbmZ1bmN0aW9uIFBhcnNlclNxbEVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuUGFyc2VyU3FsRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuUGFyc2VyU3FsRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnUGFyc2VyU3FsRXJyb3InO1xuXG4vKiogQHR5cGVkZWYge29iamVjdH0gc3FsSWRRdHNPYmplY3RcbiAqIEBkZXNjIE9uIGEgcHJhY3RpY2FsIGxldmVsLCB0aGUgdXNlZnVsIGNoYXJhY3RlcnMgYXJlOlxuICogKiBTUUwtOTIgc3RhbmRhcmQ6IFwiZG91YmxlIHF1b3Rlc1wiXG4gKiAqIFNRTCBTZXJ2ZXI6IFwiZG91YmxlIHF1b3Rlc1wiIG9yIFxcW3NxdWFyZSBicmFja2V0c1xcXVxuICogKiBteVNRTDogXFxgdGljayBtYXJrc1xcYFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJlZyAtIFRoZSBvcGVuIHF1b3RlIGNoYXJhY3Rlci5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBlbmQgLSBUaGUgY2xvc2UgcXVvdGUgY2hhcmFjdGVyLlxuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3VtbWFyeSBTdHJ1Y3R1cmVkIFF1ZXJ5IExhbmd1YWdlIChTUUwpIHBhcnNlclxuICogQGF1dGhvciBKb25hdGhhbiBFaXRlbiA8am9uYXRoYW5Ab3BlbmZpbi5jb20+XG4gKiBAZGVzYyBUaGlzIGlzIGEgc3Vic2V0IG9mIFNRTCBjb25kaXRpb25hbCBleHByZXNzaW9uIHN5bnRheC5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zMTczNTQ1LmFzcHggU1FMIFNlYXJjaCBDb25kaXRpb259XG4gKlxuICogQHBhcmFtIHttZW51SXRlbVtdfSBbb3B0aW9ucy5zY2hlbWFdIC0gQ29sdW1uIHNjaGVtYSBmb3IgY29sdW1uIG5hbWUgdmFsaWRhdGlvbi4gVGhyb3dzIGFuIGVycm9yIGlmIG5hbWUgZmFpbHMgdmFsaWRhdGlvbiAoYnV0IHNlZSBgcmVzb2x2ZUFsaWFzZXNgKS4gT21pdCB0byBza2lwIGNvbHVtbiBuYW1lIHZhbGlkYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlc29sdmVBbGlhc2VzXSAtIFZhbGlkYXRlIGNvbHVtbiBhbGlhc2VzIGFnYWluc3Qgc2NoZW1hIGFuZCB1c2UgdGhlIGFzc29jaWF0ZWQgY29sdW1uIG5hbWUgaW4gdGhlIHJldHVybmVkIGV4cHJlc3Npb24gc3RhdGUgb2JqZWN0LiBSZXF1aXJlcyBgb3B0aW9ucy5zY2hlbWFgLiBUaHJvd3MgZXJyb3IgaWYgbm8gc3VjaCBjb2x1bW4gZm91bmQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNhc2VTZW5zaXRpdmVDb2x1bW5OYW1lc10gLSBJZ25vcmUgY2FzZSB3aGlsZSB2YWxpZGF0aW5nIGNvbHVtbiBuYW1lcyBhbmQgYWxpYXNlcy5cbiAqIEBwYXJhbSB7c3FsSWRRdHNPYmplY3R9IFtvcHRpb25zLnNxbElkUXRzPXtiZWc6J1wiJyxlbmQ6J1wiJ31dXG4gKi9cbmZ1bmN0aW9uIFBhcnNlclNRTChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLnNjaGVtYSA9IG9wdGlvbnMuc2NoZW1hO1xuXG4gICAgdmFyIGlkUXRzID0gb3B0aW9ucy5zcWxJZFF0cyB8fCBkZWZhdWx0SWRRdHM7XG4gICAgdGhpcy5yZU5hbWUgPSBuZXcgUmVnRXhwKCdeKCcgKyBpZFF0cy5iZWcgKyAnKC4rPyknICsgaWRRdHMuZW5kICsgJ3woW0EtWl9dW0EtWl9AXFxcXCQjXSopXFxcXGIpJywgJ2knKTsgLy8gbWF0Y2hbMl0gfHwgbWF0Y2hbM11cbn1cblxuUGFyc2VyU1FMLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBQYXJzZXJTUUwucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNxbFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3FsU2VhcmNoQ29uZGl0aW9uXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHNxbCkge1xuICAgICAgICB2YXIgc3RhdGU7XG5cbiAgICAgICAgLy8gcmVkdWNlIGFsbCBydW5zIG9mIHdoaXRlIHNwYWNlIHRvIGEgc2luZ2xlIHNwYWNlOyB0aGVuIHRyaW1cbiAgICAgICAgc3FsID0gc3FsLnJlcGxhY2UoL1xcc1xccysvZywgJyAnKS50cmltKCk7XG5cbiAgICAgICAgc3FsID0gc3RyaXBMaXRlcmFscy5jYWxsKHRoaXMsIHNxbCk7XG4gICAgICAgIHN0YXRlID0gd2Fsay5jYWxsKHRoaXMsIHNxbCk7XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgc3RhdGUgPSB7IGNoaWxkcmVuOiBbIHN0YXRlIF0gfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiB3YWxrKHQpIHtcbiAgICB2YXIgbSwgbmFtZSwgb3AsIG9wZXJhbmQsIGJvb2wsIHRva2VuLCB0b2tlbnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB0ID0gdC50cmltKCk7XG5cbiAgICB3aGlsZSAoaSA8IHQubGVuZ3RoKSB7XG4gICAgICAgIG0gPSB0LnN1YnN0cihpKS5tYXRjaChyZUdyb3VwKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHZhciBub3QgPSAhIW1bMV07XG5cbiAgICAgICAgICAgIGkgKz0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSwgdiA9IDE7IGogPCB0Lmxlbmd0aCAmJiB2OyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAodFtqXSA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgICsrdjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRbal0gPT09ICcpJykge1xuICAgICAgICAgICAgICAgICAgICAtLXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZXJTcWxFcnJvcignRXhwZWN0ZWQgXCIpXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuID0gd2Fsay5jYWxsKHRoaXMsIHQuc3Vic3RyKGksIGogLSAxIC0gaSkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4ub3BlcmF0b3IgIT09ICdvcC1vcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlclNxbEVycm9yKCdFeHBlY3RlZCBPUiBpbiBOT1QoLi4uKSBzdWJleHByZXNzaW9uIGJ1dCBmb3VuZCAnICsgdG9rZW4ub3BlcmF0b3Iuc3Vic3RyKDMpLnRvVXBwZXJDYXNlKCkgKyAnLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbi5vcGVyYXRvciA9ICdvcC1ub3InO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpID0gajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG0gPSB0LnN1YnN0cihpKS5tYXRjaCh0aGlzLnJlTmFtZSk7XG4gICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VyU3FsRXJyb3IoJ0V4cGVjdGVkIGlkZW50aWZpZXIgb3IgcXVvdGVkIGlkZW50aWZpZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lID0gbVsyXSB8fCBtWzNdO1xuICAgICAgICAgICAgaWYgKCEvXltBLVpfXS9pLnRlc3QodFtpXSkpIHsgaSArPSAyOyB9XG4gICAgICAgICAgICBpICs9IG5hbWUubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAodFtpXSA9PT0gJyAnKSB7ICsraTsgfVxuICAgICAgICAgICAgbSA9IHQuc3Vic3RyKGkpLm1hdGNoKHJlT3ApO1xuICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlclNxbEVycm9yKCdFeHBlY3RlZCByZWxhdGlvbmFsIG9wZXJhdG9yLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBtWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpICs9IG9wLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKHRbaV0gPT09ICcgJykgeyArK2k7IH1cbiAgICAgICAgICAgIGlmIChtWzRdICYmIG1bNF0udG9VcHBlckNhc2UoKSA9PT0gJ0lOJykge1xuICAgICAgICAgICAgICAgIG0gPSB0LnN1YnN0cihpKS5tYXRjaChyZUluKTtcbiAgICAgICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlclNxbEVycm9yKCdFeHBlY3RlZCBwYXJlbnRoZXNpemVkIGxpc3QuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wZXJhbmQgPSBtWzFdO1xuICAgICAgICAgICAgICAgIGkgKz0gb3BlcmFuZC5sZW5ndGggKyAyO1xuICAgICAgICAgICAgICAgIHdoaWxlICgobSA9IG9wZXJhbmQubWF0Y2gocmVMaXRBbnl3aGVyZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhbmQgPSBvcGVyYW5kLnJlcGxhY2UocmVMaXRBbnl3aGVyZSwgdGhpcy5saXRlcmFsc1ttWzFdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtID0gdC5zdWJzdHIoaSkubWF0Y2gocmVMaXQpO1xuICAgICAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VyU3FsRXJyb3IoJ0V4cGVjdGVkIHN0cmluZyBsaXRlcmFsLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcGVyYW5kID0gbVsxXTtcbiAgICAgICAgICAgICAgICBpICs9IG9wZXJhbmQubGVuZ3RoICsgMjtcbiAgICAgICAgICAgICAgICBvcGVyYW5kID0gdGhpcy5saXRlcmFsc1tvcGVyYW5kXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLnNjaGVtYS5sb29rdXAobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGl0ZW0ubmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VyU3FsRXJyb3IodGhpcy5yZXNvbHZlQWxpYXNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnRXhwZWN0ZWQgdmFsaWQgY29sdW1uIG5hbWUuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAnRXhwZWN0ZWQgdmFsaWQgY29sdW1uIG5hbWUgb3IgYWxpYXMuJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9rZW4gPSB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBuYW1lLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBvcCxcbiAgICAgICAgICAgICAgICBvcGVyYW5kOiBvcGVyYW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgICAgIGlmIChpIDwgdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0W2ldID09PSAnICcpIHsgKytpOyB9XG4gICAgICAgICAgICBtID0gdC5zdWJzdHIoaSkubWF0Y2gocmVCb29sKTtcbiAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZXJTcWxFcnJvcignRXhwZWN0ZWQgYm9vbGVhbiBvcGVhcmF0b3IuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib29sID0gbVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaSArPSBib29sLmxlbmd0aDtcbiAgICAgICAgICAgIGJvb2wgPSAnb3AtJyArIGJvb2w7XG4gICAgICAgICAgICBpZiAodG9rZW5zLm9wZXJhdG9yICYmIHRva2Vucy5vcGVyYXRvciAhPT0gYm9vbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZXJTcWxFcnJvcignRXhwZWN0ZWQgc2FtZSBib29sZWFuIG9wZXJhdG9yIHRocm91Z2hvdXQgc3ViZXhwcmVzc2lvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2Vucy5vcGVyYXRvciA9IGJvb2w7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodFtpXSA9PT0gJyAnKSB7ICsraTsgfVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAgIHRva2Vucy5sZW5ndGggPT09IDEgPyB0b2tlbnNbMF0gOiB7XG4gICAgICAgICAgICBvcGVyYXRvcjogdG9rZW5zLm9wZXJhdG9yLFxuICAgICAgICAgICAgY2hpbGRyZW46IHRva2Vuc1xuICAgICAgICB9XG4gICAgKTtcbn1cblxuZnVuY3Rpb24gc3RyaXBMaXRlcmFscyh0KSB7XG4gICAgdmFyIGkgPSAwLCBqID0gMCwgaztcblxuICAgIHRoaXMubGl0ZXJhbHMgPSBbXTtcblxuICAgIHdoaWxlICgoaiA9IHQuaW5kZXhPZihTUVQsIGopKSA+PSAwKSB7XG4gICAgICAgIGsgPSBqO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBrID0gdC5pbmRleE9mKFNRVCwgayArIDEpO1xuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlclNxbEVycm9yKCdFeHBlY3RlZCAnICsgU1FUICsgJyAoc2luZ2xlIHF1b3RlKS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodFsrK2tdID09PSBTUVQpO1xuICAgICAgICB0aGlzLmxpdGVyYWxzLnB1c2godC5zbGljZSgrK2osIC0taykucmVwbGFjZSgvJycvZywgU1FUKSk7XG4gICAgICAgIHQgPSB0LnN1YnN0cigwLCBqKSArIGkgKyB0LnN1YnN0cihrKTtcbiAgICAgICAgaiA9IGogKyAxICsgKGkgKyAnJykubGVuZ3RoICsgMTtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlclNRTDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNzc0luamVjdG9yID0gcmVxdWlyZSgnY3NzLWluamVjdG9yJyk7XG5cbnZhciBjc3M7IC8vIGRlZmluZWQgYnkgY29kZSBpbnNlcnRlZCBieSBndWxwZmlsZSBiZXR3ZWVuIGZvbGxvd2luZyBjb21tZW50c1xuLyogaW5qZWN0OmNzcyAqL1xuY3NzID0gJy5maWx0ZXItdHJlZXtmb250LWZhbWlseTpzYW5zLXNlcmlmO2ZvbnQtc2l6ZToxMHB0O2xpbmUtaGVpZ2h0OjEuNWVtfS5maWx0ZXItdHJlZSBsYWJlbHtmb250LXdlaWdodDo0MDB9LmZpbHRlci10cmVlIGlucHV0W3R5cGU9Y2hlY2tib3hdLC5maWx0ZXItdHJlZSBpbnB1dFt0eXBlPXJhZGlvXXttYXJnaW4tbGVmdDozcHg7bWFyZ2luLXJpZ2h0OjNweH0uZmlsdGVyLXRyZWUgb2x7bWFyZ2luLXRvcDowfS5maWx0ZXItdHJlZT5zZWxlY3R7ZmxvYXQ6cmlnaHQ7Ym9yZGVyOjFweCBkb3R0ZWQgZ3JleTtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2JveC1zaGFkb3c6bm9uZX0uZmlsdGVyLXRyZWUtcmVtb3ZlLWJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDoxNXB4O2hlaWdodDoxNXB4O2JvcmRlci1yYWRpdXM6OHB4O2JhY2tncm91bmQtY29sb3I6I2U4ODtmb250LXNpemU6MTEuNXB4O2NvbG9yOiNmZmY7dGV4dC1hbGlnbjpjZW50ZXI7bGluZS1oZWlnaHQ6bm9ybWFsO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7bWFyZ2luLXJpZ2h0OjRweDtjdXJzb3I6cG9pbnRlcn0uZmlsdGVyLXRyZWUtcmVtb3ZlLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2NvbG9yOiNlODg7Zm9udC13ZWlnaHQ6NzAwO2JveC1zaGFkb3c6cmVkIDAgMCAycHggaW5zZXR9LmZpbHRlci10cmVlLXJlbW92ZS1idXR0b246OmJlZm9yZXtjb250ZW50OlxcJ1xcXFxkN1xcJ30uZmlsdGVyLXRyZWUgbGk6OmFmdGVye2ZvbnQtc2l6ZTo3MCU7Zm9udC1zdHlsZTppdGFsaWM7Zm9udC13ZWlnaHQ6NzAwO2NvbG9yOiMwODB9LmZpbHRlci10cmVlPm9sPmxpOmxhc3QtY2hpbGQ6OmFmdGVye2Rpc3BsYXk6bm9uZX0ub3AtYW5kPm9sLC5vcC1ub3I+b2wsLm9wLW9yPm9se3BhZGRpbmctbGVmdDo1cHg7bWFyZ2luLWxlZnQ6MjdweH0ub3Atb3I+b2w+bGk6OmFmdGVye21hcmdpbi1sZWZ0OjIuNWVtO2NvbnRlbnQ6XFwn4oCUIE9SIOKAlFxcJ30ub3AtYW5kPm9sPmxpOjphZnRlcnttYXJnaW4tbGVmdDoyLjVlbTtjb250ZW50OlxcJ+KAlCBBTkQg4oCUXFwnfS5vcC1ub3I+b2w+bGk6OmFmdGVye21hcmdpbi1sZWZ0OjIuNWVtO2NvbnRlbnQ6XFwn4oCUIE5PUiDigJRcXCd9LmZpbHRlci10cmVlLWVkaXRvcj4qe2ZvbnQtd2VpZ2h0OjcwMH0uZmlsdGVyLXRyZWUtZWRpdG9yPnNwYW57Zm9udC1zaXplOnNtYWxsZXJ9LmZpbHRlci10cmVlLWVkaXRvcj5pbnB1dFt0eXBlPXRleHRde3dpZHRoOjhlbTtwYWRkaW5nOjFweCA1cHggMnB4fS5maWx0ZXItdHJlZS13YXJuaW5ne2JhY2tncm91bmQtY29sb3I6I2ZmYyFpbXBvcnRhbnQ7Ym9yZGVyLWNvbG9yOiNlZGIhaW1wb3J0YW50O2ZvbnQtd2VpZ2h0OjQwMCFpbXBvcnRhbnR9LmZpbHRlci10cmVlLWVycm9ye2JhY2tncm91bmQtY29sb3I6I2ZjYyFpbXBvcnRhbnQ7Ym9yZGVyLWNvbG9yOiNjOTkhaW1wb3J0YW50O2ZvbnQtd2VpZ2h0OjQwMCFpbXBvcnRhbnR9LmZpbHRlci10cmVlLWRlZmF1bHQ+OmVuYWJsZWR7bWFyZ2luOjAgLjRlbTtiYWNrZ3JvdW5kLWNvbG9yOiNkZGQ7Ym9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudH0uZmlsdGVyLXRyZWUuZmlsdGVyLXRyZWUtdHlwZS1jb2x1bW4tZmlsdGVycz5vbD5saTpub3QoOmxhc3QtY2hpbGQpe3BhZGRpbmctYm90dG9tOi43NWVtO2JvcmRlci1ib3R0b206M3B4IGRvdWJsZSAjMDgwO21hcmdpbi1ib3R0b206Ljc1ZW19LmZpbHRlci10cmVlIC5mb290bm90ZXN7bWFyZ2luOjAgMCA2cHg7Zm9udC1zaXplOjhwdDtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6bm9ybWFsO3doaXRlLXNwYWNlOm5vcm1hbDtjb2xvcjojYzAwfS5maWx0ZXItdHJlZSAuZm9vdG5vdGVzPnB7bWFyZ2luOjB9LmZpbHRlci10cmVlIC5mb290bm90ZXM+dWx7bWFyZ2luOi0zcHggMCAwO3BhZGRpbmctbGVmdDoxN3B4O3RleHQtaW5kZXg6LTZweH0uZmlsdGVyLXRyZWUgLmZvb3Rub3Rlcz51bD5saXttYXJnaW46MnB4IDB9LmZpbHRlci10cmVlIC5mb290bm90ZXMgLmZpZWxkLW5hbWUsLmZpbHRlci10cmVlIC5mb290bm90ZXMgLmZpZWxkLXZhbHVle2ZvbnQtd2VpZ2h0OjcwMDtmb250LXN0eWxlOm5vcm1hbH0uZmlsdGVyLXRyZWUgLmZvb3Rub3RlcyAuZmllbGQtdmFsdWV7Zm9udC1mYW1pbHk6bW9ub3NwYWNlO2NvbG9yOiMwMDA7YmFja2dyb3VuZC1jb2xvcjojZGRkO3BhZGRpbmc6MCA1cHg7bWFyZ2luOjAgM3B4O2JvcmRlci1yYWRpdXM6M3B4fSc7XG4vKiBlbmRpbmplY3QgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBjc3NJbmplY3Rvci5iaW5kKHRoaXMsIGNzcywgJ2ZpbHRlci10cmVlLWJhc2UnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlZGVmIHtmdW5jdGlvbn0gb3BlcmF0aW9uUmVkdWNlclxuICogQHBhcmFtIHtib29sZWFufSBwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHFcbiAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBvcGVyYXRvciB0byB0aGUgdHdvIHBhcmFtZXRlcnMuXG4gKi9cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge29wZXJhdGlvblJlZHVjZXJ9XG4gKi9cbmZ1bmN0aW9uIEFORChwLCBxKSB7XG4gICAgcmV0dXJuIHAgJiYgcTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge29wZXJhdGlvblJlZHVjZXJ9XG4gKi9cbmZ1bmN0aW9uIE9SKHAsIHEpIHtcbiAgICByZXR1cm4gcCB8fCBxO1xufVxuXG4vKiogQHR5cGVkZWYge29iZWpjdH0gdHJlZU9wZXJhdG9yXG4gKiBAZGVzYyBFYWNoIGB0cmVlT3BlcmF0b3JgIG9iamVjdCBkZXNjcmliZXMgdHdvIHRoaW5nczpcbiAqXG4gKiAxLiBIb3cgdG8gdGFrZSB0aGUgdGVzdCByZXN1bHRzIG9mIF9uXyBjaGlsZCBub2RlcyBieSBhcHBseWluZyB0aGUgb3BlcmF0b3IgdG8gYWxsIHRoZSByZXN1bHRzIHRvIFwicmVkdWNlXCIgaXQgZG93biB0byBhIHNpbmdsZSByZXN1bHQuXG4gKiAyLiBIb3cgdG8gZ2VuZXJhdGUgU1FMIFdIRVJFIGNsYXVzZSBzeW50YXggdGhhdCBhcHBsaWVzIHRoZSBvcGVyYXRvciB0byBfbl8gY2hpbGQgbm9kZXMuXG4gKlxuICogQHByb3BlcnR5IHtvcGVyYXRpb25SZWR1Y2VyfSByZWR1Y2VcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2VlZCAtXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGFib3J0IC1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbmVnYXRlIC1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBTUUwub3AgLVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFNRTC5iZWcgLVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFNRTC5lbmQgLVxuICovXG5cbi8qKiBBIGhhc2ggb2Yge0BsaW5rIHRyZWVPcGVyYXRvcn0gb2JqZWN0cy5cbiAqIEB0eXBlIHtvYmplY3R9XG4gKi9cbnZhciB0cmVlT3BlcmF0b3JzID0ge1xuICAgICdvcC1hbmQnOiB7XG4gICAgICAgIHJlZHVjZTogQU5ELFxuICAgICAgICBzZWVkOiB0cnVlLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIG5lZ2F0ZTogZmFsc2UsXG4gICAgICAgIFNRTDoge1xuICAgICAgICAgICAgb3A6ICdBTkQnLFxuICAgICAgICAgICAgYmVnOiAnKCcsXG4gICAgICAgICAgICBlbmQ6ICcpJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICAnb3Atb3InOiB7XG4gICAgICAgIHJlZHVjZTogT1IsXG4gICAgICAgIHNlZWQ6IGZhbHNlLFxuICAgICAgICBhYm9ydDogdHJ1ZSxcbiAgICAgICAgbmVnYXRlOiBmYWxzZSxcbiAgICAgICAgU1FMOiB7XG4gICAgICAgICAgICBvcDogJ09SJyxcbiAgICAgICAgICAgIGJlZzogJygnLFxuICAgICAgICAgICAgZW5kOiAnKSdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgJ29wLW5vcic6IHtcbiAgICAgICAgcmVkdWNlOiBPUixcbiAgICAgICAgc2VlZDogZmFsc2UsXG4gICAgICAgIGFib3J0OiB0cnVlLFxuICAgICAgICBuZWdhdGU6IHRydWUsXG4gICAgICAgIFNRTDoge1xuICAgICAgICAgICAgb3A6ICdPUicsXG4gICAgICAgICAgICBiZWc6ICdOT1QgKCcsXG4gICAgICAgICAgICBlbmQ6ICcpJ1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0cmVlT3BlcmF0b3JzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxudmFyIGNzc0luamVjdG9yID0gcmVxdWlyZSgnY3NzLWluamVjdG9yJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIEZpbkJhclxuICogQHN1bW1hcnkgQ3JlYXRlIGEgc2Nyb2xsYmFyIG9iamVjdC5cbiAqIEBkZXNjIENyZWF0aW5nIGEgc2Nyb2xsYmFyIGlzIGEgdGhyZWUtc3RlcCBwcm9jZXNzOlxuICpcbiAqIDEuIEluc3RhbnRpYXRlIHRoZSBzY3JvbGxiYXIgb2JqZWN0IGJ5IGNhbGxpbmcgdGhpcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi4gVXBvbiBpbnN0YW50aWF0aW9uLCB0aGUgRE9NIGVsZW1lbnQgZm9yIHRoZSBzY3JvbGxiYXIgKHdpdGggYSBzaW5nbGUgY2hpbGQgZWxlbWVudCBmb3IgdGhlIHNjcm9sbGJhciBcInRodW1iXCIpIGlzIGNyZWF0ZWQgYnV0IGlzIG5vdCBpbnNlcnQgaXQgaW50byB0aGUgRE9NLlxuICogMi4gQWZ0ZXIgaW5zdGFudGlhdGlvbiwgaXQgaXMgdGhlIGNhbGxlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGluc2VydCB0aGUgc2Nyb2xsYmFyLCB7QGxpbmsgRmluQmFyI2Jhcnx0aGlzLmJhcn0sIGludG8gdGhlIERPTS5cbiAqIDMuIEFmdGVyIGluc2VydGlvbiwgdGhlIGNhbGxlciBtdXN0IGNhbGwge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplKCl9IGF0IGxlYXN0IG9uY2UgdG8gc2l6ZSBhbmQgcG9zaXRpb24gdGhlIHNjcm9sbGJhciBhbmQgaXRzIHRodW1iLiBBZnRlciB0aGF0LCBgcmVzaXplKClgIHNob3VsZCBhbHNvIGJlIGNhbGxlZCByZXBlYXRlZGx5IG9uIHJlc2l6ZSBldmVudHMgKGFzIHRoZSBjb250ZW50IGVsZW1lbnQgaXMgYmVpbmcgcmVzaXplZCkuXG4gKlxuICogU3VnZ2VzdGVkIGNvbmZpZ3VyYXRpb25zOlxuICogKiBfKipVbmJvdW5kKipfPGJyLz5cbiAqIFRoZSBzY3JvbGxiYXIgc2VydmVzIG1lcmVseSBhcyBhIHNpbXBsZSByYW5nZSAoc2xpZGVyKSBjb250cm9sLiBPbWl0IGJvdGggYG9wdGlvbnMub25jaGFuZ2VgIGFuZCBgb3B0aW9ucy5jb250ZW50YC5cbiAqICogXyoqQm91bmQgdG8gdmlydHVhbCBjb250ZW50IGVsZW1lbnQqKl88YnIvPlxuICogVmlydHVhbCBjb250ZW50IGlzIHByb2plY3RlZCBpbnRvIHRoZSBlbGVtZW50IHVzaW5nIGEgY3VzdG9tIGV2ZW50IGhhbmRsZXIgc3VwcGxpZWQgYnkgdGhlIHByb2dyYW1tZXIgaW4gYG9wdGlvbnMub25jaGFuZ2VgLiBBIHR5cGljYWwgdXNlIGNhc2Ugd291bGQgYmUgdG8gaGFuZGxlIHNjcm9sbGluZyBvZiB0aGUgdmlydHVhbCBjb250ZW50LiBPdGhlciB1c2UgY2FzZXMgaW5jbHVkZSBkYXRhIHRyYW5zZm9ybWF0aW9ucywgZ3JhcGhpY3MgdHJhbnNmb3JtYXRpb25zLCBfZXRjLl9cbiAqICogXyoqQm91bmQgdG8gcmVhbCBjb250ZW50KipfPGJyLz5cbiAqIFNldCBgb3B0aW9ucy5jb250ZW50YCB0byB0aGUgXCJyZWFsXCIgY29udGVudCBlbGVtZW50IGJ1dCBvbWl0IGBvcHRpb25zLm9uY2hhbmdlYC4gVGhpcyB3aWxsIGNhdXNlIHRoZSBzY3JvbGxiYXIgdG8gdXNlIHRoZSBidWlsdC1pbiBldmVudCBoYW5kbGVyIChgdGhpcy5zY3JvbGxSZWFsQ29udGVudGApIHdoaWNoIGltcGxlbWVudHMgc21vb3RoIHNjcm9sbGluZyBvZiB0aGUgY29udGVudCBlbGVtZW50IHdpdGhpbiB0aGUgY29udGFpbmVyLlxuICpcbiAqIEBwYXJhbSB7ZmluYmFyT3B0aW9uc30gW29wdGlvbnM9e31dIC0gT3B0aW9ucyBvYmplY3QuIFNlZSB0aGUgdHlwZSBkZWZpbml0aW9uIGZvciBtZW1iZXIgZGV0YWlscy5cbiAqL1xuZnVuY3Rpb24gRmluQmFyKG9wdGlvbnMpIHtcblxuICAgIC8vIG1ha2UgYm91bmQgdmVyc2lvbnMgb2YgYWxsIHRoZSBtb3VzZSBldmVudCBoYW5kbGVyXG4gICAgdmFyIGJvdW5kID0gdGhpcy5fYm91bmQgPSB7fTtcbiAgICBmb3IgKGtleSBpbiBoYW5kbGVyc1RvQmVCb3VuZCkge1xuICAgICAgICBib3VuZFtrZXldID0gaGFuZGxlcnNUb0JlQm91bmRba2V5XS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHRodW1iXG4gICAgICogQHN1bW1hcnkgVGhlIGdlbmVyYXRlZCBzY3JvbGxiYXIgdGh1bWIgZWxlbWVudC5cbiAgICAgKiBAZGVzYyBUaGUgdGh1bWIgZWxlbWVudCdzIHBhcmVudCBlbGVtZW50IGlzIGFsd2F5cyB0aGUge0BsaW5rIEZpbkJhciNiYXJ8YmFyfSBlbGVtZW50LlxuICAgICAqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBpcyB0eXBpY2FsbHkgcmVmZXJlbmNlZCBpbnRlcm5hbGx5IG9ubHkuIFRoZSBzaXplIGFuZCBwb3NpdGlvbiBvZiB0aGUgdGh1bWIgZWxlbWVudCBpcyBtYWludGFpbmVkIGJ5IGBfY2FsY1RodW1iKClgLlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgdmFyIHRodW1iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGh1bWIuY2xhc3NMaXN0LmFkZCgndGh1bWInKTtcbiAgICB0aHVtYi5vbmNsaWNrID0gYm91bmQuc2hvcnRTdG9wO1xuICAgIHRodW1iLm9ubW91c2VvdmVyID0gYm91bmQub25tb3VzZW92ZXI7XG4gICAgdGhpcy50aHVtYiA9IHRodW1iO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgYmFyXG4gICAgICogQHN1bW1hcnkgVGhlIGdlbmVyYXRlZCBzY3JvbGxiYXIgZWxlbWVudC5cbiAgICAgKiBAZGVzYyBUaGUgY2FsbGVyIGluc2VydHMgdGhpcyBlbGVtZW50IGludG8gdGhlIERPTSAodHlwaWNhbGx5IGludG8gdGhlIGNvbnRlbnQgY29udGFpbmVyKSBhbmQgdGhlbiBjYWxscyBpdHMge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplKCl9IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIFRodXMgdGhlIG5vZGUgdHJlZSBpcyB0eXBpY2FsbHk6XG4gICAgICogKiBBICoqY29udGVudCBjb250YWluZXIqKiBlbGVtZW50LCB3aGljaCBjb250YWluczpcbiAgICAgKiAgICAqIFRoZSBjb250ZW50IGVsZW1lbnQocylcbiAgICAgKiAgICAqIFRoaXMgKipzY3JvbGxiYXIgZWxlbWVudCoqLCB3aGljaCBpbiB0dXJuIGNvbnRhaW5zOlxuICAgICAqICAgICAgICAqIFRoZSAqKnRodW1iIGVsZW1lbnQqKlxuICAgICAqXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB2YXIgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBiYXIuY2xhc3NMaXN0LmFkZCgnZmluYmFyLXZlcnRpY2FsJyk7XG5cbiAgICBiYXIuYXBwZW5kQ2hpbGQodGh1bWIpO1xuICAgIGlmICh0aGlzLnBhZ2luZykge1xuICAgICAgICBiYXIub25jbGljayA9IGJvdW5kLm9uY2xpY2s7XG4gICAgfVxuICAgIHRoaXMuYmFyID0gYmFyO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBwcmVzZXRzXG4gICAgdGhpcy5vcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCc7XG4gICAgdGhpcy5fbWluID0gdGhpcy5faW5kZXggPSAwO1xuICAgIHRoaXMuX21heCA9IDEwMDtcblxuICAgIC8vIG9wdGlvbnNcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcblxuICAgICAgICAgICAgY2FzZSAnaW5kZXgnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gb3B0aW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdyYW5nZSc6XG4gICAgICAgICAgICAgICAgdmFsaWRSYW5nZShvcHRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbiA9IG9wdGlvbi5taW47XG4gICAgICAgICAgICAgICAgdGhpcy5fbWF4ID0gb3B0aW9uLm1heDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gb3B0aW9uLm1heCAtIG9wdGlvbi5taW4gKyAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAga2V5LmNoYXJBdCgwKSAhPT0gJ18nICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBGaW5CYXIucHJvdG90eXBlW2tleV0gIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3ZlcnJpZGUgcHJvdG90eXBlIGRlZmF1bHRzIGZvciBzdGFuZGFyZCA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4dGVuZCB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcyAoZm9yIHVzZSBpbiBvbmNoYW5nZSBldmVudCBoYW5kbGVycylcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gb3B0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3NzSW5qZWN0b3IoY3NzRmluQmFycywgJ2ZpbmJhci1iYXNlJywgb3B0aW9ucy5jc3NTdHlsZXNoZWV0UmVmZXJlbmNlRWxlbWVudCk7XG59XG5cbkZpbkJhci5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUaGUgc2Nyb2xsYmFyIG9yaWVudGF0aW9uLlxuICAgICAqIEBkZXNjIFNldCBieSB0aGUgY29uc3RydWN0b3IgdG8gZWl0aGVyIGAndmVydGljYWwnYCBvciBgJ2hvcml6b250YWwnYC4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBVc2VmdWwgdmFsdWVzIGFyZSBgJ3ZlcnRpY2FsJ2AgKHRoZSBkZWZhdWx0KSBvciBgJ2hvcml6b250YWwnYC5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSByZXNldHMgYHRoaXMub2hgIGFuZCBgdGhpcy5kZWx0YVByb3BgIGFuZCBjaGFuZ2VzIHRoZSBjbGFzcyBuYW1lcyBzbyBhcyB0byByZXBvc2l0aW9uIHRoZSBzY3JvbGxiYXIgYXMgcGVyIHRoZSBDU1MgcnVsZXMgZm9yIHRoZSBuZXcgb3JpZW50YXRpb24uXG4gICAgICogQGRlZmF1bHQgJ3ZlcnRpY2FsJ1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXQgb3JpZW50YXRpb24ob3JpZW50YXRpb24pIHtcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSB0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBuYW1lIG9oXG4gICAgICAgICAqIEBzdW1tYXJ5IDx1Pk88L3U+cmllbnRhdGlvbiA8dT5oPC91PmFzaCBmb3IgdGhpcyBzY3JvbGxiYXIuXG4gICAgICAgICAqIEBkZXNjIFNldCBieSB0aGUgYG9yaWVudGF0aW9uYCBzZXR0ZXIgdG8gZWl0aGVyIHRoZSB2ZXJ0aWNhbCBvciB0aGUgaG9yaXpvbnRhbCBvcmllbnRhdGlvbiBoYXNoLiBUaGUgcHJvcGVydHkgc2hvdWxkIGFsd2F5cyBiZSBzeW5jaHJvbml6ZWQgd2l0aCBgb3JpZW50YXRpb25gOyBkbyBub3QgdXBkYXRlIGRpcmVjdGx5IVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG9iamVjdCBpcyB1c2VkIGludGVybmFsbHkgdG8gYWNjZXNzIHNjcm9sbGJhcnMnIERPTSBlbGVtZW50IHByb3BlcnRpZXMgaW4gYSBnZW5lcmFsaXplZCB3YXkgd2l0aG91dCBuZWVkaW5nIHRvIGNvbnN0YW50bHkgcXVlcnkgdGhlIHNjcm9sbGJhciBvcmllbnRhdGlvbi4gRm9yIGV4YW1wbGUsIGluc3RlYWQgb2YgZXhwbGljaXRseSBjb2RpbmcgYHRoaXMuYmFyLnRvcGAgZm9yIGEgdmVydGljYWwgc2Nyb2xsYmFyIGFuZCBgdGhpcy5iYXIubGVmdGAgZm9yIGEgaG9yaXpvbnRhbCBzY3JvbGxiYXIsIHNpbXBseSBjb2RlIGB0aGlzLmJhclt0aGlzLm9oLmxlYWRpbmddYCBpbnN0ZWFkLiBTZWUgdGhlIHtAbGluayBvcmllbnRhdGlvbkhhc2hUeXBlfSBkZWZpbml0aW9uIGZvciBkZXRhaWxzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG9iamVjdCBpcyB1c2VmdWwgZXh0ZXJuYWxseSBmb3IgY29kaW5nIGdlbmVyYWxpemVkIHtAbGluayBmaW5iYXJPbkNoYW5nZX0gZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMgdGhhdCBzZXJ2ZSBib3RoIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHNjcm9sbGJhcnMuXG4gICAgICAgICAqIEB0eXBlIHtvcmllbnRhdGlvbkhhc2hUeXBlfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vaCA9IG9yaWVudGF0aW9uSGFzaGVzW3RoaXMuX29yaWVudGF0aW9uXTtcblxuICAgICAgICBpZiAoIXRoaXMub2gpIHtcbiAgICAgICAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBgb3B0aW9ucy5fb3JpZW50YXRpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgZGVsdGFQcm9wXG4gICAgICAgICAqIEBzdW1tYXJ5IFRoZSBuYW1lIG9mIHRoZSBgV2hlZWxFdmVudGAgcHJvcGVydHkgdGhpcyBzY3JvbGxiYXIgc2hvdWxkIGxpc3RlbiB0by5cbiAgICAgICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZWZ1bCB2YWx1ZXMgYXJlIGAnZGVsdGFYJ2AsIGAnZGVsdGFZJ2AsIG9yIGAnZGVsdGFaJ2AuIEEgdmFsdWUgb2YgYG51bGxgIG1lYW5zIHRvIGlnbm9yZSBtb3VzZSB3aGVlbCBldmVudHMgZW50aXJlbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBtb3VzZSB3aGVlbCBpcyBvbmUtZGltZW5zaW9uYWwgYW5kIG9ubHkgZW1pdHMgZXZlbnRzIHdpdGggYGRlbHRhWWAgZGF0YS4gVGhpcyBwcm9wZXJ0eSBpcyBwcm92aWRlZCBzbyB0aGF0IHlvdSBjYW4gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb2YgYCdkZWx0YVgnYCB3aXRoIGEgdmFsdWUgb2YgYCdkZWx0YVknYCBvbiB5b3VyIGhvcml6b250YWwgc2Nyb2xsYmFyIHByaW1hcmlseSB0byBhY2NvbW1vZGF0ZSBjZXJ0YWluIFwicGFub3JhbWljXCIgaW50ZXJmYWNlIGRlc2lnbnMgd2hlcmUgdGhlIG1vdXNlIHdoZWVsIHNob3VsZCBjb250cm9sIGhvcml6b250YWwgcmF0aGVyIHRoYW4gdmVydGljYWwgc2Nyb2xsaW5nLiBKdXN0IGdpdmUgYHsgZGVsdGFQcm9wOiAnZGVsdGFZJyB9YCBpbiB5b3VyIGhvcml6b250YWwgc2Nyb2xsYmFyIGluc3RhbnRpYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIENhdmVhdDogTm90ZSB0aGF0IGEgMi1maW5nZXIgZHJhZyBvbiBhbiBBcHBsZSB0cmFja3BhZCBlbWl0cyBldmVudHMgd2l0aCBfYm90aF8gYGRlbHRhWCBgIGFuZCBgZGVsdGFZYCBkYXRhIHNvIHlvdSBtaWdodCB3YW50IHRvIGRlbGF5IG1ha2luZyB0aGUgYWJvdmUgYWRqdXN0bWVudCB1bnRpbCB5b3UgY2FuIGRldGVybWluZSB0aGF0IHlvdSBhcmUgZ2V0dGluZyBZIGRhdGEgb25seSB3aXRoIG5vIFggZGF0YSBhdCBhbGwgKHdoaWNoIGlzIGEgc3VyZSBiZXQgeW91IG9uIGEgbW91c2Ugd2hlZWwgcmF0aGVyIHRoYW4gYSB0cmFja3BhZCkuXG5cbiAgICAgICAgICogQHR5cGUge29iamVjdHxudWxsfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWx0YVByb3AgPSB0aGlzLm9oLmRlbHRhO1xuXG4gICAgICAgIHRoaXMuYmFyLmNsYXNzTmFtZSA9IHRoaXMuYmFyLmNsYXNzTmFtZS5yZXBsYWNlKC8odmVydGljYWx8aG9yaXpvbnRhbCkvZywgb3JpZW50YXRpb24pO1xuXG4gICAgICAgIGlmICh0aGlzLmJhci5zdHlsZS5jc3NUZXh0IHx8IHRoaXMudGh1bWIuc3R5bGUuY3NzVGV4dCkge1xuICAgICAgICAgICAgdGhpcy5iYXIucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgdGhpcy50aHVtYi5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXQgb3JpZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ2FsbGJhY2sgZm9yIHNjcm9sbCBldmVudHMuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3RvciB2aWEgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC4gQWZ0ZXIgaW5zdGFudGlhdGlvbiwgYHRoaXMub25jaGFuZ2VgIG1heSBiZSB1cGRhdGVkIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogVGhpcyBldmVudCBoYW5kbGVyIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgdmFsdWUgb2YgdGhlIHNjcm9sbGJhciBpcyBjaGFuZ2VkIHRocm91Z2ggdXNlciBpbnRlcmFjdGlvbi4gVGhlIHR5cGljYWwgdXNlIGNhc2UgaXMgd2hlbiB0aGUgY29udGVudCBpcyBzY3JvbGxlZC4gSXQgaXMgY2FsbGVkIHdpdGggdGhlIGBGaW5CYXJgIG9iamVjdCBhcyBpdHMgY29udGV4dCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHNjcm9sbGJhciAoaXRzIGluZGV4LCByb3VuZGVkKSBhcyB0aGUgb25seSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBTZXQgdGhpcyBwcm9wZXJ0eSB0byBgbnVsbGAgdG8gc3RvcCBlbWl0dGluZyBzdWNoIGV2ZW50cy5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyKXxudWxsfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgb25jaGFuZ2U6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBZGQgYSBDU1MgY2xhc3MgbmFtZSB0byB0aGUgYmFyIGVsZW1lbnQncyBjbGFzcyBsaXN0LlxuICAgICAqIEBkZXNjIFNldCBieSB0aGUgY29uc3RydWN0b3IuIFNlZSB0aGUgc2ltaWxhcmx5IG5hbWVkIHByb3BlcnR5IGluIHRoZSB7QGxpbmsgZmluYmFyT3B0aW9uc30gb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdCB3aWxsIGFsd2F5cyBpbmNsdWRlIGBmaW5iYXItdmVydGljYWxgIChvciBgZmluYmFyLWhvcml6b250YWxgIGJhc2VkIG9uIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uKS4gV2hlbmV2ZXIgdGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gc29tZSB2YWx1ZSwgZmlyc3QgdGhlIG9sZCBwcmVmaXgrb3JpZW50YXRpb24gaXMgcmVtb3ZlZCBmcm9tIHRoZSBiYXIgZWxlbWVudCdzIGNsYXNzIGxpc3Q7IHRoZW4gdGhlIG5ldyBwcmVmaXgrb3JpZW50YXRpb24gaXMgYWRkZWQgdG8gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdC4gVGhpcyBwcm9wZXJ0eSBjYXVzZXMgX2FuIGFkZGl0aW9uYWxfIGNsYXNzIG5hbWUgdG8gYmUgYWRkZWQgdG8gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdC4gVGhlcmVmb3JlLCB0aGlzIHByb3BlcnR5IHdpbGwgb25seSBhZGQgYXQgbW9zdCBvbmUgYWRkaXRpb25hbCBjbGFzcyBuYW1lIHRvIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogVG8gcmVtb3ZlIF9jbGFzc25hbWUtb3JpZW50YXRpb25fIGZyb20gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdCwgc2V0IHRoaXMgcHJvcGVydHkgdG8gYSBmYWxzeSB2YWx1ZSwgc3VjaCBhcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiA+IE5PVEU6IFlvdSBvbmx5IG5lZWQgdG8gc3BlY2lmeSBhbiBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgd2hlbiB5b3UgbmVlZCB0byBoYXZlIG11bGx0aXBsZSBkaWZmZXJlbnQgc3R5bGVzIG9mIHNjcm9sbGJhcnMgb24gdGhlIHNhbWUgcGFnZS4gSWYgdGhpcyBpcyBub3QgYSByZXF1aXJlbWVudCwgdGhlbiB5b3UgZG9uJ3QgbmVlZCB0byBtYWtlIGEgbmV3IGNsYXNzOyB5b3Ugd291bGQganVzdCBjcmVhdGUgc29tZSBhZGRpdGlvbmFsIHJ1bGVzIHVzaW5nIHRoZSBzYW1lIHNlbGVjdG9ycyBpbiB0aGUgYnVpbHQtaW4gc3R5bGVzaGVldCAoLi4vY3NzL2ZpbmJhcnMuY3NzKTpcbiAgICAgKiAqYGRpdi5maW5iYXItdmVydGljYWxgIChvciBgZGl2LmZpbmJhci1ob3Jpem9udGFsYCkgZm9yIHRoZSBzY3JvbGxiYXJcbiAgICAgKiAqYGRpdi5maW5iYXItdmVydGljYWwgPiBkaXZgIChvciBgZGl2LmZpbmJhci1ob3Jpem9udGFsID4gZGl2YCkgZm9yIHRoZSBcInRodW1iLlwiXG4gICAgICpcbiAgICAgKiBPZiBjb3Vyc2UsIHlvdXIgcnVsZXMgc2hvdWxkIGNvbWUgYWZ0ZXIgdGhlIGJ1aWx0LWlucy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IGNsYXNzUHJlZml4KHByZWZpeCkge1xuICAgICAgICBpZiAodGhpcy5fY2xhc3NQcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fY2xhc3NQcmVmaXggKyB0aGlzLm9yaWVudGF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NsYXNzUHJlZml4ID0gcHJlZml4O1xuXG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFyLmNsYXNzTGlzdC5hZGQocHJlZml4ICsgJy0nICsgdGhpcy5vcmllbnRhdGlvbik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldCBjbGFzc1ByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzUHJlZml4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBpbmNyZW1lbnRcbiAgICAgKiBAc3VtbWFyeSBOdW1iZXIgb2Ygc2Nyb2xsYmFyIGluZGV4IHVuaXRzIHJlcHJlc2VudGluZyBhIHBhZ2VmdWwuIFVzZWQgZXhjbHVzaXZlbHkgZm9yIHBhZ2luZyB1cCBhbmQgZG93biBhbmQgZm9yIHNldHRpbmcgdGh1bWIgc2l6ZSByZWxhdGl2ZSB0byBjb250ZW50IHNpemUuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBDYW4gYWxzbyBiZSBnaXZlbiBhcyBhIHBhcmFtZXRlciB0byB0aGUge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplfSBtZXRob2QsIHdoaWNoIGlzIHBlcnRpbmVudCBiZWNhdXNlIGNvbnRlbnQgYXJlYSBzaXplIGNoYW5nZXMgYWZmZWN0IHRoZSBkZWZpbml0aW9uIG9mIGEgXCJwYWdlZnVsLlwiIEhvd2V2ZXIsIHlvdSBvbmx5IG5lZWQgdG8gZG8gdGhpcyBpZiB0aGlzIHZhbHVlIGlzIGJlaW5nIHVzZWQuIEl0IG5vdCB1c2VkIHdoZW46XG4gICAgICogKiB5b3UgZGVmaW5lIGBwYWdpbmcudXBgIGFuZCBgcGFnaW5nLmRvd25gXG4gICAgICogKiB5b3VyIHNjcm9sbGJhciBpcyB1c2luZyBgc2Nyb2xsUmVhbENvbnRlbnRgXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluY3JlbWVudDogMSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGJhclN0eWxlc1xuICAgICAqIEBzdW1tYXJ5IFNjcm9sbGJhciBzdHlsZXMgdG8gYmUgYXBwbGllZCBieSB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemUoKX0uXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgdmFsdWUgdG8gYmUgYXNzaWduZWQgdG8ge0BsaW5rIEZpbkJhciNzdHlsZXN8c3R5bGVzfSBvbiBlYWNoIGNhbGwgdG8ge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplKCl9LiBUaGF0IGlzLCBhIGhhc2ggb2YgdmFsdWVzIHRvIGJlIGNvcGllZCB0byB0aGUgc2Nyb2xsYmFyIGVsZW1lbnQncyBzdHlsZSBvYmplY3Qgb24gcmVzaXplOyBvciBgbnVsbGAgZm9yIG5vbmUuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjc3R5bGV8c3R5bGV9XG4gICAgICogQHR5cGUge2ZpbmJhclN0eWxlc3xudWxsfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgYmFyU3R5bGVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc3R5bGVcbiAgICAgKiBAc3VtbWFyeSBBZGRpdGlvbmFsIHNjcm9sbGJhciBzdHlsZXMuXG4gICAgICogQGRlc2MgU2VlIHR5cGUgZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLiBUaGVzZSBzdHlsZXMgYXJlIGFwcGxpZWQgZGlyZWN0bHkgdG8gdGhlIHNjcm9sbGJhcidzIGBiYXJgIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBWYWx1ZXMgYXJlIGFkanVzdGVkIGFzIGZvbGxvd3MgYmVmb3JlIGJlaW5nIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQ6XG4gICAgICogMS4gSW5jbHVkZWQgXCJwc2V1ZG8tcHJvcGVydHlcIiBuYW1lcyBmcm9tIHRoZSBzY3JvbGxiYXIncyBvcmllbnRhdGlvbiBoYXNoLCB7QGxpbmsgRmluQmFyI29ofG9ofSwgYXJlIHRyYW5zbGF0ZWQgdG8gYWN0dWFsIHByb3BlcnR5IG5hbWVzIGJlZm9yZSBiZWluZyBhcHBsaWVkLlxuICAgICAqIDIuIFdoZW4gdGhlcmUgYXJlIG1hcmdpbnMsIHBlcmNlbnRhZ2VzIGFyZSB0cmFuc2xhdGVkIHRvIGFic29sdXRlIHBpeGVsIHZhbHVlcyBiZWNhdXNlIENTUyBpZ25vcmVzIG1hcmdpbnMgaW4gaXRzIHBlcmNlbnRhZ2UgY2FsY3VsYXRpb25zLlxuICAgICAqIDMuIElmIHlvdSBnaXZlIGEgdmFsdWUgd2l0aG91dCBhIHVuaXQgKGEgcmF3IG51bWJlciksIFwicHhcIiB1bml0IGlzIGFwcGVuZGVkLlxuICAgICAqXG4gICAgICogR2VuZXJhbCBub3RlczpcbiAgICAgKiAxLiBJdCBpcyBhbHdheXMgcHJlZmVyYWJsZSB0byBzcGVjaWZ5IHN0eWxlcyB2aWEgYSBzdHlsZXNoZWV0LiBPbmx5IHNldCB0aGlzIHByb3BlcnR5IHdoZW4geW91IG5lZWQgdG8gc3BlY2lmaWNhbGx5IG92ZXJyaWRlIChhKSBzdHlsZXNoZWV0IHZhbHVlKHMpLlxuICAgICAqIDIuIENhbiBiZSBzZXQgZGlyZWN0bHkgb3IgdmlhIGNhbGxzIHRvIHRoZSB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemV9IG1ldGhvZC5cbiAgICAgKiAzLiBTaG91bGQgb25seSBiZSBzZXQgYWZ0ZXIgdGhlIHNjcm9sbGJhciBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAgICogNC4gQmVmb3JlIGFwcGx5aW5nIHRoZXNlIG5ldyB2YWx1ZXMgdG8gdGhlIGVsZW1lbnQsIF9hbGxfIGluLWxpbmUgc3R5bGUgdmFsdWVzIGFyZSByZXNldCAoYnkgcmVtb3ZpbmcgdGhlIGVsZW1lbnQncyBgc3R5bGVgIGF0dHJpYnV0ZSksIGV4cG9zaW5nIGluaGVyaXRlZCB2YWx1ZXMgKGZyb20gc3R5bGVzaGVldHMpLlxuICAgICAqIDUuIEVtcHR5IG9iamVjdCBoYXMgbm8gZWZmZWN0LlxuICAgICAqIDYuIEZhbHNleSB2YWx1ZSBpbiBwbGFjZSBvZiBvYmplY3QgaGFzIG5vIGVmZmVjdC5cbiAgICAgKlxuICAgICAqID4gQ0FWRUFUOiBEbyBub3QgYXR0ZW1wdCB0byB0cmVhdCB0aGUgb2JqZWN0IHlvdSBhc3NpZ24gdG8gdGhpcyBwcm9wZXJ0eSBhcyBpZiBpdCB3ZXJlIGB0aGlzLmJhci5zdHlsZWAuIFNwZWNpZmljYWxseSwgY2hhbmdpbmcgdGhpcyBvYmplY3QgYWZ0ZXIgYXNzaWduaW5nIGl0IHdpbGwgaGF2ZSBubyBlZmZlY3Qgb24gdGhlIHNjcm9sbGJhci4gWW91IG11c3QgYXNzaWduIGl0IGFnYWluIGlmIHlvdSB3YW50IGl0IHRvIGhhdmUgYW4gZWZmZWN0LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI2JhclN0eWxlc3xiYXJTdHlsZXN9XG4gICAgICogQHR5cGUge2ZpbmJhclN0eWxlc31cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBzdHlsZShzdHlsZXMpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzdHlsZXMgPSBleHRlbmQoe30sIHN0eWxlcywgdGhpcy5fYXV4U3R5bGVzKSk7XG5cbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYmFyID0gdGhpcy5iYXIsXG4gICAgICAgICAgICAgICAgYmFyUmVjdCA9IGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lciB8fCBiYXIucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgIG9oID0gdGhpcy5vaDtcblxuICAgICAgICAgICAgLy8gQmVmb3JlIGFwcGx5aW5nIG5ldyBzdHlsZXMsIHJldmVydCBhbGwgc3R5bGVzIHRvIHZhbHVlcyBpbmhlcml0ZWQgZnJvbSBzdHlsZXNoZWV0c1xuICAgICAgICAgICAgYmFyLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gc3R5bGVzW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIG9oKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG9oW2tleV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihOdW1iZXIodmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gKHZhbCB8fCAwKSArICdweCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvJSQvLnRlc3QodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGJhciBzaXplIGdpdmVuIGFzIHBlcmNlbnRhZ2Ugb2YgY29udGFpbmVyLCBpZiBiYXIgaGFzIG1hcmdpbnMsIHJlc3RhdGUgc2l6ZSBpbiBwaXhlbHMgbGVzcyBtYXJnaW5zLlxuICAgICAgICAgICAgICAgICAgICAvLyAoSWYgbGVmdCBhcyBwZXJjZW50YWdlLCBDU1MncyBjYWxjdWxhdGlvbiB3aWxsIG5vdCBleGNsdWRlIG1hcmdpbnMuKVxuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZW50ZWQgPSBheGlzW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5zID0gYmFyUmVjdFtvcmllbnRlZC5tYXJnaW5MZWFkaW5nXSArIGJhclJlY3Rbb3JpZW50ZWQubWFyZ2luVHJhaWxpbmddO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFyZ2lucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VJbnQodmFsLCAxMCkgLyAxMDAgKiBjb250YWluZXJSZWN0W29yaWVudGVkLnNpemVdIC0gbWFyZ2lucyArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBiYXIuc3R5bGVba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBuYW1lIHBhZ2luZ1xuICAgICAqIEBzdW1tYXJ5IEVuYWJsZSBwYWdlIHVwL2RuIGNsaWNrcy5cbiAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yLiBTZWUgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIElmIHRydXRoeSwgbGlzdGVuIGZvciBjbGlja3MgaW4gcGFnZS11cCBhbmQgcGFnZS1kb3duIHJlZ2lvbnMgb2Ygc2Nyb2xsYmFyLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0LCBjYWxsIGAucGFnaW5nLnVwKClgIG9uIHBhZ2UtdXAgY2xpY2tzIGFuZCBgLnBhZ2luZy5kb3duKClgIHdpbGwgYmUgY2FsbGVkIG9uIHBhZ2UtZG93biBjbGlja3MuXG4gICAgICpcbiAgICAgKiBDaGFuZ2luZyB0aGUgdHJ1dGhpbmVzcyBvZiB0aGlzIHZhbHVlIGFmdGVyIGluc3RhbnRpYXRpb24gY3VycmVudGx5IGhhcyBubyBlZmZlY3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW58b2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFnaW5nOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgcmFuZ2VcbiAgICAgKiBAc3VtbWFyeSBTZXR0ZXIgZm9yIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHNjcm9sbCB2YWx1ZXMuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gVGhlc2UgdmFsdWVzIGFyZSB0aGUgbGltaXRzIGZvciB7QGxpbmsgRm9vQmFyI2luZGV4fGluZGV4fS5cbiAgICAgKlxuICAgICAqIFRoZSBzZXR0ZXIgYWNjZXB0cyBhbiBvYmplY3Qgd2l0aCBleGFjdGx5IHR3byBudW1lcmljIHByb3BlcnRpZXM6IGAubWluYCB3aGljaCBtdXN0IGJlIGxlc3MgdGhhbiBgLm1heGAuIFRoZSB2YWx1ZXMgYXJlIGV4dHJhY3RlZCBhbmQgdGhlIG9iamVjdCBpcyBkaXNjYXJkZWQuXG4gICAgICpcbiAgICAgKiBUaGUgZ2V0dGVyIHJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggYC5taW5gIGFuZCAnLm1heGAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7cmFuZ2VUeXBlfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IHJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHZhbGlkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB0aGlzLl9taW4gPSByYW5nZS5taW47XG4gICAgICAgIHRoaXMuX21heCA9IHJhbmdlLm1heDtcbiAgICAgICAgdGhpcy5jb250ZW50U2l6ZSA9IHJhbmdlLm1heCAtIHJhbmdlLm1pbiArIDE7XG4gICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmluZGV4OyAvLyByZS1jbGFtcFxuICAgIH0sXG4gICAgZ2V0IHJhbmdlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWluOiB0aGlzLl9taW4sXG4gICAgICAgICAgICBtYXg6IHRoaXMuX21heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbmRleCB2YWx1ZSBvZiB0aGUgc2Nyb2xsYmFyLlxuICAgICAqIEBkZXNjIFRoaXMgaXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzY3JvbGwgdGh1bWIuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgdmFsdWUgY2xhbXBzIGl0IHRvIHtAbGluayBGaW5CYXIjbWlufG1pbn0uLntAbGluayBGaW5CYXIjbWF4fG1heH0sIHNjcm9sbCB0aGUgY29udGVudCwgYW5kIG1vdmVzIHRodW1iLlxuICAgICAqXG4gICAgICogR2V0dGluZyB0aGlzIHZhbHVlIHJldHVybnMgdGhlIGN1cnJlbnQgaW5kZXguIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGluIHRoZSByYW5nZSBgbWluYC4uYG1heGAuIEl0IGlzIGludGVudGlvbmFsbHkgbm90IHJvdW5kZWQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyB2YWx1ZSBhcyBhbiBhbHRlcm5hdGl2ZSB0byAob3IgaW4gYWRkaXRpb24gdG8pIHVzaW5nIHRoZSB7QGxpbmsgRmluQmFyI29uY2hhbmdlfG9uY2hhbmdlfSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNfc2V0U2Nyb2xsfF9zZXRTY3JvbGx9XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBpbmRleChpZHgpIHtcbiAgICAgICAgaWR4ID0gTWF0aC5taW4odGhpcy5fbWF4LCBNYXRoLm1heCh0aGlzLl9taW4sIGlkeCkpOyAvLyBjbGFtcCBpdFxuICAgICAgICB0aGlzLl9zZXRTY3JvbGwoaWR4KTtcbiAgICAgICAgLy8gdGhpcy5fc2V0VGh1bWJTaXplKCk7XG4gICAgfSxcbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3VtbWFyeSBNb3ZlIHRoZSB0aHVtYi5cbiAgICAgKiBAZGVzYyBBbHNvIGRpc3BsYXlzIHRoZSBpbmRleCB2YWx1ZSBpbiB0aGUgdGVzdCBwYW5lbCBhbmQgaW52b2tlcyB0aGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIGlkeCAtIFRoZSBuZXcgc2Nyb2xsIGluZGV4LCBhIHZhbHVlIGluIHRoZSByYW5nZSBgbWluYC4uYG1heGAuXG4gICAgICogQHBhcmFtIFtzY2FsZWQ9ZihpZHgpXSAtIFRoZSBuZXcgdGh1bWIgcG9zaXRpb24gaW4gcGl4ZWxzIGFuZCBzY2FsZWQgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5pbmcge0BsaW5rIEZpbkJhciNiYXJ8YmFyfSBlbGVtZW50LCBpLmUuLCBhIHByb3BvcnRpb25hbCBudW1iZXIgaW4gdGhlIHJhbmdlIGAwYC4uYHRodW1iTWF4YC4gV2hlbiBvbWl0dGVkLCBhIGZ1bmN0aW9uIG9mIGBpZHhgIGlzIHVzZWQuXG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBfc2V0U2Nyb2xsOiBmdW5jdGlvbiAoaWR4LCBzY2FsZWQpIHtcbiAgICAgICAgdGhpcy5faW5kZXggPSBpZHg7XG5cbiAgICAgICAgLy8gRGlzcGxheSB0aGUgaW5kZXggdmFsdWUgaW4gdGhlIHRlc3QgcGFuZWxcbiAgICAgICAgaWYgKHRoaXMudGVzdFBhbmVsSXRlbSAmJiB0aGlzLnRlc3RQYW5lbEl0ZW0uaW5kZXggaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRlc3RQYW5lbEl0ZW0uaW5kZXguaW5uZXJIVE1MID0gTWF0aC5yb3VuZChpZHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2tcbiAgICAgICAgaWYgKHRoaXMub25jaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25jaGFuZ2UuY2FsbCh0aGlzLCBNYXRoLnJvdW5kKGlkeCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW92ZSB0aGUgdGh1bWJcbiAgICAgICAgaWYgKHNjYWxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzY2FsZWQgPSAoaWR4IC0gdGhpcy5fbWluKSAvICh0aGlzLl9tYXggLSB0aGlzLl9taW4pICogdGhpcy5fdGh1bWJNYXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHVtYi5zdHlsZVt0aGlzLm9oLmxlYWRpbmddID0gc2NhbGVkICsgJ3B4JztcbiAgICB9LFxuXG4gICAgc2Nyb2xsUmVhbENvbnRlbnQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSB0aGlzLmNvbnRlbnQucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIHNpemVQcm9wID0gdGhpcy5vaC5zaXplLFxuICAgICAgICAgICAgbWF4U2Nyb2xsID0gTWF0aC5tYXgoMCwgdGhpcy5jb250ZW50W3NpemVQcm9wXSAtIGNvbnRhaW5lclJlY3Rbc2l6ZVByb3BdKSxcbiAgICAgICAgICAgIC8vc2Nyb2xsID0gTWF0aC5taW4oaWR4LCBtYXhTY3JvbGwpO1xuICAgICAgICAgICAgc2Nyb2xsID0gKGlkeCAtIHRoaXMuX21pbikgLyAodGhpcy5fbWF4IC0gdGhpcy5fbWluKSAqIG1heFNjcm9sbDtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnc2Nyb2xsOiAnICsgc2Nyb2xsKTtcbiAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlW3RoaXMub2gubGVhZGluZ10gPSAtc2Nyb2xsICsgJ3B4JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVjYWxjdWxhdGUgdGh1bWIgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAZGVzYyBUaGlzIG1ldGhvZCByZWNhbGN1bGF0ZXMgdGhlIHRodW1iIHNpemUgYW5kIHBvc2l0aW9uLiBDYWxsIGl0IG9uY2UgYWZ0ZXIgaW5zZXJ0aW5nIHlvdXIgc2Nyb2xsYmFyIGludG8gdGhlIERPTSwgYW5kIHJlcGVhdGVkbHkgd2hpbGUgcmVzaXppbmcgdGhlIHNjcm9sbGJhciAod2hpY2ggdHlwaWNhbGx5IGhhcHBlbnMgd2hlbiB0aGUgc2Nyb2xsYmFyJ3MgcGFyZW50IGlzIHJlc2l6ZWQgYnkgdXNlci5cbiAgICAgKlxuICAgICAqID4gVGhpcyBmdW5jdGlvbiBzaGlmdHMgYXJncyBpZiBmaXJzdCBhcmcgb21pdHRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5jcmVtZW50PXRoaXMuaW5jcmVtZW50XSAtIFJlc2V0cyB7QGxpbmsgRm9vQmFyI2luY3JlbWVudHxpbmNyZW1lbnR9IChzZWUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmaW5iYXJTdHlsZXN9IFtiYXJTdHlsZXM9dGhpcy5iYXJTdHlsZXNdIC0gKFNlZSB0eXBlIGRlZmluaXRpb24gZm9yIGRldGFpbHMuKSBTY3JvbGxiYXIgc3R5bGVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGJhciBlbGVtZW50LlxuICAgICAqXG4gICAgICogT25seSBzcGVjaWZ5IGEgYGJhclN0eWxlc2Agb2JqZWN0IHdoZW4geW91IG5lZWQgdG8gb3ZlcnJpZGUgc3R5bGVzaGVldCB2YWx1ZXMuIElmIHByb3ZpZGVkLCBiZWNvbWVzIHRoZSBuZXcgZGVmYXVsdCAoYHRoaXMuYmFyU3R5bGVzYCksIGZvciB1c2UgYXMgYSBkZWZhdWx0IG9uIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAgICpcbiAgICAgKiBJdCBpcyBnZW5lcmFsbHkgdGhlIGNhc2UgdGhhdCB0aGUgc2Nyb2xsYmFyJ3MgbmV3IHBvc2l0aW9uIGlzIHN1ZmZpY2llbnRseSBkZXNjcmliZWQgYnkgdGhlIGN1cnJlbnQgc3R5bGVzLiBUaGVyZWZvcmUsIGl0IGlzIHVudXN1YWwgdG8gbmVlZCB0byBwcm92aWRlIGEgYGJhclN0eWxlc2Agb2JqZWN0IG9uIGV2ZXJ5IGNhbGwgdG8gYHJlc2l6ZWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RmluQmFyfSBTZWxmIGZvciBjaGFpbmluZy5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24gKGluY3JlbWVudCwgYmFyU3R5bGVzKSB7XG4gICAgICAgIHZhciBiYXIgPSB0aGlzLmJhcjtcblxuICAgICAgICBpZiAoIWJhci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIG5vdCBpbiBET00geWV0IHNvIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lciB8fCBiYXIucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gc2hpZnQgYXJncyBpZiBpZiAxc3QgYXJnIG9taXR0ZWRcbiAgICAgICAgaWYgKHR5cGVvZiBpbmNyZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBiYXJTdHlsZXMgPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgICBpbmNyZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0eWxlID0gdGhpcy5iYXJTdHlsZXMgPSBiYXJTdHlsZXMgfHwgdGhpcy5iYXJTdHlsZXM7XG5cbiAgICAgICAgLy8gQm91bmQgdG8gcmVhbCBjb250ZW50OiBDb250ZW50IHdhcyBnaXZlbiBidXQgbm8gb25jaGFuZ2UgaGFuZGxlci5cbiAgICAgICAgLy8gU2V0IHVwIC5vbmNoYW5nZSwgLmNvbnRhaW5lclNpemUsIGFuZCAuaW5jcmVtZW50LlxuICAgICAgICAvLyBOb3RlIHRoaXMgb25seSBtYWtlcyBzZW5zZSBpZiB5b3VyIGluZGV4IHVuaXQgaXMgcGl4ZWxzLlxuICAgICAgICBpZiAodGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub25jaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2hhbmdlID0gdGhpcy5zY3JvbGxSZWFsQ29udGVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gdGhpcy5jb250ZW50W3RoaXMub2guc2l6ZV07XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXggPSB0aGlzLmNvbnRlbnRTaXplIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vbmNoYW5nZSA9PT0gdGhpcy5zY3JvbGxSZWFsQ29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJTaXplID0gY29udGFpbmVyUmVjdFt0aGlzLm9oLnNpemVdO1xuICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnQgPSB0aGlzLmNvbnRhaW5lclNpemUgLyAodGhpcy5jb250ZW50U2l6ZSAtIHRoaXMuY29udGFpbmVyU2l6ZSkgKiAodGhpcy5fbWF4IC0gdGhpcy5fbWluKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyU2l6ZSA9IDE7XG4gICAgICAgICAgICB0aGlzLmluY3JlbWVudCA9IGluY3JlbWVudCB8fCB0aGlzLmluY3JlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHRoaXMudGVzdFBhbmVsSXRlbSA9IHRoaXMudGVzdFBhbmVsSXRlbSB8fCB0aGlzLl9hZGRUZXN0UGFuZWxJdGVtKCk7XG4gICAgICAgIHRoaXMuX3NldFRodW1iU2l6ZSgpO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuZGVsdGFQcm9wICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl9ib3VuZC5vbndoZWVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTaG9ydGVuIHRyYWlsaW5nIGVuZCBvZiBzY3JvbGxiYXIgYnkgdGhpY2tuZXNzIG9mIHNvbWUgb3RoZXIgc2Nyb2xsYmFyLlxuICAgICAqIEBkZXNjIEluIHRoZSBcImNsYXNzaWNhbFwiIHNjZW5hcmlvIHdoZXJlIHZlcnRpY2FsIHNjcm9sbCBiYXIgaXMgb24gdGhlIHJpZ2h0IGFuZCBob3Jpem9udGFsIHNjcm9sbGJhciBpcyBvbiB0aGUgYm90dG9tLCB5b3Ugd2FudCB0byBzaG9ydGVuIHRoZSBcInRyYWlsaW5nIGVuZFwiIChib3R0b20gYW5kIHJpZ2h0IGVuZHMsIHJlc3BlY3RpdmVseSkgb2YgYXQgbGVhc3Qgb25lIG9mIHRoZW0gc28gdGhleSBkb24ndCBvdmVybGF5LlxuICAgICAqXG4gICAgICogVGhpcyBjb252ZW5pZW5jZSBmdW5jdGlvbiBpcyBhbiBwcm9ncmFtbWF0aWMgYWx0ZXJuYXRpdmUgdG8gaGFyZGNvZGluZyB0aGUgY29ycmVjdCBzdHlsZSB3aXRoIHRoZSBjb3JyZWN0IHZhbHVlIGluIHlvdXIgc3R5bGVzaGVldDsgb3Igc2V0dGluZyB0aGUgY29ycmVjdCBzdHlsZSB3aXRoIHRoZSBjb3JyZWN0IHZhbHVlIGluIHRoZSB7QGxpbmsgRmluQmFyI2JhclN0eWxlc3xiYXJTdHlsZXN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNmb3Jlc2hvcnRlbkJ5fGZvcmVzaG9ydGVuQnl9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGaW5CYXJ8bnVsbH0gb3RoZXJGaW5CYXIgLSBPdGhlciBzY3JvbGxiYXIgdG8gYXZvaWQgYnkgc2hvcnRlbmluZyB0aGlzIG9uZTsgYG51bGxgIHJlbW92ZXMgdGhlIHRyYWlsaW5nIHNwYWNlXG4gICAgICogQHJldHVybnMge0ZpbkJhcn0gRm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgc2hvcnRlbkJ5OiBmdW5jdGlvbiAob3RoZXJGaW5CYXIpIHsgcmV0dXJuIHRoaXMuc2hvcnRlbkVuZEJ5KCd0cmFpbGluZycsIG90aGVyRmluQmFyKTsgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNob3J0ZW4gbGVhZGluZyBlbmQgb2Ygc2Nyb2xsYmFyIGJ5IHRoaWNrbmVzcyBvZiBzb21lIG90aGVyIHNjcm9sbGJhci5cbiAgICAgKiBAZGVzYyBTdXBwb3J0cyBub24tY2xhc3NpY2FsIHNjcm9sbGJhciBzY2VuYXJpb3Mgd2hlcmUgdmVydGljYWwgc2Nyb2xsIGJhciBtYXkgYmUgb24gbGVmdCBhbmQgaG9yaXpvbnRhbCBzY3JvbGxiYXIgbWF5IGJlIG9uIHRvcCwgaW4gd2hpY2ggY2FzZSB5b3Ugd2FudCB0byBzaG9ydGVuIHRoZSBcImxlYWRpbmcgZW5kXCIgcmF0aGVyIHRoYW4gdGhlIHRyYWlsaW5nIGVuZC5cbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjc2hvcnRlbkJ5fHNob3J0ZW5CeX0uXG4gICAgICogQHBhcmFtIHtGaW5CYXJ8bnVsbH0gb3RoZXJGaW5CYXIgLSBPdGhlciBzY3JvbGxiYXIgdG8gYXZvaWQgYnkgc2hvcnRlbmluZyB0aGlzIG9uZTsgYG51bGxgIHJlbW92ZXMgdGhlIHRyYWlsaW5nIHNwYWNlXG4gICAgICogQHJldHVybnMge0ZpbkJhcn0gRm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZm9yZXNob3J0ZW5CeTogZnVuY3Rpb24gKG90aGVyRmluQmFyKSB7IHJldHVybiB0aGlzLnNob3J0ZW5FbmRCeSgnbGVhZGluZycsIG90aGVyRmluQmFyKTsgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdlbmVyYWxpemVkIHNob3J0ZW5pbmcgZnVuY3Rpb24uXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI3Nob3J0ZW5CeXxzaG9ydGVuQnl9LlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNmb3Jlc2hvcnRlbkJ5fGZvcmVzaG9ydGVuQnl9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3aGljaEVuZCAtIGEgQ1NTIHN0eWxlIHByb3BlcnR5IG5hbWUgb3IgYW4gb3JpZW50YXRpb24gaGFzaCBuYW1lIHRoYXQgdHJhbnNsYXRlcyB0byBhIENTUyBzdHlsZSBwcm9wZXJ0eSBuYW1lLlxuICAgICAqIEBwYXJhbSB7RmluQmFyfG51bGx9IG90aGVyRmluQmFyIC0gT3RoZXIgc2Nyb2xsYmFyIHRvIGF2b2lkIGJ5IHNob3J0ZW5pbmcgdGhpcyBvbmU7IGBudWxsYCByZW1vdmVzIHRoZSB0cmFpbGluZyBzcGFjZVxuICAgICAqIEByZXR1cm5zIHtGaW5CYXJ9IEZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIHNob3J0ZW5FbmRCeTogZnVuY3Rpb24gKHdoaWNoRW5kLCBvdGhlckZpbkJhcikge1xuICAgICAgICBpZiAoIW90aGVyRmluQmFyKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYXV4U3R5bGVzO1xuICAgICAgICB9IGVsc2UgaWYgKG90aGVyRmluQmFyIGluc3RhbmNlb2YgRmluQmFyICYmIG90aGVyRmluQmFyLm9yaWVudGF0aW9uICE9PSB0aGlzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG90aGVyRmluQmFyLmJhciksXG4gICAgICAgICAgICAgICAgb29oID0gb3JpZW50YXRpb25IYXNoZXNbb3RoZXJGaW5CYXIub3JpZW50YXRpb25dO1xuICAgICAgICAgICAgdGhpcy5fYXV4U3R5bGVzID0ge307XG4gICAgICAgICAgICB0aGlzLl9hdXhTdHlsZXNbd2hpY2hFbmRdID0gb3RoZXJTdHlsZVtvb2gudGhpY2tuZXNzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN1bW1hcnkgU2V0cyB0aGUgcHJvcG9ydGlvbmFsIHRodW1iIHNpemUgYW5kIGhpZGVzIHRodW1iIHdoZW4gMTAwJS5cbiAgICAgKiBAZGVzYyBUaGUgdGh1bWIgc2l6ZSBoYXMgYW4gYWJzb2x1dGUgbWluaW11bSBvZiAyMCAocGl4ZWxzKS5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIF9zZXRUaHVtYlNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9oID0gdGhpcy5vaCxcbiAgICAgICAgICAgIHRodW1iQ29tcCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMudGh1bWIpLFxuICAgICAgICAgICAgdGh1bWJNYXJnaW5MZWFkaW5nID0gcGFyc2VJbnQodGh1bWJDb21wW29oLm1hcmdpbkxlYWRpbmddKSxcbiAgICAgICAgICAgIHRodW1iTWFyZ2luVHJhaWxpbmcgPSBwYXJzZUludCh0aHVtYkNvbXBbb2gubWFyZ2luVHJhaWxpbmddKSxcbiAgICAgICAgICAgIHRodW1iTWFyZ2lucyA9IHRodW1iTWFyZ2luTGVhZGluZyArIHRodW1iTWFyZ2luVHJhaWxpbmcsXG4gICAgICAgICAgICBiYXJTaXplID0gdGhpcy5iYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbb2guc2l6ZV0sXG4gICAgICAgICAgICB0aHVtYlNpemUgPSBNYXRoLm1heCgyMCwgYmFyU2l6ZSAqIHRoaXMuY29udGFpbmVyU2l6ZSAvIHRoaXMuY29udGVudFNpemUpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lclNpemUgPCB0aGlzLmNvbnRlbnRTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmJhci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAgICAgdGhpcy50aHVtYi5zdHlsZVtvaC5zaXplXSA9IHRodW1iU2l6ZSArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG5hbWUgX3RodW1iTWF4XG4gICAgICAgICAqIEBzdW1tYXJ5IE1heGltdW0gb2Zmc2V0IG9mIHRodW1iJ3MgbGVhZGluZyBlZGdlLlxuICAgICAgICAgKiBAZGVzYyBUaGlzIGlzIHRoZSBwaXhlbCBvZmZzZXQgd2l0aGluIHRoZSBzY3JvbGxiYXIgb2YgdGhlIHRodW1iIHdoZW4gaXQgaXMgYXQgaXRzIG1heGltdW0gcG9zaXRpb24gYXQgdGhlIGV4dHJlbWUgZW5kIG9mIGl0cyByYW5nZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB2YWx1ZSB0YWtlcyBpbnRvIGFjY291bnQgdGhlIG5ld2x5IGNhbGN1bGF0ZWQgc2l6ZSBvZiB0aGUgdGh1bWIgZWxlbWVudCAoaW5jbHVkaW5nIGl0cyBtYXJnaW5zKSBhbmQgdGhlIGlubmVyIHNpemUgb2YgdGhlIHNjcm9sbGJhciAodGhlIHRodW1iJ3MgY29udGFpbmluZyBlbGVtZW50LCBpbmNsdWRpbmcgX2l0c18gbWFyZ2lucykuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5PVEU6IFNjcm9sbGJhciBwYWRkaW5nIGlzIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgYW5kIGFzc3VtZWQgdG8gYmUgMCBpbiB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBhbmQgaXMgYXNzdW1lZCB0byBiZSBgMGA7IHVzZSB0aHVtYiBtYXJnaW5zIGluIHBsYWNlIG9mIHNjcm9sbGJhciBwYWRkaW5nLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGh1bWJNYXggPSBiYXJTaXplIC0gdGh1bWJTaXplIC0gdGh1bWJNYXJnaW5zO1xuXG4gICAgICAgIHRoaXMuX3RodW1iTWFyZ2luTGVhZGluZyA9IHRodW1iTWFyZ2luTGVhZGluZzsgLy8gdXNlZCBpbiBtb3VzZWRvd25cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVtb3ZlIHRoZSBzY3JvbGxiYXIuXG4gICAgICogQGRlc2MgVW5ob29rcyBhbGwgdGhlIGV2ZW50IGhhbmRsZXJzIGFuZCB0aGVuIHJlbW92ZXMgdGhlIGVsZW1lbnQgZnJvbSB0aGUgRE9NLiBBbHdheXMgY2FsbCB0aGlzIG1ldGhvZCBwcmlvciB0byBkaXNwb3Npbmcgb2YgdGhlIHNjcm9sbGJhciBvYmplY3QuXG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZWRvd24nKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZW1vdmUnKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZXVwJyk7XG5cbiAgICAgICAgKHRoaXMuY29udGFpbmVyIHx8IHRoaXMuYmFyLnBhcmVudEVsZW1lbnQpLl9yZW1vdmVFdnQoJ3doZWVsJywgdGhpcy5fYm91bmQub253aGVlbCk7XG5cbiAgICAgICAgdGhpcy5iYXIub25jbGljayA9XG4gICAgICAgICAgICB0aGlzLnRodW1iLm9uY2xpY2sgPVxuICAgICAgICAgICAgICAgIHRoaXMudGh1bWIub25tb3VzZW92ZXIgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRodW1iLnRyYW5zaXRpb25lbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHVtYi5vbm1vdXNlb3V0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLmJhci5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gX2FkZFRlc3RQYW5lbEl0ZW1cbiAgICAgKiBAc3VtbWFyeSBBcHBlbmQgYSB0ZXN0IHBhbmVsIGVsZW1lbnQuXG4gICAgICogQGRlc2MgSWYgdGhlcmUgaXMgYSB0ZXN0IHBhbmVsIGluIHRoZSBET00gKHR5cGljYWxseSBhbiBgPG9sPi4uLjwvb2w+YCBlbGVtZW50KSB3aXRoIGNsYXNzIG5hbWVzIG9mIGJvdGggYHRoaXMuY2xhc3NQcmVmaXhgIGFuZCBgJ3Rlc3QtcGFuZWwnYCAob3IsIGJhcnJpbmcgdGhhdCwgYW55IGVsZW1lbnQgd2l0aCBjbGFzcyBuYW1lIGAndGVzdC1wYW5lbCdgKSwgYW4gYDxsaT4uLi48L2xpPmAgZWxlbWVudCB3aWxsIGJlIGNyZWF0ZWQgYW5kIGFwcGVuZGVkIHRvIGl0LiBUaGlzIG5ldyBlbGVtZW50IHdpbGwgY29udGFpbiBhIHNwYW4gZm9yIGVhY2ggY2xhc3MgbmFtZSBnaXZlbi5cbiAgICAgKlxuICAgICAqIFlvdSBzaG91bGQgZGVmaW5lIGEgQ1NTIHNlbGVjdG9yIGAubGlzdGVuaW5nYCBmb3IgdGhlc2Ugc3BhbnMuIFRoaXMgY2xhc3Mgd2lsbCBiZSBhZGRlZCB0byB0aGUgc3BhbnMgdG8gYWx0ZXIgdGhlaXIgYXBwZWFyYW5jZSB3aGVuIGEgbGlzdGVuZXIgaXMgYWRkZWQgd2l0aCB0aGF0IGNsYXNzIG5hbWUgKHByZWZpeGVkIHdpdGggJ29uJykuXG4gICAgICpcbiAgICAgKiAoVGhpcyBpcyBhbiBpbnRlcm5hbCBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbmNlIGJ5IHRoZSBjb25zdHJ1Y3RvciBvbiBldmVyeSBpbnN0YW50aWF0aW9uLilcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudHx1bmRlZmluZWR9IFRoZSBhcHBlbmRlZCBgPGxpPi4uLjwvbGk+YCBlbGVtZW50IG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlIGlzIG5vIHRlc3QgcGFuZWwuXG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBfYWRkVGVzdFBhbmVsSXRlbTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGVzdFBhbmVsSXRlbSxcbiAgICAgICAgICAgIHRlc3RQYW5lbEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIHRoaXMuX2NsYXNzUHJlZml4ICsgJy50ZXN0LXBhbmVsJykgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRlc3QtcGFuZWwnKTtcblxuICAgICAgICBpZiAodGVzdFBhbmVsRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRlc3RQYW5lbEl0ZW1QYXJ0TmFtZXMgPSBbICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnLCAnaW5kZXgnIF0sXG4gICAgICAgICAgICAgICAgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cbiAgICAgICAgICAgIHRlc3RQYW5lbEl0ZW1QYXJ0TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocGFydE5hbWUpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmlubmVySFRNTCArPSAnPHNwYW4gY2xhc3M9XCInICsgcGFydE5hbWUgKyAnXCI+JyArIHBhcnROYW1lLnJlcGxhY2UoJ21vdXNlJywgJycpICsgJzwvc3Bhbj4nO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRlc3RQYW5lbEVsZW1lbnQuYXBwZW5kQ2hpbGQoaXRlbSk7XG5cbiAgICAgICAgICAgIHRlc3RQYW5lbEl0ZW0gPSB7fTtcbiAgICAgICAgICAgIHRlc3RQYW5lbEl0ZW1QYXJ0TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocGFydE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0ZXN0UGFuZWxJdGVtW3BhcnROYW1lXSA9IGl0ZW0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShwYXJ0TmFtZSlbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXN0UGFuZWxJdGVtO1xuICAgIH0sXG5cbiAgICBfYWRkRXZ0OiBmdW5jdGlvbiAoZXZ0TmFtZSkge1xuICAgICAgICB2YXIgc3B5ID0gdGhpcy50ZXN0UGFuZWxJdGVtICYmIHRoaXMudGVzdFBhbmVsSXRlbVtldnROYW1lXTtcbiAgICAgICAgaWYgKHNweSkgeyBzcHkuY2xhc3NMaXN0LmFkZCgnbGlzdGVuaW5nJyk7IH1cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZ0TmFtZSwgdGhpcy5fYm91bmRbJ29uJyArIGV2dE5hbWVdKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUV2dDogZnVuY3Rpb24gKGV2dE5hbWUpIHtcbiAgICAgICAgdmFyIHNweSA9IHRoaXMudGVzdFBhbmVsSXRlbSAmJiB0aGlzLnRlc3RQYW5lbEl0ZW1bZXZ0TmFtZV07XG4gICAgICAgIGlmIChzcHkpIHsgc3B5LmNsYXNzTGlzdC5yZW1vdmUoJ2xpc3RlbmluZycpOyB9XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGV2dE5hbWUsIHRoaXMuX2JvdW5kWydvbicgKyBldnROYW1lXSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBvYmpuID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAob2Jqbikge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iam4pIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IG9iam5ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiB2YWxpZFJhbmdlKHJhbmdlKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyYW5nZSksXG4gICAgICAgIHZhbGlkID0gIGtleXMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICB0eXBlb2YgcmFuZ2UubWluID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHJhbmdlLm1heCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHJhbmdlLm1pbiA8PSByYW5nZS5tYXg7XG5cbiAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIC5yYW5nZSBvYmplY3QuJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYW5kbGVyc1RvQmVCb3VuZFxuICogQHR5cGUge29iamVjdH1cbiAqIEBkZXNjIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCBhcmUgYWxsIERPTSBldmVudCBoYW5kbGVycyB0aGF0IGFyZSBib3VuZCBieSB0aGUgRmluQmFyIGNvbnN0cnVjdG9yIHRvIGVhY2ggbmV3IGluc3RhbmNlLiBJbiBvdGhlciB3b3JkcywgdGhlIGB0aGlzYCB2YWx1ZSBvZiB0aGVzZSBoYW5kbGVycywgb25jZSBib3VuZCwgcmVmZXIgdG8gdGhlIEZpbkJhciBvYmplY3QgYW5kIG5vdCB0byB0aGUgZXZlbnQgZW1pdHRlci4gXCJEbyBub3QgY29uc3VtZSByYXcuXCJcbiAqL1xudmFyIGhhbmRsZXJzVG9CZUJvdW5kID0ge1xuICAgIHNob3J0U3RvcDogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcblxuICAgIG9ud2hlZWw6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdGhpcy5pbmRleCArPSBldnRbdGhpcy5kZWx0YVByb3BdO1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBvbmNsaWNrOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHZhciB0aHVtYkJveCA9IHRoaXMudGh1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBnb2luZ1VwID0gZXZ0W3RoaXMub2guY29vcmRpbmF0ZV0gPCB0aHVtYkJveFt0aGlzLm9oLmxlYWRpbmddO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wYWdpbmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5wYWdpbmdbZ29pbmdVcCA/ICd1cCcgOiAnZG93biddKE1hdGgucm91bmQodGhpcy5pbmRleCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbmRleCArPSBnb2luZ1VwID8gLXRoaXMuaW5jcmVtZW50IDogdGhpcy5pbmNyZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHRoZSB0aHVtYiBnbG93IG1vbWVudGFyaWx5XG4gICAgICAgIHRoaXMudGh1bWIuY2xhc3NMaXN0LmFkZCgnaG92ZXInKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnRodW1iLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbiB3YWl0Rm9ySXQoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB3YWl0Rm9ySXQpO1xuICAgICAgICAgICAgc2VsZi5fYm91bmQub25tb3VzZXVwKGV2dCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgb25tb3VzZW92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHVtYi5jbGFzc0xpc3QuYWRkKCdob3ZlcicpO1xuICAgICAgICB0aGlzLnRodW1iLm9ubW91c2VvdXQgPSB0aGlzLl9ib3VuZC5vbm1vdXNlb3V0O1xuICAgICAgICB0aGlzLl9hZGRFdnQoJ21vdXNlZG93bicpO1xuICAgIH0sXG5cbiAgICBvbm1vdXNlb3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2Vkb3duJyk7XG4gICAgICAgIHRoaXMudGh1bWIub25tb3VzZW92ZXIgPSB0aGlzLl9ib3VuZC5vbm1vdXNlb3ZlcjtcbiAgICAgICAgdGhpcy50aHVtYi5jbGFzc0xpc3QucmVtb3ZlKCdob3ZlcicpO1xuICAgIH0sXG5cbiAgICBvbm1vdXNlZG93bjogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdnQoJ21vdXNlZG93bicpO1xuICAgICAgICB0aGlzLnRodW1iLm9ubW91c2VvdmVyID0gdGhpcy50aHVtYi5vbm1vdXNlb3V0ID0gbnVsbDtcblxuICAgICAgICB2YXIgdGh1bWJCb3ggPSB0aGlzLnRodW1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnBpbk9mZnNldCA9IGV2dFt0aGlzLm9oLmF4aXNdIC0gdGh1bWJCb3hbdGhpcy5vaC5sZWFkaW5nXSArIHRoaXMuYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3RoaXMub2gubGVhZGluZ10gKyB0aGlzLl90aHVtYk1hcmdpbkxlYWRpbmc7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG5cbiAgICAgICAgdGhpcy5fYWRkRXZ0KCdtb3VzZW1vdmUnKTtcbiAgICAgICAgdGhpcy5fYWRkRXZ0KCdtb3VzZXVwJyk7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgb25tb3VzZW1vdmU6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdmFyIHNjYWxlZCA9IE1hdGgubWluKHRoaXMuX3RodW1iTWF4LCBNYXRoLm1heCgwLCBldnRbdGhpcy5vaC5heGlzXSAtIHRoaXMucGluT2Zmc2V0KSk7XG4gICAgICAgIHZhciBpZHggPSBzY2FsZWQgLyB0aGlzLl90aHVtYk1heCAqICh0aGlzLl9tYXggLSB0aGlzLl9taW4pICsgdGhpcy5fbWluO1xuXG4gICAgICAgIHRoaXMuX3NldFNjcm9sbChpZHgsIHNjYWxlZCk7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgb25tb3VzZXVwOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2Vtb3ZlJyk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2V1cCcpO1xuXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnYXV0byc7XG5cbiAgICAgICAgdmFyIHRodW1iQm94ID0gdGhpcy50aHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGh1bWJCb3gubGVmdCA8PSBldnQuY2xpZW50WCAmJiBldnQuY2xpZW50WCA8PSB0aHVtYkJveC5yaWdodCAmJlxuICAgICAgICAgICAgdGh1bWJCb3gudG9wIDw9IGV2dC5jbGllbnRZICYmIGV2dC5jbGllbnRZIDw9IHRodW1iQm94LmJvdHRvbVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kLm9ubW91c2VvdmVyKGV2dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZC5vbm1vdXNlb3V0KGV2dCk7XG4gICAgICAgIH1cblxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbnZhciBvcmllbnRhdGlvbkhhc2hlcyA9IHtcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgICBjb29yZGluYXRlOiAgICAgJ2NsaWVudFknLFxuICAgICAgICBheGlzOiAgICAgICAgICAgJ3BhZ2VZJyxcbiAgICAgICAgc2l6ZTogICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICBvdXRzaWRlOiAgICAgICAgJ3JpZ2h0JyxcbiAgICAgICAgaW5zaWRlOiAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgbGVhZGluZzogICAgICAgICd0b3AnLFxuICAgICAgICB0cmFpbGluZzogICAgICAgJ2JvdHRvbScsXG4gICAgICAgIG1hcmdpbkxlYWRpbmc6ICAnbWFyZ2luVG9wJyxcbiAgICAgICAgbWFyZ2luVHJhaWxpbmc6ICdtYXJnaW5Cb3R0b20nLFxuICAgICAgICB0aGlja25lc3M6ICAgICAgJ3dpZHRoJyxcbiAgICAgICAgZGVsdGE6ICAgICAgICAgICdkZWx0YVknXG4gICAgfSxcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICAgIGNvb3JkaW5hdGU6ICAgICAnY2xpZW50WCcsXG4gICAgICAgIGF4aXM6ICAgICAgICAgICAncGFnZVgnLFxuICAgICAgICBzaXplOiAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgb3V0c2lkZTogICAgICAgICdib3R0b20nLFxuICAgICAgICBpbnNpZGU6ICAgICAgICAgJ3RvcCcsXG4gICAgICAgIGxlYWRpbmc6ICAgICAgICAnbGVmdCcsXG4gICAgICAgIHRyYWlsaW5nOiAgICAgICAncmlnaHQnLFxuICAgICAgICBtYXJnaW5MZWFkaW5nOiAgJ21hcmdpbkxlZnQnLFxuICAgICAgICBtYXJnaW5UcmFpbGluZzogJ21hcmdpblJpZ2h0JyxcbiAgICAgICAgdGhpY2tuZXNzOiAgICAgICdoZWlnaHQnLFxuICAgICAgICBkZWx0YTogICAgICAgICAgJ2RlbHRhWCdcbiAgICB9XG59O1xuXG52YXIgYXhpcyA9IHtcbiAgICB0b3A6ICAgICd2ZXJ0aWNhbCcsXG4gICAgYm90dG9tOiAndmVydGljYWwnLFxuICAgIGhlaWdodDogJ3ZlcnRpY2FsJyxcbiAgICBsZWZ0OiAgICdob3Jpem9udGFsJyxcbiAgICByaWdodDogICdob3Jpem9udGFsJyxcbiAgICB3aWR0aDogICdob3Jpem9udGFsJ1xufTtcblxudmFyIGNzc0ZpbkJhcnM7IC8vIGRlZmluaXRpb24gaW5zZXJ0ZWQgYnkgZ3VscGZpbGUgYmV0d2VlbiBmb2xsb3dpbmcgY29tbWVudHNcbi8qIGluamVjdDpjc3MgKi9cbmNzc0ZpbkJhcnMgPSAnZGl2LmZpbmJhci1ob3Jpem9udGFsLGRpdi5maW5iYXItdmVydGljYWx7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luOjNweH1kaXYuZmluYmFyLWhvcml6b250YWw+LnRodW1iLGRpdi5maW5iYXItdmVydGljYWw+LnRodW1ie3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6I2QzZDNkMzstd2Via2l0LWJveC1zaGFkb3c6MCAwIDFweCAjMDAwOy1tb3otYm94LXNoYWRvdzowIDAgMXB4ICMwMDA7Ym94LXNoYWRvdzowIDAgMXB4ICMwMDA7Ym9yZGVyLXJhZGl1czo0cHg7bWFyZ2luOjJweDtvcGFjaXR5Oi40O3RyYW5zaXRpb246b3BhY2l0eSAuNXN9ZGl2LmZpbmJhci1ob3Jpem9udGFsPi50aHVtYi5ob3ZlcixkaXYuZmluYmFyLXZlcnRpY2FsPi50aHVtYi5ob3ZlcntvcGFjaXR5OjE7dHJhbnNpdGlvbjpvcGFjaXR5IC41c31kaXYuZmluYmFyLXZlcnRpY2Fse3RvcDowO2JvdHRvbTowO3JpZ2h0OjA7d2lkdGg6MTFweH1kaXYuZmluYmFyLXZlcnRpY2FsPi50aHVtYnt0b3A6MDtyaWdodDowO3dpZHRoOjdweH1kaXYuZmluYmFyLWhvcml6b250YWx7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7aGVpZ2h0OjExcHh9ZGl2LmZpbmJhci1ob3Jpem9udGFsPi50aHVtYntsZWZ0OjA7Ym90dG9tOjA7aGVpZ2h0OjdweH0nO1xuLyogZW5kaW5qZWN0ICovXG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIHRocm93ICdmaW5iYXJzOiAnICsgbXNnO1xufVxuXG4vLyBJbnRlcmZhY2Vcbm1vZHVsZS5leHBvcnRzID0gRmluQmFyO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlY3Rhbmd1bGFyID0gcmVxdWlyZSgncmVjdGFuZ3VsYXInKTtcblxudmFyIGdlc3R1cmVzID0gcmVxdWlyZSgnLi9qcy9wb2x5bWVyZ2VzdHVyZXMuZGV2LmpzJyk7XG52YXIgR3JhcGhpY3NDb250ZXh0ID0gcmVxdWlyZSgnLi9qcy9HcmFwaGljc0NvbnRleHQuanMnKTtcblxudmFyIFJFU0laRV9QT0xMSU5HX0lOVEVSVkFMID0gMjAwLFxuICAgIHBhaW50YWJsZXMgPSBbXSxcbiAgICByZXNpemFibGVzID0gW10sXG4gICAgcGFpbnRMb29wUnVubmluZyA9IHRydWUsXG4gICAgcmVzaXplTG9vcFJ1bm5pbmcgPSB0cnVlLFxuICAgIGNoYXJNYXAgPSBtYWtlQ2hhck1hcCgpO1xuXG5mdW5jdGlvbiBDYW52YXMoZGl2LCBjb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuZG91YmxlQ2xpY2tEZWxheSA9IG9wdGlvbnMuZG91YmxlQ2xpY2tEZWxheSB8fCAzMjU7XG5cbiAgICB0aGlzLmRyYWdFbmR0aW1lID0gRGF0ZS5ub3coKTtcblxuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXG4gICAgdGhpcy5jYW52YXMuc3R5bGUub3V0bGluZSA9ICdub25lJztcblxuICAgIC8vIHRoaXMuZm9jdXNlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIC8vIHRoaXMuZm9jdXNlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIC8vIHRoaXMuZm9jdXNlci5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLnpJbmRleCA9ICctMSc7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XG4gICAgLy8gdGhpcy5kaXYuYXBwZW5kQ2hpbGQodGhpcy5mb2N1c2VyKTtcblxuICAgIHRoaXMuY2FudmFzQ1RYID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmdjID0gbmV3IEdyYXBoaWNzQ29udGV4dCh0aGlzLmNhbnZhc0NUWCk7XG5cbiAgICB0aGlzLmJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMuYnVmZmVyQ1RYID0gdGhpcy5idWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmJ1ZmZlckdDID0gbmV3IEdyYXBoaWNzQ29udGV4dCh0aGlzLmJ1ZmZlckNUWCk7XG5cbiAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoLTEsIC0xKTtcbiAgICB0aGlzLmRyYWdzdGFydCA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCgtMSwgLTEpO1xuICAgIC8vdGhpcy5vcmlnaW4gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoMCwgMCk7XG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgcmVjdGFuZ3VsYXIuUmVjdGFuZ2xlKDAsIDAsIDAsIDApO1xuICAgIHRoaXMuaGFzTW91c2UgPSBmYWxzZTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHNlbGYuaGFzTW91c2UgfHwgc2VsZi5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHNlbGYuZmlubW91c2Vtb3ZlKGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5tb3VzZXVwKGUpO1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbndoZWVsbW92ZWQoZSk7XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5rZXlkb3duKGUpO1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmtleXVwKGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYW52YXMub25tb3VzZW92ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5oYXNNb3VzZSA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5mb2N1c2dhaW5lZChlKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmZvY3VzbG9zdChlKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmlubW91c2Vkb3duKGUpO1xuICAgIH0pO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmhhc01vdXNlID0gZmFsc2U7XG4gICAgICAgIHNlbGYuZmlubW91c2VvdXQoZSk7XG4gICAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmluY2xpY2soZSk7XG4gICAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmluY29udGV4dG1lbnUoZSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ3RhcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW50YXAoZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ2hvbGRwdWxzZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5ob2xkcHVsc2UoZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ2ZsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmZsaWNrKGUpO1xuICAgIH0pO1xuICAgIGdlc3R1cmVzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5jYW52YXMsICdyZWxlYXNlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbnJlbGVhc2UoZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ3RyYWNrc3RhcnQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmludHJhY2tzdGFydChlKTtcbiAgICB9KTtcbiAgICBnZXN0dXJlcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuY2FudmFzLCAndHJhY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmludHJhY2soZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ3RyYWNrZW5kJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbnRyYWNrZW5kKGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICAgIHRoaXMuY2FudmFzLmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG5cbiAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgdGhpcy5iZWdpblJlc2l6aW5nKCk7XG4gICAgdGhpcy5iZWdpblBhaW50aW5nKCk7XG59XG5cbkNhbnZhcy5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENhbnZhcy5wcm90b3R5cGUuY29uc3RydWN0b3IsXG4gICAgZGl2OiBudWxsLFxuICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICBnZXN0dXJlczogZ2VzdHVyZXMsIC8vIFRPRE86IHdoeSBkbyB3ZSBuZWVkIHRoaXM/ICh3YXMgcHJldmlvdXNseSBhdCBib3R0b20gb2YgZmlsZSlcbiAgICBjYW52YXM6IG51bGwsXG4gICAgY2FudmFzQ1RYOiBudWxsLFxuICAgIGZvY3VzZXI6IG51bGwsXG4gICAgYnVmZmVyOiBudWxsLFxuICAgIGN0eDogbnVsbCxcbiAgICBtb3VzZUxvY2F0aW9uOiBudWxsLFxuICAgIGhvbGRQdWxzZUNvdW50OiAtMSxcbiAgICBkcmFnc3RhcnQ6IG51bGwsXG4gICAgb3JpZ2luOiBudWxsLFxuICAgIGJvdW5kczogbnVsbCxcbiAgICBkaXJ0eTogZmFsc2UsXG4gICAgc2l6ZTogbnVsbCxcbiAgICBtb3VzZWRvd246IGZhbHNlLFxuICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICByZXBlYXRLZXlDb3VudDogMCxcbiAgICByZXBlYXRLZXk6IG51bGwsXG4gICAgcmVwZWF0S2V5U3RhcnRUaW1lOiAwLFxuICAgIGN1cnJlbnRLZXlzOiBbXSxcbiAgICBoYXNNb3VzZTogZmFsc2UsXG4gICAgbGFzdERvdWJsZUNsaWNrVGltZTogMCxcbiAgICBkcmFnRW5kVGltZTogMCxcbiAgICBsYXN0UmVwYWludFRpbWU6IDAsXG5cbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgc3RvcFBhaW50TG9vcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHBhaW50TG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgcmVzdGFydFBhaW50TG9vcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChwYWludExvb3BSdW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgcnVubmluZ1xuICAgICAgICB9XG4gICAgICAgIHBhaW50TG9vcFJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocGFpbnRMb29wRnVuY3Rpb24pO1xuICAgIH0sXG5cbiAgICBzdG9wUmVzaXplTG9vcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc2l6ZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgfSxcblxuICAgIHJlc3RhcnRSZXNpemVMb29wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlc2l6ZUxvb3BSdW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgcnVubmluZ1xuICAgICAgICB9XG4gICAgICAgIHJlc2l6ZUxvb3BSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgc2V0SW50ZXJ2YWwocmVzaXphYmxlc0xvb3BGdW5jdGlvbiwgMjAwKTtcbiAgICB9LFxuXG4gICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0b3BQYWludGluZygpO1xuICAgICAgICB0aGlzLnN0b3BSZXNpemluZygpO1xuICAgIH0sXG5cbiAgICB1c2VIaURQSTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5yZXNvbHZlUHJvcGVydHkoJ3VzZUhpRFBJJyk7XG4gICAgfSxcblxuICAgIHVzZUJpdEJsaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQucmVzb2x2ZVByb3BlcnR5KCd1c2VCaXRCbGl0Jyk7XG4gICAgfSxcblxuICAgIGdldEZQUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmcHMgPSB0aGlzLmNvbXBvbmVudC5yZXNvbHZlUHJvcGVydHkoJ3JlcGFpbnRJbnRlcnZhbFJhdGUnKTtcbiAgICAgICAgcmV0dXJuIGZwcyA/IHBhcnNlSW50KGZwcykgOiAwO1xuICAgIH0sXG5cbiAgICB0aWNrUGFpbnQ6IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICB2YXIgZnBzID0gdGhpcy5nZXRGUFMoKTtcbiAgICAgICAgaWYgKGZwcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDEwMDAgLyBmcHM7XG5cbiAgICAgICAgdmFyIGVsYXBzZWQgPSBub3cgLSB0aGlzLmxhc3RSZXBhaW50VGltZTtcbiAgICAgICAgaWYgKGVsYXBzZWQgPiBpbnRlcnZhbCAmJiB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RSZXBhaW50VGltZSA9IG5vdyAtIChlbGFwc2VkICUgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5wYWludE5vdygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGJlZ2luUGFpbnRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnRpY2tQYWludGVyID0gZnVuY3Rpb24obm93KSB7XG4gICAgICAgICAgICBzZWxmLnRpY2tQYWludChub3cpO1xuICAgICAgICB9O1xuICAgICAgICBwYWludGFibGVzLnB1c2godGhpcyk7XG4gICAgfSxcblxuICAgIHN0b3BQYWludGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHBhaW50YWJsZXMuc3BsaWNlKHBhaW50YWJsZXMuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgfSxcblxuICAgIGJlZ2luUmVzaXppbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMudGlja1Jlc2l6ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuY2hlY2tzaXplKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlc2l6YWJsZXMucHVzaCh0aGlzKTtcbiAgICB9LFxuXG4gICAgc3RvcFJlc2l6aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzaXphYmxlcy5zcGxpY2UocmVzaXphYmxlcy5pbmRleE9mKHRoaXMpLCAxKTtcbiAgICB9LFxuXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJlZ2luUGFpbnRpbmcoKTtcbiAgICAgICAgdGhpcy5iZWdpblJlc2l6aW5nKCk7XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0b3BQYWludGluZygpO1xuICAgICAgICB0aGlzLnN0b3BSZXNpemluZygpO1xuICAgIH0sXG5cbiAgICBjaGVja3NpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL3RoaXMgaXMgZXhwZW5zaXZlIGxldHMgZG8gaXQgYXQgc29tZSBtb2R1bG9cbiAgICAgICAgdmFyIHNpemVOb3cgPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKHNpemVOb3cud2lkdGggIT09IHRoaXMuc2l6ZS53aWR0aCB8fCBzaXplTm93LmhlaWdodCAhPT0gdGhpcy5zaXplLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5zaXplQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNpemVDaGFuZ2VkTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJveCA9IHRoaXMuc2l6ZSA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5idWZmZXIud2lkdGggPSBib3gud2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuYnVmZmVyLmhlaWdodCA9IGJveC5oZWlnaHQ7XG5cbiAgICAgICAgLy9maXggYWxhIHNpciBzcGlua2EsIHNlZVxuICAgICAgICAvL2h0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2NhbnZhcy9oaWRwaS9cbiAgICAgICAgLy9qdXN0IGFkZCAnaGRwaScgYXMgYW4gYXR0cmlidXRlIHRvIHRoZSBmaW4tY2FudmFzIHRhZ1xuICAgICAgICB2YXIgcmF0aW8gPSAxO1xuICAgICAgICB2YXIgdXNlQml0QmxpdCA9IHRoaXMudXNlQml0QmxpdCgpO1xuICAgICAgICB2YXIgaXNISURQSSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICYmIHRoaXMudXNlSGlEUEkoKTtcbiAgICAgICAgaWYgKGlzSElEUEkpIHtcbiAgICAgICAgICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgICAgIHZhciBiYWNraW5nU3RvcmVSYXRpbyA9IHRoaXMuY2FudmFzQ1RYLndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NUWC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDVFgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDVFgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NUWC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG5cbiAgICAgICAgICAgIHJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuICAgICAgICAgICAgLy90aGlzLmNhbnZhc0NUWC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5idWZmZXIud2lkdGggPSB3aWR0aCAqIHJhdGlvO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmJ1ZmZlci5oZWlnaHQgPSBoZWlnaHQgKiByYXRpbztcblxuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IHRoaXMuYnVmZmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSB0aGlzLmJ1ZmZlci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgICAgIHRoaXMuYnVmZmVyQ1RYLnNjYWxlKHJhdGlvLCByYXRpbyk7XG4gICAgICAgIGlmIChpc0hJRFBJICYmICF1c2VCaXRCbGl0KSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc0NUWC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy90aGlzLm9yaWdpbiA9IG5ldyByZWN0YW5ndWxhci5Qb2ludChNYXRoLnJvdW5kKHRoaXMuc2l6ZS5sZWZ0KSwgTWF0aC5yb3VuZCh0aGlzLnNpemUudG9wKSk7XG4gICAgICAgIHRoaXMuYm91bmRzID0gbmV3IHJlY3Rhbmd1bGFyLlJlY3RhbmdsZSgwLCAwLCBib3gud2lkdGgsIGJveC5oZWlnaHQpO1xuICAgICAgICAvL3NldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb21wID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIGlmIChjb21wKSB7XG4gICAgICAgICAgICBjb21wLnNldEJvdW5kcyh0aGlzLmJvdW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNpemVOb3RpZmljYXRpb24oKTtcbiAgICAgICAgdGhpcy5wYWludE5vdygpO1xuICAgICAgICAvL30pO1xuICAgIH0sXG5cbiAgICByZXNpemVOb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL3RvIGJlIG92ZXJyaWRkZW5cbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRzO1xuICAgIH0sXG5cbiAgICBwYWludE5vdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5zYWZlUGFpbnRJbW1lZGlhdGVseShmdW5jdGlvbihnYykge1xuICAgICAgICAgICAgZ2MuY2xlYXJSZWN0KDAsIDAsIHNlbGYuY2FudmFzLndpZHRoLCBzZWxmLmNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgICAgICB2YXIgY29tcCA9IHNlbGYuY29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKGNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wLnBhaW50KGdjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgc2FmZVBhaW50SW1tZWRpYXRlbHk6IGZ1bmN0aW9uKHBhaW50RnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHVzZUJpdEJsaXQgPSB0aGlzLnVzZUJpdEJsaXQoKSxcbiAgICAgICAgICAgIGdjID0gdXNlQml0QmxpdCA/IHRoaXMuYnVmZmVyR0MgOiB0aGlzLmdjO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZ2Muc2F2ZSgpO1xuICAgICAgICAgICAgcGFpbnRGdW5jdGlvbihnYyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBnYy5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZUJpdEJsaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmbHVzaEJ1ZmZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci53aWR0aCA+IDAgJiYgdGhpcy5idWZmZXIuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXNDVFguZHJhd0ltYWdlKHRoaXMuYnVmZmVyLCAwLCAwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkaXNwYXRjaE5ld0V2ZW50OiBmdW5jdGlvbihldmVudCwgbmFtZSwgZGV0YWlsKSB7XG4gICAgICAgIGRldGFpbCA9IHtcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsIHx8IHt9XG4gICAgICAgIH07XG4gICAgICAgIGRldGFpbC5kZXRhaWwucHJpbWl0aXZlRXZlbnQgPSBldmVudDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KG5hbWUsIGRldGFpbCkpO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50OiBmdW5jdGlvbihldmVudCwgbmFtZSwgZGV0YWlsKSB7XG4gICAgICAgIGRldGFpbCA9IGRldGFpbCB8fCB7fTtcbiAgICAgICAgZGV0YWlsLm1vdXNlID0gdGhpcy5tb3VzZUxvY2F0aW9uO1xuICAgICAgICBkZXRhaWwua2V5cyA9IHRoaXMuY3VycmVudEtleXM7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZXZlbnQsIG5hbWUsIGRldGFpbCk7XG4gICAgfSxcblxuICAgIGZpbm1vdXNlbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpICYmIHRoaXMubW91c2Vkb3duKSB7XG4gICAgICAgICAgICB0aGlzLmJlRHJhZ2dpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1kcmFnc3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRyYWdzdGFydCA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCh0aGlzLm1vdXNlTG9jYXRpb24ueCwgdGhpcy5tb3VzZUxvY2F0aW9uLnkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYWwoZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5tb3VzZUxvY2F0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZHJhZycsIHtcbiAgICAgICAgICAgICAgICBkcmFnc3RhcnQ6IHRoaXMuZHJhZ3N0YXJ0LFxuICAgICAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvdW5kcy5jb250YWlucyh0aGlzLm1vdXNlTG9jYXRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtbW91c2Vtb3ZlJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmlubW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMubW91c2VEb3duTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLm1vdXNlZG93biA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLW1vdXNlZG93bicsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGFrZUZvY3VzKCk7XG4gICAgfSxcblxuICAgIGZpbm1vdXNldXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZHJhZ2VuZCcsIHtcbiAgICAgICAgICAgICAgICBkcmFnc3RhcnQ6IHRoaXMuZHJhZ3N0YXJ0LFxuICAgICAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5iZU5vdERyYWdnaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbmR0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtbW91c2V1cCcsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vdGhpcy5tb3VzZUxvY2F0aW9uID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KC0xLCAtMSk7XG4gICAgfSxcblxuICAgIGZpbm1vdXNlb3V0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5tb3VzZWRvd24pIHtcbiAgICAgICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCgtMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1tb3VzZW91dCcpO1xuICAgIH0sXG5cbiAgICBmaW53aGVlbG1vdmVkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcoKSB8fCAhdGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtd2hlZWxtb3ZlZCcsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpbmNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0aGlzLmRvdWJsZUNsaWNrVGltZXIgJiYgRGF0ZS5ub3coKSAtIHRoaXMubGFzdENsaWNrVGltZSA8IHRoaXMuZG91YmxlQ2xpY2tEZWxheSkge1xuICAgICAgICAgICAgLy90aGlzIGlzIGEgZG91YmxlIGNsaWNrLi4uXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kb3VibGVDbGlja1RpbWVyKTsgLy8gcHJldmVudCBjbGljayBldmVudFxuICAgICAgICAgICAgdGhpcy5kb3VibGVDbGlja1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5maW5kYmxjbGljayhlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENsaWNrVGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb3VibGVDbGlja1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYWwoZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWNsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMuZG91YmxlQ2xpY2tEZWxheSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmlucmVsZWFzZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmhvbGRQdWxzZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLXJlbGVhc2UnKTtcbiAgICB9LFxuXG4gICAgZmluZmxpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZmxpY2snLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW50cmFja3N0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLXRyYWNrc3RhcnQnKTtcbiAgICB9LFxuXG4gICAgZmludHJhY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtdHJhY2snKTtcbiAgICB9LFxuXG4gICAgZmludHJhY2tlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLXRyYWNrZW5kJyk7XG4gICAgfSxcblxuICAgIGZpbmhvbGQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWhvbGQnLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5ob2xkcHVsc2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWhvbGRwdWxzZScsIHtcbiAgICAgICAgICAgIGNvdW50OiB0aGlzLmhvbGRQdWxzZUNvdW50KytcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpbnRhcDogZnVuY3Rpb24oZSkge1xuICAgICAgICAvL3RoaXMgbm9uc2Vuc2UgaXMgdG8gaG9sZCBhIHRhcCBpZiBpdCdzIHJlYWxseSBhIGRvdWJsZSBjbGlja1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgZGlmID0gbm93IC0gdGhpcy5sYXN0RG91YmxlQ2xpY2tUaW1lO1xuICAgICAgICBpZiAoZGlmIDwgMzAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy9kcmFnZW5kIGlzIGFsc28gY2F1c2luZyBhIHRhcFxuICAgICAgICAvL2xldHMgZml4IHRoaXMgaGVyZVxuICAgICAgICBpZiAobm93IC0gdGhpcy5kcmFnRW5kdGltZSA8IDEwMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLl9maW50YXAoZSk7XG4gICAgICAgIH0sIDE4MCk7XG4gICAgfSxcblxuICAgIF9maW50YXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy90aGlzIG5vbnNlbnNlIGlzIHRvIGhvbGQgYSB0YXAgaWYgaXQncyByZWFsbHkgYSBkb3VibGUgY2xpY2tcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBkaWYgPSBub3cgLSB0aGlzLmxhc3REb3VibGVDbGlja1RpbWU7XG4gICAgICAgIGlmIChkaWYgPCAzMDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1vdXNlRG93bkxvY2F0aW9uKSB7IC8vIG1heWJlIG5vIG1vdXNlZG93biBvbiBhIHBob25lP1xuICAgICAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5tb3VzZURvd25Mb2NhdGlvbjsgLy8gbW91c2UgbWF5IGhhdmUgbW92ZWQgc2luY2UgbW91c2Vkb3duXG4gICAgICAgICAgICB0aGlzLm1vdXNlRG93bkxvY2F0aW9uID0gdW5kZWZpbmVkOyAvLyBjb25zdW1lIGl0IChtYXliZSBub3QgbmVlZGVkOyBvbmNlIGEgbW91c2Vkb3duIGFsd2F5cyBhIG1vdXNlZG93bilcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy10YXAnLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5kYmxjbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmxhc3REb3VibGVDbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZGJsY2xpY2snLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdkYmxjbGljaycsIHRoaXMuY3VycmVudEtleXMpO1xuICAgIH0sXG5cbiAgICBnZXRDaGFyTWFwOiBmdW5jdGlvbigpIHsgLy9UT0RPOiBUaGlzIGlzIHN0YXRpYy4gTWFrZSBpdCBhIHByb3BlcnR5IG9mIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgcmV0dXJuIGNoYXJNYXA7XG4gICAgfSxcblxuICAgIGZpbmtleWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIga2V5Q2hhciA9IGUuc2hpZnRLZXkgPyBjaGFyTWFwW2Uua2V5Q29kZV1bMV0gOiBjaGFyTWFwW2Uua2V5Q29kZV1bMF07XG4gICAgICAgIGlmIChlLnJlcGVhdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0S2V5ID09PSBrZXlDaGFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRLZXlDb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdEtleSA9IGtleUNoYXI7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRLZXlTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXBlYXRLZXkgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXBlYXRLZXlDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdEtleVN0YXJ0VGltZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEtleXMuaW5kZXhPZihrZXlDaGFyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEtleXMucHVzaChrZXlDaGFyKTtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKGtleUNoYXIsIGUua2V5Q29kZSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdFdmVudChlLCAnZmluLWNhbnZhcy1rZXlkb3duJywge1xuICAgICAgICAgICAgYWx0OiBlLmFsdEtleSxcbiAgICAgICAgICAgIGN0cmw6IGUuY3RybEtleSxcbiAgICAgICAgICAgIGNoYXI6IGtleUNoYXIsXG4gICAgICAgICAgICBjb2RlOiBlLmNoYXJDb2RlLFxuICAgICAgICAgICAga2V5OiBlLmtleUNvZGUsXG4gICAgICAgICAgICBtZXRhOiBlLm1ldGFLZXksXG4gICAgICAgICAgICByZXBlYXRDb3VudDogdGhpcy5yZXBlYXRLZXlDb3VudCxcbiAgICAgICAgICAgIHJlcGVhdFN0YXJ0VGltZTogdGhpcy5yZXBlYXRLZXlTdGFydFRpbWUsXG4gICAgICAgICAgICBzaGlmdDogZS5zaGlmdEtleSxcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGUua2V5SWRlbnRpZmllcixcbiAgICAgICAgICAgIGN1cnJlbnRLZXlzOiB0aGlzLmN1cnJlbnRLZXlzLnNsaWNlKDApXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5rZXl1cDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIga2V5Q2hhciA9IGUuc2hpZnRLZXkgPyBjaGFyTWFwW2Uua2V5Q29kZV1bMV0gOiBjaGFyTWFwW2Uua2V5Q29kZV1bMF07XG4gICAgICAgIHRoaXMuY3VycmVudEtleXMuc3BsaWNlKHRoaXMuY3VycmVudEtleXMuaW5kZXhPZihrZXlDaGFyKSwgMSk7XG4gICAgICAgIGlmICghdGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBlYXRLZXlDb3VudCA9IDA7XG4gICAgICAgIHRoaXMucmVwZWF0S2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXBlYXRLZXlTdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMta2V5dXAnLCB7XG4gICAgICAgICAgICBhbHQ6IGUuYWx0S2V5LFxuICAgICAgICAgICAgY3RybDogZS5jdHJsS2V5LFxuICAgICAgICAgICAgY2hhcjoga2V5Q2hhcixcbiAgICAgICAgICAgIGNvZGU6IGUuY2hhckNvZGUsXG4gICAgICAgICAgICBrZXk6IGUua2V5Q29kZSxcbiAgICAgICAgICAgIG1ldGE6IGUubWV0YUtleSxcbiAgICAgICAgICAgIHJlcGVhdDogZS5yZXBlYXQsXG4gICAgICAgICAgICBzaGlmdDogZS5zaGlmdEtleSxcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGUua2V5SWRlbnRpZmllcixcbiAgICAgICAgICAgIGN1cnJlbnRLZXlzOiB0aGlzLmN1cnJlbnRLZXlzLnNsaWNlKDApXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5mb2N1c2dhaW5lZDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMtZm9jdXMtZ2FpbmVkJyk7XG4gICAgfSxcblxuICAgIGZpbmZvY3VzbG9zdDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMtZm9jdXMtbG9zdCcpO1xuICAgIH0sXG5cbiAgICBmaW5jb250ZXh0bWVudTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5jdHJsS2V5ICYmIHRoaXMuY3VycmVudEtleXMuaW5kZXhPZignQ1RSTCcpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50S2V5cy5wdXNoKCdDVFJMJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyICYmIERhdGUubm93KCkgLSB0aGlzLmxhc3RDbGlja1RpbWUgPCB0aGlzLmRvdWJsZUNsaWNrRGVsYXkpIHtcbiAgICAgICAgICAgIC8vdGhpcyBpcyBhIGRvdWJsZSBjbGljay4uLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyKTsgLy8gcHJldmVudCBjb250ZXh0IG1lbnUgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5maW5kYmxjbGljayhlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENsaWNrVGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdWJsZVJpZ2h0Q2xpY2tUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtY29udGV4dC1tZW51Jywge1xuICAgICAgICAgICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMuZG91YmxlQ2xpY2tEZWxheSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVwYWludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmcHMgPSB0aGlzLmdldEZQUygpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFwYWludExvb3BSdW5uaW5nIHx8IGZwcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wYWludE5vdygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldE1vdXNlTG9jYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZUxvY2F0aW9uO1xuICAgIH0sXG5cbiAgICBnZXRPcmlnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcCA9IG5ldyByZWN0YW5ndWxhci5Qb2ludChyZWN0LmxlZnQsIHJlY3QudG9wKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIGdldExvY2FsOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBwID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KGUuY2xpZW50WCAtIHJlY3QubGVmdCwgZS5jbGllbnRZIC0gcmVjdC50b3ApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgaGFzRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5jYW52YXM7XG4gICAgfSxcblxuICAgIHRha2VGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYW52YXMuZm9jdXMoKTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBiZURyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzYWJsZURvY3VtZW50RWxlbWVudFNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICBiZU5vdERyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuYWJsZURvY3VtZW50RWxlbWVudFNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICBpc0RyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ2dpbmc7XG4gICAgfSxcblxuICAgIGRpc2FibGVEb2N1bWVudEVsZW1lbnRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgICAgICBzdHlsZS5jc3NUZXh0ID0gc3R5bGUuY3NzVGV4dCArICctd2Via2l0LXVzZXItc2VsZWN0OiBub25lJztcbiAgICB9LFxuXG4gICAgZW5hYmxlRG9jdW1lbnRFbGVtZW50U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgICAgc3R5bGUuY3NzVGV4dCA9IHN0eWxlLmNzc1RleHQucmVwbGFjZSgnLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZScsICcnKTtcbiAgICB9LFxuXG4gICAgc2V0Rm9jdXNhYmxlOiBmdW5jdGlvbih0cnV0aHkpIHtcbiAgICAgICAgdGhpcy5mb2N1c2VyLnN0eWxlLmRpc3BsYXkgPSB0cnV0aHkgPyAnJyA6ICdub25lJztcbiAgICB9LFxuXG4gICAgaXNSaWdodENsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBpc1JpZ2h0TUI7XG4gICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICAgICAgICBpZiAoJ3doaWNoJyBpbiBlKSB7IC8vIEdlY2tvIChGaXJlZm94KSwgV2ViS2l0IChTYWZhcmkvQ2hyb21lKSAmIE9wZXJhXG4gICAgICAgICAgICBpc1JpZ2h0TUIgPSBlLndoaWNoID09PSAzO1xuICAgICAgICB9IGVsc2UgaWYgKCdidXR0b24nIGluIGUpIHsgLy8gSUUsIE9wZXJhXG4gICAgICAgICAgICBpc1JpZ2h0TUIgPSBlLmJ1dHRvbiA9PT0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNSaWdodE1CO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHBhaW50TG9vcEZ1bmN0aW9uKG5vdykge1xuICAgIGlmICghcGFpbnRMb29wUnVubmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpbnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFpbnRhYmxlc1tpXS50aWNrUGFpbnRlcihub3cpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShwYWludExvb3BGdW5jdGlvbik7XG59XG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocGFpbnRMb29wRnVuY3Rpb24pO1xuXG5mdW5jdGlvbiByZXNpemFibGVzTG9vcEZ1bmN0aW9uKG5vdykge1xuICAgIGlmICghcmVzaXplTG9vcFJ1bm5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2l6YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc2l6YWJsZXNbaV0udGlja1Jlc2l6ZXIobm93KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnNldEludGVydmFsKHJlc2l6YWJsZXNMb29wRnVuY3Rpb24sIFJFU0laRV9QT0xMSU5HX0lOVEVSVkFMKTtcblxuZnVuY3Rpb24gbWFrZUNoYXJNYXAoKSB7XG4gICAgdmFyIG1hcCA9IFtdO1xuXG4gICAgdmFyIGVtcHR5ID0gWycnLCAnJ107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIG1hcFtpXSA9IGVtcHR5O1xuICAgIH1cblxuICAgIG1hcFsyN10gPSBbJ0VTQycsICdFU0NTSElGVCddO1xuICAgIG1hcFsxOTJdID0gWydgJywgJ34nXTtcbiAgICBtYXBbNDldID0gWycxJywgJyEnXTtcbiAgICBtYXBbNTBdID0gWycyJywgJ0AnXTtcbiAgICBtYXBbNTFdID0gWyczJywgJyMnXTtcbiAgICBtYXBbNTJdID0gWyc0JywgJyQnXTtcbiAgICBtYXBbNTNdID0gWyc1JywgJyUnXTtcbiAgICBtYXBbNTRdID0gWyc2JywgJ14nXTtcbiAgICBtYXBbNTVdID0gWyc3JywgJyYnXTtcbiAgICBtYXBbNTZdID0gWyc4JywgJyonXTtcbiAgICBtYXBbNTddID0gWyc5JywgJygnXTtcbiAgICBtYXBbNDhdID0gWycwJywgJyknXTtcbiAgICBtYXBbMTg5XSA9IFsnLScsICdfJ107XG4gICAgbWFwWzE4N10gPSBbJz0nLCAnKyddO1xuICAgIG1hcFs4XSA9IFsnQkFDS1NQQUNFJywgJ0JBQ0tTUEFDRVNISUZUJ107XG4gICAgbWFwWzQ2XSA9IFsnREVMRVRFJywgJ0RFTEVURVNISUZUJ107XG4gICAgbWFwWzldID0gWydUQUInLCAnVEFCU0hJRlQnXTtcbiAgICBtYXBbODFdID0gWydxJywgJ1EnXTtcbiAgICBtYXBbODddID0gWyd3JywgJ1cnXTtcbiAgICBtYXBbNjldID0gWydlJywgJ0UnXTtcbiAgICBtYXBbODJdID0gWydyJywgJ1InXTtcbiAgICBtYXBbODRdID0gWyd0JywgJ1QnXTtcbiAgICBtYXBbODldID0gWyd5JywgJ1knXTtcbiAgICBtYXBbODVdID0gWyd1JywgJ1UnXTtcbiAgICBtYXBbNzNdID0gWydpJywgJ0knXTtcbiAgICBtYXBbNzldID0gWydvJywgJ08nXTtcbiAgICBtYXBbODBdID0gWydwJywgJ1AnXTtcbiAgICBtYXBbMjE5XSA9IFsnWycsICd7J107XG4gICAgbWFwWzIyMV0gPSBbJ10nLCAnfSddO1xuICAgIG1hcFsyMjBdID0gWydcXFxcJywgJ3wnXTtcbiAgICBtYXBbMjIwXSA9IFsnQ0FQU0xPQ0snLCAnQ0FQU0xPQ0tTSElGVCddO1xuICAgIG1hcFs2NV0gPSBbJ2EnLCAnQSddO1xuICAgIG1hcFs4M10gPSBbJ3MnLCAnUyddO1xuICAgIG1hcFs2OF0gPSBbJ2QnLCAnRCddO1xuICAgIG1hcFs3MF0gPSBbJ2YnLCAnRiddO1xuICAgIG1hcFs3MV0gPSBbJ2cnLCAnRyddO1xuICAgIG1hcFs3Ml0gPSBbJ2gnLCAnSCddO1xuICAgIG1hcFs3NF0gPSBbJ2onLCAnSiddO1xuICAgIG1hcFs3NV0gPSBbJ2snLCAnSyddO1xuICAgIG1hcFs3Nl0gPSBbJ2wnLCAnTCddO1xuICAgIG1hcFsxODZdID0gWyc7JywgJzonXTtcbiAgICBtYXBbMjIyXSA9IFsnXFwnJywgJ3wnXTtcbiAgICBtYXBbMTNdID0gWydSRVRVUk4nLCAnUkVUVVJOU0hJRlQnXTtcbiAgICBtYXBbMTZdID0gWydTSElGVCcsICdTSElGVCddO1xuICAgIG1hcFs5MF0gPSBbJ3onLCAnWiddO1xuICAgIG1hcFs4OF0gPSBbJ3gnLCAnWCddO1xuICAgIG1hcFs2N10gPSBbJ2MnLCAnQyddO1xuICAgIG1hcFs4Nl0gPSBbJ3YnLCAnViddO1xuICAgIG1hcFs2Nl0gPSBbJ2InLCAnQiddO1xuICAgIG1hcFs3OF0gPSBbJ24nLCAnTiddO1xuICAgIG1hcFs3N10gPSBbJ20nLCAnTSddO1xuICAgIG1hcFsxODhdID0gWycsJywgJzwnXTtcbiAgICBtYXBbMTkwXSA9IFsnLicsICc+J107XG4gICAgbWFwWzE5MV0gPSBbJy8nLCAnPyddO1xuICAgIG1hcFsxNl0gPSBbJ1NISUZUJywgJ1NISUZUJ107XG4gICAgbWFwWzE3XSA9IFsnQ1RSTCcsICdDVFJMU0hJRlQnXTtcbiAgICBtYXBbMThdID0gWydBTFQnLCAnQUxUU0hJRlQnXTtcbiAgICBtYXBbOTFdID0gWydDT01NQU5ETEVGVCcsICdDT01NQU5ETEVGVFNISUZUJ107XG4gICAgbWFwWzMyXSA9IFsnU1BBQ0UnLCAnU1BBQ0VTSElGVCddO1xuICAgIG1hcFs5M10gPSBbJ0NPTU1BTkRSSUdIVCcsICdDT01NQU5EUklHSFRTSElGVCddO1xuICAgIG1hcFsxOF0gPSBbJ0FMVCcsICdBTFRTSElGVCddO1xuICAgIG1hcFszOF0gPSBbJ1VQJywgJ1VQU0hJRlQnXTtcbiAgICBtYXBbMzddID0gWydMRUZUJywgJ0xFRlRTSElGVCddO1xuICAgIG1hcFs0MF0gPSBbJ0RPV04nLCAnRE9XTlNISUZUJ107XG4gICAgbWFwWzM5XSA9IFsnUklHSFQnLCAnUklHSFRTSElGVCddO1xuXG4gICAgbWFwWzMzXSA9IFsnUEFHRVVQJywgJ1BBR0VVUFNISUZUJ107XG4gICAgbWFwWzM0XSA9IFsnUEFHRURPV04nLCAnUEFHRURPV05TSElGVCddO1xuICAgIG1hcFszNV0gPSBbJ1BBR0VSSUdIVCcsICdQQUdFUklHSFRTSElGVCddOyAvLyBFTkRcbiAgICBtYXBbMzZdID0gWydQQUdFTEVGVCcsICdQQUdFTEVGVFNISUZUJ107IC8vIEhPTUVcblxuICAgIG1hcFsxMTJdID0gWydGMScsICdGMVNISUZUJ107XG4gICAgbWFwWzExM10gPSBbJ0YyJywgJ0YyU0hJRlQnXTtcbiAgICBtYXBbMTE0XSA9IFsnRjMnLCAnRjNTSElGVCddO1xuICAgIG1hcFsxMTVdID0gWydGNCcsICdGNFNISUZUJ107XG4gICAgbWFwWzExNl0gPSBbJ0Y1JywgJ0Y1U0hJRlQnXTtcbiAgICBtYXBbMTE3XSA9IFsnRjYnLCAnRjZTSElGVCddO1xuICAgIG1hcFsxMThdID0gWydGNycsICdGN1NISUZUJ107XG4gICAgbWFwWzExOV0gPSBbJ0Y4JywgJ0Y4U0hJRlQnXTtcbiAgICBtYXBbMTIwXSA9IFsnRjknLCAnRjlTSElGVCddO1xuICAgIG1hcFsxMjFdID0gWydGMTAnLCAnRjEwU0hJRlQnXTtcbiAgICBtYXBbMTIyXSA9IFsnRjExJywgJ0YxUzFISUZUJ107XG4gICAgbWFwWzEyM10gPSBbJ0YxMicsICdGMTIxSElGVCddO1xuXG4gICAgcmV0dXJuIG1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb25zb2xlTG9nZ2VyID0gcmVxdWlyZSgnLi9nYy1jb25zb2xlLWxvZ2dlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGdjIC0gVGhlIDItRCBncmFwaGljcyBjb250ZXh0IGZyb20geW91ciBjYW52YXNcbiAqIEBwYXJhbSB7Ym9vbGVhbnxhcGlMb2dnZXJ9IFtsb2dnZXI9dHJ1ZV1cbiAqICogYHRydWVgIHVzZXMgYGdjLWNvbnNvbGUtbG9nZ2VyYCBmdW5jdGlvbiBib3VuZCB0byAnZ2MuJyBhcyBwcmVmaXhcbiAqICogc3RyaW5nIHVzZXMgYGdjLWNvbnNvbGUtbG9nZ2VyYCBmdW5jdGlvbiBib3VuZCB0byBzdHJpbmdcbiAqICogZnVuY3Rpb24gdXNlZCBhcyBpc1xuICovXG5mdW5jdGlvbiBHcmFwaGljc0NvbnRleHQoZ2MsIGxvZ2dlcikge1xuICAgIHRoaXMuZ2MgPSBnYztcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVXRUJLSVQgPSAvXndlYmtpdC87XG5cbiAgICBzd2l0Y2ggKHR5cGVvZiBsb2dnZXIpIHtcblxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgbG9nZ2VyID0gIGNvbnNvbGVMb2dnZXIuYmluZCh1bmRlZmluZWQsIGxvZ2dlciArICcuJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIGlmIChsb2dnZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIgPSBjb25zb2xlTG9nZ2VyLmJpbmQodW5kZWZpbmVkLCAnZ2MuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICBpZiAobG9nZ2VyLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgIHRocm93ICdHcmFwaGljc0NvbnRleHQ6IFVzZXItc3VwcGxpZWQgQVBJIGxvZ2dlciBmdW5jdGlvbiBkb2VzIG5vdCBhY2NlcHQgdGhyZWUgcGFyYW1ldGVycy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGxvZ2dlciA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFN0dWIgb3V0IGFsbCB0aGUgcHJvdG90eXBlIG1lbWJlcnMgb2YgdGhlIGNhbnZhcyAyRCBncmFwaGljcyBjb250ZXh0OlxuICAgIE9iamVjdC5rZXlzKE9iamVjdC5nZXRQcm90b3R5cGVPZihnYykpLmZvckVhY2goTWFrZVN0dWIpO1xuXG4gICAgLy8gU29tZSBvbGRlciBicm93c2VycyAoZS5nLiwgQ2hyb21lIDQwKSBkaWQgbm90IGhhdmUgYWxsIG1lbWJlcnMgb2YgY2FudmFzXG4gICAgLy8gMkQgZ3JhcGhpY3MgY29udGV4dCBpbiB0aGUgcHJvdG90eXBlIHNvIHdlIG1ha2UgdGhpcyBhZGRpdGlvbmFsIGNhbGw6XG4gICAgT2JqZWN0LmtleXMoZ2MpLmZvckVhY2goTWFrZVN0dWIpO1xuXG4gICAgZnVuY3Rpb24gTWFrZVN0dWIoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgaW4gR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZSB8fCByZVdFQktJVC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdjW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNlbGZba2V5XSA9ICFsb2dnZXIgPyBnY1trZXldLmJpbmQoZ2MpIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlcihrZXksIGFyZ3VtZW50cywgZ2Nba2V5XS5hcHBseShnYywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGtleSwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBnY1trZXldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyID8gbG9nZ2VyKGtleSwgJ2dldHRlcicsIHJlc3VsdCkgOiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdjW2tleV0gPSBsb2dnZXIgPyBsb2dnZXIoa2V5LCAnc2V0dGVyJywgdmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGhpY3NDb250ZXh0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgWUlFTERTID0gJ1xcdTI3RjknOyAvLyBMT05HIFJJR0hUV0FSRFMgRE9VQkxFIEFSUk9XXG5cbmZ1bmN0aW9uIGNvbnNvbGVMb2dnZXIocHJlZml4LCBuYW1lLCBhcmdzLCB2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlc3VsdCA9ICdcIicgKyByZXN1bHQgKyAnXCInO1xuICAgIH1cblxuICAgIG5hbWUgPSBwcmVmaXggKyBuYW1lO1xuXG4gICAgc3dpdGNoIChhcmdzKSB7XG4gICAgICAgIGNhc2UgJ2dldHRlcic6XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lLCAnPScsIHJlc3VsdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzZXR0ZXInOlxuICAgICAgICAgICAgY29uc29sZS5sb2cobmFtZSwgWUlFTERTLCByZXN1bHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDogLy8gbWV0aG9kIGNhbGxcbiAgICAgICAgICAgIG5hbWUgKz0gJygnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignLCAnKSArICcpJztcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lLCBZSUVMRFMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnNvbGVMb2dnZXI7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8vbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgdmFyIGhhc0Z1bGxQYXRoID0gZmFsc2U7XG5cbiAgICAvLyB0ZXN0IGZvciBmdWxsIGV2ZW50IHBhdGggc3VwcG9ydFxuICAgIHZhciBwYXRoVGVzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKTtcbiAgICBpZiAocGF0aFRlc3QuY3JlYXRlU2hhZG93Um9vdCkge1xuICAgICAgICB2YXIgc3IgPSBwYXRoVGVzdC5jcmVhdGVTaGFkb3dSb290KCk7XG4gICAgICAgIHZhciBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBzci5hcHBlbmRDaGlsZChzKTtcbiAgICAgICAgcGF0aFRlc3QuYWRkRXZlbnRMaXN0ZW5lcigndGVzdHBhdGgnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgaWYgKGV2LnBhdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3BhbiBpcyBpbiB0aGUgZXZlbnQgcGF0aCwgdGhlbiBwYXRoWzBdIGlzIHRoZSByZWFsIHNvdXJjZSBmb3IgYWxsIGV2ZW50c1xuICAgICAgICAgICAgICAgIGhhc0Z1bGxQYXRoID0gZXYucGF0aFswXSA9PT0gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGV2ID0gbmV3IEN1c3RvbUV2ZW50KCd0ZXN0cGF0aCcsIHtcbiAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG11c3QgYWRkIG5vZGUgdG8gRE9NIHRvIHRyaWdnZXIgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChwYXRoVGVzdCk7XG4gICAgICAgIHMuZGlzcGF0Y2hFdmVudChldik7XG4gICAgICAgIHBhdGhUZXN0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocGF0aFRlc3QpO1xuICAgICAgICBzciA9IHMgPSBudWxsO1xuICAgIH1cbiAgICBwYXRoVGVzdCA9IG51bGw7XG5cbiAgICB2YXIgdGFyZ2V0ID0ge1xuICAgICAgICBzaGFkb3c6IGZ1bmN0aW9uKGluRWwpIHtcbiAgICAgICAgICAgIGlmIChpbkVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluRWwuc2hhZG93Um9vdCB8fCBpbkVsLndlYmtpdFNoYWRvd1Jvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhblRhcmdldDogZnVuY3Rpb24oc2hhZG93KSB7XG4gICAgICAgICAgICByZXR1cm4gc2hhZG93ICYmIEJvb2xlYW4oc2hhZG93LmVsZW1lbnRGcm9tUG9pbnQpO1xuICAgICAgICB9LFxuICAgICAgICB0YXJnZXRpbmdTaGFkb3c6IGZ1bmN0aW9uKGluRWwpIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zaGFkb3coaW5FbCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5UYXJnZXQocykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb2xkZXJTaGFkb3c6IGZ1bmN0aW9uKHNoYWRvdykge1xuICAgICAgICAgICAgdmFyIG9zID0gc2hhZG93Lm9sZGVyU2hhZG93Um9vdDtcbiAgICAgICAgICAgIGlmICghb3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2UgPSBzaGFkb3cucXVlcnlTZWxlY3Rvcignc2hhZG93Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9zID0gc2Uub2xkZXJTaGFkb3dSb290O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcztcbiAgICAgICAgfSxcbiAgICAgICAgYWxsU2hhZG93czogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHNoYWRvd3MgPSBbXSxcbiAgICAgICAgICAgICAgICBzID0gdGhpcy5zaGFkb3coZWxlbWVudCk7XG4gICAgICAgICAgICB3aGlsZSAocykge1xuICAgICAgICAgICAgICAgIHNoYWRvd3MucHVzaChzKTtcbiAgICAgICAgICAgICAgICBzID0gdGhpcy5vbGRlclNoYWRvdyhzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaGFkb3dzO1xuICAgICAgICB9LFxuICAgICAgICBzZWFyY2hSb290OiBmdW5jdGlvbihpblJvb3QsIHgsIHkpIHtcbiAgICAgICAgICAgIHZhciB0LCBzdCwgc3IsIG9zO1xuICAgICAgICAgICAgaWYgKGluUm9vdCkge1xuICAgICAgICAgICAgICAgIHQgPSBpblJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBlbGVtZW50LCBjaGVjayBpZiBpdCBoYXMgYSBTaGFkb3dSb290XG4gICAgICAgICAgICAgICAgICAgIHNyID0gdGhpcy50YXJnZXRpbmdTaGFkb3codCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpblJvb3QgIT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzaWJsaW5nIHJvb3RzXG4gICAgICAgICAgICAgICAgICAgIHNyID0gdGhpcy5vbGRlclNoYWRvdyhpblJvb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzZWFyY2ggb3RoZXIgcm9vdHMsIGZhbGwgYmFjayB0byBsaWdodCBkb20gZWxlbWVudFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaFJvb3Qoc3IsIHgsIHkpIHx8IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG93bmVyOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcyA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAvLyB3YWxrIHVwIHVudGlsIHlvdSBoaXQgdGhlIHNoYWRvdyByb290IG9yIGRvY3VtZW50XG4gICAgICAgICAgICB3aGlsZSAocy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoZSBvd25lciBlbGVtZW50IGlzIGV4cGVjdGVkIHRvIGJlIGEgRG9jdW1lbnQgb3IgU2hhZG93Um9vdFxuICAgICAgICAgICAgaWYgKHMubm9kZVR5cGUgIT0gTm9kZS5ET0NVTUVOVF9OT0RFICYmIHMubm9kZVR5cGUgIT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcyA9IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRUYXJnZXQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChoYXNGdWxsUGF0aCAmJiBpbkV2ZW50LnBhdGggJiYgaW5FdmVudC5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbkV2ZW50LnBhdGhbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeCA9IGluRXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICB5ID0gaW5FdmVudC5jbGllbnRZO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGxpc3RlbmVyIGlzIGluIHRoZSBzaGFkb3cgcm9vdCwgaXQgaXMgbXVjaCBmYXN0ZXIgdG8gc3RhcnQgdGhlcmVcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5vd25lcihpbkV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAvLyBpZiB4LCB5IGlzIG5vdCBpbiB0aGlzIHJvb3QsIGZhbGwgYmFjayB0byBkb2N1bWVudCBzZWFyY2hcbiAgICAgICAgICAgIGlmICghcy5lbGVtZW50RnJvbVBvaW50KHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgcyA9IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoUm9vdChzLCB4LCB5KTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZFRvdWNoQWN0aW9uOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgIGlmIChoYXNGdWxsUGF0aCAmJiBpbkV2ZW50LnBhdGggJiYgaW5FdmVudC5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gaW5FdmVudC5wYXRoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBuID0gcGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIG4uaGFzQXR0cmlidXRlKCd0b3VjaC1hY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4uZ2V0QXR0cmlidXRlKCd0b3VjaC1hY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IGluRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBuLmhhc0F0dHJpYnV0ZSgndG91Y2gtYWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuLmdldEF0dHJpYnV0ZSgndG91Y2gtYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbiA9IG4ucGFyZW50Tm9kZSB8fCBuLmhvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXV0byBpcyBkZWZhdWx0XG4gICAgICAgICAgICByZXR1cm4gXCJhdXRvXCI7XG4gICAgICAgIH0sXG4gICAgICAgIExDQTogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhICYmICFiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiAmJiAhYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFiICYmICFhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFzdCBjYXNlLCBhIGlzIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgYiBvciB2aWNlIHZlcnNhXG4gICAgICAgICAgICBpZiAoYS5jb250YWlucyAmJiBhLmNvbnRhaW5zKGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYi5jb250YWlucyAmJiBiLmNvbnRhaW5zKGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWRlcHRoID0gdGhpcy5kZXB0aChhKTtcbiAgICAgICAgICAgIHZhciBiZGVwdGggPSB0aGlzLmRlcHRoKGIpO1xuICAgICAgICAgICAgdmFyIGQgPSBhZGVwdGggLSBiZGVwdGg7XG4gICAgICAgICAgICBpZiAoZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYSA9IHRoaXMud2FsayhhLCBkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYiA9IHRoaXMud2FsayhiLCAtZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoYSAmJiBiICYmIGEgIT09IGIpIHtcbiAgICAgICAgICAgICAgICBhID0gYS5wYXJlbnROb2RlIHx8IGEuaG9zdDtcbiAgICAgICAgICAgICAgICBiID0gYi5wYXJlbnROb2RlIHx8IGIuaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9LFxuICAgICAgICB3YWxrOiBmdW5jdGlvbihuLCB1KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgbiAmJiAoaSA8IHUpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuID0gbi5wYXJlbnROb2RlIHx8IG4uaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9LFxuICAgICAgICBkZXB0aDogZnVuY3Rpb24obikge1xuICAgICAgICAgICAgdmFyIGQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKG4pIHtcbiAgICAgICAgICAgICAgICBkKys7XG4gICAgICAgICAgICAgICAgbiA9IG4ucGFyZW50Tm9kZSB8fCBuLmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVlcENvbnRhaW5zOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICB2YXIgY29tbW9uID0gdGhpcy5MQ0EoYSwgYik7XG4gICAgICAgICAgICAvLyBpZiBhIGlzIHRoZSBjb21tb24gYW5jZXN0b3IsIGl0IG11c3QgXCJkZWVwbHlcIiBjb250YWluIGJcbiAgICAgICAgICAgIHJldHVybiBjb21tb24gPT09IGE7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2lkZU5vZGU6IGZ1bmN0aW9uKG5vZGUsIHgsIHkpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHJldHVybiAocmVjdC5sZWZ0IDw9IHgpICYmICh4IDw9IHJlY3QucmlnaHQpICYmIChyZWN0LnRvcCA8PSB5KSAmJiAoeSA8PSByZWN0LmJvdHRvbSk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhdGg6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICAgIGlmIChoYXNGdWxsUGF0aCAmJiBldmVudC5wYXRoICYmIGV2ZW50LnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcCA9IGV2ZW50LnBhdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMuZmluZFRhcmdldChldmVudCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcC5wdXNoKG4pO1xuICAgICAgICAgICAgICAgICAgICBuID0gbi5wYXJlbnROb2RlIHx8IG4uaG9zdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc2NvcGUudGFyZ2V0RmluZGluZyA9IHRhcmdldDtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBldmVudCwgZmluZHMgdGhlIFwiZGVlcGVzdFwiIG5vZGUgdGhhdCBjb3VsZCBoYXZlIGJlZW4gdGhlIG9yaWdpbmFsIHRhcmdldCBiZWZvcmUgU2hhZG93RE9NIHJldGFyZ2V0dGluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gRXZlbnQgQW4gZXZlbnQgb2JqZWN0IHdpdGggY2xpZW50WCBhbmQgY2xpZW50WSBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIHByb2JhYmxlIGV2ZW50IG9yaWduaW5hdG9yXG4gICAgICovXG4gICAgc2NvcGUuZmluZFRhcmdldCA9IHRhcmdldC5maW5kVGFyZ2V0LmJpbmQodGFyZ2V0KTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBcImNvbnRhaW5lclwiIG5vZGUgZGVlcGx5IGNvbnRhaW5zIHRoZSBcImNvbnRhaW5lZVwiIG5vZGUsIGluY2x1ZGluZyBzaXR1YXRpb25zIHdoZXJlIHRoZSBcImNvbnRhaW5lZVwiIGlzIGNvbnRhaW5lZCBieSBvbmUgb3IgbW9yZSBTaGFkb3dET01cbiAgICAgKiByb290cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHtOb2RlfSBjb250YWluZWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNjb3BlLmRlZXBDb250YWlucyA9IHRhcmdldC5kZWVwQ29udGFpbnMuYmluZCh0YXJnZXQpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgeC95IHBvc2l0aW9uIGlzIGluc2lkZSB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgZnVuY3Rpb24gdXBIYW5kbGVyKGV2ZW50KSB7XG4gICAgICogICAgICAgdmFyIGlubm9kZSA9IFBvbHltZXJHZXN0dXJlcy5pbnNpZGVOb2RlKGV2ZW50LnRhcmdldCwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICogICAgICAgaWYgKGlubm9kZSkge1xuICAgICAqICAgICAgICAgLy8gd2FpdCBmb3IgdGFwP1xuICAgICAqICAgICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgICAvLyB0YXAgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFNjcmVlbiBYIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgc2NyZWVuIFkgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNjb3BlLmluc2lkZU5vZGUgPSB0YXJnZXQuaW5zaWRlTm9kZTtcblxufSkoZXhwb3J0cyk7XG5cbihmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBzaGFkb3dTZWxlY3Rvcih2KSB7XG4gICAgICAgIHJldHVybiAnaHRtbCAvZGVlcC8gJyArIHNlbGVjdG9yKHYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdG9yKHYpIHtcbiAgICAgICAgcmV0dXJuICdbdG91Y2gtYWN0aW9uPVwiJyArIHYgKyAnXCJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydWxlKHYpIHtcbiAgICAgICAgcmV0dXJuICd7IC1tcy10b3VjaC1hY3Rpb246ICcgKyB2ICsgJzsgdG91Y2gtYWN0aW9uOiAnICsgdiArICc7fSc7XG4gICAgfVxuICAgIHZhciBhdHRyaWIyY3NzID0gW1xuICAgICAgICAnbm9uZScsXG4gICAgICAgICdhdXRvJyxcbiAgICAgICAgJ3Bhbi14JyxcbiAgICAgICAgJ3Bhbi15Jywge1xuICAgICAgICAgICAgcnVsZTogJ3Bhbi14IHBhbi15JyxcbiAgICAgICAgICAgIHNlbGVjdG9yczogW1xuICAgICAgICAgICAgICAgICdwYW4teCBwYW4teScsXG4gICAgICAgICAgICAgICAgJ3Bhbi15IHBhbi14J1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAnbWFuaXB1bGF0aW9uJ1xuICAgIF07XG4gICAgdmFyIHN0eWxlcyA9ICcnO1xuICAgIC8vIG9ubHkgaW5zdGFsbCBzdHlsZXNoZWV0IGlmIHRoZSBicm93c2VyIGhhcyB0b3VjaCBhY3Rpb24gc3VwcG9ydFxuICAgIHZhciBoYXNUb3VjaEFjdGlvbiA9IHR5cGVvZiBkb2N1bWVudC5oZWFkLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnc3RyaW5nJztcbiAgICAvLyBvbmx5IGFkZCBzaGFkb3cgc2VsZWN0b3JzIGlmIHNoYWRvd2RvbSBpcyBzdXBwb3J0ZWRcbiAgICB2YXIgaGFzU2hhZG93Um9vdCA9ICF3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwgJiYgZG9jdW1lbnQuaGVhZC5jcmVhdGVTaGFkb3dSb290O1xuXG4gICAgaWYgKGhhc1RvdWNoQWN0aW9uKSB7XG4gICAgICAgIGF0dHJpYjJjc3MuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICBpZiAoU3RyaW5nKHIpID09PSByKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzICs9IHNlbGVjdG9yKHIpICsgcnVsZShyKSArICdcXG4nO1xuICAgICAgICAgICAgICAgIGlmIChoYXNTaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcyArPSBzaGFkb3dTZWxlY3RvcihyKSArIHJ1bGUocikgKyAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlcyArPSByLnNlbGVjdG9ycy5tYXAoc2VsZWN0b3IpICsgcnVsZShyLnJ1bGUpICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzICs9IHIuc2VsZWN0b3JzLm1hcChzaGFkb3dTZWxlY3RvcikgKyBydWxlKHIucnVsZSkgKyAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gc3R5bGVzO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG59KSgpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbnN0cnVjdG9yIGZvciBuZXcgUG9pbnRlckV2ZW50cy5cbiAqXG4gKiBOZXcgUG9pbnRlciBFdmVudHMgbXVzdCBiZSBnaXZlbiBhIHR5cGUsIGFuZCBhbiBvcHRpb25hbCBkaWN0aW9uYXJ5IG9mXG4gKiBpbml0aWFsaXphdGlvbiBwcm9wZXJ0aWVzLlxuICpcbiAqIER1ZSB0byBjZXJ0YWluIHBsYXRmb3JtIHJlcXVpcmVtZW50cywgZXZlbnRzIHJldHVybmVkIGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gKiBpZGVudGlmeSBhcyBNb3VzZUV2ZW50cy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBpblR5cGUgVGhlIHR5cGUgb2YgdGhlIGV2ZW50IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbaW5EaWN0XSBBbiBvcHRpb25hbCBkaWN0aW9uYXJ5IG9mIGluaXRpYWwgZXZlbnQgcHJvcGVydGllcy5cbiAqIEByZXR1cm4ge0V2ZW50fSBBIG5ldyBQb2ludGVyRXZlbnQgb2YgdHlwZSBgaW5UeXBlYCBhbmQgaW5pdGlhbGl6ZWQgd2l0aCBwcm9wZXJ0aWVzIGZyb20gYGluRGljdGAuXG4gKi9cbihmdW5jdGlvbihzY29wZSkge1xuXG4gICAgdmFyIE1PVVNFX1BST1BTID0gW1xuICAgICAgICAnYnViYmxlcycsXG4gICAgICAgICdjYW5jZWxhYmxlJyxcbiAgICAgICAgJ3ZpZXcnLFxuICAgICAgICAnZGV0YWlsJyxcbiAgICAgICAgJ3NjcmVlblgnLFxuICAgICAgICAnc2NyZWVuWScsXG4gICAgICAgICdjbGllbnRYJyxcbiAgICAgICAgJ2NsaWVudFknLFxuICAgICAgICAnY3RybEtleScsXG4gICAgICAgICdhbHRLZXknLFxuICAgICAgICAnc2hpZnRLZXknLFxuICAgICAgICAnbWV0YUtleScsXG4gICAgICAgICdidXR0b24nLFxuICAgICAgICAncmVsYXRlZFRhcmdldCcsXG4gICAgICAgICdwYWdlWCcsXG4gICAgICAgICdwYWdlWSdcbiAgICBdO1xuXG4gICAgdmFyIE1PVVNFX0RFRkFVTFRTID0gW1xuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAwLFxuICAgICAgICBudWxsLFxuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgXTtcblxuICAgIHZhciBOT1BfRkFDVE9SWSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9O1xuXG4gICAgdmFyIGV2ZW50RmFjdG9yeSA9IHtcbiAgICAgICAgLy8gVE9ETyhkZnJlZWRtKTogdGhpcyBpcyBvdmVycmlkZGVuIGJ5IHRhcCByZWNvZ25pemVyLCBuZWVkcyByZXZpZXdcbiAgICAgICAgcHJldmVudFRhcDogTk9QX0ZBQ1RPUlksXG4gICAgICAgIG1ha2VCYXNlRXZlbnQ6IGZ1bmN0aW9uKGluVHlwZSwgaW5EaWN0KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICAgICAgZS5pbml0RXZlbnQoaW5UeXBlLCBpbkRpY3QuYnViYmxlcyB8fCBmYWxzZSwgaW5EaWN0LmNhbmNlbGFibGUgfHwgZmFsc2UpO1xuICAgICAgICAgICAgZS5wcmV2ZW50VGFwID0gZXZlbnRGYWN0b3J5LnByZXZlbnRUYXAoZSk7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFrZUdlc3R1cmVFdmVudDogZnVuY3Rpb24oaW5UeXBlLCBpbkRpY3QpIHtcbiAgICAgICAgICAgIGluRGljdCA9IGluRGljdCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMubWFrZUJhc2VFdmVudChpblR5cGUsIGluRGljdCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKGluRGljdCksIGs7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgayA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGsgIT09ICdidWJibGVzJyAmJiBrICE9PSAnY2FuY2VsYWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrXSA9IGluRGljdFtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFrZVBvaW50ZXJFdmVudDogZnVuY3Rpb24oaW5UeXBlLCBpbkRpY3QpIHtcbiAgICAgICAgICAgIGluRGljdCA9IGluRGljdCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMubWFrZUJhc2VFdmVudChpblR5cGUsIGluRGljdCk7XG4gICAgICAgICAgICAvLyBkZWZpbmUgaW5oZXJpdGVkIE1vdXNlRXZlbnQgcHJvcGVydGllc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDIsIHA7IGkgPCBNT1VTRV9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHAgPSBNT1VTRV9QUk9QU1tpXTtcbiAgICAgICAgICAgICAgICBlW3BdID0gaW5EaWN0W3BdIHx8IE1PVVNFX0RFRkFVTFRTW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5idXR0b25zID0gaW5EaWN0LmJ1dHRvbnMgfHwgMDtcblxuICAgICAgICAgICAgLy8gU3BlYyByZXF1aXJlcyB0aGF0IHBvaW50ZXJzIHdpdGhvdXQgcHJlc3N1cmUgc3BlY2lmaWVkIHVzZSAwLjUgZm9yIGRvd25cbiAgICAgICAgICAgIC8vIHN0YXRlIGFuZCAwIGZvciB1cCBzdGF0ZS5cbiAgICAgICAgICAgIHZhciBwcmVzc3VyZSA9IDA7XG4gICAgICAgICAgICBpZiAoaW5EaWN0LnByZXNzdXJlKSB7XG4gICAgICAgICAgICAgICAgcHJlc3N1cmUgPSBpbkRpY3QucHJlc3N1cmU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXNzdXJlID0gZS5idXR0b25zID8gMC41IDogMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIHgveSBwcm9wZXJ0aWVzIGFsaWFzZWQgdG8gY2xpZW50WC9ZXG4gICAgICAgICAgICBlLnggPSBlLmNsaWVudFg7XG4gICAgICAgICAgICBlLnkgPSBlLmNsaWVudFk7XG5cbiAgICAgICAgICAgIC8vIGRlZmluZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgUG9pbnRlckV2ZW50IGludGVyZmFjZVxuICAgICAgICAgICAgZS5wb2ludGVySWQgPSBpbkRpY3QucG9pbnRlcklkIHx8IDA7XG4gICAgICAgICAgICBlLndpZHRoID0gaW5EaWN0LndpZHRoIHx8IDA7XG4gICAgICAgICAgICBlLmhlaWdodCA9IGluRGljdC5oZWlnaHQgfHwgMDtcbiAgICAgICAgICAgIGUucHJlc3N1cmUgPSBwcmVzc3VyZTtcbiAgICAgICAgICAgIGUudGlsdFggPSBpbkRpY3QudGlsdFggfHwgMDtcbiAgICAgICAgICAgIGUudGlsdFkgPSBpbkRpY3QudGlsdFkgfHwgMDtcbiAgICAgICAgICAgIGUucG9pbnRlclR5cGUgPSBpbkRpY3QucG9pbnRlclR5cGUgfHwgJyc7XG4gICAgICAgICAgICBlLmh3VGltZXN0YW1wID0gaW5EaWN0Lmh3VGltZXN0YW1wIHx8IDA7XG4gICAgICAgICAgICBlLmlzUHJpbWFyeSA9IGluRGljdC5pc1ByaW1hcnkgfHwgZmFsc2U7XG4gICAgICAgICAgICBlLl9zb3VyY2UgPSBpbkRpY3QuX3NvdXJjZSB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHNjb3BlLmV2ZW50RmFjdG9yeSA9IGV2ZW50RmFjdG9yeTtcbn0pKGV4cG9ydHMpO1xuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGltcGxlbWVudHMgYW4gbWFwIG9mIHBvaW50ZXIgc3RhdGVzXG4gKi9cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBVU0VfTUFQID0gd2luZG93Lk1hcCAmJiB3aW5kb3cuTWFwLnByb3RvdHlwZS5mb3JFYWNoO1xuICAgIHZhciBQT0lOVEVSU19GTiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBQb2ludGVyTWFwKCkge1xuICAgICAgICBpZiAoVVNFX01BUCkge1xuICAgICAgICAgICAgdmFyIG0gPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBtLnBvaW50ZXJzID0gUE9JTlRFUlNfRk47XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFBvaW50ZXJNYXAucHJvdG90eXBlID0ge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGluSWQsIGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5rZXlzLmluZGV4T2YoaW5JZCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXNbaV0gPSBpbkV2ZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleXMucHVzaChpbklkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKGluRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoYXM6IGZ1bmN0aW9uKGluSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleXMuaW5kZXhPZihpbklkKSA+IC0xO1xuICAgICAgICB9LFxuICAgICAgICAnZGVsZXRlJzogZnVuY3Rpb24oaW5JZCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmtleXMuaW5kZXhPZihpbklkKTtcbiAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihpbklkKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMua2V5cy5pbmRleE9mKGluSWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzW2ldO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmtleXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHJldHVybiB2YWx1ZSwga2V5LCBtYXBcbiAgICAgICAgZm9yRWFjaDogZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24odiwgaSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdiwgdGhpcy5rZXlzW2ldLCB0aGlzKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzY29wZS5Qb2ludGVyTWFwID0gUG9pbnRlck1hcDtcbn0pKGV4cG9ydHMpO1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgQ0xPTkVfUFJPUFMgPSBbXG4gICAgICAgIC8vIE1vdXNlRXZlbnRcbiAgICAgICAgJ2J1YmJsZXMnLFxuICAgICAgICAnY2FuY2VsYWJsZScsXG4gICAgICAgICd2aWV3JyxcbiAgICAgICAgJ2RldGFpbCcsXG4gICAgICAgICdzY3JlZW5YJyxcbiAgICAgICAgJ3NjcmVlblknLFxuICAgICAgICAnY2xpZW50WCcsXG4gICAgICAgICdjbGllbnRZJyxcbiAgICAgICAgJ2N0cmxLZXknLFxuICAgICAgICAnYWx0S2V5JyxcbiAgICAgICAgJ3NoaWZ0S2V5JyxcbiAgICAgICAgJ21ldGFLZXknLFxuICAgICAgICAnYnV0dG9uJyxcbiAgICAgICAgJ3JlbGF0ZWRUYXJnZXQnLFxuICAgICAgICAvLyBET00gTGV2ZWwgM1xuICAgICAgICAnYnV0dG9ucycsXG4gICAgICAgIC8vIFBvaW50ZXJFdmVudFxuICAgICAgICAncG9pbnRlcklkJyxcbiAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICdwcmVzc3VyZScsXG4gICAgICAgICd0aWx0WCcsXG4gICAgICAgICd0aWx0WScsXG4gICAgICAgICdwb2ludGVyVHlwZScsXG4gICAgICAgICdod1RpbWVzdGFtcCcsXG4gICAgICAgICdpc1ByaW1hcnknLFxuICAgICAgICAvLyBldmVudCBpbnN0YW5jZVxuICAgICAgICAndHlwZScsXG4gICAgICAgICd0YXJnZXQnLFxuICAgICAgICAnY3VycmVudFRhcmdldCcsXG4gICAgICAgICd3aGljaCcsXG4gICAgICAgICdwYWdlWCcsXG4gICAgICAgICdwYWdlWScsXG4gICAgICAgICd0aW1lU3RhbXAnLFxuICAgICAgICAvLyBnZXN0dXJlIGFkZG9uc1xuICAgICAgICAncHJldmVudFRhcCcsXG4gICAgICAgICd0YXBQcmV2ZW50ZWQnLFxuICAgICAgICAnX3NvdXJjZSdcbiAgICBdO1xuXG4gICAgdmFyIENMT05FX0RFRkFVTFRTID0gW1xuICAgICAgICAvLyBNb3VzZUV2ZW50XG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDAsXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIERPTSBMZXZlbCAzXG4gICAgICAgIDAsXG4gICAgICAgIC8vIFBvaW50ZXJFdmVudFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAnJyxcbiAgICAgICAgMCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIC8vIGV2ZW50IGluc3RhbmNlXG4gICAgICAgICcnLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBmdW5jdGlvbigpIHt9LFxuICAgICAgICBmYWxzZVxuICAgIF07XG5cbiAgICB2YXIgSEFTX1NWR19JTlNUQU5DRSA9ICh0eXBlb2YgU1ZHRWxlbWVudEluc3RhbmNlICE9PSAndW5kZWZpbmVkJyk7XG5cbiAgICB2YXIgZXZlbnRGYWN0b3J5ID0gc2NvcGUuZXZlbnRGYWN0b3J5O1xuXG4gICAgLy8gc2V0IG9mIHJlY29nbml6ZXJzIHRvIHJ1biBmb3IgdGhlIGN1cnJlbnRseSBoYW5kbGVkIGV2ZW50XG4gICAgdmFyIGN1cnJlbnRHZXN0dXJlcztcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbW9kdWxlIGlzIGZvciBub3JtYWxpemluZyBldmVudHMuIE1vdXNlIGFuZCBUb3VjaCBldmVudHMgd2lsbCBiZVxuICAgICAqIGNvbGxlY3RlZCBoZXJlLCBhbmQgZmlyZSBQb2ludGVyRXZlbnRzIHRoYXQgaGF2ZSB0aGUgc2FtZSBzZW1hbnRpY3MsIG5vXG4gICAgICogbWF0dGVyIHRoZSBzb3VyY2UuXG4gICAgICogRXZlbnRzIGZpcmVkOlxuICAgICAqICAgLSBwb2ludGVyZG93bjogYSBwb2ludGluZyBpcyBhZGRlZFxuICAgICAqICAgLSBwb2ludGVydXA6IGEgcG9pbnRlciBpcyByZW1vdmVkXG4gICAgICogICAtIHBvaW50ZXJtb3ZlOiBhIHBvaW50ZXIgaXMgbW92ZWRcbiAgICAgKiAgIC0gcG9pbnRlcm92ZXI6IGEgcG9pbnRlciBjcm9zc2VzIGludG8gYW4gZWxlbWVudFxuICAgICAqICAgLSBwb2ludGVyb3V0OiBhIHBvaW50ZXIgbGVhdmVzIGFuIGVsZW1lbnRcbiAgICAgKiAgIC0gcG9pbnRlcmNhbmNlbDogYSBwb2ludGVyIHdpbGwgbm8gbG9uZ2VyIGdlbmVyYXRlIGV2ZW50c1xuICAgICAqL1xuICAgIHZhciBkaXNwYXRjaGVyID0ge1xuICAgICAgICBJU19JT1M6IGZhbHNlLFxuICAgICAgICBwb2ludGVybWFwOiBuZXcgc2NvcGUuUG9pbnRlck1hcCgpLFxuICAgICAgICByZXF1aXJlZEdlc3R1cmVzOiBuZXcgc2NvcGUuUG9pbnRlck1hcCgpLFxuICAgICAgICBldmVudE1hcDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgLy8gU2NvcGUgb2JqZWN0cyBmb3IgbmF0aXZlIGV2ZW50cy5cbiAgICAgICAgLy8gVGhpcyBleGlzdHMgZm9yIGVhc2Ugb2YgdGVzdGluZy5cbiAgICAgICAgZXZlbnRTb3VyY2VzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBldmVudFNvdXJjZUxpc3Q6IFtdLFxuICAgICAgICBnZXN0dXJlczogW10sXG4gICAgICAgIC8vIG1hcCBnZXN0dXJlIGV2ZW50IC0+IHtsaXN0ZW5lcnM6IGludCwgaW5kZXg6IGdlc3R1cmVzW2ludF19XG4gICAgICAgIGRlcGVuZGVuY3lNYXA6IHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBkb3duIGFuZCB1cCBhcmUgaW4gdGhlIG1hcCB0byB0cmlnZ2VyIFwicmVnaXN0ZXJcIlxuICAgICAgICAgICAgZG93bjoge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogMCxcbiAgICAgICAgICAgICAgICBpbmRleDogLTFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cDoge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogMCxcbiAgICAgICAgICAgICAgICBpbmRleDogLTFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VzdHVyZVF1ZXVlOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIG5ldyBldmVudCBzb3VyY2UgdGhhdCB3aWxsIGdlbmVyYXRlIHBvaW50ZXIgZXZlbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBgaW5Tb3VyY2VgIG11c3QgY29udGFpbiBhbiBhcnJheSBvZiBldmVudCBuYW1lcyBuYW1lZCBgZXZlbnRzYCwgYW5kXG4gICAgICAgICAqIGZ1bmN0aW9ucyB3aXRoIHRoZSBuYW1lcyBzcGVjaWZpZWQgaW4gdGhlIGBldmVudHNgIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIG5hbWUgZm9yIHRoZSBldmVudCBzb3VyY2VcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBBIG5ldyBzb3VyY2Ugb2YgcGxhdGZvcm0gZXZlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVnaXN0ZXJTb3VyY2U6IGZ1bmN0aW9uKG5hbWUsIHNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIHMgPSBzb3VyY2U7XG4gICAgICAgICAgICB2YXIgbmV3RXZlbnRzID0gcy5ldmVudHM7XG4gICAgICAgICAgICBpZiAobmV3RXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgbmV3RXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc1tlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudE1hcFtlXSA9IHNbZV0uYmluZChzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRTb3VyY2VzW25hbWVdID0gcztcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50U291cmNlTGlzdC5wdXNoKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3Rlckdlc3R1cmU6IGZ1bmN0aW9uKG5hbWUsIHNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBvYmoubGlzdGVuZXJzID0gMDtcbiAgICAgICAgICAgIG9iai5pbmRleCA9IHRoaXMuZ2VzdHVyZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGc7IGkgPCBzb3VyY2UuZXhwb3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGcgPSBzb3VyY2UuZXhwb3Nlc1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeU1hcFtnXSA9IG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2VzdHVyZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24oZWxlbWVudCwgaW5pdGlhbCkge1xuICAgICAgICAgICAgdmFyIGwgPSB0aGlzLmV2ZW50U291cmNlTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZXM7XG4gICAgICAgICAgICAgICAgKGkgPCBsKSAmJiAoZXMgPSB0aGlzLmV2ZW50U291cmNlTGlzdFtpXSk7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgZXZlbnRzb3VyY2UgcmVnaXN0ZXJcbiAgICAgICAgICAgICAgICBlcy5yZWdpc3Rlci5jYWxsKGVzLCBlbGVtZW50LCBpbml0aWFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdW5yZWdpc3RlcjogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGwgPSB0aGlzLmV2ZW50U291cmNlTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZXM7XG4gICAgICAgICAgICAgICAgKGkgPCBsKSAmJiAoZXMgPSB0aGlzLmV2ZW50U291cmNlTGlzdFtpXSk7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgZXZlbnRzb3VyY2UgcmVnaXN0ZXJcbiAgICAgICAgICAgICAgICBlcy51bnJlZ2lzdGVyLmNhbGwoZXMsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBFVkVOVFNcbiAgICAgICAgZG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlZEdlc3R1cmVzLnNldChpbkV2ZW50LnBvaW50ZXJJZCwgY3VycmVudEdlc3R1cmVzKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KCdkb3duJywgaW5FdmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmU6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIHBpcGUgbW92ZSBldmVudHMgaW50byBnZXN0dXJlIHF1ZXVlIGRpcmVjdGx5XG4gICAgICAgICAgICBpbkV2ZW50LnR5cGUgPSAnbW92ZSc7XG4gICAgICAgICAgICB0aGlzLmZpbGxHZXN0dXJlUXVldWUoaW5FdmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVFdmVudCgndXAnLCBpbkV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZWRHZXN0dXJlcy5kZWxldGUoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGluRXZlbnQudGFwUHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KCd1cCcsIGluRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlZEdlc3R1cmVzLmRlbGV0ZShpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEdlc3R1cmVEZXBlbmRlbmN5OiBmdW5jdGlvbihub2RlLCBjdXJyZW50R2VzdHVyZXMpIHtcbiAgICAgICAgICAgIHZhciBnZXN0dXJlc1dhbnRlZCA9IG5vZGUuX3BnRXZlbnRzO1xuICAgICAgICAgICAgaWYgKGdlc3R1cmVzV2FudGVkICYmIGN1cnJlbnRHZXN0dXJlcykge1xuICAgICAgICAgICAgICAgIHZhciBnayA9IE9iamVjdC5rZXlzKGdlc3R1cmVzV2FudGVkKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgciwgcmksIGc7IGkgPCBnay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXN0dXJlXG4gICAgICAgICAgICAgICAgICAgIGcgPSBna1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlc3R1cmVzV2FudGVkW2ddID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9va3VwIGdlc3R1cmUgcmVjb2duaXplclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHRoaXMuZGVwZW5kZW5jeU1hcFtnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlY29nbml6ZXIgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpID0gciA/IHIuaW5kZXggOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHZXN0dXJlc1tyaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBMSVNURU5FUiBMT0dJQ1xuICAgICAgICBldmVudEhhbmRsZXI6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBwcmV2ZW50IG11bHRpcGxlIGRpc3BhdGNoIG9mIGV2ZW50cyBmcm9tXG4gICAgICAgICAgICAvLyBwbGF0Zm9ybSBldmVudHMuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHR3byBlbGVtZW50cyBpbiBkaWZmZXJlbnQgc2NvcGVzXG4gICAgICAgICAgICAvLyBhcmUgc2V0IHVwIHRvIGNyZWF0ZSBwb2ludGVyIGV2ZW50cywgd2hpY2ggaXMgcmVsZXZhbnQgdG8gU2hhZG93IERPTS5cblxuICAgICAgICAgICAgdmFyIHR5cGUgPSBpbkV2ZW50LnR5cGU7XG5cbiAgICAgICAgICAgIC8vIG9ubHkgZ2VuZXJhdGUgdGhlIGxpc3Qgb2YgZGVzaXJlZCBldmVudHMgb24gXCJkb3duXCJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ21vdXNlZG93bicgfHwgdHlwZSA9PT0gJ3BvaW50ZXJkb3duJyB8fCB0eXBlID09PSAnTVNQb2ludGVyRG93bicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluRXZlbnQuX2hhbmRsZWRCeVBHKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHZXN0dXJlcyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGluIElPUyBtb2RlLCB0aGVyZSBpcyBvbmx5IGEgbGlzdGVuZXIgb24gdGhlIGRvY3VtZW50LCBzbyB0aGlzIGlzIG5vdCByZS1lbnRyYW50XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuSVNfSU9TKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldiA9IGluRXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdCA9IGluRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdXAgYSBmYWtlIGV2ZW50IHRvIGdpdmUgdG8gdGhlIHBhdGggYnVpbGRlclxuICAgICAgICAgICAgICAgICAgICAgICAgZXYgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBpbkV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBjdC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IGN0LmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogaW5FdmVudC5wYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBldmVudCBwYXRoIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGJ1aWxkIGEgcGF0aCBmcm9tIHRhcmdldCBmaW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IGluRXZlbnQucGF0aCB8fCBzY29wZS50YXJnZXRGaW5kaW5nLnBhdGgoZXYpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbjsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEdlc3R1cmVEZXBlbmRlbmN5KG4sIGN1cnJlbnRHZXN0dXJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEdlc3R1cmVEZXBlbmRlbmN5KGluRXZlbnQuY3VycmVudFRhcmdldCwgY3VycmVudEdlc3R1cmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbkV2ZW50Ll9oYW5kbGVkQnlQRykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmbiA9IHRoaXMuZXZlbnRNYXAgJiYgdGhpcy5ldmVudE1hcFt0eXBlXTtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIGZuKGluRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5FdmVudC5faGFuZGxlZEJ5UEcgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICAvLyBzZXQgdXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIGxpc3RlbjogZnVuY3Rpb24odGFyZ2V0LCBldmVudHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnRzLmxlbmd0aCwgZTtcbiAgICAgICAgICAgICAgICAoaSA8IGwpICYmIChlID0gZXZlbnRzW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudCh0YXJnZXQsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHVubGlzdGVuOiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudHMubGVuZ3RoLCBlO1xuICAgICAgICAgICAgICAgIChpIDwgbCkgJiYgKGUgPSBldmVudHNbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50KHRhcmdldCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEV2ZW50OiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLmJvdW5kSGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUV2ZW50OiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLmJvdW5kSGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVWRU5UIENSRUFUSU9OIEFORCBUUkFDS0lOR1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBFdmVudCBvZiB0eXBlIGBpblR5cGVgLCBiYXNlZCBvbiB0aGUgaW5mb3JtYXRpb24gaW5cbiAgICAgICAgICogYGluRXZlbnRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5UeXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdHlwZSBvZiBldmVudCB0byBjcmVhdGVcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBBIHBsYXRmb3JtIGV2ZW50IHdpdGggYSB0YXJnZXRcbiAgICAgICAgICogQHJldHVybiB7RXZlbnR9IEEgUG9pbnRlckV2ZW50IG9mIHR5cGUgYGluVHlwZWBcbiAgICAgICAgICovXG4gICAgICAgIG1ha2VFdmVudDogZnVuY3Rpb24oaW5UeXBlLCBpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGV2ZW50RmFjdG9yeS5tYWtlUG9pbnRlckV2ZW50KGluVHlwZSwgaW5FdmVudCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID0gaW5FdmVudC5wcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgICAgIGUudGFwUHJldmVudGVkID0gaW5FdmVudC50YXBQcmV2ZW50ZWQ7XG4gICAgICAgICAgICBlLl90YXJnZXQgPSBlLl90YXJnZXQgfHwgaW5FdmVudC50YXJnZXQ7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gbWFrZSBhbmQgZGlzcGF0Y2ggYW4gZXZlbnQgaW4gb25lIGNhbGxcbiAgICAgICAgZmlyZUV2ZW50OiBmdW5jdGlvbihpblR5cGUsIGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5tYWtlRXZlbnQoaW5UeXBlLCBpbkV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgc25hcHNob3Qgb2YgaW5FdmVudCwgd2l0aCB3cml0YWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IEFuIGV2ZW50IHRoYXQgY29udGFpbnMgcHJvcGVydGllcyB0byBjb3B5LlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHNoYWxsb3cgY29waWVzIG9mIGBpbkV2ZW50YCdzXG4gICAgICAgICAqICAgIHByb3BlcnRpZXMuXG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZUV2ZW50OiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRDb3B5ID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICBwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDTE9ORV9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHAgPSBDTE9ORV9QUk9QU1tpXTtcbiAgICAgICAgICAgICAgICBldmVudENvcHlbcF0gPSBpbkV2ZW50W3BdIHx8IENMT05FX0RFRkFVTFRTW2ldO1xuICAgICAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIFNWR0luc3RhbmNlRWxlbWVudCBzaGFkb3cgdHJlZVxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgPHVzZT4gZWxlbWVudCB0aGF0IGlzIHJlcHJlc2VudGVkIGJ5IHRoZSBpbnN0YW5jZSBmb3IgU2FmYXJpLCBDaHJvbWUsIElFLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGJlaGF2aW9yIGltcGxlbWVudGVkIGJ5IEZpcmVmb3guXG4gICAgICAgICAgICAgICAgaWYgKHAgPT09ICd0YXJnZXQnIHx8IHAgPT09ICdyZWxhdGVkVGFyZ2V0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoSEFTX1NWR19JTlNUQU5DRSAmJiBldmVudENvcHlbcF0gaW5zdGFuY2VvZiBTVkdFbGVtZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Q29weVtwXSA9IGV2ZW50Q29weVtwXS5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGtlZXAgdGhlIHNlbWFudGljcyBvZiBwcmV2ZW50RGVmYXVsdFxuICAgICAgICAgICAgZXZlbnRDb3B5LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaW5FdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBldmVudENvcHk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaGVzIHRoZSBldmVudCB0byBpdHMgdGFyZ2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGFuIGV2ZW50IGhhbmRsZXIgcmV0dXJucyB0cnVlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdCA9IGluRXZlbnQuX3RhcmdldDtcbiAgICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICAgICAgdC5kaXNwYXRjaEV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIGNsb25lIHRoZSBldmVudCBmb3IgdGhlIGdlc3R1cmUgc3lzdGVtIHRvIHByb2Nlc3NcbiAgICAgICAgICAgICAgICAvLyBjbG9uZSBhZnRlciBkaXNwYXRjaCB0byBwaWNrIHVwIGdlc3R1cmUgcHJldmVudGlvbiBjb2RlXG4gICAgICAgICAgICAgICAgdmFyIGNsb25lID0gdGhpcy5jbG9uZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIGNsb25lLnRhcmdldCA9IHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxsR2VzdHVyZVF1ZXVlKGNsb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VzdHVyZVRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gcHJvY2VzcyB0aGUgZ2VzdHVyZSBxdWV1ZVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGUsIHJnOyBpIDwgdGhpcy5nZXN0dXJlUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlID0gdGhpcy5nZXN0dXJlUXVldWVbaV07XG4gICAgICAgICAgICAgICAgcmcgPSBlLl9yZXF1aXJlZEdlc3R1cmVzO1xuICAgICAgICAgICAgICAgIGlmIChyZykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgZywgZm47IGogPCB0aGlzLmdlc3R1cmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHJ1biByZWNvZ25pemVyIGlmIGFuIGVsZW1lbnQgaW4gdGhlIHNvdXJjZSBldmVudCdzIHBhdGggaXMgbGlzdGVuaW5nIGZvciB0aG9zZSBnZXN0dXJlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJnW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHRoaXMuZ2VzdHVyZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBnW2UudHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmNhbGwoZywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nZXN0dXJlUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsbEdlc3R1cmVRdWV1ZTogZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgdHJpZ2dlciB0aGUgZ2VzdHVyZSBxdWV1ZSBvbmNlXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2VzdHVyZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmJvdW5kR2VzdHVyZVRyaWdnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXYuX3JlcXVpcmVkR2VzdHVyZXMgPSB0aGlzLnJlcXVpcmVkR2VzdHVyZXMuZ2V0KGV2LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICB0aGlzLmdlc3R1cmVRdWV1ZS5wdXNoKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZGlzcGF0Y2hlci5ib3VuZEhhbmRsZXIgPSBkaXNwYXRjaGVyLmV2ZW50SGFuZGxlci5iaW5kKGRpc3BhdGNoZXIpO1xuICAgIGRpc3BhdGNoZXIuYm91bmRHZXN0dXJlVHJpZ2dlciA9IGRpc3BhdGNoZXIuZ2VzdHVyZVRyaWdnZXIuYmluZChkaXNwYXRjaGVyKTtcbiAgICBzY29wZS5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcblxuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgYGdlc3R1cmVgIG9uIGBub2RlYCB3aXRoIHRoZSBgaGFuZGxlcmAgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIElmIGBoYW5kbGVyYCBpcyB0aGUgZmlyc3QgbGlzdGVuZXIgZm9yIGBnZXN0dXJlYCwgdGhlIHVuZGVybHlpbmcgZ2VzdHVyZSByZWNvZ25pemVyIGlzIHRoZW4gZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBnZXN0dXJlXG4gICAgICogQHJldHVybiBCb29sZWFuIGBnZXN0dXJlYCBpcyBhIHZhbGlkIGdlc3R1cmVcbiAgICAgKi9cbiAgICBzY29wZS5hY3RpdmF0ZUdlc3R1cmUgPSBmdW5jdGlvbihub2RlLCBnZXN0dXJlKSB7XG4gICAgICAgIHZhciBnID0gZ2VzdHVyZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgZGVwID0gZGlzcGF0Y2hlci5kZXBlbmRlbmN5TWFwW2ddO1xuICAgICAgICBpZiAoZGVwKSB7XG4gICAgICAgICAgICB2YXIgcmVjb2duaXplciA9IGRpc3BhdGNoZXIuZ2VzdHVyZXNbZGVwLmluZGV4XTtcbiAgICAgICAgICAgIGlmICghbm9kZS5fcGdMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyKG5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUuX3BnTGlzdGVuZXJzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8oZGZyZWVkbSk6IHJlLWV2YWx1YXRlIGJvb2trZWVwaW5nIHRvIGF2b2lkIHVzaW5nIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoQWN0aW9uID0gcmVjb2duaXplci5kZWZhdWx0QWN0aW9ucyAmJiByZWNvZ25pemVyLmRlZmF1bHRBY3Rpb25zW2ddO1xuICAgICAgICAgICAgICAgIHZhciBhY3Rpb25Ob2RlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25Ob2RlID0gbm9kZS5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25Ob2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG91Y2hBY3Rpb24gJiYgYWN0aW9uTm9kZSAmJiAhYWN0aW9uTm9kZS5oYXNBdHRyaWJ1dGUoJ3RvdWNoLWFjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbk5vZGUuc2V0QXR0cmlidXRlKCd0b3VjaC1hY3Rpb24nLCB0b3VjaEFjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub2RlLl9wZ0V2ZW50cykge1xuICAgICAgICAgICAgICAgIG5vZGUuX3BnRXZlbnRzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLl9wZ0V2ZW50c1tnXSA9IChub2RlLl9wZ0V2ZW50c1tnXSB8fCAwKSArIDE7XG4gICAgICAgICAgICBub2RlLl9wZ0xpc3RlbmVycysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCb29sZWFuKGRlcCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogTGlzdGVuIGZvciBgZ2VzdHVyZWAgZnJvbSBgbm9kZWAgd2l0aCBgaGFuZGxlcmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ2VzdHVyZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAgICAgKi9cbiAgICBzY29wZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24obm9kZSwgZ2VzdHVyZSwgaGFuZGxlciwgY2FwdHVyZSkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgc2NvcGUuYWN0aXZhdGVHZXN0dXJlKG5vZGUsIGdlc3R1cmUpO1xuICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGdlc3R1cmUsIGhhbmRsZXIsIGNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlYXJzIGRvd24gdGhlIGdlc3R1cmUgY29uZmlndXJhdGlvbiBmb3IgYG5vZGVgXG4gICAgICpcbiAgICAgKiBJZiBgaGFuZGxlcmAgaXMgdGhlIGxhc3QgbGlzdGVuZXIgZm9yIGBnZXN0dXJlYCwgdGhlIHVuZGVybHlpbmcgZ2VzdHVyZSByZWNvZ25pemVyIGlzIGRpc2FibGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdlc3R1cmVcbiAgICAgKiBAcmV0dXJuIEJvb2xlYW4gYGdlc3R1cmVgIGlzIGEgdmFsaWQgZ2VzdHVyZVxuICAgICAqL1xuICAgIHNjb3BlLmRlYWN0aXZhdGVHZXN0dXJlID0gZnVuY3Rpb24obm9kZSwgZ2VzdHVyZSkge1xuICAgICAgICB2YXIgZyA9IGdlc3R1cmUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGRlcCA9IGRpc3BhdGNoZXIuZGVwZW5kZW5jeU1hcFtnXTtcbiAgICAgICAgaWYgKGRlcCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuX3BnTGlzdGVuZXJzID4gMCkge1xuICAgICAgICAgICAgICAgIG5vZGUuX3BnTGlzdGVuZXJzLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5fcGdMaXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLnVucmVnaXN0ZXIobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5fcGdFdmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5fcGdFdmVudHNbZ10gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX3BnRXZlbnRzW2ddLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fcGdFdmVudHNbZ10gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQm9vbGVhbihkZXApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGxpc3RlbmluZyBmb3IgYGdlc3R1cmVgIGZyb20gYG5vZGVgIHdpdGggYGhhbmRsZXJgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdlc3R1cmVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gICAgICovXG4gICAgc2NvcGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKG5vZGUsIGdlc3R1cmUsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHNjb3BlLmRlYWN0aXZhdGVHZXN0dXJlKG5vZGUsIGdlc3R1cmUpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGdlc3R1cmUsIGhhbmRsZXIsIGNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKGV4cG9ydHMpO1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHNjb3BlLmRpc3BhdGNoZXI7XG4gICAgdmFyIHBvaW50ZXJtYXAgPSBkaXNwYXRjaGVyLnBvaW50ZXJtYXA7XG4gICAgLy8gcmFkaXVzIGFyb3VuZCB0b3VjaGVuZCB0aGF0IHN3YWxsb3dzIG1vdXNlIGV2ZW50c1xuICAgIHZhciBERURVUF9ESVNUID0gMjU7XG5cbiAgICB2YXIgV0hJQ0hfVE9fQlVUVE9OUyA9IFswLCAxLCA0LCAyXTtcblxuICAgIHZhciBjdXJyZW50QnV0dG9ucyA9IDA7XG5cbiAgICB2YXIgRklSRUZPWF9MSU5VWCA9IC9MaW51eC4qRmlyZWZveFxcLy9pO1xuXG4gICAgdmFyIEhBU19CVVRUT05TID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBmaXJlZm94IG9uIGxpbnV4IHJldHVybnMgc3BlYy1pbmNvcnJlY3QgdmFsdWVzIGZvciBtb3VzZXVwLmJ1dHRvbnNcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQuYnV0dG9ucyNTZWVfYWxzb1xuICAgICAgICAvLyBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzcyNzU5MzAwMy8jbXNnMTZcbiAgICAgICAgaWYgKEZJUkVGT1hfTElOVVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vdXNlRXZlbnQoJ3Rlc3QnLCB7XG4gICAgICAgICAgICAgICAgYnV0dG9uczogMVxuICAgICAgICAgICAgfSkuYnV0dG9ucyA9PT0gMTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSkoKTtcblxuICAgIC8vIGhhbmRsZXIgYmxvY2sgZm9yIG5hdGl2ZSBtb3VzZSBldmVudHNcbiAgICB2YXIgbW91c2VFdmVudHMgPSB7XG4gICAgICAgIFBPSU5URVJfSUQ6IDEsXG4gICAgICAgIFBPSU5URVJfVFlQRTogJ21vdXNlJyxcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAnbW91c2Vkb3duJyxcbiAgICAgICAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgJ21vdXNldXAnXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgICAgICAnbW92ZSdcbiAgICAgICAgXSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2hlci51bmxpc3Rlbih0YXJnZXQsIHRoaXMuZXZlbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGFzdFRvdWNoZXM6IFtdLFxuICAgICAgICAvLyBjb2xsaWRlIHdpdGggdGhlIGdsb2JhbCBtb3VzZSBsaXN0ZW5lclxuICAgICAgICBpc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcbiAgICAgICAgICAgIHZhciB4ID0gaW5FdmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHkgPSBpbkV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGx0cy5sZW5ndGgsIHQ7IGkgPCBsICYmICh0ID0gbHRzW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyB3aWxsIGJlIHN3YWxsb3dlZCBuZWFyIGEgcHJpbWFyeSB0b3VjaGVuZFxuICAgICAgICAgICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpLFxuICAgICAgICAgICAgICAgICAgICBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xuICAgICAgICAgICAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUICYmIGR5IDw9IERFRFVQX0RJU1QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJlRXZlbnQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gZGlzcGF0Y2hlci5jbG9uZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgZS5wb2ludGVySWQgPSB0aGlzLlBPSU5URVJfSUQ7XG4gICAgICAgICAgICBlLmlzUHJpbWFyeSA9IHRydWU7XG4gICAgICAgICAgICBlLnBvaW50ZXJUeXBlID0gdGhpcy5QT0lOVEVSX1RZUEU7XG4gICAgICAgICAgICBlLl9zb3VyY2UgPSAnbW91c2UnO1xuICAgICAgICAgICAgaWYgKCFIQVNfQlVUVE9OUykge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gaW5FdmVudC50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBiaXQgPSBXSElDSF9UT19CVVRUT05TW2luRXZlbnQud2hpY2hdIHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCdXR0b25zIHw9IGJpdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3VzZXVwJykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QnV0dG9ucyAmPSB+Yml0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLmJ1dHRvbnMgPSBjdXJyZW50QnV0dG9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9LFxuICAgICAgICBtb3VzZWRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoKGluRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwb2ludGVybWFwLmhhcyh0aGlzLlBPSU5URVJfSUQpO1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgZS50YXJnZXQgPSBzY29wZS5maW5kVGFyZ2V0KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJtYXAuc2V0KHRoaXMuUE9JTlRFUl9JRCwgZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIuZG93bihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaChpbkV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBwb2ludGVybWFwLmdldCh0aGlzLlBPSU5URVJfSUQpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBjYXNlIHdoZXJlIHdlIG1pc3NlZCBhIG1vdXNldXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKChIQVNfQlVUVE9OUyA/IGUuYnV0dG9ucyA6IGUud2hpY2gpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUhBU19CVVRUT05TKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJ1dHRvbnMgPSBlLmJ1dHRvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5jYW5jZWwoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBNb3VzZShlLmJ1dHRvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5tb3ZlKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3VzZXVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaChpbkV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICBlLnRhcmdldCA9IHBvaW50ZXJtYXAuZ2V0KHRoaXMuUE9JTlRFUl9JRCk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci51cChlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBNb3VzZShlLmJ1dHRvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbGVhbnVwTW91c2U6IGZ1bmN0aW9uKGJ1dHRvbnMpIHtcbiAgICAgICAgICAgIGlmIChidXR0b25zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5kZWxldGUodGhpcy5QT0lOVEVSX0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzY29wZS5tb3VzZUV2ZW50cyA9IG1vdXNlRXZlbnRzO1xufSkoZXhwb3J0cyk7XG5cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgYWxsU2hhZG93cyA9IHNjb3BlLnRhcmdldEZpbmRpbmcuYWxsU2hhZG93cy5iaW5kKHNjb3BlLnRhcmdldEZpbmRpbmcpO1xuICAgIHZhciBwb2ludGVybWFwID0gZGlzcGF0Y2hlci5wb2ludGVybWFwO1xuICAgIHZhciB0b3VjaE1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbC5iaW5kKEFycmF5LnByb3RvdHlwZS5tYXApO1xuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGxvbmcgZW5vdWdoIHRvIGlnbm9yZSBjb21wYXQgbW91c2UgZXZlbnRzIG1hZGUgYnkgdG91Y2hcbiAgICB2YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG4gICAgdmFyIERFRFVQX0RJU1QgPSAyNTtcbiAgICB2YXIgQ0xJQ0tfQ09VTlRfVElNRU9VVCA9IDIwMDtcbiAgICB2YXIgSFlTVEVSRVNJUyA9IDIwO1xuICAgIHZhciBBVFRSSUIgPSAndG91Y2gtYWN0aW9uJztcbiAgICAvLyBUT0RPKGRmcmVlZG0pOiBkaXNhYmxlIHVudGlsIGh0dHA6Ly9jcmJ1Zy5jb20vMzk5NzY1IGlzIHJlc29sdmVkXG4gICAgLy8gdmFyIEhBU19UT1VDSF9BQ1RJT04gPSBBVFRSSUIgaW4gZG9jdW1lbnQuaGVhZC5zdHlsZTtcbiAgICB2YXIgSEFTX1RPVUNIX0FDVElPTiA9IGZhbHNlO1xuXG4gICAgLy8gaGFuZGxlciBibG9jayBmb3IgbmF0aXZlIHRvdWNoIGV2ZW50c1xuICAgIHZhciB0b3VjaEV2ZW50cyA9IHtcbiAgICAgICAgSVNfSU9TOiBmYWxzZSxcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAndG91Y2hzdGFydCcsXG4gICAgICAgICAgICAndG91Y2htb3ZlJyxcbiAgICAgICAgICAgICd0b3VjaGVuZCcsXG4gICAgICAgICAgICAndG91Y2hjYW5jZWwnXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgICAgICAnbW92ZSdcbiAgICAgICAgXSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCwgaW5pdGlhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuSVNfSU9TID8gaW5pdGlhbCA6ICFpbml0aWFsKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLklTX0lPUykge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIudW5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNjcm9sbFR5cGVzOiB7XG4gICAgICAgICAgICBFTUlUVEVSOiAnbm9uZScsXG4gICAgICAgICAgICBYU0NST0xMRVI6ICdwYW4teCcsXG4gICAgICAgICAgICBZU0NST0xMRVI6ICdwYW4teScsXG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoQWN0aW9uVG9TY3JvbGxUeXBlOiBmdW5jdGlvbih0b3VjaEFjdGlvbikge1xuICAgICAgICAgICAgdmFyIHQgPSB0b3VjaEFjdGlvbjtcbiAgICAgICAgICAgIHZhciBzdCA9IHRoaXMuc2Nyb2xsVHlwZXM7XG4gICAgICAgICAgICBpZiAodCA9PT0gc3QuRU1JVFRFUikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQgPT09IHN0LlhTQ1JPTExFUikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnWCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQgPT09IHN0LllTQ1JPTExFUikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnWSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnWFknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBQT0lOVEVSX1RZUEU6ICd0b3VjaCcsXG4gICAgICAgIGZpcnN0VG91Y2g6IG51bGwsXG4gICAgICAgIGlzUHJpbWFyeVRvdWNoOiBmdW5jdGlvbihpblRvdWNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdFRvdWNoID09PSBpblRvdWNoLmlkZW50aWZpZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFByaW1hcnlUb3VjaDogZnVuY3Rpb24oaW5Ub3VjaCkge1xuICAgICAgICAgICAgLy8gc2V0IHByaW1hcnkgdG91Y2ggaWYgdGhlcmUgbm8gcG9pbnRlcnMsIG9yIHRoZSBvbmx5IHBvaW50ZXIgaXMgdGhlIG1vdXNlXG4gICAgICAgICAgICBpZiAocG9pbnRlcm1hcC5wb2ludGVycygpID09PSAwIHx8IChwb2ludGVybWFwLnBvaW50ZXJzKCkgPT09IDEgJiYgcG9pbnRlcm1hcC5oYXMoMSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdFRvdWNoID0gaW5Ub3VjaC5pZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RYWSA9IHtcbiAgICAgICAgICAgICAgICAgICAgWDogaW5Ub3VjaC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICBZOiBpblRvdWNoLmNsaWVudFlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RUYXJnZXQgPSBpblRvdWNoLnRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxSZXNldENsaWNrQ291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlUHJpbWFyeVBvaW50ZXI6IGZ1bmN0aW9uKGluUG9pbnRlcikge1xuICAgICAgICAgICAgaWYgKGluUG9pbnRlci5pc1ByaW1hcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0VG91Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RYWSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldENsaWNrQ291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xpY2tDb3VudDogMCxcbiAgICAgICAgcmVzZXRJZDogbnVsbCxcbiAgICAgICAgcmVzZXRDbGlja0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldElkID0gbnVsbDtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRJZCA9IHNldFRpbWVvdXQoZm4sIENMSUNLX0NPVU5UX1RJTUVPVVQpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWxSZXNldENsaWNrQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzZXRJZCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0eXBlVG9CdXR0b25zOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgICAgICAgICByZXQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZFRhcmdldDogZnVuY3Rpb24odG91Y2gsIGlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50VG91Y2hFdmVudC50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnlUb3VjaCh0b3VjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhc3RQYXRoID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogdG91Y2guY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IHRvdWNoLmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiB0aGlzLmN1cnJlbnRUb3VjaEV2ZW50LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMuY3VycmVudFRvdWNoRXZlbnQudGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5maW5kVGFyZ2V0KGZhc3RQYXRoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZmluZFRhcmdldCh0b3VjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV1c2UgdGFyZ2V0IHdlIGZvdW5kIGluIHRvdWNoc3RhcnRcbiAgICAgICAgICAgIHJldHVybiBwb2ludGVybWFwLmdldChpZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoVG9Qb2ludGVyOiBmdW5jdGlvbihpblRvdWNoKSB7XG4gICAgICAgICAgICB2YXIgY3RlID0gdGhpcy5jdXJyZW50VG91Y2hFdmVudDtcbiAgICAgICAgICAgIHZhciBlID0gZGlzcGF0Y2hlci5jbG9uZUV2ZW50KGluVG91Y2gpO1xuICAgICAgICAgICAgLy8gU3BlYyBzcGVjaWZpZXMgdGhhdCBwb2ludGVySWQgMSBpcyByZXNlcnZlZCBmb3IgTW91c2UuXG4gICAgICAgICAgICAvLyBUb3VjaCBpZGVudGlmaWVycyBjYW4gc3RhcnQgYXQgMC5cbiAgICAgICAgICAgIC8vIEFkZCAyIHRvIHRoZSB0b3VjaCBpZGVudGlmaWVyIGZvciBjb21wYXRpYmlsaXR5LlxuICAgICAgICAgICAgdmFyIGlkID0gZS5wb2ludGVySWQgPSBpblRvdWNoLmlkZW50aWZpZXIgKyAyO1xuICAgICAgICAgICAgZS50YXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoaW5Ub3VjaCwgaWQpO1xuICAgICAgICAgICAgZS5idWJibGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGUuY2FuY2VsYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBlLmRldGFpbCA9IHRoaXMuY2xpY2tDb3VudDtcbiAgICAgICAgICAgIGUuYnV0dG9ucyA9IHRoaXMudHlwZVRvQnV0dG9ucyhjdGUudHlwZSk7XG4gICAgICAgICAgICBlLndpZHRoID0gaW5Ub3VjaC53ZWJraXRSYWRpdXNYIHx8IGluVG91Y2gucmFkaXVzWCB8fCAwO1xuICAgICAgICAgICAgZS5oZWlnaHQgPSBpblRvdWNoLndlYmtpdFJhZGl1c1kgfHwgaW5Ub3VjaC5yYWRpdXNZIHx8IDA7XG4gICAgICAgICAgICBlLnByZXNzdXJlID0gaW5Ub3VjaC53ZWJraXRGb3JjZSB8fCBpblRvdWNoLmZvcmNlIHx8IDAuNTtcbiAgICAgICAgICAgIGUuaXNQcmltYXJ5ID0gdGhpcy5pc1ByaW1hcnlUb3VjaChpblRvdWNoKTtcbiAgICAgICAgICAgIGUucG9pbnRlclR5cGUgPSB0aGlzLlBPSU5URVJfVFlQRTtcbiAgICAgICAgICAgIGUuX3NvdXJjZSA9ICd0b3VjaCc7XG4gICAgICAgICAgICAvLyBmb3J3YXJkIHRvdWNoIHByZXZlbnREZWZhdWx0c1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJzdFhZID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjdGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2Vzc1RvdWNoZXM6IGZ1bmN0aW9uKGluRXZlbnQsIGluRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB0bCA9IGluRXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUb3VjaEV2ZW50ID0gaW5FdmVudDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCB0LCBwOyBpIDwgdGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ID0gdGxbaV07XG4gICAgICAgICAgICAgICAgcCA9IHRoaXMudG91Y2hUb1BvaW50ZXIodCk7XG4gICAgICAgICAgICAgICAgaWYgKGluRXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJtYXAuc2V0KHAucG9pbnRlcklkLCBwLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb2ludGVybWFwLmhhcyhwLnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5GdW5jdGlvbi5jYWxsKHRoaXMsIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5FdmVudC50eXBlID09PSAndG91Y2hlbmQnIHx8IGluRXZlbnQuX2NhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFuVXBQb2ludGVyKHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gRm9yIHNpbmdsZSBheGlzIHNjcm9sbGVycywgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBlbGVtZW50IHNob3VsZCBlbWl0XG4gICAgICAgIC8vIHBvaW50ZXIgZXZlbnRzIG9yIGJlaGF2ZSBhcyBhIHNjcm9sbGVyXG4gICAgICAgIHNob3VsZFNjcm9sbDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RYWSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoQWN0aW9uID0gc2NvcGUudGFyZ2V0RmluZGluZy5maW5kVG91Y2hBY3Rpb24oaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbEF4aXMgPSB0aGlzLnRvdWNoQWN0aW9uVG9TY3JvbGxUeXBlKHRvdWNoQWN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsQXhpcyA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgZWxlbWVudCBpcyBhIHRvdWNoLWFjdGlvbjogbm9uZSwgc2hvdWxkIG5ldmVyIHNjcm9sbFxuICAgICAgICAgICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNjcm9sbEF4aXMgPT09ICdYWScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBlbGVtZW50IHNob3VsZCBhbHdheXMgc2Nyb2xsXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBpbkV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGUgaW50ZW5kZWQgc2Nyb2xsIGF4aXMsIGFuZCBvdGhlciBheGlzXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gc2Nyb2xsQXhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9hID0gc2Nyb2xsQXhpcyA9PT0gJ1knID8gJ1gnIDogJ1knO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGEgPSBNYXRoLmFicyh0WydjbGllbnQnICsgYV0gLSB0aGlzLmZpcnN0WFlbYV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9hID0gTWF0aC5hYnModFsnY2xpZW50JyArIG9hXSAtIHRoaXMuZmlyc3RYWVtvYV0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBkZWx0YSBpbiB0aGUgc2Nyb2xsIGF4aXMgPiBkZWx0YSBvdGhlciBheGlzLCBzY3JvbGwgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtpbmcgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGRhID49IGRvYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmluZFRvdWNoOiBmdW5jdGlvbihpblRMLCBpbklkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluVEwubGVuZ3RoLCB0OyBpIDwgbCAmJiAodCA9IGluVExbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodC5pZGVudGlmaWVyID09PSBpbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gSW4gc29tZSBpbnN0YW5jZXMsIGEgdG91Y2hzdGFydCBjYW4gaGFwcGVuIHdpdGhvdXQgYSB0b3VjaGVuZC4gVGhpc1xuICAgICAgICAvLyBsZWF2ZXMgdGhlIHBvaW50ZXJtYXAgaW4gYSBicm9rZW4gc3RhdGUuXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgb24gZXZlcnkgdG91Y2hzdGFydCwgd2UgcmVtb3ZlIHRoZSB0b3VjaGVzIHRoYXQgZGlkIG5vdCBmaXJlIGFcbiAgICAgICAgLy8gdG91Y2hlbmQgZXZlbnQuXG4gICAgICAgIC8vIFRvIGtlZXAgc3RhdGUgZ2xvYmFsbHkgY29uc2lzdGVudCwgd2UgZmlyZSBhXG4gICAgICAgIC8vIHBvaW50ZXJjYW5jZWwgZm9yIHRoaXMgXCJhYmFuZG9uZWRcIiB0b3VjaFxuICAgICAgICB2YWN1dW1Ub3VjaGVzOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGwgPSBpbkV2ZW50LnRvdWNoZXM7XG4gICAgICAgICAgICAvLyBwb2ludGVybWFwLnBvaW50ZXJzKCkgc2hvdWxkIGJlIDwgdGwubGVuZ3RoIGhlcmUsIGFzIHRoZSB0b3VjaHN0YXJ0IGhhcyBub3RcbiAgICAgICAgICAgIC8vIGJlZW4gcHJvY2Vzc2VkIHlldC5cbiAgICAgICAgICAgIGlmIChwb2ludGVybWFwLnBvaW50ZXJzKCkgPj0gdGwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBbXTtcbiAgICAgICAgICAgICAgICBwb2ludGVybWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciByZW1vdmUgcG9pbnRlcklkID09IDEsIHdoaWNoIGlzIG1vdXNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBUb3VjaCBpZGVudGlmaWVycyBhcmUgMiBzbWFsbGVyIHRoYW4gdGhlaXIgcG9pbnRlcklkLCB3aGljaCBpcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggaW4gcG9pbnRlcm1hcC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gMSAmJiAhdGhpcy5maW5kVG91Y2godGwsIGtleSAtIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgZC5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJtYXAuZGVsZXRlKHAucG9pbnRlcklkKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG91Y2hzdGFydDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdGhpcy52YWN1dW1Ub3VjaGVzKGluRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRQcmltYXJ5VG91Y2goaW5FdmVudC5jaGFuZ2VkVG91Y2hlc1swXSk7XG4gICAgICAgICAgICB0aGlzLmRlZHVwU3ludGhNb3VzZShpbkV2ZW50KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zY3JvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWNrQ291bnQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NUb3VjaGVzKGluRXZlbnQsIHRoaXMuZG93bik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRvd246IGZ1bmN0aW9uKGluUG9pbnRlcikge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5kb3duKGluUG9pbnRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNobW92ZTogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKEhBU19UT1VDSF9BQ1RJT04pIHtcbiAgICAgICAgICAgICAgICAvLyB0b3VjaGV2ZW50LmNhbmNlbGFibGUgPT0gZmFsc2UgaXMgc2VudCB3aGVuIHRoZSBwYWdlIGlzIHNjcm9sbGluZyB1bmRlciBuYXRpdmUgVG91Y2ggQWN0aW9uIGluIENocm9tZSAzNlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZC9tc2cvaW5wdXQtZGV2L3dIbnl1a2NZQmNBL2I5a210d00xakpRSlxuICAgICAgICAgICAgICAgIGlmIChpbkV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzVG91Y2hlcyhpbkV2ZW50LCB0aGlzLm1vdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNjcm9sbGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxpbmcgPT09IG51bGwgJiYgdGhpcy5zaG91bGRTY3JvbGwoaW5FdmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NUb3VjaGVzKGluRXZlbnQsIHRoaXMubW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZmlyc3RYWSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGluRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IHQuY2xpZW50WCAtIHRoaXMuZmlyc3RYWS5YO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSB0LmNsaWVudFkgLSB0aGlzLmZpcnN0WFkuWTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRkID49IEhZU1RFUkVTSVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG91Y2hjYW5jZWwoaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcnN0WFkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpblBvaW50ZXIpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIubW92ZShpblBvaW50ZXIpO1xuICAgICAgICB9LFxuICAgICAgICB0b3VjaGVuZDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdGhpcy5kZWR1cFN5bnRoTW91c2UoaW5FdmVudCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NUb3VjaGVzKGluRXZlbnQsIHRoaXMudXApO1xuICAgICAgICB9LFxuICAgICAgICB1cDogZnVuY3Rpb24oaW5Qb2ludGVyKSB7XG4gICAgICAgICAgICBpblBvaW50ZXIucmVsYXRlZFRhcmdldCA9IHNjb3BlLmZpbmRUYXJnZXQoaW5Qb2ludGVyKTtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIudXAoaW5Qb2ludGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbihpblBvaW50ZXIpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIuY2FuY2VsKGluUG9pbnRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoY2FuY2VsOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpbkV2ZW50Ll9jYW5jZWwgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzVG91Y2hlcyhpbkV2ZW50LCB0aGlzLmNhbmNlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFuVXBQb2ludGVyOiBmdW5jdGlvbihpblBvaW50ZXIpIHtcbiAgICAgICAgICAgIHBvaW50ZXJtYXBbJ2RlbGV0ZSddKGluUG9pbnRlci5wb2ludGVySWQpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVQcmltYXJ5UG9pbnRlcihpblBvaW50ZXIpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV2ZW50IHN5bnRoIG1vdXNlIGV2ZW50cyBmcm9tIGNyZWF0aW5nIHBvaW50ZXIgZXZlbnRzXG4gICAgICAgIGRlZHVwU3ludGhNb3VzZTogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGx0cyA9IHNjb3BlLm1vdXNlRXZlbnRzLmxhc3RUb3VjaGVzO1xuICAgICAgICAgICAgdmFyIHQgPSBpbkV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgLy8gb25seSB0aGUgcHJpbWFyeSBmaW5nZXIgd2lsbCBzeW50aCBtb3VzZSBldmVudHNcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeVRvdWNoKHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtZW1iZXIgeC95IG9mIGxhc3QgdG91Y2hcbiAgICAgICAgICAgICAgICB2YXIgbHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgeTogdC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsdHMucHVzaChsdCk7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gKGZ1bmN0aW9uKGx0cywgbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGx0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5iaW5kKG51bGwsIGx0cywgbHQpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sIERFRFVQX1RJTUVPVVQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHByZXZlbnQgXCJnaG9zdCBjbGlja3NcIiB0aGF0IGNvbWUgZnJvbSBlbGVtZW50cyB0aGF0IHdlcmUgcmVtb3ZlZCBpbiBhIHRvdWNoIGhhbmRsZXJcbiAgICB2YXIgU1RPUF9QUk9QX0ZOID0gRXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiB8fCBFdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdmFyIHggPSBldi5jbGllbnRYLFxuICAgICAgICAgICAgeSA9IGV2LmNsaWVudFk7XG4gICAgICAgIC8vIGNoZWNrIGlmIGEgY2xpY2sgaXMgd2l0aGluIERFRFVQX0RJU1QgcHggcmFkaXVzIG9mIHRoZSB0b3VjaHN0YXJ0XG4gICAgICAgIHZhciBjbG9zZVRvID0gZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0b3VjaC54KSxcbiAgICAgICAgICAgICAgICBkeSA9IE1hdGguYWJzKHkgLSB0b3VjaC55KTtcbiAgICAgICAgICAgIHJldHVybiAoZHggPD0gREVEVVBfRElTVCAmJiBkeSA8PSBERURVUF9ESVNUKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gaWYgY2xpY2sgY29vcmRpbmF0ZXMgYXJlIGNsb3NlIHRvIHRvdWNoIGNvb3JkaW5hdGVzLCBhc3N1bWUgdGhlIGNsaWNrIGNhbWUgZnJvbSBhIHRvdWNoXG4gICAgICAgIHZhciB3YXNUb3VjaGVkID0gc2NvcGUubW91c2VFdmVudHMubGFzdFRvdWNoZXMuc29tZShjbG9zZVRvKTtcbiAgICAgICAgLy8gaWYgdGhlIGNsaWNrIGNhbWUgZnJvbSB0b3VjaCwgYW5kIHRoZSB0b3VjaHN0YXJ0IHRhcmdldCBpcyBub3QgaW4gdGhlIHBhdGggb2YgdGhlIGNsaWNrIGV2ZW50LFxuICAgICAgICAvLyB0aGVuIHRoZSB0b3VjaHN0YXJ0IHRhcmdldCB3YXMgcHJvYmFibHkgcmVtb3ZlZCwgYW5kIHRoZSBjbGljayBzaG91bGQgYmUgXCJidXN0ZWRcIlxuICAgICAgICB2YXIgcGF0aCA9IHNjb3BlLnRhcmdldEZpbmRpbmcucGF0aChldik7XG4gICAgICAgIGlmICh3YXNUb3VjaGVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aFtpXSA9PT0gdG91Y2hFdmVudHMuZmlyc3RUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBTVE9QX1BST1BfRk4uY2FsbChldik7XG4gICAgICAgIH1cbiAgICB9LCB0cnVlKTtcblxuICAgIHNjb3BlLnRvdWNoRXZlbnRzID0gdG91Y2hFdmVudHM7XG59KShleHBvcnRzKTtcblxuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSBzY29wZS5kaXNwYXRjaGVyO1xuICAgIHZhciBwb2ludGVybWFwID0gZGlzcGF0Y2hlci5wb2ludGVybWFwO1xuICAgIHZhciBIQVNfQklUTUFQX1RZUEUgPSB3aW5kb3cuTVNQb2ludGVyRXZlbnQgJiYgdHlwZW9mIHdpbmRvdy5NU1BvaW50ZXJFdmVudC5NU1BPSU5URVJfVFlQRV9NT1VTRSA9PT0gJ251bWJlcic7XG4gICAgdmFyIG1zRXZlbnRzID0ge1xuICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICdNU1BvaW50ZXJEb3duJyxcbiAgICAgICAgICAgICdNU1BvaW50ZXJNb3ZlJyxcbiAgICAgICAgICAgICdNU1BvaW50ZXJVcCcsXG4gICAgICAgICAgICAnTVNQb2ludGVyQ2FuY2VsJyxcbiAgICAgICAgXSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2hlci51bmxpc3Rlbih0YXJnZXQsIHRoaXMuZXZlbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgUE9JTlRFUl9UWVBFUzogW1xuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAndW5hdmFpbGFibGUnLFxuICAgICAgICAgICAgJ3RvdWNoJyxcbiAgICAgICAgICAgICdwZW4nLFxuICAgICAgICAgICAgJ21vdXNlJ1xuICAgICAgICBdLFxuICAgICAgICBwcmVwYXJlRXZlbnQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gaW5FdmVudDtcbiAgICAgICAgICAgIGUgPSBkaXNwYXRjaGVyLmNsb25lRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBpZiAoSEFTX0JJVE1BUF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgZS5wb2ludGVyVHlwZSA9IHRoaXMuUE9JTlRFUl9UWVBFU1tpbkV2ZW50LnBvaW50ZXJUeXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUuX3NvdXJjZSA9ICdtcyc7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW51cDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHBvaW50ZXJtYXBbJ2RlbGV0ZSddKGlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgTVNQb2ludGVyRG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUudGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgIHBvaW50ZXJtYXAuc2V0KGluRXZlbnQucG9pbnRlcklkLCBlLnRhcmdldCk7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLmRvd24oZSk7XG4gICAgICAgIH0sXG4gICAgICAgIE1TUG9pbnRlck1vdmU6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBwb2ludGVybWFwLmdldChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICBlLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLm1vdmUoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIE1TUG9pbnRlclVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUudGFyZ2V0ID0gcG9pbnRlcm1hcC5nZXQoZS5wb2ludGVySWQpO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci51cChlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIE1TUG9pbnRlckNhbmNlbDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUucmVsYXRlZFRhcmdldCA9IHNjb3BlLmZpbmRUYXJnZXQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLnRhcmdldCA9IHBvaW50ZXJtYXAuZ2V0KGUucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIuY2FuY2VsKGUpO1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwKGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzY29wZS5tc0V2ZW50cyA9IG1zRXZlbnRzO1xufSkoZXhwb3J0cyk7XG5cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgcG9pbnRlcm1hcCA9IGRpc3BhdGNoZXIucG9pbnRlcm1hcDtcbiAgICB2YXIgcG9pbnRlckV2ZW50cyA9IHtcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAncG9pbnRlcmRvd24nLFxuICAgICAgICAgICAgJ3BvaW50ZXJtb3ZlJyxcbiAgICAgICAgICAgICdwb2ludGVydXAnLFxuICAgICAgICAgICAgJ3BvaW50ZXJjYW5jZWwnXG4gICAgICAgIF0sXG4gICAgICAgIHByZXBhcmVFdmVudDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSBkaXNwYXRjaGVyLmNsb25lRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLl9zb3VyY2UgPSAncG9pbnRlcic7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2hlci51bmxpc3Rlbih0YXJnZXQsIHRoaXMuZXZlbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW51cDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHBvaW50ZXJtYXBbJ2RlbGV0ZSddKGlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRlcmRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLnRhcmdldCA9IHNjb3BlLmZpbmRUYXJnZXQoaW5FdmVudCk7XG4gICAgICAgICAgICBwb2ludGVybWFwLnNldChlLnBvaW50ZXJJZCwgZS50YXJnZXQpO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5kb3duKGUpO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludGVybW92ZTogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHBvaW50ZXJtYXAuZ2V0KGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIGUudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIubW92ZShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRlcnVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUudGFyZ2V0ID0gcG9pbnRlcm1hcC5nZXQoZS5wb2ludGVySWQpO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci51cChlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50ZXJjYW5jZWw6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLnJlbGF0ZWRUYXJnZXQgPSBzY29wZS5maW5kVGFyZ2V0KGluRXZlbnQpO1xuICAgICAgICAgICAgZS50YXJnZXQgPSBwb2ludGVybWFwLmdldChlLnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLmNhbmNlbChlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2NvcGUucG9pbnRlckV2ZW50cyA9IHBvaW50ZXJFdmVudHM7XG59KShleHBvcnRzKTtcblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBjb250YWlucyB0aGUgaGFuZGxlcnMgZm9yIG5hdGl2ZSBwbGF0Zm9ybSBldmVudHMuXG4gKiBGcm9tIGhlcmUsIHRoZSBkaXNwYXRjaGVyIGlzIGNhbGxlZCB0byBjcmVhdGUgdW5pZmllZCBwb2ludGVyIGV2ZW50cy5cbiAqIEluY2x1ZGVkIGFyZSB0b3VjaCBldmVudHMgKHYxKSwgbW91c2UgZXZlbnRzLCBhbmQgTVNQb2ludGVyRXZlbnRzLlxuICovXG4oZnVuY3Rpb24oc2NvcGUpIHtcblxuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgbmF2ID0gd2luZG93Lm5hdmlnYXRvcjtcblxuICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJTb3VyY2UoJ3BvaW50ZXInLCBzY29wZS5wb2ludGVyRXZlbnRzKTtcbiAgICB9IGVsc2UgaWYgKG5hdi5tc1BvaW50ZXJFbmFibGVkKSB7XG4gICAgICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJTb3VyY2UoJ21zJywgc2NvcGUubXNFdmVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJTb3VyY2UoJ21vdXNlJywgc2NvcGUubW91c2VFdmVudHMpO1xuICAgICAgICBpZiAod2luZG93Lm9udG91Y2hzdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyU291cmNlKCd0b3VjaCcsIHNjb3BlLnRvdWNoRXZlbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdvcmsgYXJvdW5kIGlPUyBidWdzIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzU2MjggYW5kIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY1MDZcbiAgICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIHZhciBJU19JT1MgPSB1YS5tYXRjaCgvaVBhZHxpUGhvbmV8aVBvZC8pICYmICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcblxuICAgIGRpc3BhdGNoZXIuSVNfSU9TID0gSVNfSU9TO1xuICAgIHNjb3BlLnRvdWNoRXZlbnRzLklTX0lPUyA9IElTX0lPUztcblxuICAgIGRpc3BhdGNoZXIucmVnaXN0ZXIoZG9jdW1lbnQsIHRydWUpO1xufSkoZXhwb3J0cyk7XG5cbi8qKlxuICogVGhpcyBldmVudCBkZW5vdGVzIHRoZSBiZWdpbm5pbmcgb2YgYSBzZXJpZXMgb2YgdHJhY2tpbmcgZXZlbnRzLlxuICpcbiAqIEBtb2R1bGUgUG9pbnRlckdlc3R1cmVzXG4gKiBAc3VibW9kdWxlIEV2ZW50c1xuICogQGNsYXNzIHRyYWNrc3RhcnRcbiAqL1xuLyoqXG4gKiBQaXhlbHMgbW92ZWQgaW4gdGhlIHggZGlyZWN0aW9uIHNpbmNlIHRyYWNrc3RhcnQuXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBkeFxuICovXG4vKipcbiAqIFBpeGVzIG1vdmVkIGluIHRoZSB5IGRpcmVjdGlvbiBzaW5jZSB0cmFja3N0YXJ0LlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgZHlcbiAqL1xuLyoqXG4gKiBQaXhlbHMgbW92ZWQgaW4gdGhlIHggZGlyZWN0aW9uIHNpbmNlIHRoZSBsYXN0IHRyYWNrLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgZGR4XG4gKi9cbi8qKlxuICogUGl4bGVzIG1vdmVkIGluIHRoZSB5IGRpcmVjdGlvbiBzaW5jZSB0aGUgbGFzdCB0cmFjay5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IGRkeVxuICovXG4vKipcbiAqIFRoZSBjbGllbnRYIHBvc2l0aW9uIG9mIHRoZSB0cmFjayBnZXN0dXJlLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgY2xpZW50WFxuICovXG4vKipcbiAqIFRoZSBjbGllbnRZIHBvc2l0aW9uIG9mIHRoZSB0cmFjayBnZXN0dXJlLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgY2xpZW50WVxuICovXG4vKipcbiAqIFRoZSBwYWdlWCBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgZ2VzdHVyZS5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IHBhZ2VYXG4gKi9cbi8qKlxuICogVGhlIHBhZ2VZIHBvc2l0aW9uIG9mIHRoZSB0cmFjayBnZXN0dXJlLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgcGFnZVlcbiAqL1xuLyoqXG4gKiBUaGUgc2NyZWVuWCBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgZ2VzdHVyZS5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IHNjcmVlblhcbiAqL1xuLyoqXG4gKiBUaGUgc2NyZWVuWSBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgZ2VzdHVyZS5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IHNjcmVlbllcbiAqL1xuLyoqXG4gKiBUaGUgbGFzdCB4IGF4aXMgZGlyZWN0aW9uIG9mIHRoZSBwb2ludGVyLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgeERpcmVjdGlvblxuICovXG4vKipcbiAqIFRoZSBsYXN0IHkgYXhpcyBkaXJlY3Rpb24gb2YgdGhlIHBvaW50ZXIuXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSB5RGlyZWN0aW9uXG4gKi9cbi8qKlxuICogQSBzaGFyZWQgb2JqZWN0IGJldHdlZW4gYWxsIHRyYWNraW5nIGV2ZW50cy5cbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHRyYWNrSW5mb1xuICovXG4vKipcbiAqIFRoZSBlbGVtZW50IGN1cnJlbnRseSB1bmRlciB0aGUgcG9pbnRlci5cbiAqIEB0eXBlIEVsZW1lbnRcbiAqIEBwcm9wZXJ0eSByZWxhdGVkVGFyZ2V0XG4gKi9cbi8qKlxuICogVGhlIHR5cGUgb2YgcG9pbnRlciB0aGF0IG1ha2UgdGhlIHRyYWNrIGdlc3R1cmUuXG4gKiBAdHlwZSBTdHJpbmdcbiAqIEBwcm9wZXJ0eSBwb2ludGVyVHlwZVxuICovXG4vKipcbiAqXG4gKiBUaGlzIGV2ZW50IGZpcmVzIGZvciBhbGwgcG9pbnRlciBtb3ZlbWVudCBiZWluZyB0cmFja2VkLlxuICpcbiAqIEBjbGFzcyB0cmFja1xuICogQGV4dGVuZHMgdHJhY2tzdGFydFxuICovXG4vKipcbiAqIFRoaXMgZXZlbnQgZmlyZXMgd2hlbiB0aGUgcG9pbnRlciBpcyBubyBsb25nZXIgYmVpbmcgdHJhY2tlZC5cbiAqXG4gKiBAY2xhc3MgdHJhY2tlbmRcbiAqIEBleHRlbmRzIHRyYWNrc3RhcnRcbiAqL1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHNjb3BlLmRpc3BhdGNoZXI7XG4gICAgdmFyIGV2ZW50RmFjdG9yeSA9IHNjb3BlLmV2ZW50RmFjdG9yeTtcbiAgICB2YXIgcG9pbnRlcm1hcCA9IG5ldyBzY29wZS5Qb2ludGVyTWFwKCk7XG4gICAgdmFyIHRyYWNrID0ge1xuICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICdtb3ZlJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICd0cmFja3N0YXJ0JyxcbiAgICAgICAgICAgICd0cmFjaycsXG4gICAgICAgICAgICAndHJhY2t4JyxcbiAgICAgICAgICAgICd0cmFja3knLFxuICAgICAgICAgICAgJ3RyYWNrZW5kJ1xuICAgICAgICBdLFxuICAgICAgICBkZWZhdWx0QWN0aW9uczoge1xuICAgICAgICAgICAgJ3RyYWNrJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3RyYWNreCc6ICdwYW4teScsXG4gICAgICAgICAgICAndHJhY2t5JzogJ3Bhbi14J1xuICAgICAgICB9LFxuICAgICAgICBXSUdHTEVfVEhSRVNIT0xEOiA0LFxuICAgICAgICBjbGFtcERpcjogZnVuY3Rpb24oaW5EZWx0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGluRGVsdGEgPiAwID8gMSA6IC0xO1xuICAgICAgICB9LFxuICAgICAgICBjYWxjUG9zaXRpb25EZWx0YTogZnVuY3Rpb24oaW5BLCBpbkIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gMCxcbiAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgIGlmIChpbkEgJiYgaW5CKSB7XG4gICAgICAgICAgICAgICAgeCA9IGluQi5wYWdlWCAtIGluQS5wYWdlWDtcbiAgICAgICAgICAgICAgICB5ID0gaW5CLnBhZ2VZIC0gaW5BLnBhZ2VZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGZpcmVUcmFjazogZnVuY3Rpb24oaW5UeXBlLCBpbkV2ZW50LCBpblRyYWNraW5nRGF0YSkge1xuICAgICAgICAgICAgdmFyIHQgPSBpblRyYWNraW5nRGF0YTtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5jYWxjUG9zaXRpb25EZWx0YSh0LmRvd25FdmVudCwgaW5FdmVudCk7XG4gICAgICAgICAgICB2YXIgZGQgPSB0aGlzLmNhbGNQb3NpdGlvbkRlbHRhKHQubGFzdE1vdmVFdmVudCwgaW5FdmVudCk7XG4gICAgICAgICAgICBpZiAoZGQueCkge1xuICAgICAgICAgICAgICAgIHQueERpcmVjdGlvbiA9IHRoaXMuY2xhbXBEaXIoZGQueCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluVHlwZSA9PT0gJ3RyYWNreCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGQueSkge1xuICAgICAgICAgICAgICAgIHQueURpcmVjdGlvbiA9IHRoaXMuY2xhbXBEaXIoZGQueSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluVHlwZSA9PT0gJ3RyYWNreScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZ2VzdHVyZVByb3RvID0ge1xuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cmFja0luZm86IHQudHJhY2tJbmZvLFxuICAgICAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IGluRXZlbnQucmVsYXRlZFRhcmdldCxcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogaW5FdmVudC5wb2ludGVyVHlwZSxcbiAgICAgICAgICAgICAgICBwb2ludGVySWQ6IGluRXZlbnQucG9pbnRlcklkLFxuICAgICAgICAgICAgICAgIF9zb3VyY2U6ICd0cmFjaydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaW5UeXBlICE9PSAndHJhY2t5Jykge1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by54ID0gaW5FdmVudC54O1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by5keCA9IGQueDtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uZGR4ID0gZGQueDtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uY2xpZW50WCA9IGluRXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8ucGFnZVggPSBpbkV2ZW50LnBhZ2VYO1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by5zY3JlZW5YID0gaW5FdmVudC5zY3JlZW5YO1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by54RGlyZWN0aW9uID0gdC54RGlyZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluVHlwZSAhPT0gJ3RyYWNreCcpIHtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uZHkgPSBkLnk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLmRkeSA9IGRkLnk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLnkgPSBpbkV2ZW50Lnk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLmNsaWVudFkgPSBpbkV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLnBhZ2VZID0gaW5FdmVudC5wYWdlWTtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uc2NyZWVuWSA9IGluRXZlbnQuc2NyZWVuWTtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8ueURpcmVjdGlvbiA9IHQueURpcmVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlID0gZXZlbnRGYWN0b3J5Lm1ha2VHZXN0dXJlRXZlbnQoaW5UeXBlLCBnZXN0dXJlUHJvdG8pO1xuICAgICAgICAgICAgdC5kb3duVGFyZ2V0LmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbkV2ZW50LmlzUHJpbWFyeSAmJiAoaW5FdmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyA/IGluRXZlbnQuYnV0dG9ucyA9PT0gMSA6IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRvd25FdmVudDogaW5FdmVudCxcbiAgICAgICAgICAgICAgICAgICAgZG93blRhcmdldDogaW5FdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrSW5mbzoge30sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RNb3ZlRXZlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHhEaXJlY3Rpb246IDAsXG4gICAgICAgICAgICAgICAgICAgIHlEaXJlY3Rpb246IDAsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNraW5nOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5zZXQoaW5FdmVudC5wb2ludGVySWQsIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHBvaW50ZXJtYXAuZ2V0KGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwLnRyYWNraW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5jYWxjUG9zaXRpb25EZWx0YShwLmRvd25FdmVudCwgaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3ZlID0gZC54ICogZC54ICsgZC55ICogZC55O1xuICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCB0cmFja2luZyBvbmx5IGlmIGZpbmdlciBtb3ZlcyBtb3JlIHRoYW4gV0lHR0xFX1RIUkVTSE9MRFxuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZSA+IHRoaXMuV0lHR0xFX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcC50cmFja2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxhc3RNb3ZlRXZlbnQgPSBwLmRvd25FdmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVRyYWNrKCd0cmFja3N0YXJ0JywgaW5FdmVudCwgcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHAudHJhY2tpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlVHJhY2soJ3RyYWNrJywgaW5FdmVudCwgcCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVRyYWNrKCd0cmFja3gnLCBpbkV2ZW50LCBwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlVHJhY2soJ3RyYWNreScsIGluRXZlbnQsIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwLmxhc3RNb3ZlRXZlbnQgPSBpbkV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIHAgPSBwb2ludGVybWFwLmdldChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgIGlmIChwLnRyYWNraW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVRyYWNrKCd0cmFja2VuZCcsIGluRXZlbnQsIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb2ludGVybWFwLmRlbGV0ZShpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJHZXN0dXJlKCd0cmFjaycsIHRyYWNrKTtcbn0pKGV4cG9ydHMpO1xuXG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIHBvaW50ZXIgaXMgaGVsZCBkb3duIGZvciAyMDBtcy5cbiAqXG4gKiBAbW9kdWxlIFBvaW50ZXJHZXN0dXJlc1xuICogQHN1Ym1vZHVsZSBFdmVudHNcbiAqIEBjbGFzcyBob2xkXG4gKi9cbi8qKlxuICogVHlwZSBvZiBwb2ludGVyIHRoYXQgbWFkZSB0aGUgaG9sZGluZyBldmVudC5cbiAqIEB0eXBlIFN0cmluZ1xuICogQHByb3BlcnR5IHBvaW50ZXJUeXBlXG4gKi9cbi8qKlxuICogU2NyZWVuIFggYXhpcyBwb3NpdGlvbiBvZiB0aGUgaGVsZCBwb2ludGVyXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBjbGllbnRYXG4gKi9cbi8qKlxuICogU2NyZWVuIFkgYXhpcyBwb3NpdGlvbiBvZiB0aGUgaGVsZCBwb2ludGVyXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBjbGllbnRZXG4gKi9cbi8qKlxuICogVHlwZSBvZiBwb2ludGVyIHRoYXQgbWFkZSB0aGUgaG9sZGluZyBldmVudC5cbiAqIEB0eXBlIFN0cmluZ1xuICogQHByb3BlcnR5IHBvaW50ZXJUeXBlXG4gKi9cbi8qKlxuICogVGhpcyBldmVudCBpcyBmaXJlZCBldmVyeSAyMDBtcyB3aGlsZSBhIHBvaW50ZXIgaXMgaGVsZCBkb3duLlxuICpcbiAqIEBjbGFzcyBob2xkcHVsc2VcbiAqIEBleHRlbmRzIGhvbGRcbiAqL1xuLyoqXG4gKiBNaWxsaXNlY29uZHMgcG9pbnRlciBoYXMgYmVlbiBoZWxkIGRvd24uXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBob2xkVGltZVxuICovXG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIGhlbGQgcG9pbnRlciBpcyByZWxlYXNlZCBvciBtb3ZlZC5cbiAqXG4gKiBAY2xhc3MgcmVsZWFzZVxuICovXG5cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgZXZlbnRGYWN0b3J5ID0gc2NvcGUuZXZlbnRGYWN0b3J5O1xuICAgIHZhciBob2xkID0ge1xuICAgICAgICAvLyB3YWl0IGF0IGxlYXN0IEhPTERfREVMQVkgbXMgYmV0d2VlbiBob2xkIGFuZCBwdWxzZSBldmVudHNcbiAgICAgICAgSE9MRF9ERUxBWTogMjAwLFxuICAgICAgICAvLyBwb2ludGVyIGNhbiBtb3ZlIFdJR0dMRV9USFJFU0hPTEQgcGl4ZWxzIGJlZm9yZSBub3QgY291bnRpbmcgYXMgYSBob2xkXG4gICAgICAgIFdJR0dMRV9USFJFU0hPTEQ6IDE2LFxuICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICdtb3ZlJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICdob2xkJyxcbiAgICAgICAgICAgICdob2xkcHVsc2UnLFxuICAgICAgICAgICAgJ3JlbGVhc2UnXG4gICAgICAgIF0sXG4gICAgICAgIGhlbGRQb2ludGVyOiBudWxsLFxuICAgICAgICBob2xkSm9iOiBudWxsLFxuICAgICAgICBwdWxzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaG9sZCA9IERhdGUubm93KCkgLSB0aGlzLmhlbGRQb2ludGVyLnRpbWVTdGFtcDtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5oZWxkID8gJ2hvbGRwdWxzZScgOiAnaG9sZCc7XG4gICAgICAgICAgICB0aGlzLmZpcmVIb2xkKHR5cGUsIGhvbGQpO1xuICAgICAgICAgICAgdGhpcy5oZWxkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5ob2xkSm9iKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVIb2xkKCdyZWxlYXNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhlbGQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaGVsZFBvaW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ob2xkSm9iID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKGluRXZlbnQuaXNQcmltYXJ5ICYmICF0aGlzLmhlbGRQb2ludGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWxkUG9pbnRlciA9IGluRXZlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBpbkV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLmhvbGRKb2IgPSBzZXRJbnRlcnZhbCh0aGlzLnB1bHNlLmJpbmQodGhpcyksIHRoaXMuSE9MRF9ERUxBWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWxkUG9pbnRlciAmJiB0aGlzLmhlbGRQb2ludGVyLnBvaW50ZXJJZCA9PT0gaW5FdmVudC5wb2ludGVySWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWxkUG9pbnRlciAmJiB0aGlzLmhlbGRQb2ludGVyLnBvaW50ZXJJZCA9PT0gaW5FdmVudC5wb2ludGVySWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGluRXZlbnQuY2xpZW50WCAtIHRoaXMuaGVsZFBvaW50ZXIuY2xpZW50WDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGluRXZlbnQuY2xpZW50WSAtIHRoaXMuaGVsZFBvaW50ZXIuY2xpZW50WTtcbiAgICAgICAgICAgICAgICBpZiAoKHggKiB4ICsgeSAqIHkpID4gdGhpcy5XSUdHTEVfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaXJlSG9sZDogZnVuY3Rpb24oaW5UeXBlLCBpbkhvbGRUaW1lKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHtcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IHRoaXMuaGVsZFBvaW50ZXIucG9pbnRlclR5cGUsXG4gICAgICAgICAgICAgICAgcG9pbnRlcklkOiB0aGlzLmhlbGRQb2ludGVyLnBvaW50ZXJJZCxcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmhlbGRQb2ludGVyLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5oZWxkUG9pbnRlci5jbGllbnRZLFxuICAgICAgICAgICAgICAgIF9zb3VyY2U6ICdob2xkJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpbkhvbGRUaW1lKSB7XG4gICAgICAgICAgICAgICAgcC5ob2xkVGltZSA9IGluSG9sZFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZSA9IGV2ZW50RmFjdG9yeS5tYWtlR2VzdHVyZUV2ZW50KGluVHlwZSwgcCk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5kaXNwYXRjaEV2ZW50KGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyR2VzdHVyZSgnaG9sZCcsIGhvbGQpO1xufSkoZXhwb3J0cyk7XG5cbi8qKlxuICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGEgcG9pbnRlciBxdWlja2x5IGdvZXMgZG93biBhbmQgdXAsIGFuZCBpcyB1c2VkIHRvXG4gKiBkZW5vdGUgYWN0aXZhdGlvbi5cbiAqXG4gKiBBbnkgZ2VzdHVyZSBldmVudCBjYW4gcHJldmVudCB0aGUgdGFwIGV2ZW50IGZyb20gYmVpbmcgY3JlYXRlZCBieSBjYWxsaW5nXG4gKiBgZXZlbnQucHJldmVudFRhcGAuXG4gKlxuICogQW55IHBvaW50ZXIgZXZlbnQgY2FuIHByZXZlbnQgdGhlIHRhcCBieSBzZXR0aW5nIHRoZSBgdGFwUHJldmVudGVkYCBwcm9wZXJ0eVxuICogb24gaXRzZWxmLlxuICpcbiAqIEBtb2R1bGUgUG9pbnRlckdlc3R1cmVzXG4gKiBAc3VibW9kdWxlIEV2ZW50c1xuICogQGNsYXNzIHRhcFxuICovXG4vKipcbiAqIFggYXhpcyBwb3NpdGlvbiBvZiB0aGUgdGFwLlxuICogQHByb3BlcnR5IHhcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIFkgYXhpcyBwb3NpdGlvbiBvZiB0aGUgdGFwLlxuICogQHByb3BlcnR5IHlcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIFR5cGUgb2YgdGhlIHBvaW50ZXIgdGhhdCBtYWRlIHRoZSB0YXAuXG4gKiBAcHJvcGVydHkgcG9pbnRlclR5cGVcbiAqIEB0eXBlIFN0cmluZ1xuICovXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHNjb3BlLmRpc3BhdGNoZXI7XG4gICAgdmFyIGV2ZW50RmFjdG9yeSA9IHNjb3BlLmV2ZW50RmFjdG9yeTtcbiAgICB2YXIgcG9pbnRlcm1hcCA9IG5ldyBzY29wZS5Qb2ludGVyTWFwKCk7XG4gICAgdmFyIHRhcCA9IHtcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAnZG93bicsXG4gICAgICAgICAgICAndXAnXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICd0YXAnXG4gICAgICAgIF0sXG4gICAgICAgIGRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbkV2ZW50LmlzUHJpbWFyeSAmJiAhaW5FdmVudC50YXBQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICBwb2ludGVybWFwLnNldChpbkV2ZW50LnBvaW50ZXJJZCwge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGluRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBidXR0b25zOiBpbkV2ZW50LmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgIHg6IGluRXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgeTogaW5FdmVudC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZFRhcDogZnVuY3Rpb24oZSwgZG93blN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgdGFwID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBhbGxvdyBsZWZ0IGNsaWNrIHRvIHRhcCBmb3IgbW91c2VcbiAgICAgICAgICAgICAgICB0YXAgPSAoZS5idXR0b25zIF4gMSkgJiYgKGRvd25TdGF0ZS5idXR0b25zICYgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFwICYmICFlLnRhcFByZXZlbnRlZDtcbiAgICAgICAgfSxcbiAgICAgICAgdXA6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHBvaW50ZXJtYXAuZ2V0KGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGlmIChzdGFydCAmJiB0aGlzLnNob3VsZFRhcChpbkV2ZW50LCBzdGFydCkpIHtcbiAgICAgICAgICAgICAgICAvLyB1cC5yZWxhdGVkVGFyZ2V0IGlzIHRhcmdldCBjdXJyZW50bHkgdW5kZXIgZmluZ2VyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBzY29wZS50YXJnZXRGaW5kaW5nLkxDQShzdGFydC50YXJnZXQsIGluRXZlbnQucmVsYXRlZFRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBldmVudEZhY3RvcnkubWFrZUdlc3R1cmVFdmVudCgndGFwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBpbkV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBpbkV2ZW50LmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGluRXZlbnQuZGV0YWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IGluRXZlbnQucG9pbnRlclR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVySWQ6IGluRXZlbnQucG9pbnRlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWx0S2V5OiBpbkV2ZW50LmFsdEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmxLZXk6IGluRXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFLZXk6IGluRXZlbnQubWV0YUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0S2V5OiBpbkV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgX3NvdXJjZTogJ3RhcCdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVybWFwLmRlbGV0ZShpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHBhdGNoIGV2ZW50RmFjdG9yeSB0byByZW1vdmUgaWQgZnJvbSB0YXAncyBwb2ludGVybWFwIGZvciBwcmV2ZW50VGFwIGNhbGxzXG4gICAgZXZlbnRGYWN0b3J5LnByZXZlbnRUYXAgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGUudGFwUHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBvaW50ZXJtYXAuZGVsZXRlKGUucG9pbnRlcklkKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJHZXN0dXJlKCd0YXAnLCB0YXApO1xufSkoZXhwb3J0cyk7XG5cbi8qXG4gKiBCYXNpYyBzdHJhdGVneTogZmluZCB0aGUgZmFydGhlc3QgYXBhcnQgcG9pbnRzLCB1c2UgYXMgZGlhbWV0ZXIgb2YgY2lyY2xlXG4gKiByZWFjdCB0byBzaXplIGNoYW5nZSBhbmQgcm90YXRpb24gb2YgdGhlIGNob3JkXG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIHBvaW50ZXItZ2VzdHVyZXNcbiAqIEBzdWJtb2R1bGUgRXZlbnRzXG4gKiBAY2xhc3MgcGluY2hcbiAqL1xuLyoqXG4gKiBTY2FsZSBvZiB0aGUgcGluY2ggem9vbSBnZXN0dXJlXG4gKiBAcHJvcGVydHkgc2NhbGVcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIENlbnRlciBYIHBvc2l0aW9uIG9mIHBvaW50ZXJzIGNhdXNpbmcgcGluY2hcbiAqIEBwcm9wZXJ0eSBjZW50ZXJYXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuLyoqXG4gKiBDZW50ZXIgWSBwb3NpdGlvbiBvZiBwb2ludGVycyBjYXVzaW5nIHBpbmNoXG4gKiBAcHJvcGVydHkgY2VudGVyWVxuICogQHR5cGUgTnVtYmVyXG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIHBvaW50ZXItZ2VzdHVyZXNcbiAqIEBzdWJtb2R1bGUgRXZlbnRzXG4gKiBAY2xhc3Mgcm90YXRlXG4gKi9cbi8qKlxuICogQW5nbGUgKGluIGRlZ3JlZXMpIG9mIHJvdGF0aW9uLiBNZWFzdXJlZCBmcm9tIHN0YXJ0aW5nIHBvc2l0aW9ucyBvZiBwb2ludGVycy5cbiAqIEBwcm9wZXJ0eSBhbmdsZVxuICogQHR5cGUgTnVtYmVyXG4gKi9cbi8qKlxuICogQ2VudGVyIFggcG9zaXRpb24gb2YgcG9pbnRlcnMgY2F1c2luZyByb3RhdGlvblxuICogQHByb3BlcnR5IGNlbnRlclhcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIENlbnRlciBZIHBvc2l0aW9uIG9mIHBvaW50ZXJzIGNhdXNpbmcgcm90YXRpb25cbiAqIEBwcm9wZXJ0eSBjZW50ZXJZXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSBzY29wZS5kaXNwYXRjaGVyO1xuICAgIHZhciBldmVudEZhY3RvcnkgPSBzY29wZS5ldmVudEZhY3Rvcnk7XG4gICAgdmFyIHBvaW50ZXJtYXAgPSBuZXcgc2NvcGUuUG9pbnRlck1hcCgpO1xuICAgIHZhciBSQURfVE9fREVHID0gMTgwIC8gTWF0aC5QSTtcbiAgICB2YXIgcGluY2ggPSB7XG4gICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgJ2Rvd24nLFxuICAgICAgICAgICAgJ3VwJyxcbiAgICAgICAgICAgICdtb3ZlJyxcbiAgICAgICAgICAgICdjYW5jZWwnXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICdwaW5jaHN0YXJ0JyxcbiAgICAgICAgICAgICdwaW5jaCcsXG4gICAgICAgICAgICAncGluY2hlbmQnLFxuICAgICAgICAgICAgJ3JvdGF0ZSdcbiAgICAgICAgXSxcbiAgICAgICAgZGVmYXVsdEFjdGlvbnM6IHtcbiAgICAgICAgICAgICdwaW5jaCc6ICdub25lJyxcbiAgICAgICAgICAgICdyb3RhdGUnOiAnbm9uZSdcbiAgICAgICAgfSxcbiAgICAgICAgcmVmZXJlbmNlOiB7fSxcbiAgICAgICAgZG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgcG9pbnRlcm1hcC5zZXQoaW5FdmVudC5wb2ludGVySWQsIGluRXZlbnQpO1xuICAgICAgICAgICAgaWYgKHBvaW50ZXJtYXAucG9pbnRlcnMoKSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY2FsY0Nob3JkKCk7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5jYWxjQW5nbGUocG9pbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZmVyZW5jZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICBkaWFtZXRlcjogcG9pbnRzLmRpYW1ldGVyLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHNjb3BlLnRhcmdldEZpbmRpbmcuTENBKHBvaW50cy5hLnRhcmdldCwgcG9pbnRzLmIudGFyZ2V0KVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVQaW5jaCgncGluY2hzdGFydCcsIHBvaW50cy5kaWFtZXRlciwgcG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXA6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBwID0gcG9pbnRlcm1hcC5nZXQoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgdmFyIG51bSA9IHBvaW50ZXJtYXAucG9pbnRlcnMoKTtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG51bSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaXJlICdwaW5jaGVuZCcgYmVmb3JlIGRlbGV0aW5nIHBvaW50ZXJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY2FsY0Nob3JkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVBpbmNoKCdwaW5jaGVuZCcsIHBvaW50cy5kaWFtZXRlciwgcG9pbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5kZWxldGUoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAocG9pbnRlcm1hcC5oYXMoaW5FdmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5zZXQoaW5FdmVudC5wb2ludGVySWQsIGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludGVybWFwLnBvaW50ZXJzKCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsY1BpbmNoUm90YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudXAoaW5FdmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpcmVQaW5jaDogZnVuY3Rpb24odHlwZSwgZGlhbWV0ZXIsIHBvaW50cykge1xuICAgICAgICAgICAgdmFyIHpvb20gPSBkaWFtZXRlciAvIHRoaXMucmVmZXJlbmNlLmRpYW1ldGVyO1xuICAgICAgICAgICAgdmFyIGUgPSBldmVudEZhY3RvcnkubWFrZUdlc3R1cmVFdmVudCh0eXBlLCB7XG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNjYWxlOiB6b29tLFxuICAgICAgICAgICAgICAgIGNlbnRlclg6IHBvaW50cy5jZW50ZXIueCxcbiAgICAgICAgICAgICAgICBjZW50ZXJZOiBwb2ludHMuY2VudGVyLnksXG4gICAgICAgICAgICAgICAgX3NvdXJjZTogJ3BpbmNoJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZS50YXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmlyZVJvdGF0ZTogZnVuY3Rpb24oYW5nbGUsIHBvaW50cykge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBNYXRoLnJvdW5kKChhbmdsZSAtIHRoaXMucmVmZXJlbmNlLmFuZ2xlKSAlIDM2MCk7XG4gICAgICAgICAgICB2YXIgZSA9IGV2ZW50RmFjdG9yeS5tYWtlR2VzdHVyZUV2ZW50KCdyb3RhdGUnLCB7XG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBkaWZmLFxuICAgICAgICAgICAgICAgIGNlbnRlclg6IHBvaW50cy5jZW50ZXIueCxcbiAgICAgICAgICAgICAgICBjZW50ZXJZOiBwb2ludHMuY2VudGVyLnksXG4gICAgICAgICAgICAgICAgX3NvdXJjZTogJ3BpbmNoJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZS50YXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY1BpbmNoUm90YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmNhbGNDaG9yZCgpO1xuICAgICAgICAgICAgdmFyIGRpYW1ldGVyID0gcG9pbnRzLmRpYW1ldGVyO1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5jYWxjQW5nbGUocG9pbnRzKTtcbiAgICAgICAgICAgIGlmIChkaWFtZXRlciAhPSB0aGlzLnJlZmVyZW5jZS5kaWFtZXRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZVBpbmNoKCdwaW5jaCcsIGRpYW1ldGVyLCBwb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFuZ2xlICE9IHRoaXMucmVmZXJlbmNlLmFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlUm90YXRlKGFuZ2xlLCBwb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYWxjQ2hvcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBvaW50ZXJzID0gW107XG4gICAgICAgICAgICBwb2ludGVybWFwLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgIHBvaW50ZXJzLnB1c2gocCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gMDtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHdpdGggYXQgbGVhc3QgdHdvIHBvaW50ZXJzXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0ge1xuICAgICAgICAgICAgICAgIGE6IHBvaW50ZXJzWzBdLFxuICAgICAgICAgICAgICAgIGI6IHBvaW50ZXJzWzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHgsIHksIGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBwb2ludGVyc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBwb2ludGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHBvaW50ZXJzW2pdO1xuICAgICAgICAgICAgICAgICAgICB4ID0gTWF0aC5hYnMoYS5jbGllbnRYIC0gYi5jbGllbnRYKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IE1hdGguYWJzKGEuY2xpZW50WSAtIGIuY2xpZW50WSk7XG4gICAgICAgICAgICAgICAgICAgIGQgPSB4ICsgeTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQgPiBkaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOiBhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGI6IGJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ID0gTWF0aC5hYnMocG9pbnRzLmEuY2xpZW50WCArIHBvaW50cy5iLmNsaWVudFgpIC8gMjtcbiAgICAgICAgICAgIHkgPSBNYXRoLmFicyhwb2ludHMuYS5jbGllbnRZICsgcG9pbnRzLmIuY2xpZW50WSkgLyAyO1xuICAgICAgICAgICAgcG9pbnRzLmNlbnRlciA9IHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb2ludHMuZGlhbWV0ZXIgPSBkaXN0O1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY0FuZ2xlOiBmdW5jdGlvbihwb2ludHMpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcG9pbnRzLmEuY2xpZW50WCAtIHBvaW50cy5iLmNsaWVudFg7XG4gICAgICAgICAgICB2YXIgeSA9IHBvaW50cy5hLmNsaWVudFkgLSBwb2ludHMuYi5jbGllbnRZO1xuICAgICAgICAgICAgcmV0dXJuICgzNjAgKyBNYXRoLmF0YW4yKHksIHgpICogUkFEX1RPX0RFRykgJSAzNjA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJHZXN0dXJlKCdwaW5jaCcsIHBpbmNoKTtcbn0pKGV4cG9ydHMpOyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihudW1Sb3dzKSB7XG5cbiAgICB2YXIgZmlyc3ROYW1lcyA9IFsnT2xpdmlhJywgJ1NvcGhpYScsICdBdmEnLCAnSXNhYmVsbGEnLCAnQm95JywgJ0xpYW0nLCAnTm9haCcsICdFdGhhbicsICdNYXNvbicsICdMb2dhbicsICdNb2UnLCAnTGFycnknLCAnQ3VybHknLCAnU2hlbXAnLCAnR3JvdWNobycsICdIYXJwbycsICdDaGljbycsICdaZXBwbycsICdTdGFubGV5JywgJ0hhcmR5J107XG4gICAgdmFyIGxhc3ROYW1lcyA9IFsnV2lydHMnLCAnT25laWwnLCAnU21pdGgnLCAnQmFyYmFyb3NhJywgJ1NvcHJhbm8nLCAnR290dGknLCAnQ29sdW1ibycsICdMdWNpYW5vJywgJ0RvZXJyZScsICdEZVBlbmEnXTtcbiAgICB2YXIgbW9udGhzID0gWycwMScsICcwMicsICcwMycsICcwNCcsICcwNScsICcwNicsICcwNycsICcwOCcsICcwOScsICcxMCcsICcxMScsICcxMiddO1xuICAgIHZhciBkYXlzID0gWycwMScsICcwMicsICcwMycsICcwNCcsICcwNScsICcwNicsICcwNycsICcwOCcsICcwOScsICcxMCcsICcxMScsICcxMicsICcxMycsICcxNCcsICcxNScsICcxNicsICcxNycsICcxOCcsICcxOScsICcyMCcsICcyMScsICcyMicsICcyMycsICcyNCcsICcyNScsICcyNicsICcyNycsICcyOCcsICcyOScsICczMCddO1xuICAgIHZhciBzdGF0ZXMgPSBbJ0FsYWJhbWEnLCAnQWxhc2thJywgJ0FyaXpvbmEnLCAnQXJrYW5zYXMnLCAnQ2FsaWZvcm5pYScsICdDb2xvcmFkbycsICdDb25uZWN0aWN1dCcsICdEZWxhd2FyZScsICdGbG9yaWRhJywgJ0dlb3JnaWEnLCAnSGF3YWlpJywgJ0lkYWhvJywgJ0lsbGlub2lzJywgJ0luZGlhbmEnLCAnSW93YScsICdLYW5zYXMnLCAnS2VudHVja3knLCAnTG91aXNpYW5hJywgJ01haW5lJywgJ01hcnlsYW5kJywgJ01hc3NhY2h1c2V0dHMnLCAnTWljaGlnYW4nLCAnTWlubmVzb3RhJywgJ01pc3Npc3NpcHBpJywgJ01pc3NvdXJpJywgJ01vbnRhbmEnLCAnTmVicmFza2EnLCAnTmV2YWRhJywgJ05ldyBIYW1wc2hpcmUnLCAnTmV3IEplcnNleScsICdOZXcgTWV4aWNvJywgJ05ldyBZb3JrJywgJ05vcnRoIENhcm9saW5hJywgJ05vcnRoIERha290YScsICdPaGlvJywgJ09rbGFob21hJywgJ09yZWdvbicsICdQZW5uc3lsdmFuaWEnLCAnUmhvZGUgSXNsYW5kJywgJ1NvdXRoIENhcm9saW5hJywgJ1NvdXRoIERha290YScsICdUZW5uZXNzZWUnLCAnVGV4YXMnLCAnVXRhaCcsICdWZXJtb250JywgJ1ZpcmdpbmlhJywgJ1dhc2hpbmd0b24nLCAnV2VzdCBWaXJnaW5pYScsICdXaXNjb25zaW4nLCAnV3lvbWluZyddO1xuXG4gICAgdmFyIHJhbmRvbUZ1bmMgPSBNYXRoLnJhbmRvbTtcbiAgICAvL3ZhciByYW5kb21GdW5jID0gcm5kO1xuICAgIHZhciByYW5kb21QZXJzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZpcnN0TmFtZSA9IE1hdGgucm91bmQoKGZpcnN0TmFtZXMubGVuZ3RoIC0gMSkgKiByYW5kb21GdW5jKCkpO1xuICAgICAgICB2YXIgbGFzdE5hbWUgPSBNYXRoLnJvdW5kKChsYXN0TmFtZXMubGVuZ3RoIC0gMSkgKiByYW5kb21GdW5jKCkpO1xuICAgICAgICB2YXIgcGV0cyA9IE1hdGgucm91bmQoMTAgKiByYW5kb21GdW5jKCkpO1xuICAgICAgICB2YXIgYmlydGh5ZWFyID0gMTkwMCArIE1hdGgucm91bmQocmFuZG9tRnVuYygpICogMTE0KTtcbiAgICAgICAgdmFyIGJpcnRobW9udGggPSBNYXRoLnJvdW5kKHJhbmRvbUZ1bmMoKSAqIDExKTtcbiAgICAgICAgdmFyIGJpcnRoZGF5ID0gTWF0aC5yb3VuZChyYW5kb21GdW5jKCkgKiAyOSk7XG4gICAgICAgIHZhciBiaXJ0aHN0YXRlID0gTWF0aC5yb3VuZChyYW5kb21GdW5jKCkgKiA0OSk7XG4gICAgICAgIHZhciByZXNpZGVuY2VzdGF0ZSA9IE1hdGgucm91bmQocmFuZG9tRnVuYygpICogNDkpO1xuICAgICAgICB2YXIgdHJhdmVsID0gcmFuZG9tRnVuYygpICogMTAwMDtcbiAgICAgICAgdmFyIGluY29tZSA9IHJhbmRvbUZ1bmMoKSAqIDEwMDAwMDtcbiAgICAgICAgdmFyIGVtcGxveWVkID0gTWF0aC5yb3VuZChyYW5kb21GdW5jKCkpO1xuICAgICAgICB2YXIgcGVyc29uID0ge1xuICAgICAgICAgICAgbGFzdF9uYW1lOiBsYXN0TmFtZXNbbGFzdE5hbWVdLFxuICAgICAgICAgICAgLy9qc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgIGZpcnN0X25hbWU6IGZpcnN0TmFtZXNbZmlyc3ROYW1lXSxcbiAgICAgICAgICAgIC8vanNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICBwZXRzOiBwZXRzLFxuICAgICAgICAgICAgYmlydGhEYXRlOiBiaXJ0aHllYXIgKyAnLScgKyBtb250aHNbYmlydGhtb250aF0gKyAnLScgKyBkYXlzW2JpcnRoZGF5XSxcbiAgICAgICAgICAgIGJpcnRoU3RhdGU6IHN0YXRlc1tiaXJ0aHN0YXRlXSxcbiAgICAgICAgICAgIHJlc2lkZW5jZVN0YXRlOiBzdGF0ZXNbcmVzaWRlbmNlc3RhdGVdLFxuICAgICAgICAgICAgZW1wbG95ZWQ6IGVtcGxveWVkID09PSAxLFxuICAgICAgICAgICAgaW5jb21lOiBpbmNvbWUsXG4gICAgICAgICAgICB0cmF2ZWw6IHRyYXZlbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGVyc29uO1xuICAgIH07XG5cbiAgICB2YXIgZGF0YSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUm93czsgaSsrKSB7XG4gICAgICAgIHZhciBwZXJzb24gPSByYW5kb21QZXJzb24oKTtcbiAgICAgICAgcGVyc29uLm9yZGVyID0gaTtcbiAgICAgICAgZGF0YS5wdXNoKHBlcnNvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG5cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBKU0RhdGFTb3VyY2U6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZScpLFxuICAgIERhdGFTb3VyY2VTb3J0ZXI6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZVNvcnRlcicpLFxuICAgIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGU6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZScpLFxuICAgIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXI6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZUdsb2JhbEZpbHRlcicpLFxuICAgIERhdGFTb3VyY2VBZ2dyZWdhdG9yOiByZXF1aXJlKCcuL2pzL0RhdGFTb3VyY2VBZ2dyZWdhdG9yJyksXG4gICAgRGF0YVNvdXJjZVRyZWV2aWV3OiByZXF1aXJlKCcuL2pzL0RhdGFTb3VyY2VUcmVldmlldycpLFxuICAgIERhdGFOb2RlR3JvdXBTb3J0ZXI6IHJlcXVpcmUoJy4vanMvRGF0YU5vZGVHcm91cFNvcnRlcicpLFxuICAgIHV0aWw6IHtcbiAgICAgICAgYWdncmVnYXRpb25zOiByZXF1aXJlKCcuL2pzL3V0aWwvYWdncmVnYXRpb25zJyksXG4gICAgICAgIE1hcHB5OiByZXF1aXJlKCcuL2pzL3V0aWwvTWFwcHknKSxcbiAgICAgICAgc3RhYmxlU29ydDogcmVxdWlyZSgnLi9qcy91dGlsL3N0YWJsZVNvcnQnKSxcbiAgICAgICAgaGVhZGVyaWZ5OiByZXF1aXJlKCcuL2pzL3V0aWwvaGVhZGVyaWZ5JyksXG4gICAgICAgIGdlbmVyYXRlU2FtcGxlRGF0YTogcmVxdWlyZSgnLi9nZW5lcmF0ZVNhbXBsZURhdGEuanMnKVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIEJhc2UoKSB7fVxuQmFzZS5leHRlbmQgPSByZXF1aXJlKCdleHRlbmQtbWUnKTtcblxuQmFzZS5wcm90b3R5cGUuY2xpY2sgPSBmdW5jdGlvbih5KSB7XG4gICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmNsaWNrKHkpO1xuICAgIH1cbn07XG5cbkJhc2UucHJvdG90eXBlLmZpbmRSb3cgPSBmdW5jdGlvbihjb2x1bW5OYW1lLCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZmluZFJvdyhjb2x1bW5OYW1lLCB2YWx1ZSk7XG59O1xuXG5CYXNlLnByb3RvdHlwZS5yZXBsYWNlSW5kZW50ID0gJ18nO1xuXG5CYXNlLnByb3RvdHlwZS5maXhJbmRlbnRGb3JUYWJsZURpc3BsYXkgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgY291bnQgPSBzdHJpbmcuc2VhcmNoKC9cXFMvKTtcbiAgICB2YXIgZW5kID0gc3RyaW5nLnN1YnN0cmluZyhjb3VudCk7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGNvdW50ICsgMSkuam9pbih0aGlzLnJlcGxhY2VJbmRlbnQpICsgZW5kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5CYXNlLnByb3RvdHlwZS5kdW1wID0gZnVuY3Rpb24obWF4KSB7XG4gICAgbWF4ID0gTWF0aC5taW4odGhpcy5nZXRSb3dDb3VudCgpLCBtYXggfHwgTWF0aC5tYXgoMTAwLCB0aGlzLmdldFJvd0NvdW50KCkpKTtcbiAgICB2YXIgZGF0YSA9IFtdO1xuICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldEhlYWRlcnMoKTtcbiAgICB2YXIgY0NvdW50ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgIHZhciB2aWV3TWFrZXNTZW5zZSA9IHRoaXMudmlld01ha2VzU2Vuc2U7XG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCBtYXg7IHIrKykge1xuICAgICAgICB2YXIgcm93ID0ge307XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY0NvdW50OyBjKyspIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmdldFZhbHVlKGMsIHIpO1xuICAgICAgICAgICAgaWYgKGMgPT09IDAgJiYgdmlld01ha2VzU2Vuc2UpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLmZpeEluZGVudEZvclRhYmxlRGlzcGxheSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93W2ZpZWxkc1tjXV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtyXSA9IHJvdztcbiAgICB9XG4gICAgY29uc29sZS50YWJsZShkYXRhKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcblxuLyoqXG4gKiBTZWUge0BsaW5rIERhdGFCYXNlTm9kZSNpbml0aWFsaXplfGluaXRpYWxpemUoKX0gbWV0aG9kIGZvciBwYXJhbWV0ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRhTm9kZUJhc2UgPSBCYXNlLmV4dGVuZCgnRGF0YU5vZGVCYXNlJywge1xuXG4gICAgaXNOdWxsT2JqZWN0OiBmYWxzZSxcblxuICAgIElOREVOVDogJyAgICcsIC8vIDMgc3BhY2VzXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVCYXNlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUJhc2UucHJvdG90eXBlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMubGFiZWwgPSBrZXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUJhc2UucHJvdG90eXBlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IFsnJ107IC8vIFRPRE86IFdoeSBpcyB0aGlzIGZpcnN0IGVsZW1lbnQgbmVlZGVkP1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVCYXNlLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyW119XG4gICAgICAgICAqIEBkZWZhdWx0IFsnJ11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTsgLy8gVE9ETzogZm9ybWVybHkgcm93SW5kZXhcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFOb2RlQmFzZS5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0NoaWxkcmVuID0gZmFsc2U7IC8vIFRPRE86IFdoZXJlL2hvdyBpcyB0aGlzIHVzZWQ/XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUJhc2UucHJvdG90eXBlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVCYXNlLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9IDE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUJhc2UucHJvdG90eXBlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gZGVwdGhcbiAgICAgKi9cbiAgICB0b0FycmF5OiBmdW5jdGlvbihkZXB0aCkge1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgICAgIHRoaXMuZGF0YVswXSA9IHRoaXMuY29tcHV0ZURlcHRoU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBjb21wdXRlRGVwdGhTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkodGhpcy5kZXB0aCArIDEpLmpvaW4odGhpcy5JTkRFTlQpICsgJyAgJyArIHRoaXMubGFiZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBjb21wdXRlSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldEluZGV4OiBmdW5jdGlvbigpIHsgLy8gVE9ETzogZm9ybWVybHkgZ2V0QWxsUm93SW5kZXhlc1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gYWdncmVnYXRvclxuICAgICAqL1xuICAgIGNvbXB1dGVBZ2dyZWdhdGVzOiBmdW5jdGlvbihhZ2dyZWdhdG9yKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKTtcblxuICAgICAgICBpZiAoaW5kZXgubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBzT2Zmc2V0ID0gTnVtYmVyKGFnZ3JlZ2F0b3IuaGFzR3JvdXBzKCkpO1xuXG4gICAgICAgICAgICAvLyByZWRpbWVuc2lvbiB0aGUgZGF0YVxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICBkYXRhLmxlbmd0aCA9IGdyb3Vwc09mZnNldCArIGFnZ3JlZ2F0b3IuYWdncmVnYXRlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHZhciBzb3J0ZXIgPSBhZ2dyZWdhdG9yLnNvcnRlckluc3RhbmNlO1xuICAgICAgICAgICAgc29ydGVyLmluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgICAgIGFnZ3JlZ2F0b3IuYWdncmVnYXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGFnZ3JlZ2F0ZSwgaSkge1xuICAgICAgICAgICAgICAgIGRhdGFbZ3JvdXBzT2Zmc2V0ICsgaV0gPSBhZ2dyZWdhdGUoc29ydGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0b3JcbiAgICAgKi9cbiAgICBidWlsZFZpZXc6IGZ1bmN0aW9uKGFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgYWdncmVnYXRvci5hZGRWaWV3KHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRvZ2dsZUV4cGFuc2lvblN0YXRlOiBmdW5jdGlvbigpIHsgLyogYWdncmVnYXRvciAqL1xuICAgICAgICAvL2RvIG5vdGhpbmcgYnkgZGVmYXVsdFxuICAgIH0sXG5cbiAgICBzb3J0R3JvdXBzOiBmdW5jdGlvbihncm91cFNvcnRlcikge1xuICAgIH1cbn0pO1xuXG4vL0RhdGFOb2RlQmFzZS5wcm90b3R5cGUuYXBwbHlBZ2dyZWdhdGVzID0gRGF0YU5vZGVCYXNlLnByb3RvdHlwZS5jb21wdXRlQWdncmVnYXRlcztcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTm9kZUJhc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBNYXAgPSByZXF1aXJlKCcuL3V0aWwvTWFwcHknKTtcbnZhciBEYXRhTm9kZUJhc2UgPSByZXF1aXJlKCcuL0RhdGFOb2RlQmFzZScpO1xuXG52YXIgZXhwYW5kZWRNYXAgPSB7XG4gICAgdHJ1ZTogJ1xcdTI1YmMnLCAvLyBCTEFDSyBET1dOLVBPSU5USU5HIFRSSUFOR0xFIGFrYSAn4pa8J1xuICAgIGZhbHNlOiAnXFx1MjViNicgLy8gQkxBQ0sgUklHSFQtUE9JTlRJTkcgVFJJQU5HTEUgYWthICfilrYnXG59O1xuXG4vKipcbiAqID4gU2VlIHtAbGluayBEYXRhTm9kZUdyb3VwI2luaXRpYWxpemV8aW5pdGlhbGl6ZSgpfSBtZXRob2QgZm9yIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERhdGFOb2RlQmFzZVxuICovXG52YXIgRGF0YU5vZGVHcm91cCA9IERhdGFOb2RlQmFzZS5leHRlbmQoJ0RhdGFOb2RlR3JvdXAnLCB7XG5cbiAgICBleHRlbmRhYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gZGVwdGhcbiAgICAgKi9cbiAgICB0b0FycmF5OiBmdW5jdGlvbihkZXB0aCkge1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnZhbHVlcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC50b0FycmF5KGRlcHRoICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmNvbXB1dGVEZXB0aFN0cmluZygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNvbXB1dGVEZXB0aFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSBBcnJheSh0aGlzLmRlcHRoICsgMSkuam9pbih0aGlzLklOREVOVCkgK1xuICAgICAgICAgICAgZXhwYW5kZWRNYXBbdGhpcy5leHBhbmRlZF0gKyAnICcgK1xuICAgICAgICAgICAgdGhpcy5sYWJlbDtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmNvbXB1dGVJbmRleCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgY29tcHV0ZUluZGV4OiBmdW5jdGlvbigpIHsgLy8gVE9ETzogZm9ybWVybHkgY29tcHV0ZUFsbFJvd0luZGV4ZXNcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICByZXN1bHQuYXBwZW5kID0gYXBwZW5kO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoY2hpbGQuZ2V0SW5kZXgoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gYWdncmVnYXRvclxuICAgICAqL1xuICAgIHRvZ2dsZUV4cGFuc2lvblN0YXRlOiBmdW5jdGlvbihhZ2dyZWdhdG9yKSB7IC8qIGFnZ3JlZ2F0b3IgKi9cbiAgICAgICAgdGhpcy5leHBhbmRlZCA9ICF0aGlzLmV4cGFuZGVkO1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmNvbXB1dGVEZXB0aFN0cmluZygpO1xuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlQWdncmVnYXRlcyhhZ2dyZWdhdG9yKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gYWdncmVnYXRvclxuICAgICAqL1xuICAgIGNvbXB1dGVBZ2dyZWdhdGVzOiBmdW5jdGlvbihhZ2dyZWdhdG9yKSB7XG4gICAgICAgIERhdGFOb2RlQmFzZS5wcm90b3R5cGUuY29tcHV0ZUFnZ3JlZ2F0ZXMuY2FsbCh0aGlzLCBhZ2dyZWdhdG9yKTsgLy8gY2FsbCBiYXNlIGNsYXNzJ3MgdmVyc2lvblxuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuY29tcHV0ZUFnZ3JlZ2F0ZXMoYWdncmVnYXRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gYWdncmVnYXRvclxuICAgICAqL1xuICAgIGJ1aWxkVmlldzogZnVuY3Rpb24oYWdncmVnYXRvcikge1xuICAgICAgICBhZ2dyZWdhdG9yLnZpZXcucHVzaCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLmJ1aWxkVmlldyhhZ2dyZWdhdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgY29tcHV0ZUhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSAxO1xuXG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgKyBjaGlsZC5jb21wdXRlSGVpZ2h0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodGhpcy5oZWlnaHQgPSBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICBzb3J0V2l0aDogZnVuY3Rpb24oc29ydGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICBzb3J0ZXIuc29ydEdyb3VwKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuc29ydFdpdGgoc29ydGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjbGVhckdyb3VwU29ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5vcmlnaW5hbE9yZGVyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3JpZ2luYWxPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0gPSB0aGlzLm9yaWdpbmFsT3JkZXJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5jbGVhckdyb3VwU29ydHMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHN1bW1hcnkgQXJyYXkgbWl4aW4gdG8gYXBwZW5kIGFub3RoZXIgYXJyYXkgdG8gZW5kIG9mIGB0aGlzYCBvbmUuXG4gKiBAZGVzYyBBcHBlbmRzIGluIHBsYWNlLCB1bmxpa2UgYHRoaXMuY29uY2F0KClgIHdoaWNoIGNyZWF0ZXMgYSBuZXcgYXJyYXkuXG4gKiBVc2VzIGxlc3MgbWVtb3J5IHRoYW4gY29uY2F0LCBpbXBvcnRhbnQgd2hlbiBgYXBwZW5kaXhgIGlzIGh1Z2UuXG4gKiA+IENBVVRJT046IE11dGF0ZXMgYHRoaXNgIGFycmF5IVxuICogQHBhcmFtIHtBcnJheX0gYXBwZW5kaXhcbiAqIEByZXR1cm5zIHtBcnJheX0gUmVmZXJlbmNlIHRvIGB0aGlzYCAoZm9yIGNvbnZlbmllbmNlKVxuICovXG5mdW5jdGlvbiBhcHBlbmQoYXBwZW5kaXgpIHtcbiAgICB0aGlzLnNwbGljZS5iaW5kKHRoaXMsIHRoaXMubGVuZ3RoLCAwKS5hcHBseSh0aGlzLCBhcHBlbmRpeCk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU5vZGVHcm91cDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcbnZhciBzdGFibGVTb3J0ID0gcmVxdWlyZSgnLi91dGlsL3N0YWJsZVNvcnQnKS5zb3J0O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRGF0YVNvdXJjZUluZGV4ZWRcbiAqL1xudmFyIERhdGFOb2RlR3JvdXBTb3J0ZXIgPSBCYXNlLmV4dGVuZCgnRGF0YU5vZGVHcm91cFNvcnRlcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gZGF0YVNvdXJjZTtcbiAgICAgICAgdGhpcy5zb3J0cyA9IFtdO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdC5nZXRSb3coeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBjb2x1bW5JbmRleFxuICAgICAqIEBwYXJhbSBkaXJlY3Rpb25cbiAgICAgKi9cbiAgICBzb3J0T246IGZ1bmN0aW9uKGNvbHVtbkluZGV4LCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5zb3J0cy5wdXNoKFtjb2x1bW5JbmRleCwgZGlyZWN0aW9uXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnNvcnRHcm91cHModGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNsZWFyU29ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNvcnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5idWlsZFZpZXcoKTtcbiAgICB9LFxuXG4gICAgc29ydEdyb3VwOiBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoIWdyb3VwLm9yaWdpbmFsT3JkZXIpIHtcbiAgICAgICAgICAgIGdyb3VwLm9yaWdpbmFsT3JkZXIgPSBncm91cC5jaGlsZHJlbi5zbGljZSgwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc29ydHMgPSB0aGlzLnNvcnRzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnNvcnRHcm91cE9uRWFjaChncm91cCwgc29ydHNbc29ydHMubGVuZ3RoIC0gaSAtIDFdKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzb3J0R3JvdXBPbkVhY2g6IGZ1bmN0aW9uKGdyb3VwLCBzb3J0SW5mbykge1xuICAgICAgICAvLyB3ZSBhY3R1YWxseSBzb3J0IHRoZSBjaGlsZHJlbiBoZXJlLi4uLlxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBncm91cC5jaGlsZHJlbi5zbGljZSgwKTtcbiAgICAgICAgdmFyIGNvbEluZGV4ID0gc29ydEluZm9bMF07XG4gICAgICAgIHZhciBhc2NEZXNjID0gc29ydEluZm9bMV07XG4gICAgICAgIHZhciBpbmRleFZlY3RvciA9IFtdO1xuICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbmRleFZlY3RvcltpXSA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFibGVTb3J0KGluZGV4VmVjdG9yLCBmdW5jdGlvbihyb3dOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW3Jvd051bWJlcl07XG4gICAgICAgICAgICBpZiAoY29sSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubGFiZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuZGF0YVtjb2xJbmRleF07XG4gICAgICAgIH0sIGFzY0Rlc2MpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZ3JvdXAuY2hpbGRyZW5baV0gPSBjaGlsZHJlbltpbmRleFZlY3RvcltpXV07XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5EYXRhTm9kZUdyb3VwU29ydGVyLnByb3RvdHlwZS5hcHBseVNvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgKGNvbnNvbGUud2FybiB8fCBjb25zb2xlLmxvZykuY2FsbChjb25zb2xlLCAnYXBwbHlTb3J0cyBkZXByZWNhdGVkOyB1c2UgYXBwbHknKTtcbiAgICB0aGlzLmFwcGx5KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFOb2RlR3JvdXBTb3J0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhTm9kZUJhc2UgPSByZXF1aXJlKCcuL0RhdGFOb2RlQmFzZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRGF0YU5vZGVCYXNlXG4gKi9cbnZhciBEYXRhTm9kZUxlYWYgPSBEYXRhTm9kZUJhc2UuZXh0ZW5kKCdEYXRhTm9kZUxlYWYnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBkZXB0aFxuICAgICAqL1xuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKGRlcHRoKSB7XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gdGhpcy5jb21wdXRlRGVwdGhTdHJpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtZXJbXX1cbiAgICAgKi9cbiAgICBnZXRJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBhZ2dyZWdhdG9yXG4gICAgICovXG4gICAgYnVpbGRWaWV3OiBmdW5jdGlvbihhZ2dyZWdhdG9yKSB7XG4gICAgICAgIGFnZ3JlZ2F0b3IuYWRkVmlldyh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGNvbXB1dGVIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgc29ydFdpdGg6IGZ1bmN0aW9uKHNvcnRlcikge1xuICAgICAgLy8gZG8gbm90aGluZyB3ZSBoYXZlIG5vIGNoaWxkcmVuIHRvIHNvcnRcbiAgICB9LFxuXG4gICAgY2xlYXJHcm91cFNvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmcgd2UgaGF2ZSBubyBjaGlsZHJlbiB0byBzb3J0XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTm9kZUxlYWY7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhTm9kZUdyb3VwID0gcmVxdWlyZSgnLi9EYXRhTm9kZUdyb3VwJyk7XG5cbi8qKlxuICogU2VlIHtAbGluayBEYXRhTm9kZUdyb3VwI2luaXRpYWxpemV8aW5pdGlhbGl6ZSgpfSBtZXRob2QgZm9yIHBhcmFtZXRlcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERhdGFOb2RlR3JvdXBcbiAqL1xudmFyIERhdGFOb2RlVHJlZSA9IERhdGFOb2RlR3JvdXAuZXh0ZW5kKCdEYXRhTm9kZVRyZWUnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi52YWx1ZXM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQudG9BcnJheSgwKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBhZ2dyZWdhdG9yXG4gICAgICovXG4gICAgYnVpbGRWaWV3OiBmdW5jdGlvbihhZ2dyZWdhdG9yKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQuYnVpbGRWaWV3KGFnZ3JlZ2F0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBjb21wdXRlSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IDE7XG5cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgKyBjaGlsZC5jb21wdXRlSGVpZ2h0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAodGhpcy5oZWlnaHQgPSBoZWlnaHQpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU5vZGVUcmVlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vQmFzZScpO1xudmFyIGhlYWRlcmlmeSA9IHJlcXVpcmUoJy4vdXRpbC9oZWFkZXJpZnknKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0W119IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkc1xuICovXG52YXIgRGF0YVNvdXJjZSA9IEJhc2UuZXh0ZW5kKCdEYXRhU291cmNlJywge1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRhdGEsIGZpZWxkcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHMgfHwgY29tcHV0ZUZpZWxkTmFtZXMoZGF0YVswXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3RbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfSxcblxuICAgIGlzTnVsbE9iamVjdDogZmFsc2UsXG5cbiAgICBnZXREYXRhSW5kZXg6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3ldO1xuICAgIH0sXG5cbiAgICBmaW5kUm93OiBmdW5jdGlvbihjb2x1bW5OYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmZpbmQoZnVuY3Rpb24ocm93KSB7IHJldHVybiByb3dbY29sdW1uTmFtZV0gPT09IHZhbHVlOyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLmdldFJvdyh5KTtcbiAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dbdGhpcy5maWVsZHNbeF1dO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ2V0Um93KHkpW3RoaXMuZmllbGRzW3hdXSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWVsZHMoKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICBnZXRGaWVsZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHRoaXMuaGVhZGVycyB8fCB0aGlzLmdldERlZmF1bHRIZWFkZXJzKCkubWFwKGZ1bmN0aW9uKGVhY2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyaWZ5LnRyYW5zZm9ybShlYWNoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZHNcbiAgICAgKi9cbiAgICBzZXRGaWVsZHM6IGZ1bmN0aW9uKGZpZWxkcykge1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gaGVhZGVyc1xuICAgICAqL1xuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKCEoaGVhZGVycyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgZXJyb3IoJ3NldEhlYWRlcnMnLCAncGFyYW0gIzEgYGhlYWRlcnNgIG5vdCBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldEdyYW5kVG90YWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9ub3RoaW5nIGhlcmVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGFycmF5T2ZVbmlmb3JtT2JqZWN0c1xuICAgICAqL1xuICAgIHNldERhdGE6IGZ1bmN0aW9uKGFycmF5T2ZVbmlmb3JtT2JqZWN0cykge1xuICAgICAgICB0aGlzLmRhdGEgPSBhcnJheU9mVW5pZm9ybU9iamVjdHM7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGVycm9yKG1ldGhvZE5hbWUsIG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFTb3VyY2UuJyArIG1ldGhvZE5hbWUgKyAnOiAnICsgbWVzc2FnZSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZpZWxkTmFtZXMob2JqZWN0KSB7XG4gICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0IHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gZS5zdWJzdHIoMCwgMikgIT09ICdfXyc7XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcbnZhciBEYXRhU291cmNlU29ydGVyID0gcmVxdWlyZSgnLi9EYXRhU291cmNlU29ydGVyJyk7XG52YXIgRGF0YU5vZGVUcmVlID0gcmVxdWlyZSgnLi9EYXRhTm9kZVRyZWUnKTtcbnZhciBEYXRhTm9kZUdyb3VwID0gcmVxdWlyZSgnLi9EYXRhTm9kZUdyb3VwJyk7XG52YXIgRGF0YU5vZGVMZWFmID0gcmVxdWlyZSgnLi9EYXRhTm9kZUxlYWYnKTtcbnZhciBoZWFkZXJpZnkgPSByZXF1aXJlKCcuL3V0aWwvaGVhZGVyaWZ5Jyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0RhdGFTb3VyY2V9IGRhdGFTb3VyY2VcbiAqL1xudmFyIERhdGFTb3VyY2VBZ2dyZWdhdG9yID0gQmFzZS5leHRlbmQoJ0RhdGFTb3VyY2VBZ2dyZWdhdG9yJywge1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRhdGFTb3VyY2UpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7RGF0YVNvdXJjZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge0RhdGFOb2RlVHJlZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJlZSA9IG5ldyBEYXRhTm9kZVRyZWUoJ1RvdGFscycpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZXMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyb3VwQnlzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKiBAZGVmYXVsdCBbXVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aWV3ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQGRlZmF1bHQge31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc29ydGVySW5zdGFuY2UgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmVzb3J0R3JvdXBzID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAZGVmYXVsdCB7fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0QWdncmVnYXRlID0ge307XG5cbiAgICAgICAgdGhpcy5zZXRBZ2dyZWdhdGVzKHt9KTtcbiAgICB9LFxuXG4gICAgaXNOdWxsT2JqZWN0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gYWdncmVnYXRpb25zXG4gICAgICovXG4gICAgc2V0QWdncmVnYXRlczogZnVuY3Rpb24oYWdncmVnYXRpb25zKSB7XG4gICAgICAgIHRoaXMubGFzdEFnZ3JlZ2F0ZSA9IGFnZ3JlZ2F0aW9ucztcbiAgICAgICAgdGhpcy5jbGVhckFnZ3JlZ2F0aW9ucygpO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhZ2dyZWdhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQWdncmVnYXRlKGtleSwgYWdncmVnYXRpb25zW2tleV0pO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0RmllbGRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuZ2V0SGVhZGVycygpLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS50b0xvd2VyQ2FzZSgpLnNwbGl0KCcgJykuam9pbignXycpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICB9LFxuXG4gICAgZ2V0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldEhlYWRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVycyA9IHRoaXMuYWdncmVnYXRlcy5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuaGVhZGVyO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuaGFzR3JvdXBzKCkpIHtcbiAgICAgICAgICAgIGhlYWRlcnMudW5zaGlmdCgnVHJlZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBsYWJlbFxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICovXG4gICAgYWRkQWdncmVnYXRlOiBmdW5jdGlvbihsYWJlbCwgZnVuYykge1xuICAgICAgICBmdW5jLmhlYWRlciA9IGhlYWRlcmlmeS50cmFuc2Zvcm0obGFiZWwpO1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZXMucHVzaChmdW5jKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBjb2x1bW5JbmRleEFycmF5XG4gICAgICovXG4gICAgc2V0R3JvdXBCeXM6IGZ1bmN0aW9uKGNvbHVtbkluZGV4QXJyYXkpIHtcbiAgICAgICAgdmFyIGdyb3VwQnlzID0gdGhpcy5ncm91cEJ5cztcbiAgICAgICAgZ3JvdXBCeXMubGVuZ3RoID0gMDtcbiAgICAgICAgY29sdW1uSW5kZXhBcnJheS5mb3JFYWNoKGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgICAgICBncm91cEJ5cy5wdXNoKGNvbHVtbkluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0QWdncmVnYXRlcyh0aGlzLmxhc3RBZ2dyZWdhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICovXG4gICAgYWRkR3JvdXBCeTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdGhpcy5ncm91cEJ5cy5wdXNoKGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0dyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ3JvdXBCeXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzQWdncmVnYXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuYWdncmVnYXRlcy5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhcHBseTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYnVpbGRHcm91cFRyZWUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNsZWFyR3JvdXBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ncm91cEJ5cy5sZW5ndGggPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXJBZ2dyZWdhdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZXMubGVuZ3RoID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGJ1aWxkR3JvdXBUcmVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJldmVyc2VkR3JvdXBCeXMgPSB0aGlzLmdyb3VwQnlzLnNsaWNlKDApLnJldmVyc2UoKSxcbiAgICAgICAgICAgIGxlYWZEZXB0aCA9IHRoaXMuZ3JvdXBCeXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMuZGF0YVNvdXJjZSxcbiAgICAgICAgICAgIHJvd0NvdW50ID0gc291cmNlLmdldFJvd0NvdW50KCksXG4gICAgICAgICAgICB0cmVlID0gdGhpcy50cmVlID0gbmV3IERhdGFOb2RlVHJlZSgnVG90YWxzJyk7XG5cbiAgICAgICAgLy8gZmlyc3Qgc29ydCBkYXRhXG4gICAgICAgIGlmICh0aGlzLnByZXNvcnRHcm91cHMpIHtcbiAgICAgICAgICAgIHJldmVyc2VkR3JvdXBCeXMuZm9yRWFjaChmdW5jdGlvbihncm91cEJ5KSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gbmV3IERhdGFTb3VyY2VTb3J0ZXIoc291cmNlKTtcbiAgICAgICAgICAgICAgICBzb3VyY2Uuc29ydE9uKGdyb3VwQnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJvd0NvdW50OyByKyspIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gdHJlZTtcblxuICAgICAgICAgICAgdGhpcy5ncm91cEJ5cy5mb3JFYWNoKGZ1bmN0aW9uKGcsIGMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gc291cmNlLmdldFZhbHVlKGcsIHIpLFxuICAgICAgICAgICAgICAgICAgICBmYWN0b3J5RGF0YU5vZGUgPSAoYyA9PT0gbGVhZkRlcHRoKSA/IGZhY3RvcnlEYXRhTm9kZUxlYWYgOiBmYWN0b3J5RGF0YU5vZGVHcm91cDtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5jaGlsZHJlbi5nZXRJZlVuZGVmaW5lZChrZXksIGZhY3RvcnlEYXRhTm9kZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcGF0aC5pbmRleC5wdXNoKHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zb3J0ZXJJbnN0YW5jZSA9IG5ldyBEYXRhU291cmNlU29ydGVyKHNvdXJjZSk7XG4gICAgICAgIHRyZWUudG9BcnJheSgpO1xuICAgICAgICB0cmVlLmNvbXB1dGVBZ2dyZWdhdGVzKHRoaXMpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlldygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGRhdGFOb2RlXG4gICAgICovXG4gICAgYWRkVmlldzogZnVuY3Rpb24oZGF0YU5vZGUpIHtcbiAgICAgICAgdGhpcy52aWV3LnB1c2goZGF0YU5vZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgYnVpbGRWaWV3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy52aWV3Lmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMudHJlZS5jb21wdXRlSGVpZ2h0KCk7XG4gICAgICAgIHRoaXMudHJlZS5idWlsZFZpZXcodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Knxib29sZWFufVxuICAgICAqL1xuICAgIHZpZXdNYWtlc1NlbnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQWdncmVnYXRlcygpICYmIHRoaXMuaGFzR3JvdXBzKCk7XG4gICAgfSxcblxuICAgIGdldERhdGFJbmRleDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3TWFrZXNTZW5zZSgpID8geSA6IHRoaXMuZGF0YVNvdXJjZS5nZXREYXRhSW5kZXgoeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0VmFsdWUoeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm93ID0gdGhpcy52aWV3W3ldO1xuXG4gICAgICAgIHJldHVybiByb3cgPyByb3cuZ2V0VmFsdWUoeCkgOiBudWxsOyAvLyBUT0RPOiB3aGF0IGtpbmQgb2Ygb2JqZWN0IGlzIHJvdy4uLiA/IHNob3VsZCBpdCBiZSB1bmZpbHRyZWQ/XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnNldFZhbHVlKHgsIHksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEhlYWRlcnMoKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5sZW5ndGg7IC8vaGVhZGVyIGNvbHVtblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHlcbiAgICAgKi9cbiAgICBjbGljazogZnVuY3Rpb24oeSkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5jbGljayh5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JvdXAsIGV4cGFuZGFibGU7XG4gICAgICAgIGlmICgoZ3JvdXAgPSB0aGlzLnZpZXdbeV0pKSB7XG4gICAgICAgICAgICBncm91cC50b2dnbGVFeHBhbnNpb25TdGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIGlmICgoZXhwYW5kYWJsZSA9IGdyb3VwLmNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRWaWV3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISFleHBhbmRhYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGhlYWRlcnNcbiAgICAgKi9cbiAgICBzZXRIZWFkZXJzOiBmdW5jdGlvbihoZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zZXRIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGZpZWxkc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHNldEZpZWxkczogZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uuc2V0RmllbGRzKGZpZWxkcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0W119XG4gICAgICovXG4gICAgZ2V0R3JhbmRUb3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmlldyA9IHRoaXMudHJlZTtcbiAgICAgICAgcmV0dXJuIFt2aWV3LmRhdGFdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93KHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvbGx1cHMgPSB0aGlzLnZpZXdbeV07XG5cbiAgICAgICAgcmV0dXJuIHJvbGx1cHMgPyByb2xsdXBzIDogdGhpcy50cmVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGFycmF5T2ZVbmlmb3JtT2JqZWN0c1xuICAgICAqL1xuICAgIHNldERhdGE6IGZ1bmN0aW9uKGFycmF5T2ZVbmlmb3JtT2JqZWN0cykge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc2V0RGF0YShhcnJheU9mVW5pZm9ybU9iamVjdHMpO1xuICAgICAgICB0aGlzLmFwcGx5KCk7XG4gICAgfSxcblxuICAgIHNvcnRHcm91cHM6IGZ1bmN0aW9uKGdyb3VwU29ydGVyKSB7XG4gICAgICAgIHRoaXMudHJlZS5jbGVhckdyb3VwU29ydHMoKTtcbiAgICAgICAgdGhpcy50cmVlLnNvcnRXaXRoKGdyb3VwU29ydGVyKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXcoKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gZmFjdG9yeURhdGFOb2RlTGVhZihrZXkpIHtcbiAgICByZXR1cm4gbmV3IERhdGFOb2RlTGVhZihrZXkpO1xufVxuXG5mdW5jdGlvbiBmYWN0b3J5RGF0YU5vZGVHcm91cChrZXkpIHtcbiAgICByZXR1cm4gbmV3IERhdGFOb2RlR3JvdXAoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlQWdncmVnYXRvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFTb3VyY2VJbmRleGVkID0gcmVxdWlyZSgnLi9EYXRhU291cmNlSW5kZXhlZCcpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gZmlsdGVyRnVuY3Rpb25cbiAqIEBwYXJhbSBjZWxsVmFsdWVcbiAqIEBwYXJhbSB7b2JqZWN0fSByb3dPYmplY3QgLSBSZWZlcmVuY2UgdG8gYHRoaXMuZGF0YVNvdXJjZS5kYXRhW3JdYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByIC0gUm93IG51bWJlciAoaW5kZXggd2l0aGluIGB0aGlzLmRhdGFTb3VyY2UuZGF0YWApLlxuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhU291cmNlSW5kZXhlZFxuICovXG52YXIgRGF0YVNvdXJjZUdsb2JhbEZpbHRlciA9IERhdGFTb3VyY2VJbmRleGVkLmV4dGVuZCgnRGF0YVNvdXJjZUdsb2JhbEZpbHRlcicsIHtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtmaWx0ZXJdIC0gSWYgdW5kZWZpbmVkLCBkZWxldGVzIGZpbHRlci5cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHtmaWx0ZXJGdW5jdGlvbn1cbiAgICAgICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR2xvYmFsRmlsdGVyLnByb3RvdHlwZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbHRlcjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgYXBwbHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFySW5kZXgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRJbmRleChmdW5jdGlvbiBhcHBseUZpbHRlcihyLCByb3dPYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIudGVzdChyb3dPYmplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdsb2JhbEZpbHRlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyID8gdGhpcy5pbmRleC5sZW5ndGggOiB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93Q291bnQoKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlR2xvYmFsRmlsdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vQmFzZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRGF0YVNvdXJjZUluZGV4ZWQgPSBCYXNlLmV4dGVuZCgnRGF0YVNvdXJjZUluZGV4ZWQnLCB7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGlzTnVsbE9iamVjdDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGRhdGFTb3VyY2VcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VJbmRleGVkLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgdHJhbnNwb3NlWTogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleC5sZW5ndGggPyB0aGlzLmluZGV4W3ldIDogeTtcbiAgICB9LFxuXG4gICAgZ2V0RGF0YUluZGV4OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0RGF0YUluZGV4KHRoaXMudHJhbnNwb3NlWSh5KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93KHRoaXMudHJhbnNwb3NlWSh5KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp8TWl4ZWR9XG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRWYWx1ZSh4LCB0aGlzLnRyYW5zcG9zZVkoeSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnNldFZhbHVlKHgsIHRoaXMudHJhbnNwb3NlWSh5KSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge051bWJlcnwqfVxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXgubGVuZ3RoIHx8IHRoaXMuZGF0YVNvdXJjZS5nZXRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRDb2x1bW5Db3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRGaWVsZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VJbmRleGVkLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBmaWVsZHNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzZXRGaWVsZHM6IGZ1bmN0aW9uKGZpZWxkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnNldEZpZWxkcyhmaWVsZHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gaGVhZGVyc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBzZXRIZWFkZXJzOiBmdW5jdGlvbihoZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uuc2V0SGVhZGVycyhoZWFkZXJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0SGVhZGVycygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0R3JhbmRUb3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldEdyYW5kVG90YWxzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfSBhcnJheU9mVW5pZm9ybU9iamVjdHNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0W119XG4gICAgICovXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oYXJyYXlPZlVuaWZvcm1PYmplY3RzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uuc2V0RGF0YShhcnJheU9mVW5pZm9ybU9iamVjdHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXJJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaW5kZXgubGVuZ3RoID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VJbmRleGVkLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7ZmlsdGVyUHJlZGljYXRlfSBwcmVkaWNhdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119XG4gICAgICovXG4gICAgYnVpbGRJbmRleDogZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICAgIHZhciByb3dDb3VudCA9IHRoaXMuZGF0YVNvdXJjZS5nZXRSb3dDb3VudCgpLFxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xuXG4gICAgICAgIHRoaXMuY2xlYXJJbmRleCgpO1xuXG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcm93Q291bnQ7IHIrKykge1xuICAgICAgICAgICAgaWYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlLmNhbGwodGhpcywgciwgdGhpcy5kYXRhU291cmNlLmdldFJvdyhyKSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleC5wdXNoKHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn0pO1xuXG4vKiogQHR5cGVkZWYge2Z1bmN0aW9ufSBmaWx0ZXJQcmVkaWNhdGVcbiAqIEBzdW1tYXJ5IEFwcGxpZXMgZmlsdGVyIHRvIGdpdmVuIHJvdy5cbiAqIEBwYXJhbSB7bnVibWVyfSByIC0gUm93IGluZGV4IG9mIHJvdyBkYXRhIHdpdGhpbiByb3dzIGFycmF5IGB0aGlzLmRhdGFTb3VyY2UuZGF0YVtdYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSByb3dPYmplY3QgLSBSb3cgZGF0YTsgZWxlbWVudCBvZiBgdGhpcy5kYXRhU291cmNlLmRhdGFbXWAuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUm93IHF1YWxpZmllcyAocGFzc2VzIHRocm91Z2ggZmlsdGVyKS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VJbmRleGVkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0YVNvdXJjZUluZGV4ZWQgPSByZXF1aXJlKCcuL0RhdGFTb3VyY2VJbmRleGVkJyk7XG52YXIgc3RhYmxlU29ydCA9IHJlcXVpcmUoJy4vdXRpbC9zdGFibGVTb3J0Jyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhU291cmNlSW5kZXhlZFxuICovXG52YXIgRGF0YVNvdXJjZVNvcnRlciA9IERhdGFTb3VyY2VJbmRleGVkLmV4dGVuZCgnRGF0YVNvdXJjZVNvcnRlcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXIucHJvdG90eXBlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXNjZW5kaW5nU29ydCA9IGZhbHNlOyAvLyBUT0RPOiB0aGlzIGRvZXMgbm90IHNlZW0gdG8gYmUgaW4gdXNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJZHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RpcmVjdGlvbj0xXVxuICAgICAqL1xuICAgIHNvcnRPbjogZnVuY3Rpb24oY29sSWR4LCBkaXJlY3Rpb24pIHtcbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFySW5kZXgoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpczsgLy8gZm9yIHVzZSBpbiBnZXRWYWx1ZVxuICAgICAgICAgICAgICAgIHN0YWJsZVNvcnQuc29ydCh0aGlzLmJ1aWxkSW5kZXgoKSwgZ2V0VmFsdWUsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRWYWx1ZShyb3dJZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxPckZ1bmNDYWxsKHNlbGYuZGF0YVNvdXJjZS5nZXRWYWx1ZShjb2xJZHgsIHJvd0lkeCkpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7KnxmdW5jdGlvbn0gdmFsT3JGdW5jXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gdmFsT3JGdW5jQ2FsbCh2YWxPckZ1bmMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbE9yRnVuYyA9PT0gJ2Z1bmN0aW9uJyA/IHZhbE9yRnVuYygpIDogdmFsT3JGdW5jO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VTb3J0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcbnZhciBEYXRhU291cmNlU29ydGVyID0gcmVxdWlyZSgnLi9EYXRhU291cmNlU29ydGVyJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhU291cmNlSW5kZXhlZFxuICovXG52YXIgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSA9IERhdGFTb3VyY2VJbmRleGVkLmV4dGVuZCgnRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZScsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2F2ZWF0czpcbiAgICAgICAgICpcbiAgICAgICAgICogMS4gQ29sdW1ucyBzaG91bGQgYmUgdW5pcXVlbHkgcmVwcmVzZW50ZWQgKGkuZS4sIG5vIHJlcGVhdHMgd2l0aCBzYW1lIGNvbHVtbkluZGV4KVxuICAgICAgICAgKiAyLiBDb2x1bW5zIHNob3VsZCBiZSBhZGRlZCBsb3ctIHRvIGhpZ2gtb3JkZXIgKGkuZS4sIG1vc3QgZ3JvdXBlZCBjb2x1bW5zIGNvbWUgbGFzdClcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge251bWJlcltdfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc29ydHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0RhdGFTb3VyY2V9XG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0ID0gdGhpcy5kYXRhU291cmNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3QuZ2V0Um93KHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gY29sdW1uSW5kZXhcbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uXG4gICAgICovXG4gICAgc29ydE9uOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuc29ydHMucHVzaChbY29sdW1uSW5kZXgsIGRpcmVjdGlvbl0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhcHBseTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlYWNoID0gdGhpcy5kYXRhU291cmNlO1xuXG4gICAgICAgIHRoaXMuc29ydHMuZm9yRWFjaChmdW5jdGlvbihzb3J0KSB7XG4gICAgICAgICAgICBlYWNoID0gbmV3IERhdGFTb3VyY2VTb3J0ZXIoZWFjaCk7XG4gICAgICAgICAgICBlYWNoLnNvcnRPbi5hcHBseShlYWNoLCBzb3J0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5sYXN0ID0gZWFjaDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXJTb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc29ydHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5sYXN0ID0gdGhpcy5kYXRhU291cmNlO1xuICAgIH0sXG5cbiAgICBnZXREYXRhSW5kZXg6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdC5nZXREYXRhSW5kZXgoeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0LmdldFZhbHVlKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmxhc3Quc2V0VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgIH1cbn0pO1xuXG5EYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZS5hcHBseVNvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgKGNvbnNvbGUud2FybiB8fCBjb25zb2xlLmxvZykuY2FsbChjb25zb2xlLCAnYXBwbHlTb3J0cyBkZXByZWNhdGVkOyB1c2UgYXBwbHknKTtcbiAgICB0aGlzLmFwcGx5KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGU7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcblxudmFyIGV4cGFuZGVkTWFwID0ge1xuICAgIHRydWU6ICdcXHUyNWJjICcsIC8vIEJMQUNLIERPV04tUE9JTlRJTkcgVFJJQU5HTEUgYWthICfilrwnXG4gICAgZmFsc2U6ICdcXHUyNWI2ICcsIC8vIEJMQUNLIFJJR0hULVBPSU5USU5HIFRSSUFOR0xFIGFrYSAn4pa2J1xuICAgIHVuZGVmaW5lZDogJyAgJyAvLyBmb3IgbGVhZiByb3dzXG59O1xuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhU291cmNlSW5kZXhlZFxuICovXG52YXIgRGF0YVNvdXJjZVRyZWV2aWV3ID0gRGF0YVNvdXJjZUluZGV4ZWQuZXh0ZW5kKCdEYXRhU291cmNlVHJlZXZpZXcnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUdXJucyB0cmVlIHZpZXcgKipvbioqLlxuICAgICAqIEBkZXNjIENhbGN1bGF0ZXMgb3IgcmVjYWxjdWxhdGVzIG5lc3RpbmcgZGVwdGggb2YgZWFjaCByb3cgYW5kIG1hcmtzIGl0IGFzIGV4cGFuZGFibGUgaWYgaXQgaGFzIGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogSWYgcmVzZXR0aW5nIHByZXZpb3VzbHkgc2V0IGRhdGEsIHRoZSBzdGF0ZSBvZiBleHBhbnNpb24gb2YgYWxsIHJvd3MgdGhhdCBzdGlsbCBoYXZlIGNoaWxkcmVuIGlzIHJldGFpbmVkLlxuICAgICAqXG4gICAgICogQWxsIHRocmVlIG5hbWVkIGNvbHVtbnMgbXVzdCBleGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxvYmplY3R9IFtvcHRpb25zXSAtIElmIGZhbHN5IChvciBvbWl0dGVkKSwgdHVybnMgdHJlZSB2aWV3ICoqb2ZmKiouXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLklEPSdJRCddIC0gQ29sdW1uIG5hbWUgb2YgdGhlIHByaW1hcnkga2V5IGNvbHVtbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGFyZW50SUQ9J3BhcmVudElEJ10gLSBDb2x1bW4gbmFtZSBvZiB0aGUgZm9yZWlnbiBrZXkgY29sdW1uIGZvciBncm91cGluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZHJpbGxkb3duPSduYW1lJ10gLSBDb2x1bW4gbmFtZSBvZiB0aGUgZHJpbGxkb3duIGNvbHVtbiB0byBkZWNvcmF0ZS5cbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRSZWxhdGlvbjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgaWRDb2x1bW5OYW1lLCBwYXJlbnRJZENvbHVtbk5hbWUsIHRyZWVDb2x1bW5OYW1lLCBmaWVsZHMsXG4gICAgICAgICAgICByb3dDb3VudCwgciwgcGFyZW50SUQsIGRlcHRoLCBsZWFmUm93LCByb3csIElEO1xuXG4gICAgICAgIHRoaXMudHJlZUNvbHVtbkluZGV4ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBmaWVsZHMgPSB0aGlzLmdldEZpZWxkcygpO1xuICAgICAgICAgICAgaWRDb2x1bW5OYW1lID0gb3B0aW9ucy5pZENvbHVtbk5hbWUgfHwgJ0lEJztcbiAgICAgICAgICAgIHBhcmVudElkQ29sdW1uTmFtZSA9IG9wdGlvbnMucGFyZW50SWRDb2x1bW5OYW1lIHx8ICdwYXJlbnRJRCc7XG4gICAgICAgICAgICB0cmVlQ29sdW1uTmFtZSA9IG9wdGlvbnMudHJlZUNvbHVtbk5hbWUgfHwgJ25hbWUnO1xuXG4gICAgICAgICAgICBpZiAoIC8vIGFsbCB0aHJlZSBjb2x1bW5zIG11c3QgZXhpc3RcbiAgICAgICAgICAgICAgICBmaWVsZHMuaW5kZXhPZihpZENvbHVtbk5hbWUpID49IDAgJiZcbiAgICAgICAgICAgICAgICBmaWVsZHMuaW5kZXhPZihwYXJlbnRJZENvbHVtbk5hbWUpID49IDAgJiZcbiAgICAgICAgICAgICAgICBmaWVsZHMuaW5kZXhPZih0cmVlQ29sdW1uTmFtZSkgPj0gMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZENvbHVtbk5hbWUgPSBpZENvbHVtbk5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRJZENvbHVtbk5hbWUgPSBwYXJlbnRJZENvbHVtbk5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uSW5kZXggPSBmaWVsZHMuaW5kZXhPZih0cmVlQ29sdW1uTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50cmVlQ29sdW1uSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gbXV0YXRlIGRhdGEgcm93IHdpdGggX19ERVBUSCBhbmQgX19FWFBBTkRFRFxuICAgICAgICAgICAgcm93Q291bnQgPSB0aGlzLmdldFJvd0NvdW50KCk7XG4gICAgICAgICAgICByID0gcm93Q291bnQ7XG4gICAgICAgICAgICB3aGlsZSAoci0tKSB7XG4gICAgICAgICAgICAgICAgZGVwdGggPSAtMTtcbiAgICAgICAgICAgICAgICBsZWFmUm93ID0gdGhpcy5nZXRSb3cocik7XG4gICAgICAgICAgICAgICAgcm93ID0gbGVhZlJvdztcbiAgICAgICAgICAgICAgICBJRCA9IHJvd1tpZENvbHVtbk5hbWVdO1xuXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJRCA9IHJvd1twYXJlbnRJZENvbHVtbk5hbWVdO1xuICAgICAgICAgICAgICAgICAgICByb3cgPSB0aGlzLmZpbmRSb3coaWRDb2x1bW5OYW1lLCBwYXJlbnRJRCk7XG4gICAgICAgICAgICAgICAgICAgICsrZGVwdGg7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocGFyZW50SUQgIT0gdW5kZWZpbmVkKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcblxuICAgICAgICAgICAgICAgIGxlYWZSb3cuX19ERVBUSCA9IGRlcHRoO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZpbmRSb3cocGFyZW50SWRDb2x1bW5OYW1lLCBJRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxlYWZSb3cuX19FWFBBTkRFRDsgLy8gbm8gbG9uZ2VyIGV4cGFuZGFibGVcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlYWZSb3cuX19FWFBBTkRFRCA9PT0gdW5kZWZpbmVkKSB7IC8vIHJldGFpbiBwcmV2aW91cyBzZXR0aW5nIGZvciBvbGQgcm93c1xuICAgICAgICAgICAgICAgICAgICBsZWFmUm93Ll9fRVhQQU5ERUQgPSBmYWxzZTsgLy8gZGVmYXVsdCBmb3IgbmV3IHJvdyBpcyB1bmV4cGFuZGVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZUNvbHVtbkluZGV4O1xuICAgIH0sXG5cbiAgICBhcHBseTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYnVpbGRJbmRleCh0aGlzLnRyZWVDb2x1bW5JbmRleCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29sbGFwc2VSb3dzKTtcbiAgICB9LFxuXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gRGF0YVNvdXJjZUluZGV4ZWQucHJvdG90eXBlLmdldFZhbHVlLmNhbGwodGhpcywgeCwgeSk7XG5cbiAgICAgICAgaWYgKHggPT09IHRoaXMudHJlZUNvbHVtbkluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gdGhpcy5nZXRSb3coeSksXG4gICAgICAgICAgICAgICAgcHJlZml4ID0gQXJyYXkocm93Ll9fREVQVEggKyAxKS5qb2luKCcgICAgJykgKyBleHBhbmRlZE1hcFtyb3cuX19FWFBBTkRFRF07XG4gICAgICAgICAgICB2YWx1ZSA9IHByZWZpeCArIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBjbGljazogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgZXhwYW5kYWJsZSwgcm93ID0gdGhpcy5nZXRSb3coeSk7XG4gICAgICAgIGlmICgoZXhwYW5kYWJsZSA9IHJvdy5fX0VYUEFOREVEICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByb3cuX19FWFBBTkRFRCA9ICFyb3cuX19FWFBBTkRFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwYW5kYWJsZTtcbiAgICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBjb2xsYXBzZVJvd3Mociwgcm93KSB7XG4gICAgdmFyIHBhcmVudElEO1xuICAgIHdoaWxlICgocGFyZW50SUQgPSByb3dbdGhpcy5wYXJlbnRJZENvbHVtbk5hbWVdKSAhPSB1bmRlZmluZWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgcm93ID0gdGhpcy5maW5kUm93KHRoaXMuaWRDb2x1bW5OYW1lLCBwYXJlbnRJRCk7XG4gICAgICAgIGlmIChyb3cuX19FWFBBTkRFRCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlVHJlZXZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hcHB5KCkge1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIHRoaXMudmFsdWVzID0gW107XG59XG5cbk1hcHB5LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBNYXBweS5wcm90b3R5cGUuY29uc3RydWN0b3IsIC8vIHByZXNlcnZlIGNvbnN0cnVjdG9yXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgTWFwcHkucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgaGFzaENvZGUgPSBoYXNoKGtleSk7XG4gICAgICAgIGlmICghKGhhc2hDb2RlIGluIHRoaXMuZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFbaGFzaENvZGVdID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBNYXBweS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGhhc2hDb2RlID0gaGFzaChrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2hhc2hDb2RlXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgTWFwcHkucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGlmVW5kZWZpbmVkRnVuYyAtIFZhbHVlIGdldHRlciB3aGVuIHZhbHVlIGlzIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0SWZVbmRlZmluZWQ6IGZ1bmN0aW9uKGtleSwgaWZVbmRlZmluZWRGdW5jKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGlmVW5kZWZpbmVkRnVuYyhrZXkpO1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cy5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBNYXBweS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMua2V5cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnZhbHVlcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE1hcHB5LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKi9cbiAgICBkZWxldGU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgaGFzaENvZGUgPSBoYXNoKGtleSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFbaGFzaENvZGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGJldHRlckluZGV4T2YodGhpcy5rZXlzLCBrZXkpO1xuICAgICAgICAgICAgdGhpcy5rZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtoYXNoQ29kZV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE1hcHB5LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlXG4gICAgICovXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRlZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXMsXG4gICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VsZi5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpdGVyYXRlZSh2YWx1ZSwga2V5LCBzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBNYXBweS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZVxuICAgICAqIEByZXR1cm5zIHtNYXBweX1cbiAgICAgKi9cbiAgICBtYXA6IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzLFxuICAgICAgICAgICAgbmV3TWFwID0gbmV3IE1hcHB5KCksXG4gICAgICAgICAgICBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAoISh0eXBlb2YgaXRlcmF0ZWUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICBpdGVyYXRlZSA9IHJlZmxlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLmdldChrZXkpLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgc2VsZik7XG4gICAgICAgICAgICBuZXdNYXAuc2V0KGtleSwgdHJhbnNmb3JtZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld01hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE1hcHB5LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtNYXBweX1cbiAgICAgKi9cbiAgICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXMsXG4gICAgICAgICAgICBuZXdNYXAgPSBuZXcgTWFwcHkoKSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLmdldChrZXkpO1xuICAgICAgICAgICAgbmV3TWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdNYXA7XG4gICAgfVxuXG59O1xuXG52YXIgT0lEX1BSRUZJWCA9ICcufi4jJV8nOyAvL3RoaXMgc2hvdWxkIGJlIHNvbWV0aGluZyB3ZSBuZXZlciB3aWxsIHNlZSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgc3RyaW5nXG52YXIgY291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGhhc2goa2V5KSB7XG4gICAgdmFyIHR5cGVPZiA9IHR5cGVvZiBrZXk7XG5cbiAgICBzd2l0Y2ggKHR5cGVPZikge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIHJldHVybiBPSURfUFJFRklYICsgdHlwZU9mICsgJ18nICsga2V5O1xuXG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICByZXR1cm4gJ1VOREVGSU5FRCc7XG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05VTEwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoIHdoZW4gbm90IG51bGw6XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiAoa2V5Ll9fX2Zpbmhhc2ggPSBrZXkuX19fZmluaGFzaCB8fCBPSURfUFJFRklYICsgY291bnRlcisrKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgIH1cbn1cblxuLy8gT2JqZWN0LmlzIHBvbHlmaWxsLCBjb3VydGVzeSBvZiBAV2ViUmVmbGVjdGlvblxudmFyIGlzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYiA/IGEgIT09IDAgfHwgMSAvIGEgPT0gMSAvIGIgOiBhICE9IGEgJiYgYiAhPSBiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxufTtcblxuZnVuY3Rpb24gcmVmbGVjdGlvbih2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xufVxuXG4vLyBNb3JlIHJlbGlhYmxlIGluZGV4T2YsIGNvdXJ0ZXN5IG9mIEBXZWJSZWZsZWN0aW9uXG5mdW5jdGlvbiBiZXR0ZXJJbmRleE9mKGFyciwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IDApIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tICYmICFpcyhhcnJbaV0sIHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaSA9IFtdLmluZGV4T2YuY2FsbChhcnIsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwcHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG1vZHVsZSBhZ2dyZWdhdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gYWdncmVnYXRpb25GdW5jdGlvblxuICogQHN1bW1hcnkgQSBib3VuZCBmdW5jdGlvbi5cbiAqIEBkZXNjIEFuIGFnZ3JlZ2F0aW9uIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBgY29sdW1uSW5kZXhgIHZhbHVlIHN1cHBsaWVkIHRvIG9uZSBvZiB0aGUgYWJvdmUgZmFjdG9yeSBmdW5jdGlvbnMuXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JvdXBcbiAqIEByZXR1cm5zIHsqfSBBZ2dyZWdhdGVkIHZhbHVlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqIEByZXR1cm5zIHthZ2dyZWdhdGlvbkZ1bmN0aW9ufSBCb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjb3VudDogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7YWdncmVnYXRpb25GdW5jdGlvbn0gQm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3VtOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gc3VtLmJpbmQodGhpcywgY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7YWdncmVnYXRpb25GdW5jdGlvbn0gQm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbWluOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gbWlubWF4LmJpbmQodGhpcywgY29sdW1uSW5kZXgsIE1hdGgubWluLCBJbmZpbml0eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqIEByZXR1cm5zIHthZ2dyZWdhdGlvbkZ1bmN0aW9ufSBCb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBtYXg6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBtaW5tYXguYmluZCh0aGlzLCBjb2x1bW5JbmRleCwgTWF0aC5tYXgsIC1JbmZpbml0eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqIEByZXR1cm5zIHthZ2dyZWdhdGlvbkZ1bmN0aW9ufSBCb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBhdmc6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBhdmcuYmluZCh0aGlzLCBjb2x1bW5JbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqIEByZXR1cm5zIHthZ2dyZWdhdGlvbkZ1bmN0aW9ufSBCb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmaXJzdDogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0LmJpbmQodGhpcywgY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7YWdncmVnYXRpb25GdW5jdGlvbn0gQm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbGFzdDogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxhc3QuYmluZCh0aGlzLCBjb2x1bW5JbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqIEByZXR1cm5zIHthZ2dyZWdhdGlvbkZ1bmN0aW9ufSBCb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGRkZXY6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBzdGRkZXYuYmluZCh0aGlzLCBjb2x1bW5JbmRleCk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gY291bnQoZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXAuZ2V0Um93Q291bnQoKTtcbn1cblxuZnVuY3Rpb24gc3VtKGNvbHVtbkluZGV4LCBncm91cCkge1xuICAgIHZhciByID0gZ3JvdXAuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgbiA9IDA7XG5cbiAgICB3aGlsZSAoci0tKSB7XG4gICAgICAgIG4gKz0gZ3JvdXAuZ2V0VmFsdWUoY29sdW1uSW5kZXgsIHIpO1xuICAgIH1cblxuICAgIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBtaW5tYXgoY29sdW1uSW5kZXgsIG1ldGhvZCwgbiwgZ3JvdXApIHtcbiAgICB2YXIgciA9IGdyb3VwLmdldFJvd0NvdW50KCk7XG5cbiAgICB3aGlsZSAoci0tKSB7XG4gICAgICAgIG4gPSBtZXRob2QobiwgZ3JvdXAuZ2V0VmFsdWUoY29sdW1uSW5kZXgsIHIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gYXZnKGNvbHVtbkluZGV4LCBncm91cCkge1xuICAgIHJldHVybiBzdW0oY29sdW1uSW5kZXgsIGdyb3VwKSAvIGdyb3VwLmdldFJvd0NvdW50KCk7XG59XG5cbmZ1bmN0aW9uIGZpcnN0KGNvbHVtbkluZGV4LCBncm91cCkge1xuICAgIHJldHVybiBncm91cC5nZXRWYWx1ZShjb2x1bW5JbmRleCwgMCk7XG59XG5cbmZ1bmN0aW9uIGxhc3QoY29sdW1uSW5kZXgsIGdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwLmdldFZhbHVlKGNvbHVtbkluZGV4LCBncm91cC5nZXRSb3dDb3VudCgpIC0gMSk7XG59XG5cbmZ1bmN0aW9uIHN0ZGRldihjb2x1bW5JbmRleCwgZ3JvdXApIHtcbiAgICB2YXIgcm93cyA9IGdyb3VwLmdldFJvd0NvdW50KCksXG4gICAgICAgIG1lYW4gPSBhdmcoY29sdW1uSW5kZXgsIGdyb3VwKTtcblxuICAgIGZvciAodmFyIGRldiwgciA9IHJvd3MsIHZhcmlhbmNlID0gMDsgci0tOyB2YXJpYW5jZSArPSBkZXYgKiBkZXYpIHtcbiAgICAgICAgZGV2ID0gZ3JvdXAuZ2V0VmFsdWUoY29sdW1uSW5kZXgsIHIpIC0gbWVhbjtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHZhcmlhbmNlIC8gcm93cyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5PVEU6IEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYGNhcGl0YWxpemVgIGlzIHN0aWxsIGEgZnVuY3Rpb24sIGRvdWJsaW5nIG5vdyBhcyB0aGUgQVBJLlxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgIHJldHVybiAoL1thLXpdLy50ZXN0KHN0cmluZykgPyBzdHJpbmcgOiBzdHJpbmcudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgLnJlcGxhY2UoL1tcXHNcXC1fXSooW15cXHNcXC1fXSkoW15cXHNcXC1fXSspL2csIHJlcGxhY2VyKVxuICAgICAgICAucmVwbGFjZSgvW0EtWl0vZywgJyAkJicpXG4gICAgICAgIC50cmltKCk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VyKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gYi50b1VwcGVyQ2FzZSgpICsgYztcbn1cblxuZnVuY3Rpb24gc2V0KG1ldGhvZE5hbWUpIHtcbiAgICBjYXBpdGFsaXplLnRyYW5zZm9ybSA9IGNhcGl0YWxpemVbbWV0aG9kTmFtZV07XG59XG5cbmZ1bmN0aW9uIHBhc3N0aHJvdWdoKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmc7XG59XG5cbmNhcGl0YWxpemUudHJhbnNmb3JtID0gcGFzc3Rocm91Z2g7XG5jYXBpdGFsaXplLnNldCA9IHNldDtcbmNhcGl0YWxpemUucGFzc3Rocm91Z2ggPSBwYXNzdGhyb3VnaDtcbmNhcGl0YWxpemUuY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG5cbm1vZHVsZS5leHBvcnRzID0gY2FwaXRhbGl6ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBOb3RlIHRoYXQge0BsaW5rIG1vZHVsZTpzdGFibGVTb3J0I3NvcnR8c29ydCgpfSBpcyB0aGUgb25seSBleHBvc2VkIG1ldGhvZC5cbiAqIEBtb2R1bGUgc3RhYmxlU29ydFxuICovXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogQHBhcmFtIHtib29sZWFufSBkZXNjZW5kaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIxXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIyXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHN0YWJpbGl6ZShjb21wYXJhdG9yLCBkZXNjZW5kaW5nLCBhcnIxLCBhcnIyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2hhZG93XG4gICAgdmFyIHggPSBhcnIxWzBdO1xuICAgIHZhciB5ID0gYXJyMlswXTtcblxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgIHggPSBkZXNjZW5kaW5nID8gYXJyMlsxXSA6IGFycjFbMV07XG4gICAgICAgIHkgPSBkZXNjZW5kaW5nID8gYXJyMVsxXSA6IGFycjJbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29tcGFyYXRvcih4LCB5KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGFzY2VuZGluZ051bWJlcnMoeCwgeSkge1xuICAgIHJldHVybiB4IC0geTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGRlc2NlbmRpbmdOdW1iZXJzKHgsIHkpIHtcbiAgICByZXR1cm4geSAtIHg7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHhcbiAqIEBwYXJhbSB5XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBhc2NlbmRpbmdBbGxPdGhlcnMoeCwgeSkge1xuICAgIHJldHVybiB4IDwgeSA/IC0xIDogMTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGRlc2NlbmRpbmdBbGxPdGhlcnMoeCwgeSkge1xuICAgIHJldHVybiB5IDwgeCA/IC0xIDogMTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0gdHlwZU9mRGF0YVxuICogQHJldHVybnMge2Z1bmN0aW9uKHRoaXM6YXNjZW5kaW5nKX1cbiAqL1xuZnVuY3Rpb24gYXNjZW5kaW5nKHR5cGVPZkRhdGEpIHtcbiAgICByZXR1cm4gc3RhYmlsaXplLmJpbmQodGhpcywgdHlwZU9mRGF0YSA9PT0gJ251bWJlcicgPyBhc2NlbmRpbmdOdW1iZXJzIDogYXNjZW5kaW5nQWxsT3RoZXJzLCBmYWxzZSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHR5cGVPZkRhdGFcbiAqIEByZXR1cm5zIHtmdW5jdGlvbih0aGlzOmRlc2NlbmRpbmcpfVxuICovXG5mdW5jdGlvbiBkZXNjZW5kaW5nKHR5cGVPZkRhdGEpIHtcbiAgICByZXR1cm4gc3RhYmlsaXplLmJpbmQodGhpcywgdHlwZU9mRGF0YSA9PT0gJ251bWJlcicgPyBkZXNjZW5kaW5nTnVtYmVycyA6IGRlc2NlbmRpbmdBbGxPdGhlcnMsIHRydWUpO1xufVxuXG4vKipcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRWYWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtkaXJlY3Rpb249MV1cbiAqL1xuZnVuY3Rpb24gc29ydChpbmRleCwgZ2V0VmFsdWUsIGRpcmVjdGlvbikge1xuXG4gICAgdmFyIGNvbXBhcmUsIGk7XG5cbiAgICAvLyBhcHBseSBkZWZhdWx0c1xuICAgIGlmIChkaXJlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaXJlY3Rpb24gPSAxO1xuICAgIH1cblxuICAgIGlmIChpbmRleC5sZW5ndGgpIHsgLy8gc29tZXRoaW5nIHRvIGRvXG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBiYWlsOiBub3RoaW5nIHRvIHNvcnRcblxuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgY2FzZSAxOiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNvbXBhcmUgPSBhc2NlbmRpbmcodHlwZW9mIGdldFZhbHVlKDApKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgICBjb21wYXJlID0gZGVzY2VuZGluZyh0eXBlb2YgZ2V0VmFsdWUoMCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHVwIHRoZSBzb3J0Li4uLi5cbiAgICAgICAgdmFyIHRtcCA9IG5ldyBBcnJheShpbmRleC5sZW5ndGgpO1xuXG4gICAgICAgIC8vIGFkZCB0aGUgaW5kZXggZm9yIFwic3RhYmlsaXR5XCJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGluZGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0bXBbaV0gPSBbZ2V0VmFsdWUoaSksIGldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG8gdGhlIGFjdHVhbCBzb3J0XG4gICAgICAgIHRtcC5zb3J0KGNvbXBhcmUpO1xuXG4gICAgICAgIC8vIGNvcHkgdGhlIHNvcnRlZCB2YWx1ZXMgaW50byBvdXIgaW5kZXggdmVjdG9yXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW5kZXhbaV0gPSB0bXBbaV1bMV07XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0cy5zb3J0ID0gc29ydDtcbiIsIi8vIGxpc3QtZHJhZ29uIG5vZGUgbW9kdWxlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L2xpc3QtZHJhZ29uXG5cbi8qIGVzbGludC1lbnYgbm9kZSwgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjc3NJbmplY3RvciA9IHJlcXVpcmUoJ2Nzcy1pbmplY3RvcicpO1xudmFyIGZvcm1hdCA9IHJlcXVpcmUoJ3RlbXBsZXgnKTtcblxudmFyIFJFVkVSVF9UT19TVFlMRVNIRUVUX1ZBTFVFID0gbnVsbDsgIC8vIG51bGwgcmVtb3ZlcyB0aGUgc3R5bGVcblxudmFyIHRyYW5zZm9ybSwgdGltZXIsIHNjcm9sbFZlbG9jaXR5LCBjc3NMaXN0RHJhZ29uO1xuXG4vKiBpbmplY3Q6Y3NzICovXG5jc3NMaXN0RHJhZ29uID0gJ2Rpdi5kcmFnb24tbGlzdHtwb3NpdGlvbjpyZWxhdGl2ZTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9ZGl2LmRyYWdvbi1saXN0PmRpdixkaXYuZHJhZ29uLWxpc3Q+dWx7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3JpZ2h0OjB9ZGl2LmRyYWdvbi1saXN0PmRpdnt0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiMwMDc5NmI7Y29sb3I6I2ZmZjtib3gtc2hhZG93OjAgM3B4IDZweCByZ2JhKDAsMCwwLC4xNiksMCAzcHggNnB4IHJnYmEoMCwwLDAsLjIzKTtvdmVyZmxvdzpoaWRkZW47d2hpdGUtc3BhY2U6bm93cmFwfWRpdi5kcmFnb24tbGlzdD51bHtvdmVyZmxvdy15OmF1dG87Ym90dG9tOjA7bWFyZ2luOjA7cGFkZGluZzowO2JveC1zaGFkb3c6MCAxcHggM3B4IHJnYmEoMCwwLDAsLjEyKSwwIDFweCAycHggcmdiYSgwLDAsMCwuMjQpfWRpdi5kcmFnb24tbGlzdD51bD5saSxsaS5kcmFnb24tcG9we3doaXRlLXNwYWNlOm5vd3JhcDtsaXN0LXN0eWxlLXR5cGU6bm9uZTtib3JkZXI6MCBzb2xpZCAjZjRmNGY0O2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNlMGUwZTA7Y3Vyc29yOm1vdmU7dHJhbnNpdGlvbjpib3JkZXItdG9wLXdpZHRoIC4yc31kaXYuZHJhZ29uLWxpc3Q+dWw+bGk6bGFzdC1jaGlsZHtoZWlnaHQ6MDtib3JkZXItYm90dG9tOm5vbmV9bGkuZHJhZ29uLXBvcHtwb3NpdGlvbjpmaXhlZDtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyOjFweCBzb2xpZCAjZTBlMGUwO2xlZnQ6MDt0b3A6MDtvdmVyZmxvdy14OmhpZGRlbjtib3gtc2hhZG93OnJnYmEoMCwwLDAsLjE4ODIzNSkgMCAxMHB4IDIwcHgscmdiYSgwLDAsMCwuMjI3NDUxKSAwIDZweCA2cHh9Jztcbi8qIGVuZGluamVjdCAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBMaXN0RHJhZ29uXG4gKlxuICogQGRlc2MgVGhpcyBvYmplY3Qgc2VydmljZXMgYSBzZXQgb2YgaXRlbSBsaXN0cyB0aGF0IGFsbG93IGRyYWdnaW5nIGFuZCBkcm9wcGluZyBpdGVtcyB3aXRoaW4gYW5kIGJldHdlZW4gbGlzdHMgaW4gYSBzZXQuXG4gKlxuICogVHdvIHN0cmF0ZWdpZXMgYXJlIHN1cHBvcnRlZDpcbiAqXG4gKiAxLiBTdXBwbHkgeW91ciBvd24gSFRNTCBtYXJrdXAgYW5kIGxldCB0aGUgQVBJIGJ1aWxkIHRoZSBpdGVtIG1vZGVscyBmb3IgeW91LlxuICogICAgVG8gdXNlIHRoaXMgc3RyYXRlZ3ksIHNjcmlwdCB5b3VyIEhUTUwgYW5kIHByb3ZpZGUgb25lIG9mIHRoZXNlOlxuICogICAgKiBhbiBhcnJheSBvZiBhbGwgdGhlIGxpc3QgaXRlbSAoYDxsaT5gKSB0YWdzXG4gKiAgICAqIGEgQ1NTIHNlbGVjdG9yIHRoYXQgcG9pbnRzIHRvIGFsbCB0aGUgbGlzdCBpdGVtIHRhZ3NcbiAqIDIuIFN1cHBseSB5b3VyIG93biBpdGVtIG1vZGVscyBhbmQgbGV0IHRoZSBBUEkgYnVpbGQgdGhlIEhUTUwgbWFya3VwIGZvciB5b3UuXG4gKiAgICBUbyB1c2UgdGhpcyBzdHJhdGVneSwgcHJvdmlkZSBhbiBhcnJheSBvZiBtb2RlbCBsaXN0cy5cbiAqXG4gKiBUaGUgbmV3IExpc3REcmFnb24gb2JqZWN0J3MgYG1vZGVsTGlzdHNgIHByb3BlcnR5IHJlZmVyZW5jZXMgdGhlIGFycmF5IG9mIG1vZGVsIGxpc3RzIHRoZSBBUEkgY29uc3RydWN0ZWQgZm9yIHlvdSBpbiBzdHJhdGVneSAjMSBvciB0aGUgYXJyYXkgb2YgbW9kZWwgbGlzdHMgeW91IHN1cHBsaWVkIGZvciBzdHJhdGVneSAjMi5cbiAqXG4gKiBBZnRlciB0aGUgdXNlciBwZXJmb3JtcyBhIHN1Y2Nlc3NmdWwgZHJhZy1hbmQtZHJvcCBvcGVyYXRpb24sIHRoZSBwb3NpdGlvbiBvZiB0aGUgbW9kZWwgcmVmZXJlbmNlcyB3aXRoaW4gdGhlIGBtb2RlbExpc3RzYCBhcnJheSBpcyByZWFycmFuZ2VkLiAoVGhlIG1vZGVscyB0aGVtc2VsdmVzIGFyZSB0aGUgb3JpZ2luYWwgb2JqZWN0cyBhcyBzdXBwbGllZCBpbiB0aGUgbW9kZWwgbGlzdHM7IHRoZXkgYXJlIG5vdCByZWJ1aWx0IG9yIGFsdGVyZWQgaW4gYW55IHdheS4gSnVzdCB0aGUgcmVmZXJlbmNlcyB0byB0aGVtIGFyZSBtb3ZlZCBhcm91bmQuKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnRbXXxtb2RlbExpc3RUeXBlW119IHNlbGVjdG9yT3JNb2RlbExpc3RzIC0gWW91IG11c3Qgc3VwcGx5IG9uZSBvZiB0aGUgaXRlbXMgaW4gKipib2xkKiogYmVsb3c6XG4gKlxuICogMS4gX0ZvciBzdHJhdGVneSAjMSBhYm92ZSAoQVBJIGNyZWF0ZXMgbW9kZWxzIGZyb20gc3VwcGxpZWQgZWxlbWVudHMpOl8gQWxsIHRoZSBsaXN0IGl0ZW0gKGA8bGk+YCkgRE9NIGVsZW1lbnRzIG9mIGFsbCB0aGUgbGlzdHMgeW91IHdhbnQgdGhlIG5ldyBvYmplY3QgdG8gbWFuYWdlLCBhcyBlaXRoZXI6XG4gKiAgICAxLiAqKkEgQ1NTIHNlbGVjdG9yOyoqIF9vcl9cbiAqICAgIDIuICoqQW4gYXJyYXkgb2YgRE9NIGVsZW1lbnRzKipcbiAqIDIuIF9Gb3Igc3RyYXRlZ3kgIzIgYWJvdmUgKEFQSSBjcmVhdGVzIGVsZW1lbnRzIGZyb20gc3VwcGxpZWQgbW9kZWxzKTpfICoqQW4gYXJyYXkgb2YgbW9kZWwgbGlzdHMsKiogZWFjaCBvZiB3aGljaCBpcyBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtczpcbiAqICAgIDEuIEFuIGFycmF5IG9mIGl0ZW0gbW9kZWxzICh3aXRoIHZhcmlvdXMgb3B0aW9uIHByb3BlcnRpZXMgaGFuZ2luZyBvZmYgb2YgaXQpOyBfYW5kL29yX1xuICogICAgMi4gQSB7QGxpbmsgbW9kZWxMaXN0VHlwZX0gb2JqZWN0IHdpdGggdGhvc2Ugc2FtZSB2YXJpb3VzIG9wdGlvbiBwcm9wZXJ0aWVzIGluY2x1ZGluZyB0aGUgcmVxdWlyZWQgYG1vZGVsc2AgcHJvcGVydHkgY29udGFpbmluZyB0aGF0IHNhbWUgYXJyYXkgb2YgaXRlbSBtb2RlbHMuXG4gKlxuICogSW4gZWl0aGVyIGNhc2UgKDIuMSBvciAyLjIpLCBlYWNoIGVsZW1lbnQgb2Ygc3VjaCBhcnJheXMgb2YgaXRlbSBtb2RlbHMgbWF5IHRha2UgdGhlIGZvcm0gb2Y6XG4gKiAqIEEgc3RyaW5nIHByaW1pdGl2ZTsgX29yX1xuICogKiBBIHtAbGluayBpdGVtTW9kZWxUeXBlfSBvYmplY3Qgd2l0aCBhIHZhcmlvdXMgb3B0aW9uIHByb3BlcnRpZXMgaW5jbHVkaW5nIHRoZSByZXF1aXJlZCBgbGFiZWxgIHByb3BlcnR5IGNvbnRhaW5pbmcgYSBzdHJpbmcgcHJpbWl0aXZlLlxuICpcbiAqIFJlZ2FyZGluZyB0aGVzZSBzdHJpbmcgcHJpbWl0aXZlcywgZWFjaCBpcyBlaXRoZXI6XG4gKiAqIEEgc3RyaW5nIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgbGlzdCBpdGVtOyBfb3JfXG4gKiAqIEEgZm9ybWF0IHN0cmluZyB3aXRoIG90aGVyIHByb3BlcnR5IHZhbHVlcyBtZXJnZWQgaW4sIHRoZSByZXN1bHQgb2Ygd2hpY2ggaXMgdG8gYmUgZGlzcGxheWVkIGluIHRoZSBsaXN0IGl0ZW0uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSAtIFlvdSBtYXkgc3VwcGx5IFwiZ2xvYmFsXCIgdGVtcGxhdGUgdmFyaWFibGVzIGhlcmUsIHJlcHJlc2VudGluZyB0aGUgXCJvdXRlciBzY29wZSxcIiBhZnRlciBmaXJzdCBzZWFyY2hpbmcgZWFjaCBtb2RlbCBhbmQgdGhlbiBlYWNoIG1vZGVsIGxpc3QuXG4gKiBAcGFyYW0ge3VuZGVmaW5lZHxudWxsfEVsZW1lbnR8c3RyaW5nfSBbY3NzU3R5bGVzaGVldFJlZmVyZW5jZUVsZW1lbnRdIC0gRGV0ZXJtaW5lcyB3aGVyZSB0byBpbnNlcnQgdGhlIHN0eWxlc2hlZXQuIChUaGlzIGlzIHRoZSBvbmx5IGZvcm1hbCBvcHRpb24uKSBQYXNzZWQgdG8gY3NzLWluamVjdG9yLCB0aGUgb3ZlcmxvYWRzIGFyZSAoZnJvbSBjc3MtaW5qZWN0b3IgZG9jcyk6XG4gKiAqIGB1bmRlZmluZWRgIHR5cGUgKG9yIG9taXR0ZWQpOiBpbmplY3RzIHN0eWxlc2hlZXQgYXQgdG9wIG9mIGA8aGVhZD4uLi48L2hlYWQ+YCBlbGVtZW50XG4gKiAqIGBudWxsYCB2YWx1ZTogaW5qZWN0cyBzdHlsZXNoZWV0IGF0IGJvdHRvbSBvZiBgPGhlYWQ+Li4uPC9oZWFkPmAgZWxlbWVudFxuICogKiBgRWxlbWVudGAgdHlwZTogaW5qZWN0cyBzdHlsZXNoZWV0IGltbWVkaWF0ZWx5IGJlZm9yZSBnaXZlbiBlbGVtZW50LCB3aGVyZXZlciBpdCBpcyBmb3VuZC5cbiAqICogYHN0cmluZ2AgdHlwZTogaW5qZWN0cyBzdHlsZXNoZWV0IGltbWVkaWF0ZWx5IGJlZm9yZSBnaXZlbiBmaXJzdCBlbGVtZW50IGZvdW5kIHRoYXQgbWF0Y2hlcyB0aGUgZ2l2ZW4gY3NzIHNlbGVjdG9yLlxuICovXG5mdW5jdGlvbiBMaXN0RHJhZ29uKHNlbGVjdG9yT3JNb2RlbExpc3RzLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGlzdERyYWdvbikpIHtcbiAgICAgICAgdGhyb3cgZXJyb3IoJ05vdCBjYWxsZWQgd2l0aCBcIm5ld1wiIGtleXdvcmQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzLCBtb2RlbExpc3RzLCBpdGVtcztcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHR5cGVvZiBzZWxlY3Rvck9yTW9kZWxMaXN0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaXRlbXMgPSB0b0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JPck1vZGVsTGlzdHMpKTtcbiAgICAgICAgbW9kZWxMaXN0cyA9IGNyZWF0ZU1vZGVsTGlzdHNGcm9tTGlzdEVsZW1lbnRzKGl0ZW1zKTtcbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yT3JNb2RlbExpc3RzWzBdIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICBpdGVtcyA9IHRvQXJyYXkoc2VsZWN0b3JPck1vZGVsTGlzdHMpO1xuICAgICAgICBtb2RlbExpc3RzID0gY3JlYXRlTW9kZWxMaXN0c0Zyb21MaXN0RWxlbWVudHMoaXRlbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBhcmFtIGlzIGFycmF5IG9mIG1vZGVsIGxpc3RzXG4gICAgICAgIC8vIGJ1aWxkIG5ldyA8dWw+IGVsZW1lbnQocykgZm9yIGVhY2ggbGlzdCBhbmQgcHV0IGluIGAubW9kZWxMaXN0c2A7XG4gICAgICAgIC8vIGZpbGwgYC5pdGVtc2AgYXJyYXkgd2l0aCA8bGk+IGVsZW1lbnRzIGZyb20gdGhlc2UgbmV3IDx1bD4gZWxlbWVudHNcbiAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgbW9kZWxMaXN0cyA9IGNyZWF0ZUxpc3RFbGVtZW50c0Zyb21Nb2RlbExpc3RzKHNlbGVjdG9yT3JNb2RlbExpc3RzLCBvcHRpb25zKTtcbiAgICAgICAgbW9kZWxMaXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdCh0b0FycmF5KGxpc3QuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaScpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGdyYWIgd2hlZWwgZXZlbnRzIGFuZCBkb24ndCBsZXQgJ2VtIGJ1YmJsZVxuICAgIG1vZGVsTGlzdHMuZm9yRWFjaChmdW5jdGlvbiAobW9kZWxMaXN0KSB7XG4gICAgICAgIG1vZGVsTGlzdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgY2FwdHVyZUV2ZW50KTtcbiAgICB9KTtcblxuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW1FbGVtZW50LCBpbmRleCkge1xuICAgICAgICB2YXIgaXRlbSA9IChpdGVtRWxlbWVudCAhPT0gaXRlbUVsZW1lbnQucGFyZW50RWxlbWVudC5sYXN0RWxlbWVudENoaWxkKVxuICAgICAgICAgICAgPyBzZWxmLmFkZEV2dChpdGVtRWxlbWVudCwgJ21vdXNlZG93bicsIGl0ZW1FbGVtZW50LCB0cnVlKVxuICAgICAgICAgICAgOiB7IGVsZW1lbnQ6IGl0ZW1FbGVtZW50IH07XG5cbiAgICAgICAgLyogYGl0ZW0ubW9kZWxgIG5vdCBjdXJyZW50bHkgbmVlZGVkIHNvIGNvbW1lbnRlZCBvdXQgaGVyZS5cbiAgICAgICAgICogKE9yaWdpbmFsbHkgdXNlZCBmb3IgcmVidWlsZGluZyBtb2RlbExpc3RzIGZvciBmaW5hbFxuICAgICAgICAgKiByZXBvcnRpbmcsIG1vZGVsTGlzdHMgYXJlIG5vdyBzcGxpY2VkIG9uIGV2ZXJ5IHN1Y2Nlc3NmdWxcbiAgICAgICAgICogZHJhZy1hbmQtZHJvcCBvcGVyYXRpb24gc28gdGhleSdyZSBhbHdheXMgdXAgdG8gZGF0ZS4pXG5cbiAgICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLml0ZW1Db29yZGluYXRlcyhpdGVtRWxlbWVudCk7XG4gICAgICAgICBpdGVtLm1vZGVsID0gdGhpcy5tb2RlbExpc3RzW29yaWdpbi5saXN0XS5tb2RlbHNbb3JpZ2luLml0ZW1dO1xuXG4gICAgICAgICAqL1xuXG4gICAgICAgIGl0ZW1zW2luZGV4XSA9IGl0ZW07XG4gICAgfSk7XG5cbiAgICB0cmFuc2Zvcm0gPSAndHJhbnNmb3JtJyBpbiBpdGVtc1swXS5lbGVtZW50LnN0eWxlXG4gICAgICAgID8gJ3RyYW5zZm9ybScgLy8gQ2hyb21lIDQ1IGFuZCBGaXJlZm94IDQwXG4gICAgICAgIDogJy13ZWJraXQtdHJhbnNmb3JtJzsgLy8gU2FmYXJpIDhcblxuICAgIC8vIHNldCB1cCB0aGUgbmV3IG9iamVjdFxuICAgIHRoaXMubW9kZWxMaXN0cyA9IG1vZGVsTGlzdHM7XG4gICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICB0aGlzLmNhbGxiYWNrID0ge307XG5cbiAgICBjc3NJbmplY3Rvcihjc3NMaXN0RHJhZ29uLCAnbGlzdC1kcmFnb24tYmFzZScsIG9wdGlvbnMuY3NzU3R5bGVzaGVldFJlZmVyZW5jZUVsZW1lbnQpO1xuXG59XG5cbkxpc3REcmFnb24ucHJvdG90eXBlID0ge1xuXG4gICAgYWRkRXZ0OiBmdW5jdGlvbiAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgZG9Ob3RCaW5kKSB7XG4gICAgICAgIHZhciBiaW5kaW5nID0ge1xuICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcnNbdHlwZV0uYmluZCh0YXJnZXQsIHRoaXMpLFxuICAgICAgICAgICAgZWxlbWVudDogbGlzdGVuZXIgfHwgd2luZG93XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFkb05vdEJpbmQpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbdHlwZV0gPSBiaW5kaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgYmluZGluZy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgYmluZGluZy5oYW5kbGVyKTtcblxuICAgICAgICByZXR1cm4gYmluZGluZztcbiAgICB9LFxuXG4gICAgcmVtb3ZlRXZ0OiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZ3NbdHlwZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW3R5cGVdO1xuICAgICAgICBiaW5kaW5nLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBiaW5kaW5nLmhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICByZW1vdmVBbGxFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyByZW1vdmUgZHJhZyAmIGRyb3AgZXZlbnRzIChtb3VzZW1vdmUsIG1vdXNldXAsIGFuZCB0cmFuc2l0aW9uZW5kKVxuICAgICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMuYmluZGluZ3MpIHtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5iaW5kaW5nc1t0eXBlXTtcbiAgICAgICAgICAgIGJpbmRpbmcuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGJpbmRpbmcuaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBtb3VzZWRvd24gZXZlbnRzIGZyb20gYWxsIGxpc3QgaXRlbXNcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5oYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGl0ZW0uaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB3aGVlbCBldmVudHMgb24gdGhlIGxpc3QgZWxlbWVudHNcbiAgICAgICAgdGhpcy5tb2RlbExpc3RzLmZvckVhY2goZnVuY3Rpb24gKG1vZGVsTGlzdCkge1xuICAgICAgICAgICAgbW9kZWxMaXN0LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBjYXB0dXJlRXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcG9pbnRJbkxpc3RSZWN0czogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsTGlzdHMuZmluZChmdW5jdGlvbiAobW9kZWxMaXN0KSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IG1vZGVsTGlzdC5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICByZWN0ID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6ICAgd2luZG93LnNjcm9sbFggKyByZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiAgICB3aW5kb3cuc2Nyb2xsWSArIHJlY3QudG9wLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAgd2luZG93LnNjcm9sbFggKyByZWN0LnJpZ2h0LFxuICAgICAgICAgICAgICAgIGJvdHRvbTogd2luZG93LnNjcm9sbFkgKyByZWN0LmJvdHRvbSxcbiAgICAgICAgICAgICAgICB3aWR0aDogIHJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbW9kZWxMaXN0LnJlY3QgPSByZWN0O1xuXG4gICAgICAgICAgICBpZiAocG9pbnRJblJlY3QocG9pbnQsIHJlY3QpKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxMaXN0LnJlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBmb3VuZFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBwb2ludEluSXRlbVJlY3RzOiBmdW5jdGlvbiAocG9pbnQsIGV4Y2VwdDEsIGV4Y2VwdDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBpdGVtLmVsZW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIGVsZW1lbnQgIT09IGV4Y2VwdDEgJiZcbiAgICAgICAgICAgICAgICBlbGVtZW50ICE9PSBleGNlcHQyICYmXG4gICAgICAgICAgICAgICAgcG9pbnRJblJlY3QocG9pbnQsIGl0ZW0ucmVjdClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBnZXQgcG9zaXRpb25zIG9mIGFsbCBsaXN0IGl0ZW1zIGluIHBhZ2UgY29vcmRzIChub3JtYWxpemVkIGZvciB3aW5kb3cgYW5kIGxpc3Qgc2Nyb2xsaW5nKVxuICAgIGdldEFsbEl0ZW1Cb3VuZGluZ1JlY3RzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtb2RlbExpc3RzID0gdGhpcy5tb2RlbExpc3RzLCBoZWlnaHQ7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgdmFyIGl0ZW1FbGVtZW50ID0gaXRlbS5lbGVtZW50LFxuICAgICAgICAgICAgICAgIGxpc3RFbGVtZW50ID0gaXRlbUVsZW1lbnQucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICBsaXN0ID0gbW9kZWxMaXN0cy5maW5kKGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBsaXN0LmVsZW1lbnQgPT09IGxpc3RFbGVtZW50OyB9KTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIG9taXR0ZWQ6IGRlZmF1bHQgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgIGxpc3QuaXNEcm9wVGFyZ2V0ID09PSB1bmRlZmluZWQgfHxcblxuICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uOiB1c2UgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICAgICAgdHlwZW9mIGxpc3QuaXNEcm9wVGFyZ2V0ID09PSAnZnVuY3Rpb24nICYmIGxpc3QuaXNEcm9wVGFyZ2V0KCkgfHxcblxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZTogdXNlIHRydXRoaW5lc3Mgb2YgZ2l2ZW4gdmFsdWVcbiAgICAgICAgICAgICAgICBsaXN0LmlzRHJvcFRhcmdldFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBpdGVtRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tID0gcmVjdC5ib3R0b207XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbUVsZW1lbnQgPT09IGxpc3RFbGVtZW50Lmxhc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tID0gbGlzdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm90dG9tIDwgcmVjdC50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IHJlY3QudG9wICsgKGhlaWdodCB8fCA1MCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAgIHdpbmRvdy5zY3JvbGxYICsgcmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogIHdpbmRvdy5zY3JvbGxYICsgcmVjdC5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAgICB3aW5kb3cuc2Nyb2xsWSArIHJlY3QudG9wICAgICsgbGlzdEVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgICAgICBib3R0b206IHdpbmRvdy5zY3JvbGxZICsgYm90dG9tICsgbGlzdEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ucmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZWluc2VydDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGU7XG4gICAgICAgIHN0eWxlLndpZHRoID0gc3R5bGVbdHJhbnNmb3JtXSA9IHN0eWxlLnRyYW5zaXRpb24gPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTtcblxuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZ29uLXBvcCcpO1xuXG4gICAgICAgIHRoaXMuZHJvcC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICAgICAgICB0aGlzLmRyb3Auc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTtcbiAgICAgICAgdGhpcy5kcm9wLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRhcmdldCwgdGhpcy5kcm9wKTtcblxuICAgICAgICBkZWxldGUgdGhpcy5kcm9wO1xuICAgIH0sXG5cbiAgICAvLyByZXR1cm4gYW4gb2JqZWN0IHsgaXRlbTogPGl0ZW0gaW5kZXggd2l0aGluIGxpc3Q+LCBsaXN0OiA8bGlzdCBpbmRleCB3aXRoaW4gbGlzdCBvZiBsaXN0cz4gfVxuICAgIGl0ZW1Db29yZGluYXRlczogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGxpc3RFbGVtZW50ID0gaXRlbS5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgY29vcmRzID0geyBpdGVtOiAwIH07XG5cbiAgICAgICAgd2hpbGUgKChpdGVtID0gaXRlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSkge1xuICAgICAgICAgICAgKytjb29yZHMuaXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9kZWxMaXN0cy5maW5kKGZ1bmN0aW9uIChsaXN0LCBpbmRleCkge1xuICAgICAgICAgICAgY29vcmRzLmxpc3QgPSBpbmRleDtcbiAgICAgICAgICAgIHJldHVybiBsaXN0LmVsZW1lbnQgPT09IGxpc3RFbGVtZW50OyAvLyBzdG9wIHdoZW4gd2UgZmluZCB0aGUgb25lIHdlIGJlbG9uZyB0b1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgIH1cblxufTtcblxudmFyIGhhbmRsZXJzID0ge1xuICAgIG1vdXNlZG93bjogZnVuY3Rpb24gKGRyYWdvbiwgZXZ0KSB7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsgIC8vcHJldmVudHMgdXNlciBzZWxlY3Rpb24gb2YgcmVuZGVyZWQgbm9kZXMgZHVyaW5nIGRyYWdcblxuICAgICAgICBpZiAoZHJhZ29uLmRyb3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBkcmFnb24ucmVjdCA9IHJlY3QgPSB7XG4gICAgICAgICAgICBsZWZ0OiAgIE1hdGgucm91bmQocmVjdC5sZWZ0IC0gMSksXG4gICAgICAgICAgICB0b3A6ICAgIE1hdGgucm91bmQocmVjdC50b3AgLSAxKSxcbiAgICAgICAgICAgIHJpZ2h0OiAgTWF0aC5yb3VuZChyZWN0LnJpZ2h0KSxcbiAgICAgICAgICAgIGJvdHRvbTogTWF0aC5yb3VuZChyZWN0LmJvdHRvbSksXG4gICAgICAgICAgICB3aWR0aDogIE1hdGgucm91bmQocmVjdC53aWR0aCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQocmVjdC5oZWlnaHQpXG4gICAgICAgIH07XG5cbiAgICAgICAgZHJhZ29uLnBpbiA9IHtcbiAgICAgICAgICAgIHg6IHdpbmRvdy5zY3JvbGxYICsgZXZ0LmNsaWVudFgsXG4gICAgICAgICAgICB5OiB3aW5kb3cuc2Nyb2xsWSArIGV2dC5jbGllbnRZXG4gICAgICAgIH07XG5cbiAgICAgICAgZHJhZ29uLm9yaWdpbiA9IGRyYWdvbi5pdGVtQ29vcmRpbmF0ZXModGhpcyk7XG5cbiAgICAgICAgaWYgKGRyYWdvbi5jYWxsYmFjay5ncmFiYmVkKSB7XG4gICAgICAgICAgICBkcmFnb24uY2FsbGJhY2suZ3JhYmJlZC5jYWxsKHRoaXMsIGRyYWdvbik7XG4gICAgICAgIH1cblxuICAgICAgICBkcmFnb24uZ2V0QWxsSXRlbUJvdW5kaW5nUmVjdHMoKTtcblxuICAgICAgICBkcmFnb24uZHJvcCA9IHRoaXMubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBkcmFnb24uZHJvcC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICAgICAgICBkcmFnb24uZHJvcC5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9IHJlY3QuaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICB0aGlzLnN0eWxlLndpZHRoID0gcmVjdC53aWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgICAgICAgdGhpcy5zdHlsZVt0cmFuc2Zvcm1dID0gdHJhbnNsYXRlKFxuICAgICAgICAgICAgcmVjdC5sZWZ0IC0gd2luZG93LnNjcm9sbFgsXG4gICAgICAgICAgICByZWN0LnRvcCAgLSB3aW5kb3cuc2Nyb2xsWVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2RyYWdvbi1wb3AnKTtcbiAgICAgICAgdGhpcy5zdHlsZS56SW5kZXggPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkcmFnb24ubW9kZWxMaXN0c1swXS5jb250YWluZXIucGFyZW50RWxlbWVudCkuekluZGV4O1xuXG4gICAgICAgIGlmICghZHJhZ29uLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgLy8gd2FsayBiYWNrIHRvIGNsb3Nlc3Qgc2hhZG93IHJvb3QgT1IgYm9keSB0YWcgT1Igcm9vdCB0YWdcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgU2hhZG93Um9vdCAhPT0gJ3VuZGVmaW5lZCcgJiYgY29udGFpbmVyIGluc3RhbmNlb2YgU2hhZG93Um9vdCB8fFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIudGFnTmFtZSA9PT0gJ0JPRFknXG4gICAgICAgICAgICAgICAgKXtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHJhZ29uLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRyYWdvbi5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcyk7XG5cbiAgICAgICAgcmVjdC5sZWZ0ICAgKz0gd2luZG93LnNjcm9sbFg7XG4gICAgICAgIHJlY3QudG9wICAgICs9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICByZWN0LnJpZ2h0ICArPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgcmVjdC5ib3R0b20gKz0gd2luZG93LnNjcm9sbFk7XG5cbiAgICAgICAgZHJhZ29uLmFkZEV2dCh0aGlzLCAnbW91c2Vtb3ZlJyk7XG4gICAgICAgIGRyYWdvbi5hZGRFdnQodGhpcywgJ21vdXNldXAnKTtcbiAgICB9LFxuXG4gICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZHJhZ29uLCBldnQpIHtcbiAgICAgICAgZHJhZ29uLmRyb3Auc3R5bGUudHJhbnNpdGlvbiA9IFJFVkVSVF9UT19TVFlMRVNIRUVUX1ZBTFVFO1xuXG4gICAgICAgIHZhciBob3Zlckxpc3QgPSBkcmFnb24ucG9pbnRJbkxpc3RSZWN0cyh7IHg6IGV2dC5jbGllbnRYLCB5OiBldnQuY2xpZW50WSB9KSB8fCBkcmFnb24ubW9zdFJlY2VudEhvdmVyTGlzdDtcblxuICAgICAgICBpZiAoaG92ZXJMaXN0KSB7XG4gICAgICAgICAgICB2YXIgZHggPSBldnQuY2xpZW50WCAtIGRyYWdvbi5waW4ueCxcbiAgICAgICAgICAgICAgICBkeSA9IGV2dC5jbGllbnRZIC0gZHJhZ29uLnBpbi55O1xuXG4gICAgICAgICAgICBkcmFnb24ubW9zdFJlY2VudEhvdmVyTGlzdCA9IGhvdmVyTGlzdDtcblxuICAgICAgICAgICAgdmFyIG1heFNjcm9sbFkgPSBob3Zlckxpc3QuZWxlbWVudC5zY3JvbGxIZWlnaHQgLSBob3Zlckxpc3QucmVjdC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgeSA9IGV2dC5jbGllbnRZICsgd2luZG93LnNjcm9sbFksXG4gICAgICAgICAgICAgICAgbWFnbml0dWRlO1xuXG4gICAgICAgICAgICBpZiAobWF4U2Nyb2xsWSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBsaXN0IGlzIHNjcm9sbGFibGUgKGlzIHRhbGxlciB0aGFuIHJlY3QpXG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyTGlzdC5lbGVtZW50LnNjcm9sbFRvcCA+IDAgJiYgKG1hZ25pdHVkZSA9IHkgLSAoaG92ZXJMaXN0LnJlY3QudG9wICsgNSkpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3VzZSBuZWFyIG9yIGFib3ZlIHRvcCBhbmQgbGlzdCBpcyBub3Qgc2Nyb2xsZWQgdG8gdG9wIHlldFxuICAgICAgICAgICAgICAgICAgICByZXNldEF1dG9TY3JvbGxUaW1lcihtYWduaXR1ZGUsIDAsIGhvdmVyTGlzdC5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhvdmVyTGlzdC5lbGVtZW50LnNjcm9sbFRvcCA8IG1heFNjcm9sbFkgJiYgKG1hZ25pdHVkZSA9IHkgLSAoaG92ZXJMaXN0LnJlY3QuYm90dG9tIC0gMSAtIDUpKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbW91c2UgbmVhciBvciBiZWxvdyBib3R0b20gYW5kIGxpc3Qgbm90IHNjcm9sbGVkIHRvIGJvdHRvbSB5ZXRcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRBdXRvU2Nyb2xsVGltZXIobWFnbml0dWRlLCBtYXhTY3JvbGxZLCBob3Zlckxpc3QuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbW91c2UgaW5zaWRlXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0QXV0b1Njcm9sbFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBkcmFnb24ucG9pbnRJbkl0ZW1SZWN0cyh7XG4gICAgICAgICAgICAgICAgeDogZXZ0LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgeTogZHJhZ29uLnJlY3QuYm90dG9tICsgd2luZG93LnNjcm9sbFkgKyBkeSArIGhvdmVyTGlzdC5lbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgfSwgdGhpcywgZHJhZ29uLmRyb3ApO1xuXG4gICAgICAgICAgICB0aGlzLnN0eWxlW3RyYW5zZm9ybV0gPSB0cmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgZHJhZ29uLnJlY3QubGVmdCAtIHdpbmRvdy5zY3JvbGxYICsgZHgsXG4gICAgICAgICAgICAgICAgZHJhZ29uLnJlY3QudG9wIC0gd2luZG93LnNjcm9sbFkgKyBkeVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBvdGhlci5lbGVtZW50O1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbiA9IFJFVkVSVF9UT19TVFlMRVNIRUVUX1ZBTFVFO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBkcmFnb24uZHJvcC5zdHlsZS5ib3JkZXJUb3BXaWR0aDtcbiAgICAgICAgICAgICAgICBkcmFnb24uZHJvcC5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZHJhZ29uLmRyb3AgPSBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1vdXNldXA6IGZ1bmN0aW9uIChkcmFnb24sIGV2dCkge1xuICAgICAgICByZXNldEF1dG9TY3JvbGxUaW1lcigpO1xuICAgICAgICBkcmFnb24ucmVtb3ZlRXZ0KCdtb3VzZW1vdmUnKTtcbiAgICAgICAgZHJhZ29uLnJlbW92ZUV2dCgnbW91c2V1cCcpO1xuXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICB2YXIgbmV3UmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgd2luZG93LnNjcm9sbFggKyBuZXdSZWN0LmxlZnQgPT09IGRyYWdvbi5yZWN0LmxlZnQgJiZcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxZICsgbmV3UmVjdC50b3AgPT09IGRyYWdvbi5yZWN0LnRvcFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGRyYWdvbi5yZWluc2VydCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkcm9wUmVjdCA9IGRyYWdvbi5kcm9wLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICBkcmFnb24uYWRkRXZ0KHRoaXMsICd0cmFuc2l0aW9uZW5kJywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IFJFVkVSVF9UT19TVFlMRVNIRUVUX1ZBTFVFOyAvL3JldmVydHMgdG8gMjAwbXNcbiAgICAgICAgICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gdHJhbnNmb3JtO1xuICAgICAgICAgICAgdGhpcy5zdHlsZVt0cmFuc2Zvcm1dID0gdHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgIGRyb3BSZWN0LmxlZnQgLSB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgICAgICAgICAgICBkcm9wUmVjdC50b3AgLSB3aW5kb3cuc2Nyb2xsWVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0cmFuc2l0aW9uZW5kOiBmdW5jdGlvbiAoZHJhZ29uLCBldnQpIHtcbiAgICAgICAgaWYgKGV2dC5wcm9wZXJ0eU5hbWUgPT09IHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgZHJhZ29uLnJlbW92ZUV2dCgndHJhbnNpdGlvbmVuZCcpO1xuICAgICAgICAgICAgZHJhZ29uLnJlaW5zZXJ0KHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9IFJFVkVSVF9UT19TVFlMRVNIRUVUX1ZBTFVFOyAvL3JldmVydHMgdG8gYm9yZGVyLXRvcC13aWR0aFxuXG4gICAgICAgICAgICB2YXIgb3JpZ2luTGlzdCA9IGRyYWdvbi5tb2RlbExpc3RzW2RyYWdvbi5vcmlnaW4ubGlzdF07XG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBvcmlnaW5MaXN0LnNwbGljZShkcmFnb24ub3JpZ2luLml0ZW0sIDEpWzBdO1xuICAgICAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gZHJhZ29uLml0ZW1Db29yZGluYXRlcyh0aGlzKTtcbiAgICAgICAgICAgIHZhciBkZXN0aW5hdGlvbkxpc3QgPSBkcmFnb24ubW9kZWxMaXN0c1tkZXN0aW5hdGlvbi5saXN0XTtcbiAgICAgICAgICAgIHZhciBpbnRlckxpc3REcm9wID0gb3JpZ2luTGlzdCAhPT0gZGVzdGluYXRpb25MaXN0O1xuICAgICAgICAgICAgdmFyIGxpc3RDaGFuZ2VkID0gaW50ZXJMaXN0RHJvcCB8fCBkcmFnb24ub3JpZ2luLml0ZW0gIT09IGRlc3RpbmF0aW9uLml0ZW07XG4gICAgICAgICAgICBkZXN0aW5hdGlvbkxpc3Quc3BsaWNlKGRlc3RpbmF0aW9uLml0ZW0sIDAsIG1vZGVsKTtcblxuICAgICAgICAgICAgaWYgKGxpc3RDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luTGlzdC5lbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdsaXN0Y2hhbmdlZCcpKTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJMaXN0RHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkxpc3QuZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnbGlzdGNoYW5nZWQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZHJhZ29uLmNhbGxiYWNrLmRyb3BwZWQpIHtcbiAgICAgICAgICAgICAgICBkcmFnb24uY2FsbGJhY2suZHJvcHBlZC5jYWxsKHRoaXMsIGRyYWdvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiByZXNldEF1dG9TY3JvbGxUaW1lcihtYWduaXR1ZGUsIGxpbWl0LCBlbGVtZW50KSB7XG4gICAgaWYgKCFtYWduaXR1ZGUpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgIHNjcm9sbFZlbG9jaXR5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hhbmdlRGlyZWN0aW9uID1cbiAgICAgICAgICAgIHNjcm9sbFZlbG9jaXR5ICA8ICAwICYmIG1hZ25pdHVkZSAgPj0gMCB8fFxuICAgICAgICAgICAgc2Nyb2xsVmVsb2NpdHkgPT09IDAgJiYgbWFnbml0dWRlICE9PSAwIHx8XG4gICAgICAgICAgICBzY3JvbGxWZWxvY2l0eSAgPiAgMCAmJiBtYWduaXR1ZGUgIDw9IDA7XG4gICAgICAgIHNjcm9sbFZlbG9jaXR5ID0gbWFnbml0dWRlID4gMCA/IE1hdGgubWluKDUwLCBtYWduaXR1ZGUpIDogTWF0aC5tYXgoLTUwLCBtYWduaXR1ZGUpO1xuICAgICAgICBpZiAoY2hhbmdlRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wICsgc2Nyb2xsVmVsb2NpdHk7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFZlbG9jaXR5IDwgMCAmJiBzY3JvbGxUb3AgPCBsaW1pdCB8fCBzY3JvbGxWZWxvY2l0eSA+IDAgJiYgc2Nyb2xsVG9wID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSBsaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTI1KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9BcnJheShhcnJheUxpa2VPYmplY3QpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlT2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gcG9pbnRJblJlY3QocG9pbnQsIHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC50b3AgPD0gcG9pbnQueSAmJiBwb2ludC55IDw9IHJlY3QuYm90dG9tXG4gICAgICAgICYmIHJlY3QubGVmdCA8PSBwb2ludC54ICYmIHBvaW50LnggPD0gcmVjdC5yaWdodDtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlKGxlZnQsIHRvcCkge1xuICAgIHJldHVybiAndHJhbnNsYXRlKCdcbiAgICAgICAgKyBNYXRoLmZsb29yKGxlZnQgKyB3aW5kb3cuc2Nyb2xsWCkgKyAncHgsJ1xuICAgICAgICArIE1hdGguZmxvb3IodG9wICsgd2luZG93LnNjcm9sbFkpICsgJ3B4KSc7XG59XG5cbmZ1bmN0aW9uIGh0bWxFbmNvZGUoc3RyaW5nKSB7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyaW5nKTtcblxuICAgIHJldHVybiBkb2N1bWVudFxuICAgICAgICAuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgICAgIC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSlcbiAgICAgICAgLnBhcmVudE5vZGVcbiAgICAgICAgLmlubmVySFRNTDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGA8dWw+Li4uPC91bD5gIGVsZW1lbnRzIGFuZCBpbnNlcnRzIHRoZW0gaW50byBhbiBgZWxlbWVudGAgcHJvcGVydHkgb24gZWFjaCBtb2RlbC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbExpc3RzXG4gKiBAcmV0dXJucyBgbW9kZWxMaXN0c2BcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTGlzdEVsZW1lbnRzRnJvbU1vZGVsTGlzdHMobW9kZWxMaXN0cywgb3B0aW9ucykge1xuICAgIHZhciB0ZW1wbGF0ZUxhYmVsID0gb3B0aW9ucy5sYWJlbCB8fCAne2xhYmVsfSc7XG5cbiAgICBtb2RlbExpc3RzLmZvckVhY2goZnVuY3Rpb24gKG1vZGVsTGlzdCwgbGlzdEluZGV4KSB7XG4gICAgICAgIHZhciBsaXN0TGFiZWwgPSBtb2RlbExpc3QubGFiZWwgfHwgdGVtcGxhdGVMYWJlbCxcbiAgICAgICAgICAgIGxpc3RIdG1sRW5jb2RlID0gbW9kZWxMaXN0Lmh0bWxFbmNvZGUgIT09IHVuZGVmaW5lZCAmJiBtb2RlbExpc3QuaHRtbEVuY29kZSB8fCBvcHRpb25zLmh0bWxFbmNvZGUsXG4gICAgICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgIGxpc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcblxuICAgICAgICBpZiAobW9kZWxMaXN0Lm1vZGVscykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobW9kZWxMaXN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kZWxzJykge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbExpc3QubW9kZWxzW2tleV0gPSBtb2RlbExpc3Rba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1vZGVsTGlzdHNbbGlzdEluZGV4XSA9IG1vZGVsTGlzdCA9IG1vZGVsTGlzdC5tb2RlbHM7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZWxMaXN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIG1vZGVsTGlzdC5tb2RlbHMgPSBtb2RlbExpc3Q7IC8vIHBvaW50IHRvIHNlbGZcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yKCdMaXN0IFt7MX1dIG5vdCBhbiBhcnJheSBvZiBtb2RlbHMgKHdpdGggb3Igd2l0aG91dCBhZGRpdGlvbmFsIHByb3BlcnRpZXMpIE9SICcgK1xuICAgICAgICAgICAgICAgICdhbiBvYmplY3QgKHdpdGggYSBgbW9kZWxzYCBwcm9wZXJ0eSBjb250YWluaW5nIGFuIGFycmF5IG9mIG1vZGVscykuJywgbGlzdEluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZGVsTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICAgICAgdmFyIG1vZGVsTGFiZWwgPSBtb2RlbC5sYWJlbCB8fCBsaXN0TGFiZWwsXG4gICAgICAgICAgICAgICAgbW9kZWxIdG1sRW5jb2RlID0gbW9kZWwuaHRtbEVuY29kZSAhPT0gdW5kZWZpbmVkICYmIG1vZGVsLmh0bWxFbmNvZGUgfHwgbGlzdEh0bWxFbmNvZGUsXG4gICAgICAgICAgICAgICAgbW9kZWxPYmplY3QgPSB0eXBlb2YgbW9kZWwgPT09ICdvYmplY3QnID8gbW9kZWwgOiB7IGxhYmVsOiBtb2RlbH0sXG4gICAgICAgICAgICAgICAgbGFiZWwgPSBmb3JtYXQuY2FsbChbbW9kZWxPYmplY3QsIG1vZGVsTGlzdCwgb3B0aW9uc10sIG1vZGVsTGFiZWwpLFxuICAgICAgICAgICAgICAgIGl0ZW1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblxuICAgICAgICAgICAgaXRlbUVsZW1lbnQuaW5uZXJIVE1MID0gbW9kZWxIdG1sRW5jb2RlID8gaHRtbEVuY29kZShsYWJlbCkgOiBsYWJlbDtcblxuICAgICAgICAgICAgbGlzdEVsZW1lbnQuYXBwZW5kQ2hpbGQoaXRlbUVsZW1lbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhcHBlbmQgdGhlIGZpbmFsIFwiZmVuY2Vwb3N0XCIgaXRlbSAtLSBkcm9wIHRhcmdldCBhdCBib3R0b20gb2YgbGlzdCBhZnRlciBhbGwgaXRlbXNcbiAgICAgICAgdmFyIGl0ZW1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgaXRlbUVsZW1lbnQuaW5uZXJIVE1MID0gJyZuYnNwOyc7XG4gICAgICAgIGxpc3RFbGVtZW50LmFwcGVuZENoaWxkKGl0ZW1FbGVtZW50KTtcblxuICAgICAgICAvLyBhcHBlbmQgaGVhZGVyIHRvIGNvbnRhaW5lclxuICAgICAgICBpZiAobW9kZWxMaXN0LnRpdGxlKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBoZWFkZXIuaW5uZXJIVE1MID0gbGlzdEh0bWxFbmNvZGUgPyBodG1sRW5jb2RlKG1vZGVsTGlzdC50aXRsZSkgOiBtb2RlbExpc3QudGl0bGU7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChsaXN0RWxlbWVudCk7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBtb2RlbExpc3QuY3NzQ2xhc3NOYW1lcyB8fCBvcHRpb25zLmNzc0NsYXNzTmFtZXMgfHwgJ2RyYWdvbi1saXN0JztcbiAgICAgICAgbW9kZWxMaXN0LmVsZW1lbnQgPSBsaXN0RWxlbWVudDtcbiAgICAgICAgbW9kZWxMaXN0LmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9KTtcblxuICAgIHJldHVybiBtb2RlbExpc3RzO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGAubW9kZWxMaXN0c2AgYXJyYXkgd2l0aCB0aGVzZSA8bGk+IGVsZW1lbnRzJyBwYXJlbnQgPHVsPiBlbGVtZW50c1xuICogQHBhcmFtIHtFbGVtZW50W119IGxpc3RJdGVtRWxlbWVudHNcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9kZWxMaXN0c0Zyb21MaXN0RWxlbWVudHMobGlzdEl0ZW1FbGVtZW50cykge1xuICAgIHZhciBtb2RlbExpc3RzID0gW107XG5cbiAgICBsaXN0SXRlbUVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW1FbGVtZW50KSB7XG4gICAgICAgIHZhciBsaXN0RWxlbWVudCA9IGl0ZW1FbGVtZW50LnBhcmVudEVsZW1lbnQsXG4gICAgICAgICAgICBjb250YWluZXIgPSBsaXN0RWxlbWVudC5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgbW9kZWxzID0gW107XG4gICAgICAgIGlmICghbW9kZWxMaXN0cy5maW5kKGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBsaXN0LmVsZW1lbnQgPT09IGxpc3RFbGVtZW50OyB9KSkge1xuICAgICAgICAgICAgdG9BcnJheShsaXN0RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaScpKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtRWxlbWVudCAhPT0gbGlzdEVsZW1lbnQubGFzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbHMucHVzaChpdGVtRWxlbWVudC5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbW9kZWxzLmVsZW1lbnQgPSBsaXN0RWxlbWVudDtcbiAgICAgICAgICAgIG1vZGVscy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgICAgICBtb2RlbExpc3RzLnB1c2gobW9kZWxzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1vZGVsTGlzdHM7XG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVFdmVudChldnQpIHtcbiAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIGVycm9yKCkge1xuICAgIHJldHVybiAnbGlzdC1kcmFnb246ICcgKyBmb3JtYXQuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG59XG5cbi8vIHRoaXMgaW50ZXJmYWNlIGNvbnNpc3RzIHNvbGVseSBvZiB0aGUgcHJvdG90eXBhbCBvYmplY3QgY29uc3RydWN0b3Jcbm1vZHVsZS5leHBvcnRzID0gTGlzdERyYWdvbjtcbiIsIjsoZnVuY3Rpb24gKCkgeyAvLyBjbG9zdXJlIGZvciB3ZWIgYnJvd3NlcnNcblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbn0gZWxzZSB7XG4gIC8vIGp1c3Qgc2V0IHRoZSBnbG9iYWwgZm9yIG5vbi1ub2RlIHBsYXRmb3Jtcy5cbiAgdGhpcy5MUlVDYWNoZSA9IExSVUNhY2hlXG59XG5cbmZ1bmN0aW9uIGhPUCAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuZnVuY3Rpb24gbmFpdmVMZW5ndGggKCkgeyByZXR1cm4gMSB9XG5cbmZ1bmN0aW9uIExSVUNhY2hlIChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMUlVDYWNoZSkpXG4gICAgcmV0dXJuIG5ldyBMUlVDYWNoZShvcHRpb25zKVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpXG4gICAgb3B0aW9ucyA9IHsgbWF4OiBvcHRpb25zIH1cblxuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9XG5cbiAgdGhpcy5fbWF4ID0gb3B0aW9ucy5tYXhcbiAgLy8gS2luZCBvZiB3ZWlyZCB0byBoYXZlIGEgZGVmYXVsdCBtYXggb2YgSW5maW5pdHksIGJ1dCBvaCB3ZWxsLlxuICBpZiAoIXRoaXMuX21heCB8fCAhKHR5cGVvZiB0aGlzLl9tYXggPT09IFwibnVtYmVyXCIpIHx8IHRoaXMuX21heCA8PSAwIClcbiAgICB0aGlzLl9tYXggPSBJbmZpbml0eVxuXG4gIHRoaXMuX2xlbmd0aENhbGN1bGF0b3IgPSBvcHRpb25zLmxlbmd0aCB8fCBuYWl2ZUxlbmd0aFxuICBpZiAodHlwZW9mIHRoaXMuX2xlbmd0aENhbGN1bGF0b3IgIT09IFwiZnVuY3Rpb25cIilcbiAgICB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yID0gbmFpdmVMZW5ndGhcblxuICB0aGlzLl9hbGxvd1N0YWxlID0gb3B0aW9ucy5zdGFsZSB8fCBmYWxzZVxuICB0aGlzLl9tYXhBZ2UgPSBvcHRpb25zLm1heEFnZSB8fCBudWxsXG4gIHRoaXMuX2Rpc3Bvc2UgPSBvcHRpb25zLmRpc3Bvc2VcbiAgdGhpcy5yZXNldCgpXG59XG5cbi8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCBcIm1heFwiLFxuICB7IHNldCA6IGZ1bmN0aW9uIChtTCkge1xuICAgICAgaWYgKCFtTCB8fCAhKHR5cGVvZiBtTCA9PT0gXCJudW1iZXJcIikgfHwgbUwgPD0gMCApIG1MID0gSW5maW5pdHlcbiAgICAgIHRoaXMuX21heCA9IG1MXG4gICAgICBpZiAodGhpcy5fbGVuZ3RoID4gdGhpcy5fbWF4KSB0cmltKHRoaXMpXG4gICAgfVxuICAsIGdldCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21heCB9XG4gICwgZW51bWVyYWJsZSA6IHRydWVcbiAgfSlcblxuLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBsZW5ndGhDYWxjdWxhdG9yIGNoYW5nZXMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCBcImxlbmd0aENhbGN1bGF0b3JcIixcbiAgeyBzZXQgOiBmdW5jdGlvbiAobEMpIHtcbiAgICAgIGlmICh0eXBlb2YgbEMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yID0gbmFpdmVMZW5ndGhcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdGhpcy5faXRlbUNvdW50XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9jYWNoZSkge1xuICAgICAgICAgIHRoaXMuX2NhY2hlW2tleV0ubGVuZ3RoID0gMVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yID0gbENcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gMFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICB0aGlzLl9jYWNoZVtrZXldLmxlbmd0aCA9IHRoaXMuX2xlbmd0aENhbGN1bGF0b3IodGhpcy5fY2FjaGVba2V5XS52YWx1ZSlcbiAgICAgICAgICB0aGlzLl9sZW5ndGggKz0gdGhpcy5fY2FjaGVba2V5XS5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fbGVuZ3RoID4gdGhpcy5fbWF4KSB0cmltKHRoaXMpXG4gICAgfVxuICAsIGdldCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xlbmd0aENhbGN1bGF0b3IgfVxuICAsIGVudW1lcmFibGUgOiB0cnVlXG4gIH0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsXG4gIHsgZ2V0IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbGVuZ3RoIH1cbiAgLCBlbnVtZXJhYmxlIDogdHJ1ZVxuICB9KVxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsIFwiaXRlbUNvdW50XCIsXG4gIHsgZ2V0IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faXRlbUNvdW50IH1cbiAgLCBlbnVtZXJhYmxlIDogdHJ1ZVxuICB9KVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciBpID0gMFxuICB2YXIgaXRlbUNvdW50ID0gdGhpcy5faXRlbUNvdW50XG5cbiAgZm9yICh2YXIgayA9IHRoaXMuX21ydSAtIDE7IGsgPj0gMCAmJiBpIDwgaXRlbUNvdW50OyBrLS0pIGlmICh0aGlzLl9scnVMaXN0W2tdKSB7XG4gICAgaSsrXG4gICAgdmFyIGhpdCA9IHRoaXMuX2xydUxpc3Rba11cbiAgICBpZiAoaXNTdGFsZSh0aGlzLCBoaXQpKSB7XG4gICAgICBkZWwodGhpcywgaGl0KVxuICAgICAgaWYgKCF0aGlzLl9hbGxvd1N0YWxlKSBoaXQgPSB1bmRlZmluZWRcbiAgICB9XG4gICAgaWYgKGhpdCkge1xuICAgICAgZm4uY2FsbCh0aGlzcCwgaGl0LnZhbHVlLCBoaXQua2V5LCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGtleXMgPSBuZXcgQXJyYXkodGhpcy5faXRlbUNvdW50KVxuICB2YXIgaSA9IDBcbiAgZm9yICh2YXIgayA9IHRoaXMuX21ydSAtIDE7IGsgPj0gMCAmJiBpIDwgdGhpcy5faXRlbUNvdW50OyBrLS0pIGlmICh0aGlzLl9scnVMaXN0W2tdKSB7XG4gICAgdmFyIGhpdCA9IHRoaXMuX2xydUxpc3Rba11cbiAgICBrZXlzW2krK10gPSBoaXQua2V5XG4gIH1cbiAgcmV0dXJuIGtleXNcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheSh0aGlzLl9pdGVtQ291bnQpXG4gIHZhciBpID0gMFxuICBmb3IgKHZhciBrID0gdGhpcy5fbXJ1IC0gMTsgayA+PSAwICYmIGkgPCB0aGlzLl9pdGVtQ291bnQ7IGstLSkgaWYgKHRoaXMuX2xydUxpc3Rba10pIHtcbiAgICB2YXIgaGl0ID0gdGhpcy5fbHJ1TGlzdFtrXVxuICAgIHZhbHVlc1tpKytdID0gaGl0LnZhbHVlXG4gIH1cbiAgcmV0dXJuIHZhbHVlc1xufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kaXNwb3NlICYmIHRoaXMuX2NhY2hlKSB7XG4gICAgZm9yICh2YXIgayBpbiB0aGlzLl9jYWNoZSkge1xuICAgICAgdGhpcy5fZGlzcG9zZShrLCB0aGlzLl9jYWNoZVtrXS52YWx1ZSlcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCkgLy8gaGFzaCBvZiBpdGVtcyBieSBrZXlcbiAgdGhpcy5fbHJ1TGlzdCA9IE9iamVjdC5jcmVhdGUobnVsbCkgLy8gbGlzdCBvZiBpdGVtcyBpbiBvcmRlciBvZiB1c2UgcmVjZW5jeVxuICB0aGlzLl9tcnUgPSAwIC8vIG1vc3QgcmVjZW50bHkgdXNlZFxuICB0aGlzLl9scnUgPSAwIC8vIGxlYXN0IHJlY2VudGx5IHVzZWRcbiAgdGhpcy5fbGVuZ3RoID0gMCAvLyBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGxpc3RcbiAgdGhpcy5faXRlbUNvdW50ID0gMFxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZHVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IFtdXG4gIHZhciBpID0gMFxuXG4gIGZvciAodmFyIGsgPSB0aGlzLl9tcnUgLSAxOyBrID49IDAgJiYgaSA8IHRoaXMuX2l0ZW1Db3VudDsgay0tKSBpZiAodGhpcy5fbHJ1TGlzdFtrXSkge1xuICAgIHZhciBoaXQgPSB0aGlzLl9scnVMaXN0W2tdXG4gICAgaWYgKCFpc1N0YWxlKHRoaXMsIGhpdCkpIHtcbiAgICAgIC8vRG8gbm90IHN0b3JlIHN0YWxlZCBoaXRzXG4gICAgICArK2lcbiAgICAgIGFyci5wdXNoKHtcbiAgICAgICAgazogaGl0LmtleSxcbiAgICAgICAgdjogaGl0LnZhbHVlLFxuICAgICAgICBlOiBoaXQubm93ICsgKGhpdC5tYXhBZ2UgfHwgMClcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvL2FyciBoYXMgdGhlIG1vc3QgcmVhZCBmaXJzdFxuICByZXR1cm4gYXJyXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5kdW1wTHJ1ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fbHJ1TGlzdFxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG1heEFnZSkge1xuICBtYXhBZ2UgPSBtYXhBZ2UgfHwgdGhpcy5fbWF4QWdlXG4gIHZhciBub3cgPSBtYXhBZ2UgPyBEYXRlLm5vdygpIDogMFxuICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvcih2YWx1ZSlcblxuICBpZiAoaE9QKHRoaXMuX2NhY2hlLCBrZXkpKSB7XG4gICAgaWYgKGxlbiA+IHRoaXMuX21heCkge1xuICAgICAgZGVsKHRoaXMsIHRoaXMuX2NhY2hlW2tleV0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgLy8gZGlzcG9zZSBvZiB0aGUgb2xkIG9uZSBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgICBpZiAodGhpcy5fZGlzcG9zZSlcbiAgICAgIHRoaXMuX2Rpc3Bvc2Uoa2V5LCB0aGlzLl9jYWNoZVtrZXldLnZhbHVlKVxuXG4gICAgdGhpcy5fY2FjaGVba2V5XS5ub3cgPSBub3dcbiAgICB0aGlzLl9jYWNoZVtrZXldLm1heEFnZSA9IG1heEFnZVxuICAgIHRoaXMuX2NhY2hlW2tleV0udmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMuX2xlbmd0aCArPSAobGVuIC0gdGhpcy5fY2FjaGVba2V5XS5sZW5ndGgpXG4gICAgdGhpcy5fY2FjaGVba2V5XS5sZW5ndGggPSBsZW5cbiAgICB0aGlzLmdldChrZXkpXG5cbiAgICBpZiAodGhpcy5fbGVuZ3RoID4gdGhpcy5fbWF4KVxuICAgICAgdHJpbSh0aGlzKVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHZhciBoaXQgPSBuZXcgRW50cnkoa2V5LCB2YWx1ZSwgdGhpcy5fbXJ1KyssIGxlbiwgbm93LCBtYXhBZ2UpXG5cbiAgLy8gb3ZlcnNpemVkIG9iamVjdHMgZmFsbCBvdXQgb2YgY2FjaGUgYXV0b21hdGljYWxseS5cbiAgaWYgKGhpdC5sZW5ndGggPiB0aGlzLl9tYXgpIHtcbiAgICBpZiAodGhpcy5fZGlzcG9zZSkgdGhpcy5fZGlzcG9zZShrZXksIHZhbHVlKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdGhpcy5fbGVuZ3RoICs9IGhpdC5sZW5ndGhcbiAgdGhpcy5fbHJ1TGlzdFtoaXQubHVdID0gdGhpcy5fY2FjaGVba2V5XSA9IGhpdFxuICB0aGlzLl9pdGVtQ291bnQgKytcblxuICBpZiAodGhpcy5fbGVuZ3RoID4gdGhpcy5fbWF4KVxuICAgIHRyaW0odGhpcylcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICBpZiAoIWhPUCh0aGlzLl9jYWNoZSwga2V5KSkgcmV0dXJuIGZhbHNlXG4gIHZhciBoaXQgPSB0aGlzLl9jYWNoZVtrZXldXG4gIGlmIChpc1N0YWxlKHRoaXMsIGhpdCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgdHJ1ZSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhpdCA9IHRoaXMuX2xydUxpc3RbdGhpcy5fbHJ1XVxuICBkZWwodGhpcywgaGl0KVxuICByZXR1cm4gaGl0IHx8IG51bGxcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgZGVsKHRoaXMsIHRoaXMuX2NhY2hlW2tleV0pXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGFycikge1xuICAvL3Jlc2V0IHRoZSBjYWNoZVxuICB0aGlzLnJlc2V0KCk7XG5cbiAgdmFyIG5vdyA9IERhdGUubm93KClcbiAgLy9BIHByZXZpb3VzIHNlcmlhbGl6ZWQgY2FjaGUgaGFzIHRoZSBtb3N0IHJlY2VudCBpdGVtcyBmaXJzdFxuICBmb3IgKHZhciBsID0gYXJyLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tICkge1xuICAgIHZhciBoaXQgPSBhcnJbbF1cbiAgICB2YXIgZXhwaXJlc0F0ID0gaGl0LmUgfHwgMFxuICAgIGlmIChleHBpcmVzQXQgPT09IDApIHtcbiAgICAgIC8vdGhlIGl0ZW0gd2FzIGNyZWF0ZWQgd2l0aG91dCBleHBpcmF0aW9uIGluIGEgbm9uIGFnZWQgY2FjaGVcbiAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1heEFnZSA9IGV4cGlyZXNBdCAtIG5vd1xuICAgICAgLy9kb250IGFkZCBhbHJlYWR5IGV4cGlyZWQgaXRlbXNcbiAgICAgIGlmIChtYXhBZ2UgPiAwKSB0aGlzLnNldChoaXQuaywgaGl0LnYsIG1heEFnZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0IChzZWxmLCBrZXksIGRvVXNlKSB7XG4gIHZhciBoaXQgPSBzZWxmLl9jYWNoZVtrZXldXG4gIGlmIChoaXQpIHtcbiAgICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgICBkZWwoc2VsZiwgaGl0KVxuICAgICAgaWYgKCFzZWxmLl9hbGxvd1N0YWxlKSBoaXQgPSB1bmRlZmluZWRcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvVXNlKSB1c2Uoc2VsZiwgaGl0KVxuICAgIH1cbiAgICBpZiAoaGl0KSBoaXQgPSBoaXQudmFsdWVcbiAgfVxuICByZXR1cm4gaGl0XG59XG5cbmZ1bmN0aW9uIGlzU3RhbGUoc2VsZiwgaGl0KSB7XG4gIGlmICghaGl0IHx8ICghaGl0Lm1heEFnZSAmJiAhc2VsZi5fbWF4QWdlKSkgcmV0dXJuIGZhbHNlXG4gIHZhciBzdGFsZSA9IGZhbHNlO1xuICB2YXIgZGlmZiA9IERhdGUubm93KCkgLSBoaXQubm93XG4gIGlmIChoaXQubWF4QWdlKSB7XG4gICAgc3RhbGUgPSBkaWZmID4gaGl0Lm1heEFnZVxuICB9IGVsc2Uge1xuICAgIHN0YWxlID0gc2VsZi5fbWF4QWdlICYmIChkaWZmID4gc2VsZi5fbWF4QWdlKVxuICB9XG4gIHJldHVybiBzdGFsZTtcbn1cblxuZnVuY3Rpb24gdXNlIChzZWxmLCBoaXQpIHtcbiAgc2hpZnRMVShzZWxmLCBoaXQpXG4gIGhpdC5sdSA9IHNlbGYuX21ydSArK1xuICBzZWxmLl9scnVMaXN0W2hpdC5sdV0gPSBoaXRcbn1cblxuZnVuY3Rpb24gdHJpbSAoc2VsZikge1xuICB3aGlsZSAoc2VsZi5fbHJ1IDwgc2VsZi5fbXJ1ICYmIHNlbGYuX2xlbmd0aCA+IHNlbGYuX21heClcbiAgICBkZWwoc2VsZiwgc2VsZi5fbHJ1TGlzdFtzZWxmLl9scnVdKVxufVxuXG5mdW5jdGlvbiBzaGlmdExVIChzZWxmLCBoaXQpIHtcbiAgZGVsZXRlIHNlbGYuX2xydUxpc3RbIGhpdC5sdSBdXG4gIHdoaWxlIChzZWxmLl9scnUgPCBzZWxmLl9tcnUgJiYgIXNlbGYuX2xydUxpc3Rbc2VsZi5fbHJ1XSkgc2VsZi5fbHJ1ICsrXG59XG5cbmZ1bmN0aW9uIGRlbCAoc2VsZiwgaGl0KSB7XG4gIGlmIChoaXQpIHtcbiAgICBpZiAoc2VsZi5fZGlzcG9zZSkgc2VsZi5fZGlzcG9zZShoaXQua2V5LCBoaXQudmFsdWUpXG4gICAgc2VsZi5fbGVuZ3RoIC09IGhpdC5sZW5ndGhcbiAgICBzZWxmLl9pdGVtQ291bnQgLS1cbiAgICBkZWxldGUgc2VsZi5fY2FjaGVbIGhpdC5rZXkgXVxuICAgIHNoaWZ0TFUoc2VsZiwgaGl0KVxuICB9XG59XG5cbi8vIGNsYXNzeSwgc2luY2UgVjggcHJlZmVycyBwcmVkaWN0YWJsZSBvYmplY3RzLlxuZnVuY3Rpb24gRW50cnkgKGtleSwgdmFsdWUsIGx1LCBsZW5ndGgsIG5vdywgbWF4QWdlKSB7XG4gIHRoaXMua2V5ID0ga2V5XG4gIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB0aGlzLmx1ID0gbHVcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgdGhpcy5ub3cgPSBub3dcbiAgaWYgKG1heEFnZSkgdGhpcy5tYXhBZ2UgPSBtYXhBZ2Vcbn1cblxufSkoKVxuIiwiLyohXG4gKiBtdXN0YWNoZS5qcyAtIExvZ2ljLWxlc3Mge3ttdXN0YWNoZX19IHRlbXBsYXRlcyB3aXRoIEphdmFTY3JpcHRcbiAqIGh0dHA6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanNcbiAqL1xuXG4vKmdsb2JhbCBkZWZpbmU6IGZhbHNlIE11c3RhY2hlOiB0cnVlKi9cblxuKGZ1bmN0aW9uIGRlZmluZU11c3RhY2hlIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmIHR5cGVvZiBleHBvcnRzLm5vZGVOYW1lICE9PSAnc3RyaW5nJykge1xuICAgIGZhY3RvcnkoZXhwb3J0cyk7IC8vIENvbW1vbkpTXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KTsgLy8gQU1EXG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsLk11c3RhY2hlID0ge307XG4gICAgZmFjdG9yeShNdXN0YWNoZSk7IC8vIHNjcmlwdCwgd3NoLCBhc3BcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiBtdXN0YWNoZUZhY3RvcnkgKG11c3RhY2hlKSB7XG5cbiAgdmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXlQb2x5ZmlsbCAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3JlIGNvcnJlY3QgdHlwZW9mIHN0cmluZyBoYW5kbGluZyBhcnJheVxuICAgKiB3aGljaCBub3JtYWxseSByZXR1cm5zIHR5cGVvZiAnb2JqZWN0J1xuICAgKi9cbiAgZnVuY3Rpb24gdHlwZVN0ciAob2JqKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdhcnJheScgOiB0eXBlb2Ygb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4gIH1cblxuICAvKipcbiAgICogTnVsbCBzYWZlIHdheSBvZiBjaGVja2luZyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QsXG4gICAqIGluY2x1ZGluZyBpdHMgcHJvdG90eXBlLCBoYXMgYSBnaXZlbiBwcm9wZXJ0eVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzUHJvcGVydHkgKG9iaiwgcHJvcE5hbWUpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgKHByb3BOYW1lIGluIG9iaik7XG4gIH1cblxuICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2lzc3Vlcy5hcGFjaGUub3JnL2ppcmEvYnJvd3NlL0NPVUNIREItNTc3XG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg5XG4gIHZhciByZWdFeHBUZXN0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0O1xuICBmdW5jdGlvbiB0ZXN0UmVnRXhwIChyZSwgc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlZ0V4cFRlc3QuY2FsbChyZSwgc3RyaW5nKTtcbiAgfVxuXG4gIHZhciBub25TcGFjZVJlID0gL1xcUy87XG4gIGZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAoc3RyaW5nKSB7XG4gICAgcmV0dXJuICF0ZXN0UmVnRXhwKG5vblNwYWNlUmUsIHN0cmluZyk7XG4gIH1cblxuICB2YXIgZW50aXR5TWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7JyxcbiAgICAnLyc6ICcmI3gyRjsnXG4gIH07XG5cbiAgZnVuY3Rpb24gZXNjYXBlSHRtbCAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UoL1smPD5cIidcXC9dL2csIGZ1bmN0aW9uIGZyb21FbnRpdHlNYXAgKHMpIHtcbiAgICAgIHJldHVybiBlbnRpdHlNYXBbc107XG4gICAgfSk7XG4gIH1cblxuICB2YXIgd2hpdGVSZSA9IC9cXHMqLztcbiAgdmFyIHNwYWNlUmUgPSAvXFxzKy87XG4gIHZhciBlcXVhbHNSZSA9IC9cXHMqPS87XG4gIHZhciBjdXJseVJlID0gL1xccypcXH0vO1xuICB2YXIgdGFnUmUgPSAvI3xcXF58XFwvfD58XFx7fCZ8PXwhLztcblxuICAvKipcbiAgICogQnJlYWtzIHVwIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHN0cmluZyBpbnRvIGEgdHJlZSBvZiB0b2tlbnMuIElmIHRoZSBgdGFnc2BcbiAgICogYXJndW1lbnQgaXMgZ2l2ZW4gaGVyZSBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggdHdvIHN0cmluZyB2YWx1ZXM6IHRoZVxuICAgKiBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3MgdXNlZCBpbiB0aGUgdGVtcGxhdGUgKGUuZy4gWyBcIjwlXCIsIFwiJT5cIiBdKS4gT2ZcbiAgICogY291cnNlLCB0aGUgZGVmYXVsdCBpcyB0byB1c2UgbXVzdGFjaGVzIChpLmUuIG11c3RhY2hlLnRhZ3MpLlxuICAgKlxuICAgKiBBIHRva2VuIGlzIGFuIGFycmF5IHdpdGggYXQgbGVhc3QgNCBlbGVtZW50cy4gVGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlXG4gICAqIG11c3RhY2hlIHN5bWJvbCB0aGF0IHdhcyB1c2VkIGluc2lkZSB0aGUgdGFnLCBlLmcuIFwiI1wiIG9yIFwiJlwiLiBJZiB0aGUgdGFnXG4gICAqIGRpZCBub3QgY29udGFpbiBhIHN5bWJvbCAoaS5lLiB7e215VmFsdWV9fSkgdGhpcyBlbGVtZW50IGlzIFwibmFtZVwiLiBGb3JcbiAgICogYWxsIHRleHQgdGhhdCBhcHBlYXJzIG91dHNpZGUgYSBzeW1ib2wgdGhpcyBlbGVtZW50IGlzIFwidGV4dFwiLlxuICAgKlxuICAgKiBUaGUgc2Vjb25kIGVsZW1lbnQgb2YgYSB0b2tlbiBpcyBpdHMgXCJ2YWx1ZVwiLiBGb3IgbXVzdGFjaGUgdGFncyB0aGlzIGlzXG4gICAqIHdoYXRldmVyIGVsc2Ugd2FzIGluc2lkZSB0aGUgdGFnIGJlc2lkZXMgdGhlIG9wZW5pbmcgc3ltYm9sLiBGb3IgdGV4dCB0b2tlbnNcbiAgICogdGhpcyBpcyB0aGUgdGV4dCBpdHNlbGYuXG4gICAqXG4gICAqIFRoZSB0aGlyZCBhbmQgZm91cnRoIGVsZW1lbnRzIG9mIHRoZSB0b2tlbiBhcmUgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyxcbiAgICogcmVzcGVjdGl2ZWx5LCBvZiB0aGUgdG9rZW4gaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlLlxuICAgKlxuICAgKiBUb2tlbnMgdGhhdCBhcmUgdGhlIHJvb3Qgbm9kZSBvZiBhIHN1YnRyZWUgY29udGFpbiB0d28gbW9yZSBlbGVtZW50czogMSkgYW5cbiAgICogYXJyYXkgb2YgdG9rZW5zIGluIHRoZSBzdWJ0cmVlIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlIGF0XG4gICAqIHdoaWNoIHRoZSBjbG9zaW5nIHRhZyBmb3IgdGhhdCBzZWN0aW9uIGJlZ2lucy5cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlVGVtcGxhdGUgKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgaWYgKCF0ZW1wbGF0ZSlcbiAgICAgIHJldHVybiBbXTtcblxuICAgIHZhciBzZWN0aW9ucyA9IFtdOyAgICAgLy8gU3RhY2sgdG8gaG9sZCBzZWN0aW9uIHRva2Vuc1xuICAgIHZhciB0b2tlbnMgPSBbXTsgICAgICAgLy8gQnVmZmVyIHRvIGhvbGQgdGhlIHRva2Vuc1xuICAgIHZhciBzcGFjZXMgPSBbXTsgICAgICAgLy8gSW5kaWNlcyBvZiB3aGl0ZXNwYWNlIHRva2VucyBvbiB0aGUgY3VycmVudCBsaW5lXG4gICAgdmFyIGhhc1RhZyA9IGZhbHNlOyAgICAvLyBJcyB0aGVyZSBhIHt7dGFnfX0gb24gdGhlIGN1cnJlbnQgbGluZT9cbiAgICB2YXIgbm9uU3BhY2UgPSBmYWxzZTsgIC8vIElzIHRoZXJlIGEgbm9uLXNwYWNlIGNoYXIgb24gdGhlIGN1cnJlbnQgbGluZT9cblxuICAgIC8vIFN0cmlwcyBhbGwgd2hpdGVzcGFjZSB0b2tlbnMgYXJyYXkgZm9yIHRoZSBjdXJyZW50IGxpbmVcbiAgICAvLyBpZiB0aGVyZSB3YXMgYSB7eyN0YWd9fSBvbiBpdCBhbmQgb3RoZXJ3aXNlIG9ubHkgc3BhY2UuXG4gICAgZnVuY3Rpb24gc3RyaXBTcGFjZSAoKSB7XG4gICAgICBpZiAoaGFzVGFnICYmICFub25TcGFjZSkge1xuICAgICAgICB3aGlsZSAoc3BhY2VzLmxlbmd0aClcbiAgICAgICAgICBkZWxldGUgdG9rZW5zW3NwYWNlcy5wb3AoKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGFjZXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaGFzVGFnID0gZmFsc2U7XG4gICAgICBub25TcGFjZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBvcGVuaW5nVGFnUmUsIGNsb3NpbmdUYWdSZSwgY2xvc2luZ0N1cmx5UmU7XG4gICAgZnVuY3Rpb24gY29tcGlsZVRhZ3MgKHRhZ3NUb0NvbXBpbGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnc1RvQ29tcGlsZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHRhZ3NUb0NvbXBpbGUgPSB0YWdzVG9Db21waWxlLnNwbGl0KHNwYWNlUmUsIDIpO1xuXG4gICAgICBpZiAoIWlzQXJyYXkodGFnc1RvQ29tcGlsZSkgfHwgdGFnc1RvQ29tcGlsZS5sZW5ndGggIT09IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YWdzOiAnICsgdGFnc1RvQ29tcGlsZSk7XG5cbiAgICAgIG9wZW5pbmdUYWdSZSA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHRhZ3NUb0NvbXBpbGVbMF0pICsgJ1xcXFxzKicpO1xuICAgICAgY2xvc2luZ1RhZ1JlID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCh0YWdzVG9Db21waWxlWzFdKSk7XG4gICAgICBjbG9zaW5nQ3VybHlSZSA9IG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBlc2NhcGVSZWdFeHAoJ30nICsgdGFnc1RvQ29tcGlsZVsxXSkpO1xuICAgIH1cblxuICAgIGNvbXBpbGVUYWdzKHRhZ3MgfHwgbXVzdGFjaGUudGFncyk7XG5cbiAgICB2YXIgc2Nhbm5lciA9IG5ldyBTY2FubmVyKHRlbXBsYXRlKTtcblxuICAgIHZhciBzdGFydCwgdHlwZSwgdmFsdWUsIGNociwgdG9rZW4sIG9wZW5TZWN0aW9uO1xuICAgIHdoaWxlICghc2Nhbm5lci5lb3MoKSkge1xuICAgICAgc3RhcnQgPSBzY2FubmVyLnBvcztcblxuICAgICAgLy8gTWF0Y2ggYW55IHRleHQgYmV0d2VlbiB0YWdzLlxuICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChvcGVuaW5nVGFnUmUpO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpIDwgdmFsdWVMZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNociA9IHZhbHVlLmNoYXJBdChpKTtcblxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoY2hyKSkge1xuICAgICAgICAgICAgc3BhY2VzLnB1c2godG9rZW5zLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2tlbnMucHVzaChbICd0ZXh0JywgY2hyLCBzdGFydCwgc3RhcnQgKyAxIF0pO1xuICAgICAgICAgIHN0YXJ0ICs9IDE7XG5cbiAgICAgICAgICAvLyBDaGVjayBmb3Igd2hpdGVzcGFjZSBvbiB0aGUgY3VycmVudCBsaW5lLlxuICAgICAgICAgIGlmIChjaHIgPT09ICdcXG4nKVxuICAgICAgICAgICAgc3RyaXBTcGFjZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1hdGNoIHRoZSBvcGVuaW5nIHRhZy5cbiAgICAgIGlmICghc2Nhbm5lci5zY2FuKG9wZW5pbmdUYWdSZSkpXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBoYXNUYWcgPSB0cnVlO1xuXG4gICAgICAvLyBHZXQgdGhlIHRhZyB0eXBlLlxuICAgICAgdHlwZSA9IHNjYW5uZXIuc2Nhbih0YWdSZSkgfHwgJ25hbWUnO1xuICAgICAgc2Nhbm5lci5zY2FuKHdoaXRlUmUpO1xuXG4gICAgICAvLyBHZXQgdGhlIHRhZyB2YWx1ZS5cbiAgICAgIGlmICh0eXBlID09PSAnPScpIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChlcXVhbHNSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhbihlcXVhbHNSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd7Jykge1xuICAgICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdDdXJseVJlKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuKGN1cmx5UmUpO1xuICAgICAgICBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgICB0eXBlID0gJyYnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXRjaCB0aGUgY2xvc2luZyB0YWcuXG4gICAgICBpZiAoIXNjYW5uZXIuc2NhbihjbG9zaW5nVGFnUmUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHRhZyBhdCAnICsgc2Nhbm5lci5wb3MpO1xuXG4gICAgICB0b2tlbiA9IFsgdHlwZSwgdmFsdWUsIHN0YXJ0LCBzY2FubmVyLnBvcyBdO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJyMnIHx8IHR5cGUgPT09ICdeJykge1xuICAgICAgICBzZWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJy8nKSB7XG4gICAgICAgIC8vIENoZWNrIHNlY3Rpb24gbmVzdGluZy5cbiAgICAgICAgb3BlblNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcblxuICAgICAgICBpZiAoIW9wZW5TZWN0aW9uKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5vcGVuZWQgc2VjdGlvbiBcIicgKyB2YWx1ZSArICdcIiBhdCAnICsgc3RhcnQpO1xuXG4gICAgICAgIGlmIChvcGVuU2VjdGlvblsxXSAhPT0gdmFsdWUpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCBzZWN0aW9uIFwiJyArIG9wZW5TZWN0aW9uWzFdICsgJ1wiIGF0ICcgKyBzdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICduYW1lJyB8fCB0eXBlID09PSAneycgfHwgdHlwZSA9PT0gJyYnKSB7XG4gICAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJz0nKSB7XG4gICAgICAgIC8vIFNldCB0aGUgdGFncyBmb3IgdGhlIG5leHQgdGltZSBhcm91bmQuXG4gICAgICAgIGNvbXBpbGVUYWdzKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIG5vIG9wZW4gc2VjdGlvbnMgd2hlbiB3ZSdyZSBkb25lLlxuICAgIG9wZW5TZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG5cbiAgICBpZiAob3BlblNlY3Rpb24pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHNlY3Rpb24gXCInICsgb3BlblNlY3Rpb25bMV0gKyAnXCIgYXQgJyArIHNjYW5uZXIucG9zKTtcblxuICAgIHJldHVybiBuZXN0VG9rZW5zKHNxdWFzaFRva2Vucyh0b2tlbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lcyB0aGUgdmFsdWVzIG9mIGNvbnNlY3V0aXZlIHRleHQgdG9rZW5zIGluIHRoZSBnaXZlbiBgdG9rZW5zYCBhcnJheVxuICAgKiB0byBhIHNpbmdsZSB0b2tlbi5cbiAgICovXG4gIGZ1bmN0aW9uIHNxdWFzaFRva2VucyAodG9rZW5zKSB7XG4gICAgdmFyIHNxdWFzaGVkVG9rZW5zID0gW107XG5cbiAgICB2YXIgdG9rZW4sIGxhc3RUb2tlbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlblswXSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbiAmJiBsYXN0VG9rZW5bMF0gPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGxhc3RUb2tlblsxXSArPSB0b2tlblsxXTtcbiAgICAgICAgICBsYXN0VG9rZW5bM10gPSB0b2tlblszXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcXVhc2hlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcXVhc2hlZFRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtcyB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHRva2Vuc2AgaW50byBhIG5lc3RlZCB0cmVlIHN0cnVjdHVyZSB3aGVyZVxuICAgKiB0b2tlbnMgdGhhdCByZXByZXNlbnQgYSBzZWN0aW9uIGhhdmUgdHdvIGFkZGl0aW9uYWwgaXRlbXM6IDEpIGFuIGFycmF5IG9mXG4gICAqIGFsbCB0b2tlbnMgdGhhdCBhcHBlYXIgaW4gdGhhdCBzZWN0aW9uIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsXG4gICAqIHRlbXBsYXRlIHRoYXQgcmVwcmVzZW50cyB0aGUgZW5kIG9mIHRoYXQgc2VjdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG5lc3RUb2tlbnMgKHRva2Vucykge1xuICAgIHZhciBuZXN0ZWRUb2tlbnMgPSBbXTtcbiAgICB2YXIgY29sbGVjdG9yID0gbmVzdGVkVG9rZW5zO1xuICAgIHZhciBzZWN0aW9ucyA9IFtdO1xuXG4gICAgdmFyIHRva2VuLCBzZWN0aW9uO1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICBjYXNlICcjJzpcbiAgICAgIGNhc2UgJ14nOlxuICAgICAgICBjb2xsZWN0b3IucHVzaCh0b2tlbik7XG4gICAgICAgIHNlY3Rpb25zLnB1c2godG9rZW4pO1xuICAgICAgICBjb2xsZWN0b3IgPSB0b2tlbls0XSA9IFtdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJy8nOlxuICAgICAgICBzZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG4gICAgICAgIHNlY3Rpb25bNV0gPSB0b2tlblsyXTtcbiAgICAgICAgY29sbGVjdG9yID0gc2VjdGlvbnMubGVuZ3RoID4gMCA/IHNlY3Rpb25zW3NlY3Rpb25zLmxlbmd0aCAtIDFdWzRdIDogbmVzdGVkVG9rZW5zO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbGxlY3Rvci5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmVzdGVkVG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2ltcGxlIHN0cmluZyBzY2FubmVyIHRoYXQgaXMgdXNlZCBieSB0aGUgdGVtcGxhdGUgcGFyc2VyIHRvIGZpbmRcbiAgICogdG9rZW5zIGluIHRlbXBsYXRlIHN0cmluZ3MuXG4gICAqL1xuICBmdW5jdGlvbiBTY2FubmVyIChzdHJpbmcpIHtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLnRhaWwgPSBzdHJpbmc7XG4gICAgdGhpcy5wb3MgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSB0YWlsIGlzIGVtcHR5IChlbmQgb2Ygc3RyaW5nKS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLmVvcyA9IGZ1bmN0aW9uIGVvcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFpbCA9PT0gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWVzIHRvIG1hdGNoIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqIFJldHVybnMgdGhlIG1hdGNoZWQgdGV4dCBpZiBpdCBjYW4gbWF0Y2gsIHRoZSBlbXB0eSBzdHJpbmcgb3RoZXJ3aXNlLlxuICAgKi9cbiAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbiA9IGZ1bmN0aW9uIHNjYW4gKHJlKSB7XG4gICAgdmFyIG1hdGNoID0gdGhpcy50YWlsLm1hdGNoKHJlKTtcblxuICAgIGlmICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggIT09IDApXG4gICAgICByZXR1cm4gJyc7XG5cbiAgICB2YXIgc3RyaW5nID0gbWF0Y2hbMF07XG5cbiAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpO1xuICAgIHRoaXMucG9zICs9IHN0cmluZy5sZW5ndGg7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTa2lwcyBhbGwgdGV4dCB1bnRpbCB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGNhbiBiZSBtYXRjaGVkLiBSZXR1cm5zXG4gICAqIHRoZSBza2lwcGVkIHN0cmluZywgd2hpY2ggaXMgdGhlIGVudGlyZSB0YWlsIGlmIG5vIG1hdGNoIGNhbiBiZSBtYWRlLlxuICAgKi9cbiAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblVudGlsID0gZnVuY3Rpb24gc2NhblVudGlsIChyZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudGFpbC5zZWFyY2gocmUpLCBtYXRjaDtcblxuICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICBjYXNlIC0xOlxuICAgICAgbWF0Y2ggPSB0aGlzLnRhaWw7XG4gICAgICB0aGlzLnRhaWwgPSAnJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMDpcbiAgICAgIG1hdGNoID0gJyc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbWF0Y2ggPSB0aGlzLnRhaWwuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoaW5kZXgpO1xuICAgIH1cblxuICAgIHRoaXMucG9zICs9IG1hdGNoLmxlbmd0aDtcblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHJlbmRlcmluZyBjb250ZXh0IGJ5IHdyYXBwaW5nIGEgdmlldyBvYmplY3QgYW5kXG4gICAqIG1haW50YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgY29udGV4dC5cbiAgICovXG4gIGZ1bmN0aW9uIENvbnRleHQgKHZpZXcsIHBhcmVudENvbnRleHQpIHtcbiAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIHRoaXMuY2FjaGUgPSB7ICcuJzogdGhpcy52aWV3IH07XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRDb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29udGV4dCB1c2luZyB0aGUgZ2l2ZW4gdmlldyB3aXRoIHRoaXMgY29udGV4dFxuICAgKiBhcyB0aGUgcGFyZW50LlxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKHZpZXcpIHtcbiAgICByZXR1cm4gbmV3IENvbnRleHQodmlldywgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBuYW1lIGluIHRoaXMgY29udGV4dCwgdHJhdmVyc2luZ1xuICAgKiB1cCB0aGUgY29udGV4dCBoaWVyYXJjaHkgaWYgdGhlIHZhbHVlIGlzIGFic2VudCBpbiB0aGlzIGNvbnRleHQncyB2aWV3LlxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gbG9va3VwIChuYW1lKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcblxuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHZhbHVlID0gY2FjaGVbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgbmFtZXMsIGluZGV4LCBsb29rdXBIaXQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignLicpID4gMCkge1xuICAgICAgICAgIHZhbHVlID0gY29udGV4dC52aWV3O1xuICAgICAgICAgIG5hbWVzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgIGluZGV4ID0gMDtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVzaW5nIHRoZSBkb3Qgbm90aW9uIHBhdGggaW4gYG5hbWVgLCB3ZSBkZXNjZW5kIHRocm91Z2ggdGhlXG4gICAgICAgICAgICogbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUbyBiZSBjZXJ0YWluIHRoYXQgdGhlIGxvb2t1cCBoYXMgYmVlbiBzdWNjZXNzZnVsLCB3ZSBoYXZlIHRvXG4gICAgICAgICAgICogY2hlY2sgaWYgdGhlIGxhc3Qgb2JqZWN0IGluIHRoZSBwYXRoIGFjdHVhbGx5IGhhcyB0aGUgcHJvcGVydHlcbiAgICAgICAgICAgKiB3ZSBhcmUgbG9va2luZyBmb3IuIFdlIHN0b3JlIHRoZSByZXN1bHQgaW4gYGxvb2t1cEhpdGAuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUaGlzIGlzIHNwZWNpYWxseSBuZWNlc3NhcnkgZm9yIHdoZW4gdGhlIHZhbHVlIGhhcyBiZWVuIHNldCB0b1xuICAgICAgICAgICAqIGB1bmRlZmluZWRgIGFuZCB3ZSB3YW50IHRvIGF2b2lkIGxvb2tpbmcgdXAgcGFyZW50IGNvbnRleHRzLlxuICAgICAgICAgICAqKi9cbiAgICAgICAgICB3aGlsZSAodmFsdWUgIT0gbnVsbCAmJiBpbmRleCA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBuYW1lcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICBsb29rdXBIaXQgPSBoYXNQcm9wZXJ0eSh2YWx1ZSwgbmFtZXNbaW5kZXhdKTtcblxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtuYW1lc1tpbmRleCsrXV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gY29udGV4dC52aWV3W25hbWVdO1xuICAgICAgICAgIGxvb2t1cEhpdCA9IGhhc1Byb3BlcnR5KGNvbnRleHQudmlldywgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9va3VwSGl0KVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgY2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpXG4gICAgICB2YWx1ZSA9IHZhbHVlLmNhbGwodGhpcy52aWV3KTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQSBXcml0ZXIga25vd3MgaG93IHRvIHRha2UgYSBzdHJlYW0gb2YgdG9rZW5zIGFuZCByZW5kZXIgdGhlbSB0byBhXG4gICAqIHN0cmluZywgZ2l2ZW4gYSBjb250ZXh0LiBJdCBhbHNvIG1haW50YWlucyBhIGNhY2hlIG9mIHRlbXBsYXRlcyB0b1xuICAgKiBhdm9pZCB0aGUgbmVlZCB0byBwYXJzZSB0aGUgc2FtZSB0ZW1wbGF0ZSB0d2ljZS5cbiAgICovXG4gIGZ1bmN0aW9uIFdyaXRlciAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgY2FjaGVkIHRlbXBsYXRlcyBpbiB0aGlzIHdyaXRlci5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUgKCkge1xuICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHRva2Vuc1xuICAgKiB0aGF0IGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBwYXJzZS5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICAgIHZhciB0b2tlbnMgPSBjYWNoZVt0ZW1wbGF0ZV07XG5cbiAgICBpZiAodG9rZW5zID09IG51bGwpXG4gICAgICB0b2tlbnMgPSBjYWNoZVt0ZW1wbGF0ZV0gPSBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0YWdzKTtcblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZ2gtbGV2ZWwgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgd2l0aFxuICAgKiB0aGUgZ2l2ZW4gYHZpZXdgLlxuICAgKlxuICAgKiBUaGUgb3B0aW9uYWwgYHBhcnRpYWxzYCBhcmd1bWVudCBtYXkgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlXG4gICAqIG5hbWVzIGFuZCB0ZW1wbGF0ZXMgb2YgcGFydGlhbHMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGVtcGxhdGUuIEl0IG1heVxuICAgKiBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGxvYWQgcGFydGlhbCB0ZW1wbGF0ZXMgb24gdGhlIGZseVxuICAgKiB0aGF0IHRha2VzIGEgc2luZ2xlIGFyZ3VtZW50OiB0aGUgbmFtZSBvZiB0aGUgcGFydGlhbC5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpIHtcbiAgICB2YXIgdG9rZW5zID0gdGhpcy5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgdmFyIGNvbnRleHQgPSAodmlldyBpbnN0YW5jZW9mIENvbnRleHQpID8gdmlldyA6IG5ldyBDb250ZXh0KHZpZXcpO1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbnMsIGNvbnRleHQsIHBhcnRpYWxzLCB0ZW1wbGF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvdy1sZXZlbCBtZXRob2QgdGhhdCByZW5kZXJzIHRoZSBnaXZlbiBhcnJheSBvZiBgdG9rZW5zYCB1c2luZ1xuICAgKiB0aGUgZ2l2ZW4gYGNvbnRleHRgIGFuZCBgcGFydGlhbHNgLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgYG9yaWdpbmFsVGVtcGxhdGVgIGlzIG9ubHkgZXZlciB1c2VkIHRvIGV4dHJhY3QgdGhlIHBvcnRpb25cbiAgICogb2YgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRoYXQgd2FzIGNvbnRhaW5lZCBpbiBhIGhpZ2hlci1vcmRlciBzZWN0aW9uLlxuICAgKiBJZiB0aGUgdGVtcGxhdGUgZG9lc24ndCB1c2UgaGlnaGVyLW9yZGVyIHNlY3Rpb25zLCB0aGlzIGFyZ3VtZW50IG1heVxuICAgKiBiZSBvbWl0dGVkLlxuICAgKi9cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJUb2tlbnMgPSBmdW5jdGlvbiByZW5kZXJUb2tlbnMgKHRva2VucywgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgYnVmZmVyID0gJyc7XG5cbiAgICB2YXIgdG9rZW4sIHN5bWJvbCwgdmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIHN5bWJvbCA9IHRva2VuWzBdO1xuXG4gICAgICBpZiAoc3ltYm9sID09PSAnIycpIHZhbHVlID0gdGhpcy5yZW5kZXJTZWN0aW9uKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICdeJykgdmFsdWUgPSB0aGlzLnJlbmRlckludmVydGVkKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICc+JykgdmFsdWUgPSB0aGlzLnJlbmRlclBhcnRpYWwodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJyYnKSB2YWx1ZSA9IHRoaXMudW5lc2NhcGVkVmFsdWUodG9rZW4sIGNvbnRleHQpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnbmFtZScpIHZhbHVlID0gdGhpcy5lc2NhcGVkVmFsdWUodG9rZW4sIGNvbnRleHQpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAndGV4dCcpIHZhbHVlID0gdGhpcy5yYXdWYWx1ZSh0b2tlbik7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBidWZmZXIgKz0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlclNlY3Rpb24gPSBmdW5jdGlvbiByZW5kZXJTZWN0aW9uICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGJ1ZmZlciA9ICcnO1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZW5kZXIgYW4gYXJiaXRyYXJ5IHRlbXBsYXRlXG4gICAgLy8gaW4gdGhlIGN1cnJlbnQgY29udGV4dCBieSBoaWdoZXItb3JkZXIgc2VjdGlvbnMuXG4gICAgZnVuY3Rpb24gc3ViUmVuZGVyICh0ZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIHNlbGYucmVuZGVyKHRlbXBsYXRlLCBjb250ZXh0LCBwYXJ0aWFscyk7XG4gICAgfVxuXG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKHZhciBqID0gMCwgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGogPCB2YWx1ZUxlbmd0aDsgKytqKSB7XG4gICAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlW2pdKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUZW1wbGF0ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBoaWdoZXItb3JkZXIgc2VjdGlvbnMgd2l0aG91dCB0aGUgb3JpZ2luYWwgdGVtcGxhdGUnKTtcblxuICAgICAgLy8gRXh0cmFjdCB0aGUgcG9ydGlvbiBvZiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdGhhdCB0aGUgc2VjdGlvbiBjb250YWlucy5cbiAgICAgIHZhbHVlID0gdmFsdWUuY2FsbChjb250ZXh0LnZpZXcsIG9yaWdpbmFsVGVtcGxhdGUuc2xpY2UodG9rZW5bM10sIHRva2VuWzVdKSwgc3ViUmVuZGVyKTtcblxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJJbnZlcnRlZCA9IGZ1bmN0aW9uIHJlbmRlckludmVydGVkICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG5cbiAgICAvLyBVc2UgSmF2YVNjcmlwdCdzIGRlZmluaXRpb24gb2YgZmFsc3kuIEluY2x1ZGUgZW1wdHkgYXJyYXlzLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg2XG4gICAgaWYgKCF2YWx1ZSB8fCAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSlcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyUGFydGlhbCA9IGZ1bmN0aW9uIHJlbmRlclBhcnRpYWwgKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscykge1xuICAgIGlmICghcGFydGlhbHMpIHJldHVybjtcblxuICAgIHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24ocGFydGlhbHMpID8gcGFydGlhbHModG9rZW5bMV0pIDogcGFydGlhbHNbdG9rZW5bMV1dO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRoaXMucGFyc2UodmFsdWUpLCBjb250ZXh0LCBwYXJ0aWFscywgdmFsdWUpO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUudW5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiB1bmVzY2FwZWRWYWx1ZSAodG9rZW4sIGNvbnRleHQpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiBlc2NhcGVkVmFsdWUgKHRva2VuLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIG11c3RhY2hlLmVzY2FwZSh2YWx1ZSk7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yYXdWYWx1ZSA9IGZ1bmN0aW9uIHJhd1ZhbHVlICh0b2tlbikge1xuICAgIHJldHVybiB0b2tlblsxXTtcbiAgfTtcblxuICBtdXN0YWNoZS5uYW1lID0gJ211c3RhY2hlLmpzJztcbiAgbXVzdGFjaGUudmVyc2lvbiA9ICcyLjIuMCc7XG4gIG11c3RhY2hlLnRhZ3MgPSBbICd7eycsICd9fScgXTtcblxuICAvLyBBbGwgaGlnaC1sZXZlbCBtdXN0YWNoZS4qIGZ1bmN0aW9ucyB1c2UgdGhpcyB3cml0ZXIuXG4gIHZhciBkZWZhdWx0V3JpdGVyID0gbmV3IFdyaXRlcigpO1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhlIGRlZmF1bHQgd3JpdGVyLlxuICAgKi9cbiAgbXVzdGFjaGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUgKCkge1xuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLmNsZWFyQ2FjaGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIHRlbXBsYXRlIGluIHRoZSBkZWZhdWx0IHdyaXRlciBhbmQgcmV0dXJucyB0aGVcbiAgICogYXJyYXkgb2YgdG9rZW5zIGl0IGNvbnRhaW5zLiBEb2luZyB0aGlzIGFoZWFkIG9mIHRpbWUgYXZvaWRzIHRoZSBuZWVkIHRvXG4gICAqIHBhcnNlIHRlbXBsYXRlcyBvbiB0aGUgZmx5IGFzIHRoZXkgYXJlIHJlbmRlcmVkLlxuICAgKi9cbiAgbXVzdGFjaGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5wYXJzZSh0ZW1wbGF0ZSwgdGFncyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGB0ZW1wbGF0ZWAgd2l0aCB0aGUgZ2l2ZW4gYHZpZXdgIGFuZCBgcGFydGlhbHNgIHVzaW5nIHRoZVxuICAgKiBkZWZhdWx0IHdyaXRlci5cbiAgICovXG4gIG11c3RhY2hlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdGVtcGxhdGUhIFRlbXBsYXRlIHNob3VsZCBiZSBhIFwic3RyaW5nXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdidXQgXCInICsgdHlwZVN0cih0ZW1wbGF0ZSkgKyAnXCIgd2FzIGdpdmVuIGFzIHRoZSBmaXJzdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FyZ3VtZW50IGZvciBtdXN0YWNoZSNyZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKScpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLnJlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpO1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAwLjQueC4sXG4gIC8qZXNsaW50LWRpc2FibGUgKi8gLy8gZXNsaW50IHdhbnRzIGNhbWVsIGNhc2VkIGZ1bmN0aW9uIG5hbWVcbiAgbXVzdGFjaGUudG9faHRtbCA9IGZ1bmN0aW9uIHRvX2h0bWwgKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscywgc2VuZCkge1xuICAgIC8qZXNsaW50LWVuYWJsZSovXG5cbiAgICB2YXIgcmVzdWx0ID0gbXVzdGFjaGUucmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscyk7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihzZW5kKSkge1xuICAgICAgc2VuZChyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIGVzY2FwaW5nIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIHVzZXIgbWF5IG92ZXJyaWRlIGl0LlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzI0NFxuICBtdXN0YWNoZS5lc2NhcGUgPSBlc2NhcGVIdG1sO1xuXG4gIC8vIEV4cG9ydCB0aGVzZSBtYWlubHkgZm9yIHRlc3RpbmcsIGJ1dCBhbHNvIGZvciBhZHZhbmNlZCB1c2FnZS5cbiAgbXVzdGFjaGUuU2Nhbm5lciA9IFNjYW5uZXI7XG4gIG11c3RhY2hlLkNvbnRleHQgPSBDb250ZXh0O1xuICBtdXN0YWNoZS5Xcml0ZXIgPSBXcml0ZXI7XG5cbn0pKTtcbiIsIi8qIG9iamVjdC1pdGVyYXRvcnMuanMgLSBNaW5pIFVuZGVyc2NvcmUgbGlicmFyeVxuICogYnkgSm9uYXRoYW4gRWl0ZW5cbiAqXG4gKiBUaGUgbWV0aG9kcyBiZWxvdyBvcGVyYXRlIG9uIG9iamVjdHMgKGJ1dCBub3QgYXJyYXlzKSBzaW1pbGFybHlcbiAqIHRvIFVuZGVyc2NvcmUgKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNjb2xsZWN0aW9ucykuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb246XG4gKiBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L29iamVjdC1pdGVyYXRvcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3VtbWFyeSBXcmFwIGFuIG9iamVjdCBmb3Igb25lIG1ldGhvZCBjYWxsLlxuICogQERlc2MgTm90ZSB0aGF0IHRoZSBgbmV3YCBrZXl3b3JkIGlzIG5vdCBuZWNlc3NhcnkuXG4gKiBAcGFyYW0ge29iamVjdHxudWxsfHVuZGVmaW5lZH0gb2JqZWN0IC0gYG51bGxgIG9yIGB1bmRlZmluZWRgIGlzIHRyZWF0ZWQgYXMgYW4gZW1wdHkgcGxhaW4gb2JqZWN0LlxuICogQHJldHVybiB7V3JhcHBlcn0gVGhlIHdyYXBwZWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBXcmFwcGVyKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBXcmFwcGVyKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcmFwcGVyKSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyYXBwZXIob2JqZWN0KTtcbiAgICB9XG4gICAgdGhpcy5vcmlnaW5hbFZhbHVlID0gb2JqZWN0O1xuICAgIHRoaXMubyA9IG9iamVjdCB8fCB7fTtcbn1cblxuLyoqXG4gKiBAbmFtZSBXcmFwcGVyLmNoYWluXG4gKiBAc3VtbWFyeSBXcmFwIGFuIG9iamVjdCBmb3IgYSBjaGFpbiBvZiBtZXRob2QgY2FsbHMuXG4gKiBARGVzYyBDYWxscyB0aGUgY29uc3RydWN0b3IgYFdyYXBwZXIoKWAgYW5kIG1vZGlmaWVzIHRoZSB3cmFwcGVyIGZvciBjaGFpbmluZy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge1dyYXBwZXJ9IFRoZSB3cmFwcGVkIG9iamVjdC5cbiAqL1xuV3JhcHBlci5jaGFpbiA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgd3JhcHBlZCA9IFdyYXBwZXIob2JqZWN0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgd3JhcHBlZC5jaGFpbmluZyA9IHRydWU7XG4gICAgcmV0dXJuIHdyYXBwZWQ7XG59O1xuXG5XcmFwcGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBVbndyYXAgYW4gb2JqZWN0IHdyYXBwZWQgd2l0aCB7QGxpbmsgV3JhcHBlci5jaGFpbnxXcmFwcGVyLmNoYWluKCl9LlxuICAgICAqIEByZXR1cm4ge29iamVjdHxudWxsfHVuZGVmaW5lZH0gVGhlIHZhbHVlIG9yaWdpbmFsbHkgd3JhcHBlZCBieSB0aGUgY29uc3RydWN0b3IuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbZWFjaF0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI2VhY2gpIG1ldGhvZDogSXRlcmF0ZSBvdmVyIHRoZSBtZW1iZXJzIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgY2FsbGluZyBgaXRlcmF0ZWUoKWAgd2l0aCBlYWNoLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gRm9yIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6IGAodmFsdWUsIGtleSwgb2JqZWN0KWAuIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiBpcyB1bmRlZmluZWQ7IGFuIGAuZWFjaGAgbG9vcCBjYW5ub3QgYmUgYnJva2VuIG91dCBvZiAodXNlIHtAbGluayBXcmFwcGVyI2ZpbmR8LmZpbmR9IGluc3RlYWQpLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byB0aGlzIG9iamVjdC4gSW4gb3RoZXIgd29yZHMsIHRoaXMgb2JqZWN0IGJlY29tZXMgdGhlIGB0aGlzYCB2YWx1ZSBpbiB0aGUgY2FsbHMgdG8gYGl0ZXJhdGVlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHtXcmFwcGVyfSBUaGUgd3JhcHBlZCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGVhY2g6IGZ1bmN0aW9uIChpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgbyA9IHRoaXMubztcbiAgICAgICAgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpdGVyYXRlZS5jYWxsKHRoaXMsIG9ba2V5XSwga2V5LCBvKTtcbiAgICAgICAgfSwgY29udGV4dCB8fCBvKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW2ZpbmRdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNmaW5kKSBtZXRob2Q6IExvb2sgdGhyb3VnaCBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHJldHVybmluZyB0aGUgZmlyc3Qgb25lIHRoYXQgcGFzc2VzIGEgdHJ1dGggdGVzdCAoYHByZWRpY2F0ZWApLCBvciBgdW5kZWZpbmVkYCBpZiBubyB2YWx1ZSBwYXNzZXMgdGhlIHRlc3QuIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgYWNjZXB0YWJsZSBtZW1iZXIsIGFuZCBkb2Vzbid0IG5lY2Vzc2FyaWx5IHRyYXZlcnNlIHRoZSBlbnRpcmUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZSAtIEZvciBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOiBgKHZhbHVlLCBrZXksIG9iamVjdClgLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHRydXRoeSBpZiB0aGUgbWVtYmVyIHBhc3NlcyB0aGUgdGVzdCBhbmQgZmFsc3kgb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYHByZWRpY2F0ZWAgaXMgYm91bmQgdG8gdGhpcyBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG9iamVjdCBiZWNvbWVzIHRoZSBgdGhpc2AgdmFsdWUgaW4gdGhlIGNhbGxzIHRvIGBwcmVkaWNhdGVgLiAoT3RoZXJ3aXNlLCB0aGUgYHRoaXNgIHZhbHVlIHdpbGwgYmUgdGhlIHVud3JhcHBlZCBvYmplY3QuKVxuICAgICAqIEByZXR1cm4geyp9IFRoZSBmb3VuZCBwcm9wZXJ0eSdzIHZhbHVlLCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGZpbmQ6IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBPYmplY3Qua2V5cyhvKS5maW5kKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlLmNhbGwodGhpcywgb1trZXldLCBrZXksIG8pO1xuICAgICAgICAgICAgfSwgY29udGV4dCB8fCBvKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9bcmVzdWx0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNaW1pY3MgVW5kZXJzY29yZSdzIFtmaWx0ZXJdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNmaWx0ZXIpIG1ldGhvZDogTG9vayB0aHJvdWdoIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgcmV0dXJuaW5nIHRoZSB2YWx1ZXMgb2YgYWxsIG1lbWJlcnMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdCAoYHByZWRpY2F0ZWApLCBvciBlbXB0eSBhcnJheSBpZiBubyB2YWx1ZSBwYXNzZXMgdGhlIHRlc3QuIFRoZSBmdW5jdGlvbiBhbHdheXMgdHJhdmVyc2VzIHRoZSBlbnRpcmUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZSAtIEZvciBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOiBgKHZhbHVlLCBrZXksIG9iamVjdClgLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHRydXRoeSBpZiB0aGUgbWVtYmVyIHBhc3NlcyB0aGUgdGVzdCBhbmQgZmFsc3kgb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYHByZWRpY2F0ZWAgaXMgYm91bmQgdG8gdGhpcyBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG9iamVjdCBiZWNvbWVzIHRoZSBgdGhpc2AgdmFsdWUgaW4gdGhlIGNhbGxzIHRvIGBwcmVkaWNhdGVgLiAoT3RoZXJ3aXNlLCB0aGUgYHRoaXNgIHZhbHVlIHdpbGwgYmUgdGhlIHVud3JhcHBlZCBvYmplY3QuKVxuICAgICAqIEByZXR1cm4geyp9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbCh0aGlzLCBvW2tleV0sIGtleSwgbykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjb250ZXh0IHx8IG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW21hcF0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI21hcCkgbWV0aG9kOiBQcm9kdWNlcyBhIG5ldyBhcnJheSBvZiB2YWx1ZXMgYnkgbWFwcGluZyBlYWNoIHZhbHVlIGluIGxpc3QgdGhyb3VnaCBhIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIChgaXRlcmF0ZWVgKS4gVGhlIGZ1bmN0aW9uIGFsd2F5cyB0cmF2ZXJzZXMgdGhlIGVudGlyZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBGb3IgZWFjaCBtZW1iZXIgb2YgdGhlIHdyYXBwZWQgb2JqZWN0LCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogYCh2YWx1ZSwga2V5LCBvYmplY3QpYC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIGNvbmNhdGVuYXRlZCB0byB0aGUgZW5kIG9mIHRoZSBuZXcgYXJyYXkuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIElmIGdpdmVuLCBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIHRoaXMgb2JqZWN0LiBJbiBvdGhlciB3b3JkcywgdGhpcyBvYmplY3QgYmVjb21lcyB0aGUgYHRoaXNgIHZhbHVlIGluIHRoZSBjYWxscyB0byBgcHJlZGljYXRlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHsqfSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgbWFwOiBmdW5jdGlvbiAoaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZXJhdGVlLmNhbGwodGhpcywgb1trZXldLCBrZXksIG8pKTtcbiAgICAgICAgICAgIH0sIGNvbnRleHQgfHwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbcmVkdWNlXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jcmVkdWNlKSBtZXRob2Q6IEJvaWwgZG93biB0aGUgdmFsdWVzIG9mIGFsbCB0aGUgbWVtYmVycyBvZiB0aGUgd3JhcHBlZCBvYmplY3QgaW50byBhIHNpbmdsZSB2YWx1ZS4gYG1lbW9gIGlzIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24sIGFuZCBlYWNoIHN1Y2Nlc3NpdmUgc3RlcCBvZiBpdCBzaG91bGQgYmUgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlKClgLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gRm9yIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogYChtZW1vLCB2YWx1ZSwga2V5LCBvYmplY3QpYC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgdGhlIG5ldyB2YWx1ZSBvZiBgbWVtb2AgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFttZW1vXSAtIElmIG5vIG1lbW8gaXMgcGFzc2VkIHRvIHRoZSBpbml0aWFsIGludm9jYXRpb24gb2YgcmVkdWNlLCB0aGUgaXRlcmF0ZWUgaXMgbm90IGludm9rZWQgb24gdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3QuIFRoZSBmaXJzdCBlbGVtZW50IGlzIGluc3RlYWQgcGFzc2VkIGFzIHRoZSBtZW1vIGluIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBpdGVyYXRlZSBvbiB0aGUgbmV4dCBlbGVtZW50IGluIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byB0aGlzIG9iamVjdC4gSW4gb3RoZXIgd29yZHMsIHRoaXMgb2JqZWN0IGJlY29tZXMgdGhlIGB0aGlzYCB2YWx1ZSBpbiB0aGUgY2FsbHMgdG8gYGl0ZXJhdGVlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgb2YgYG1lbW9gIFwicmVkdWNlZFwiIGFzIHBlciBgaXRlcmF0ZWVgLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlZHVjZTogZnVuY3Rpb24gKGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpZHgpIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gKCFpZHggJiYgbWVtbyA9PT0gdW5kZWZpbmVkKSA/IG9ba2V5XSA6IGl0ZXJhdGVlKG1lbW8sIG9ba2V5XSwga2V5LCBvKTtcbiAgICAgICAgICAgIH0sIGNvbnRleHQgfHwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW2V4dGVuZF0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI2V4dGVuZCkgbWV0aG9kOiBDb3B5IGFsbCBvZiB0aGUgcHJvcGVydGllcyBpbiBlYWNoIG9mIHRoZSBgc291cmNlYCBvYmplY3QgcGFyYW1ldGVyKHMpIG92ZXIgdG8gdGhlICh3cmFwcGVkKSBkZXN0aW5hdGlvbiBvYmplY3QgKHRodXMgbXV0YXRpbmcgaXQpLiBJdCdzIGluLW9yZGVyLCBzbyB0aGUgcHJvcGVydGllcyBvZiB0aGUgbGFzdCBgc291cmNlYCBvYmplY3Qgd2lsbCBvdmVycmlkZSBwcm9wZXJ0aWVzIHdpdGggdGhlIHNhbWUgbmFtZSBpbiBwcmV2aW91cyBhcmd1bWVudHMgb3IgaW4gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiA+IFRoaXMgbWV0aG9kIGNvcGllcyBvd24gbWVtYmVycyBhcyB3ZWxsIGFzIG1lbWJlcnMgaW5oZXJpdGVkIGZyb20gcHJvdG90eXBlIGNoYWluLlxuICAgICAqIEBwYXJhbSB7Li4ub2JqZWN0fG51bGx8dW5kZWZpbmVkfSBzb3VyY2UgLSBWYWx1ZXMgb2YgYG51bGxgIG9yIGB1bmRlZmluZWRgIGFyZSB0cmVhdGVkIGFzIGVtcHR5IHBsYWluIG9iamVjdHMuXG4gICAgICogQHJldHVybiB7V3JhcHBlcnxvYmplY3R9IFRoZSB3cmFwcGVkIGRlc3RpbmF0aW9uIG9iamVjdCBpZiBjaGFpbmluZyBpcyBpbiBlZmZlY3Q7IG90aGVyd2lzZSB0aGUgdW53cmFwcGVkIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBleHRlbmQ6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZm9yRWFjaChmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBvW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFpbmluZyA/IHRoaXMgOiBvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNaW1pY3MgVW5kZXJzY29yZSdzIFtleHRlbmRPd25dKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNleHRlbmRPd24pIG1ldGhvZDogTGlrZSB7QGxpbmsgV3JhcHBlciNleHRlbmR8ZXh0ZW5kfSwgYnV0IG9ubHkgY29waWVzIGl0cyBcIm93blwiIHByb3BlcnRpZXMgb3ZlciB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4ub2JqZWN0fG51bGx8dW5kZWZpbmVkfSBzb3VyY2UgLSBWYWx1ZXMgb2YgYG51bGxgIG9yIGB1bmRlZmluZWRgIGFyZSB0cmVhdGVkIGFzIGVtcHR5IHBsYWluIG9iamVjdHMuXG4gICAgICogQHJldHVybiB7V3JhcHBlcnxvYmplY3R9IFRoZSB3cmFwcGVkIGRlc3RpbmF0aW9uIG9iamVjdCBpZiBjaGFpbmluZyBpcyBpbiBlZmZlY3Q7IG90aGVyd2lzZSB0aGUgdW53cmFwcGVkIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBleHRlbmRPd246IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZm9yRWFjaChmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICBXcmFwcGVyKG9iamVjdCkuZWFjaChmdW5jdGlvbiAodmFsLCBrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgICAgICAgICAgICAgb1trZXldID0gdmFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFpbmluZyA/IHRoaXMgOiBvO1xuICAgIH1cbn07XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbmRcbmlmICghQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1leHRlbmQtbmF0aXZlXG4gICAgICAgIGlmICh0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmluZCBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGggPj4+IDA7XG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpLCBsaXN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV3JhcHBlcjtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSRUdFWFBfSU5ESVJFQ1RJT04gPSAvXihcXHcrKVxcKChcXHcrKVxcKSQvOyAgLy8gZmluZHMgY29tcGxldGUgcGF0dGVybiBhKGIpIHdoZXJlIGJvdGggYSBhbmQgYiBhcmUgcmVnZXggXCJ3b3Jkc1wiXG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSB2YWx1ZUl0ZW1cbiAqIFlvdSBzaG91bGQgc3VwcGx5IGJvdGggYG5hbWVgIGFuZCBgYWxpYXNgIGJ1dCB5b3UgY291bGQgb21pdCBvbmUgb3IgdGhlIG90aGVyIGFuZCB3aGljaGV2ZXIgeW91IHByb3ZpZGUgd2lsbCBiZSB1c2VkIGZvciBib3RoLlxuICogPiBJZiB5b3Ugb25seSBnaXZlIHRoZSBgbmFtZWAgcHJvcGVydHksIHlvdSBtaWdodCBhcyB3ZWxsIGp1c3QgZ2l2ZSBhIHN0cmluZyBmb3Ige0BsaW5rIG1lbnVJdGVtfSByYXRoZXIgdGhhbiB0aGlzIG9iamVjdC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZT1hbGlhc10gLSBWYWx1ZSBvZiBgdmFsdWVgIGF0dHJpYnV0ZSBvZiBgPG9wdGlvbj4uLi48L29wdGlvbj5gIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2FsaWFzPW5hbWVdIC0gVGV4dCBvZiBgPG9wdGlvbj4uLi48L29wdGlvbj5gIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGVdIE9uZSBvZiB0aGUga2V5cyBvZiBgdGhpcy5jb252ZXJ0ZXJzYC4gSWYgbm90IG9uZSBvZiB0aGVzZSAoaW5jbHVkaW5nIGB1bmRlZmluZWRgKSwgZmllbGQgdmFsdWVzIHdpbGwgYmUgdGVzdGVkIHdpdGggYSBzdHJpbmcgY29tcGFyaXNvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2hpZGRlbj1mYWxzZV1cbiAqL1xuXG4vKiogQHR5cGVkZWYge29iamVjdHxtZW51SXRlbVtdfSBzdWJtZW51SXRlbVxuICogQHN1bW1hcnkgSGllcmFyY2hpY2FsIGFycmF5IG9mIHNlbGVjdCBsaXN0IGl0ZW1zLlxuICogQGRlc2MgRGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIHRoZSBsaXN0IG9mIGA8b3B0aW9uPi4uLjwvb3B0aW9uPmAgYW5kIGA8b3B0Z3JvdXA+Li4uPC9vcHRncm91cD5gIGVsZW1lbnRzIHRoYXQgbWFrZSB1cCBhIGA8c2VsZWN0Pi4uLjwvc2VsZWN0PmAgZWxlbWVudC5cbiAqXG4gKiA+IEFsdGVybmF0ZSBmb3JtOiBJbnN0ZWFkIG9mIGFuIG9iamVjdCB3aXRoIGEgYG1lbnVgIHByb3BlcnR5IGNvbnRhaW5pbmcgYW4gYXJyYXksIG1heSBpdHNlbGYgYmUgdGhhdCBhcnJheS4gQm90aCBmb3JtcyBoYXZlIHRoZSBvcHRpb25hbCBgbGFiZWxgIHByb3BlcnR5LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYWJlbF0gLSBEZWZhdWx0cyB0byBhIGdlbmVyYXRlZCBzdHJpbmcgb2YgdGhlIGZvcm0gXCJHcm91cCBuWy5tXS4uLlwiIHdoZXJlIGVhY2ggZGVjaW1hbCBwb3NpdGlvbiByZXByZXNlbnRzIGEgbGV2ZWwgb2YgdGhlIG9wdGdyb3VwIGhpZXJhcmNoeS5cbiAqIEBwcm9wZXJ0eSB7bWVudUl0ZW1bXX0gc3VibWVudVxuICovXG5cbi8qKiBAdHlwZWRlZiB7c3RyaW5nfHZhbHVlSXRlbXxzdWJtZW51SXRlbX0gbWVudUl0ZW1cbiAqIE1heSBiZSBvbmUgb2YgdGhyZWUgcG9zc2libGUgdHlwZXMgdGhhdCBzcGVjaWZ5IGVpdGhlciBhbiBgPG9wdGlvbj4uLi4uPC9vcHRpb24+YCBlbGVtZW50IG9yIGFuIGA8b3B0Z3JvdXA+Li4uLjwvb3B0Z3JvdXA+YCBlbGVtZW50IGFzIGZvbGxvd3M6XG4gKiAqIElmIGEgYHN0cmluZ2AsIHNwZWNpZmllcyB0aGUgdGV4dCBvZiBhbiBgPG9wdGlvbj4uLi4uPC9vcHRpb24+YCBlbGVtZW50IHdpdGggbm8gYHZhbHVlYCBhdHRyaWJ1dGUuIChJbiB0aGUgYWJzZW5jZSBvZiBhIGB2YWx1ZWAgYXR0cmlidXRlLCB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBvZiB0aGUgZWxlbWVudCBkZWZhdWx0cyB0byB0aGUgdGV4dC4pXG4gKiAqIElmIHNoYXBlZCBsaWtlIGEge0BsaW5rIHZhbHVlSXRlbX0gb2JqZWN0LCBzcGVjaWZpZXMgYm90aCB0aGUgdGV4dCBhbmQgdmFsdWUgb2YgYW4gYDxvcHRpb24uLi4uPC9vcHRpb24+YCBlbGVtZW50LlxuICogKiBJZiBzaGFwZWQgbGlrZSBhIHtAbGluayBzdWJtZW51SXRlbX0gb2JqZWN0IChvciBpdHMgYWx0ZXJuYXRlIGFycmF5IGZvcm0pLCBzcGVjaWZpZXMgYW4gYDxvcHRncm91cD4uLi4uPC9vcHRncm91cD5gIGVsZW1lbnQuXG4gKi9cblxuLyoqXG4gKiBAc3VtbWFyeSBCdWlsZHMgYSBuZXcgbWVudSBwcmUtcG9wdWxhdGVkIHdpdGggaXRlbXMgYW5kIGdyb3Vwcy5cbiAqIEBkZXNjIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIG5ldyBwb3AtdXAgbWVudSAoYS5rLmEuIFwiZHJvcC1kb3duXCIpLiBUaGlzIGlzIGEgYDxzZWxlY3Q+Li4uPC9zZWxlY3Q+YCBlbGVtZW50LCBwcmUtcG9wdWxhdGVkIHdpdGggaXRlbXMgKGA8b3B0aW9uPi4uLjwvb3B0aW9uPmAgZWxlbWVudHMpIGFuZCBncm91cHMgKGA8b3B0Z3JvdXA+Li4uPC9vcHRncm91cD5gIGVsZW1lbnRzKS5cbiAqID4gQm9udXM6IFRoaXMgZnVuY3Rpb24gYWxzbyBidWlsZHMgYGlucHV0IHR5cGU9dGV4dGAgZWxlbWVudHMuXG4gKiA+IE5PVEU6IFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIE9QVEdST1VQIGVsZW1lbnRzIGZvciBzdWJ0cmVlcy4gSG93ZXZlciwgbm90ZSB0aGF0IEhUTUw1IHNwZWNpZmllcyB0aGF0IE9QVEdST1VQIGVsZW1uZW50cyBtYWRlIG5vdCBuZXN0ISBUaGlzIGZ1bmN0aW9uIGdlbmVyYXRlcyB0aGUgbWFya3VwIGZvciB0aGVtIGJ1dCB0aGV5IGFyZSBub3QgcmVuZGVyZWQgYnkgbW9zdCBicm93c2Vycywgb3Igbm90IGNvbXBsZXRlbHkuIFRoZXJlZm9yZSwgZm9yIG5vdywgZG8gbm90IHNwZWNpZnkgbW9yZSB0aGFuIG9uZSBsZXZlbCBzdWJ0cmVlcy4gRnV0dXJlIHZlcnNpb25zIG9mIEhUTUwgbWF5IHN1cHBvcnQgaXQuIEkgYWxzbyBwbGFuIHRvIGFkZCBoZXJlIG9wdGlvbnMgdG8gYXZvaWQgT1BUR1JPVVBTIGVudGlyZWx5IGVpdGhlciBieSBpbmRlbnRpbmcgb3B0aW9uIHRleHQsIG9yIGJ5IGNyZWF0aW5nIGFsdGVybmF0ZSBET00gbm9kZXMgdXNpbmcgYDxsaT5gIGluc3RlYWQgb2YgYDxzZWxlY3Q+YCwgb3IgYm90aC5cbiAqIEBtZW1iZXJPZiBwb3BNZW51XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gZWwgLSBNdXN0IGJlIG9uZSBvZiAoY2FzZS1zZW5zaXRpdmUpOlxuICogKiB0ZXh0IGJveCAtIGFuIGBIVE1MSW5wdXRFbGVtZW50YCB0byB1c2UgYW4gZXhpc3RpbmcgZWxlbWVudCBvciBgJ0lOUFVUJ2AgdG8gY3JlYXRlIGEgbmV3IG9uZVxuICogKiBkcm9wLWRvd24gLSBhbiBgSFRNTFNlbGVjdEVsZW1lbnRgIHRvIHVzZSBhbiBleGlzdGluZyBlbGVtZW50IG9yIGAnU0VMRUNUJ2AgdG8gY3JlYXRlIGEgbmV3IG9uZVxuICogKiBzdWJtZW51IC0gYW4gYEhUTUxPcHRHcm91cEVsZW1lbnRgIHRvIHVzZSBhbiBleGlzdGluZyBlbGVtZW50IG9yIGAnT1BUR1JPVVAnYCB0byBjcmVhdGUgYSBuZXcgb25lIChtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHkpXG4gKlxuICogQHBhcmFtIHttZW51SXRlbVtdfSBbbWVudV0gLSBIaWVyYXJjaGljYWwgbGlzdCBvZiBzdHJpbmdzIHRvIGFkZCBhcyBgPG9wdGlvbj4uLi48L29wdGlvbj5gIG9yIGA8b3B0Z3JvdXA+Li4uLjwvb3B0Z3JvdXA+YCBlbGVtZW50cy4gT21pdHRpbmcgY3JlYXRlcyBhIHRleHQgYm94LlxuICpcbiAqIEBwYXJhbSB7bnVsbHxzdHJpbmd9IFtvcHRpb25zLnByb21wdD0nJ10gLSBBZGRzIGFuIGluaXRpYWwgYDxvcHRpb24+Li4uPC9vcHRpb24+YCBlbGVtZW50IHRvIHRoZSBkcm9wLWRvd24gd2l0aCB0aGlzIHZhbHVlIGluIHBhcmVudGhlc2VzIGFzIGl0cyBgdGV4dGA7IGFuZCBlbXB0eSBzdHJpbmcgYXMgaXRzIGB2YWx1ZWAuIERlZmF1bHQgaXMgZW1wdHkgc3RyaW5nLCB3aGljaCBjcmVhdGVzIGEgYmxhbmsgcHJvbXB0OyBgbnVsbGAgc3VwcHJlc3NlcyBwcm9tcHQgYWx0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNvcnRdIC0gV2hldGhlciB0byBhbHBoYSBzb3J0IG9yIG5vdC4gSWYgdHJ1dGh5LCBzb3J0cyBlYWNoIG9wdGdyb3VwIG9uIGl0cyBgbGFiZWxgOyBhbmQgZWFjaCBzZWxlY3Qgb3B0aW9uIG9uIGl0cyB0ZXh0IChpdHMgYGFsaWFzYCBpZiBnaXZlbjsgb3IgaXRzIGBuYW1lYCBpZiBub3QpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zLmJsYWNrbGlzdF0gLSBPcHRpb25hbCBsaXN0IG9mIG1lbnUgaXRlbSBuYW1lcyB0byBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IFtvcHRpb25zLmJyZWFkY3J1bWJzXSAtIExpc3Qgb2Ygb3B0aW9uIGdyb3VwIHNlY3Rpb24gbnVtYmVycyAocm9vdCBpcyBzZWN0aW9uIDApLiAoRm9yIGludGVybmFsIHVzZS4pXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hcHBlbmQ9ZmFsc2VdIC0gV2hlbiBgZWxgIGlzIGFuIGV4aXN0aW5nIGA8c2VsZWN0PmAgRWxlbWVudCwgZ2l2aW5nIHRydXRoeSB2YWx1ZSBhZGRzIHRoZSBuZXcgY2hpbGRyZW4gd2l0aG91dCBmaXJzdCByZW1vdmluZyBleGlzdGluZyBjaGlsZHJlbi5cbiAqXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gRWl0aGVyIGEgYDxzZWxlY3Q+YCBvciBgPG9wdGdyb3VwPmAgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gYnVpbGQoZWwsIG1lbnUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBwcm9tcHQgPSBvcHRpb25zLnByb21wdCxcbiAgICAgICAgYmxhY2tsaXN0ID0gb3B0aW9ucy5ibGFja2xpc3QsXG4gICAgICAgIHNvcnQgPSBvcHRpb25zLnNvcnQsXG4gICAgICAgIGJyZWFkY3J1bWJzID0gb3B0aW9ucy5icmVhZGNydW1icyB8fCBbXSxcbiAgICAgICAgcGF0aCA9IGJyZWFkY3J1bWJzLmxlbmd0aCA/IGJyZWFkY3J1bWJzLmpvaW4oJy4nKSArICcuJyA6ICcnLFxuICAgICAgICBzdWJ0cmVlTmFtZSA9IHBvcE1lbnUuc3VidHJlZSxcbiAgICAgICAgZ3JvdXBJbmRleCA9IDAsXG4gICAgICAgIHRhZ05hbWU7XG5cbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIHRhZ05hbWUgPSBlbC50YWdOYW1lO1xuICAgICAgICBpZiAoIW9wdGlvbnMuYXBwZW5kKSB7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSAnJzsgLy8gcmVtb3ZlIGFsbCA8b3B0aW9uPiBhbmQgPG9wdGdyb3VwPiBlbGVtZW50c1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFnTmFtZSA9IGVsO1xuICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKG1lbnUpIHtcbiAgICAgICAgdmFyIGFkZCwgbmV3T3B0aW9uO1xuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgICAgIGFkZCA9IGVsLmFkZDtcbiAgICAgICAgICAgIGlmIChwcm9tcHQpIHtcbiAgICAgICAgICAgICAgICBuZXdPcHRpb24gPSBuZXcgT3B0aW9uKHByb21wdCwgJycpO1xuICAgICAgICAgICAgICAgIG5ld09wdGlvbi5pbm5lckhUTUwgKz0gJyZoZWxsaXA7JztcbiAgICAgICAgICAgICAgICBlbC5hZGQobmV3T3B0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvbXB0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZWwuYWRkKG5ldyBPcHRpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGQgPSBlbC5hcHBlbmRDaGlsZDtcbiAgICAgICAgICAgIGVsLmxhYmVsID0gcHJvbXB0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvcnQpIHtcbiAgICAgICAgICAgIG1lbnUgPSBtZW51LnNsaWNlKCkuc29ydChpdGVtQ29tcGFyYXRvcik7IC8vIHNvcnRlZCBjbG9uZVxuICAgICAgICB9XG5cbiAgICAgICAgbWVudS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIC8vIGlmIGl0ZW0gaXMgb2YgZm9ybSBhKGIpIGFuZCB0aGVyZSBpcyBhbiBmdW5jdGlvbiBhIGluIG9wdGlvbnMsIHRoZW4gaXRlbSA9IG9wdGlvbnMuYShiKVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGlyZWN0aW9uID0gaXRlbS5tYXRjaChSRUdFWFBfSU5ESVJFQ1RJT04pO1xuICAgICAgICAgICAgICAgIGlmIChpbmRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGluZGlyZWN0aW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGluZGlyZWN0aW9uWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IG9wdGlvbnNbYV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGYoYik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnYnVpbGQ6IEV4cGVjdGVkIG9wdGlvbnMuJyArIGEgKyAnIHRvIGJlIGEgZnVuY3Rpb24uJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1YnRyZWUgPSBpdGVtW3N1YnRyZWVOYW1lXSB8fCBpdGVtO1xuICAgICAgICAgICAgaWYgKHN1YnRyZWUgaW5zdGFuY2VvZiBBcnJheSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWRjcnVtYnM6IGJyZWFkY3J1bWJzLmNvbmNhdCgrK2dyb3VwSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICBwcm9tcHQ6IGl0ZW0ubGFiZWwgfHwgJ0dyb3VwICcgKyBwYXRoICsgZ3JvdXBJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogc29ydCxcbiAgICAgICAgICAgICAgICAgICAgYmxhY2tsaXN0OiBibGFja2xpc3RcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIG9wdGdyb3VwID0gYnVpbGQoJ09QVEdST1VQJywgc3VidHJlZSwgZ3JvdXBPcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRncm91cC5jaGlsZEVsZW1lbnRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChvcHRncm91cCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoYmxhY2tsaXN0ICYmIGJsYWNrbGlzdC5pbmRleE9mKGl0ZW0pID49IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZC5jYWxsKGVsLCBuZXcgT3B0aW9uKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uaGlkZGVuKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGl0ZW0ubmFtZSB8fCBpdGVtLmFsaWFzO1xuICAgICAgICAgICAgICAgIGlmICghKGJsYWNrbGlzdCAmJiBibGFja2xpc3QuaW5kZXhPZihuYW1lKSA+PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGQuY2FsbChlbCwgbmV3IE9wdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYWxpYXMgfHwgaXRlbS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWwudHlwZSA9ICd0ZXh0JztcbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG59XG5cbmZ1bmN0aW9uIGl0ZW1Db21wYXJhdG9yKGEsIGIpIHtcbiAgICBhID0gYS5hbGlhcyB8fCBhLm5hbWUgfHwgYS5sYWJlbCB8fCBhO1xuICAgIGIgPSBiLmFsaWFzIHx8IGIubmFtZSB8fCBiLmxhYmVsIHx8IGI7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5IFJlY3Vyc2l2ZWx5IHNlYXJjaGVzIHRoZSBjb250ZXh0IGFycmF5IG9mIGBtZW51SXRlbWBzIGZvciBhIG5hbWVkIGBpdGVtYC5cbiAqIEBtZW1iZXJPZiBwb3BNZW51XG4gKiBAdGhpcyBBcnJheVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmtleXM9W3BvcE1lbnUuZGVmYXVsdEtleV1dIC0gUHJvcGVydGllcyB0byBzZWFyY2ggZWFjaCBtZW51SXRlbSB3aGVuIGl0IGlzIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2FzZVNlbnNpdGl2ZT1mYWxzZV0gLSBJZ25vcmUgY2FzZSB3aGlsZSBzZWFyY2hpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBWYWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge3VuZGVmaW5lZHxtZW51SXRlbX0gVGhlIGZvdW5kIGl0ZW0gb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLlxuICovXG5mdW5jdGlvbiBsb29rdXAob3B0aW9ucywgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YWx1ZSA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIHNoYWxsb3csIGRlZXAsIGl0ZW0sIHByb3AsXG4gICAgICAgIGtleXMgPSBvcHRpb25zICYmIG9wdGlvbnMua2V5cyB8fCBbcG9wTWVudS5kZWZhdWx0S2V5XSxcbiAgICAgICAgY2FzZVNlbnNpdGl2ZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jYXNlU2Vuc2l0aXZlO1xuXG4gICAgdmFsdWUgPSB0b1N0cmluZyh2YWx1ZSwgY2FzZVNlbnNpdGl2ZSk7XG5cbiAgICBzaGFsbG93ID0gdGhpcy5maW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIHN1YnRyZWUgPSBpdGVtW3BvcE1lbnUuc3VidHJlZV0gfHwgaXRlbTtcblxuICAgICAgICBpZiAoc3VidHJlZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gKGRlZXAgPSBsb29rdXAuY2FsbChzdWJ0cmVlLCBvcHRpb25zLCB2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKGl0ZW0sIGNhc2VTZW5zaXRpdmUpID09PSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHByb3AgPSBpdGVtW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wICYmIHRvU3RyaW5nKHByb3AsIGNhc2VTZW5zaXRpdmUpID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0ZW0gPSBkZWVwIHx8IHNoYWxsb3c7XG5cbiAgICByZXR1cm4gaXRlbSAmJiAoaXRlbS5uYW1lID8gaXRlbSA6IHsgbmFtZTogaXRlbSB9KTtcbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcocywgY2FzZVNlbnNpdGl2ZSkge1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBpZiAocykge1xuICAgICAgICByZXN1bHQgKz0gczsgLy8gY29udmVydCBzIHRvIHN0cmluZ1xuICAgICAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgUmVjdXJzaXZlbHkgd2Fsa3MgdGhlIGNvbnRleHQgYXJyYXkgb2YgYG1lbnVJdGVtYHMgYW5kIGNhbGxzIGBpdGVyYXRlZWAgb24gZWFjaCBpdGVtIHRoZXJlaW4uXG4gKiBAZGVzYyBgaXRlcmF0ZWVgIGlzIGNhbGxlZCB3aXRoIGVhY2ggaXRlbSAodGVybWluYWwgbm9kZSkgaW4gdGhlIG1lbnUgdHJlZSBhbmQgYSBmbGF0IDAtYmFzZWQgaW5kZXguIFJlY3Vyc2VzIG9uIG1lbWJlciB3aXRoIG5hbWUgb2YgYHBvcE1lbnUuc3VidHJlZWAuXG4gKlxuICogVGhlIG5vZGUgd2lsbCBhbHdheXMgYmUgYSB7QGxpbmsgdmFsdWVJdGVtfSBvYmplY3Q7IHdoZW4gYSBgc3RyaW5nYCwgaXQgaXMgYm94ZWQgZm9yIHlvdS5cbiAqXG4gKiBAbWVtYmVyT2YgcG9wTWVudVxuICpcbiAqIEB0aGlzIEFycmF5XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBGb3IgZWFjaCBpdGVtIGluIHRoZSBtZW51LCBgaXRlcmF0ZWVgIGlzIGNhbGxlZCB3aXRoOlxuICogKiB0aGUgYHZhbHVlSXRlbWAgKGlmIHRoZSBpdGVtIGlzIGEgcHJpbWF0aXZlIHN0cmluZywgaXQgaXMgd3JhcHBlZCB1cCBmb3IgeW91KVxuICogKiBhIDAtYmFzZWQgYG9yZGluYWxgXG4gKlxuICogVGhlIGBpdGVyYXRlZWAgcmV0dXJuIHZhbHVlIGNhbiBiZSB1c2VkIHRvIHJlcGxhY2UgdGhlIGl0ZW0sIGFzIGZvbGxvd3M6XG4gKiAqIGB1bmRlZmluZWRgIC0gZG8gbm90aGluZ1xuICogKiBgbnVsbGAgLSBzcGxpY2Ugb3V0IHRoZSBpdGVtOyByZXN1bHRpbmcgZW1wdHkgc3VibWVudXMgYXJlIGFsc28gc3BsaWNlZCBvdXQgKHNlZSBub3RlKVxuICogKiBhbnl0aGluZyBlbHNlIC0gcmVwbGFjZSB0aGUgaXRlbSB3aXRoIHRoaXMgdmFsdWU7IGlmIHZhbHVlIGlzIGEgc3VidHJlZSAoaS5lLiwgYW4gYXJyYXkpIGBpdGVyYXRlZWAgd2lsbCB0aGVuIGJlIGNhbGxlZCB0byB3YWxrIGl0IGFzIHdlbGwgKHNlZSBub3RlKVxuICpcbiAqID4gTm90ZTogUmV0dXJuaW5nIGFueXRoaW5nIChvdGhlciB0aGFuIGB1bmRlZmluZWRgKSBmcm9tIGBpdGVyYXRlZWAgd2lsbCAoZGVlcGx5KSBtdXRhdGUgdGhlIG9yaWdpbmFsIGBtZW51YCBzbyB5b3UgbWF5IHdhbnQgdG8gY29weSBpdCBmaXJzdCAoZGVlcGx5LCBpbmNsdWRpbmcgYWxsIGxldmVscyBvZiBhcnJheSBuZXN0aW5nIGJ1dCBub3QgdGhlIHRlcm1pbmFsIG5vZGUgb2JqZWN0cykuXG4gKlxuICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIGl0ZW1zICh0ZXJtaW5hbCBub2RlcykgaW4gdGhlIG1lbnUgdHJlZS5cbiAqL1xuZnVuY3Rpb24gd2FsayhpdGVyYXRlZSkge1xuICAgIHZhciBtZW51ID0gdGhpcyxcbiAgICAgICAgb3JkaW5hbCA9IDAsXG4gICAgICAgIHN1YnRyZWVOYW1lID0gcG9wTWVudS5zdWJ0cmVlLFxuICAgICAgICBpLCBpdGVtLCBzdWJ0cmVlLCBuZXdWYWw7XG5cbiAgICBmb3IgKGkgPSBtZW51Lmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGl0ZW0gPSBtZW51W2ldO1xuICAgICAgICBzdWJ0cmVlID0gaXRlbVtzdWJ0cmVlTmFtZV0gfHwgaXRlbTtcblxuICAgICAgICBpZiAoIShzdWJ0cmVlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICBzdWJ0cmVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdWJ0cmVlKSB7XG4gICAgICAgICAgICBuZXdWYWwgPSBpdGVyYXRlZShpdGVtLm5hbWUgPyBpdGVtIDogeyBuYW1lOiBpdGVtIH0sIG9yZGluYWwpO1xuICAgICAgICAgICAgb3JkaW5hbCArPSAxO1xuXG4gICAgICAgICAgICBpZiAobmV3VmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbnUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBvcmRpbmFsIC09IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVudVtpXSA9IGl0ZW0gPSBuZXdWYWw7XG4gICAgICAgICAgICAgICAgICAgIHN1YnRyZWUgPSBpdGVtW3N1YnRyZWVOYW1lXSB8fCBpdGVtO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShzdWJ0cmVlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJ0cmVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1YnRyZWUpIHtcbiAgICAgICAgICAgIG9yZGluYWwgKz0gd2Fsay5jYWxsKHN1YnRyZWUsIGl0ZXJhdGVlKTtcbiAgICAgICAgICAgIGlmIChzdWJ0cmVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1lbnUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIG9yZGluYWwgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcmRpbmFsO1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5IEZvcm1hdCBpdGVtIG5hbWUgd2l0aCBpdCdzIGFsaWFzIHdoZW4gYXZhaWxhYmxlLlxuICogQG1lbWJlck9mIHBvcE1lbnVcbiAqIEBwYXJhbSB7c3RyaW5nfHZhbHVlSXRlbX0gaXRlbVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCBuYW1lIGFuZCBhbGlhcy5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0SXRlbShpdGVtKSB7XG4gICAgdmFyIHJlc3VsdCA9IGl0ZW0ubmFtZSB8fCBpdGVtO1xuICAgIGlmIChpdGVtLmFsaWFzKSB7XG4gICAgICAgIHJlc3VsdCA9ICdcIicgKyBpdGVtLmFsaWFzICsgJ1wiICgnICsgcmVzdWx0ICsgJyknO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGlzR3JvdXBQcm94eShzKSB7XG4gICAgcmV0dXJuIFJFR0VYUF9JTkRJUkVDVElPTi50ZXN0KHMpO1xufVxuXG4vKipcbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHBvcE1lbnUgPSB7XG4gICAgYnVpbGQ6IGJ1aWxkLFxuICAgIHdhbGs6IHdhbGssXG4gICAgbG9va3VwOiBsb29rdXAsXG4gICAgZm9ybWF0SXRlbTogZm9ybWF0SXRlbSxcbiAgICBpc0dyb3VwUHJveHk6IGlzR3JvdXBQcm94eSxcbiAgICBzdWJ0cmVlOiAnc3VibWVudScsXG4gICAgZGVmYXVsdEtleTogJ25hbWUnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvcE1lbnU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1lbnYgbm9kZSwgYnJvd3NlciAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcmVhZC1vbmx5IHByb3BlcnR5IGFuZCBhdHRhY2hlcyBpdCB0byB0aGUgcHJvdmlkZWQgY29udGV4dC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgZm9yIG5ldyBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSAtIFZhbHVlIG9mIG5ldyBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gYWRkUmVhZE9ubHlQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfSk7XG59XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIFBvaW50XG4gKlxuICogQGRlc2MgVGhpcyBvYmplY3QgcmVwcmVzZW50cyBhIHNpbmdsZSBwb2ludCBpbiBhbiBhYnN0cmFjdCAyLWRpbWVuc2lvbmFsIG1hdHJpeC5cbiAqXG4gKiBUaGUgdW5pdCBvZiBtZWFzdXJlIGlzIHR5cGljYWxseSBwaXhlbHMuXG4gKiAoSWYgdXNlZCB0byBtb2RlbCBjb21wdXRlciBncmFwaGljcywgdmVydGljYWwgY29vcmRpbmF0ZXMgYXJlIHR5cGljYWxseSBtZWFzdXJlZCBkb3dud2FyZHNcbiAqIGZyb20gdGhlIHRvcCBvZiB0aGUgd2luZG93LiBUaGlzIGNvbnZlbnRpb24gaG93ZXZlciBpcyBub3QgaW5oZXJlbnQgaW4gdGhpcyBvYmplY3QuKVxuICpcbiAqIE5vdGU6IFRoaXMgb2JqZWN0IHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBuZXcgcG9pbnQncyBgeGAgcHJvcGVydHlcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIG5ldyBwb2ludCdzIGB5YCBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBQb2ludCh4LCB5KSB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSB4XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAc3VtbWFyeSBUaGlzIHBvaW50J3MgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBkZXNjIENyZWF0ZWQgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgUG9pbnR8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ3gnLCBOdW1iZXIoeCkgfHwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSB5XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAc3VtbWFyeSBUaGlzIHBvaW50J3MgdmVydGljYWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFBvaW50fGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgYWRkUmVhZE9ubHlQcm9wZXJ0eS5jYWxsKHRoaXMsICd5JywgTnVtYmVyKHkpIHx8IDApO1xuXG59XG5cblBvaW50LnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gQSBuZXcgcG9pbnQgd2hpY2ggaXMgdGhpcyBwb2ludCdzIHBvc2l0aW9uIGluY3JlYXNlZCBieSBjb29yZGluYXRlcyBvZiBnaXZlbiBgb2Zmc2V0YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBvZmZzZXQgLSBIb3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCB2YWx1ZXMgdG8gYWRkIHRvIHRoaXMgcG9pbnQncyBjb29yZGluYXRlcy5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgcGx1czogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICB0aGlzLnggKyBvZmZzZXQueCxcbiAgICAgICAgICAgIHRoaXMueSArIG9mZnNldC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gQSBuZXcgcG9pbnQgd2hpY2ggaXMgdGhpcyBwb2ludCdzIHBvc2l0aW9uIGluY3JlYXNlZCBieSBnaXZlbiBvZmZzZXRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0WD0wXSAtIFZhbHVlIHRvIGFkZCB0byB0aGlzIHBvaW50J3MgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0WT0wXSAtIFZhbHVlIHRvIGFkZCB0byB0aGlzIHBvaW50J3MgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwbHVzWFk6IGZ1bmN0aW9uKG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIHRoaXMueCArIChvZmZzZXRYIHx8IDApLFxuICAgICAgICAgICAgdGhpcy55ICsgKG9mZnNldFkgfHwgMClcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1BvaW50fSBBIG5ldyBwb2ludCB3aGljaCBpcyB0aGlzIHBvaW50J3MgcG9zaXRpb24gZGVjcmVhc2VkIGJ5IGNvb3JkaW5hdGVzIG9mIGdpdmVuIGBvZmZzZXRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IG9mZnNldCAtIEhvcml6b250YWwgYW5kIHZlcnRpY2FsIHZhbHVlcyB0byBzdWJ0cmFjdCBmcm9tIHRoaXMgcG9pbnQncyBjb29yZGluYXRlcy5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgbWludXM6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgdGhpcy54IC0gb2Zmc2V0LngsXG4gICAgICAgICAgICB0aGlzLnkgLSBvZmZzZXQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IEEgbmV3IGBQb2ludGAgcG9zaXRpb25lZCB0byBsZWFzdCB4IGFuZCBsZWFzdCB5IG9mIHRoaXMgcG9pbnQgYW5kIGdpdmVuIGBvZmZzZXRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnQuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIG1pbjogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIE1hdGgubWluKHRoaXMueCwgcG9pbnQueCksXG4gICAgICAgICAgICBNYXRoLm1pbih0aGlzLnksIHBvaW50LnkpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gQSBuZXcgYFBvaW50YCBwb3NpdGlvbmVkIHRvIGdyZWF0ZXN0IHggYW5kIGdyZWF0ZXN0IHkgb2YgdGhpcyBwb2ludCBhbmQgZ2l2ZW4gYHBvaW50YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgdG8gY29tcGFyZSB0byB0aGlzIHBvaW50LlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtYXg6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICBNYXRoLm1heCh0aGlzLngsIHBvaW50LngpLFxuICAgICAgICAgICAgTWF0aC5tYXgodGhpcy55LCBwb2ludC55KVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBEaXN0YW5jZSBiZXR3ZWVuIGdpdmVuIGBwb2ludGAgYW5kIHRoaXMgcG9pbnQgdXNpbmcgUHl0aGFnb3JlYW4gVGhlb3JlbSBmb3JtdWxhLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCBmcm9tIHdoaWNoIHRvIGNvbXB1dGUgdGhlIGRpc3RhbmNlIHRvIHRoaXMgcG9pbnQuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRpc3RhbmNlOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB2YXIgZGVsdGFYID0gcG9pbnQueCAtIHRoaXMueCxcbiAgICAgICAgICAgIGRlbHRhWSA9IHBvaW50LnkgLSB0aGlzLnk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgICAgICAgIGRlbHRhWCAqIGRlbHRhWCArXG4gICAgICAgICAgICBkZWx0YVkgKiBkZWx0YVlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogXyhGb3JtZXJseTogYGVxdWFsYC4pX1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIF9ib3RoXyBjb29yZGluYXRlcyBvZiB0aGlzIHBvaW50IGFyZSBleGFjdGx5IGVxdWFsIHRvIHRob3NlIG9mIGdpdmVuIGBwb2ludGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludC5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgZXF1YWxzOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgIHRoaXMueCA9PT0gcG9pbnQueCAmJlxuICAgICAgICAgICAgICAgIHRoaXMueSA9PT0gcG9pbnQueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIF9ib3RoXyBjb29yZGluYXRlcyBvZiB0aGlzIHBvaW50IGFyZSBncmVhdGVyIHRoYW4gdGhvc2Ugb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgdG8gY29tcGFyZSB0byB0aGlzIHBvaW50XG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdyZWF0ZXJUaGFuOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy54ID4gcG9pbnQueCAmJlxuICAgICAgICAgICAgdGhpcy55ID4gcG9pbnQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBfYm90aF8gY29vcmRpbmF0ZXMgb2YgdGhpcyBwb2ludCBhcmUgbGVzcyB0aGFuIHRob3NlIG9mIGdpdmVuIGBwb2ludGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludFxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBsZXNzVGhhbjogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMueCA8IHBvaW50LnggJiZcbiAgICAgICAgICAgIHRoaXMueSA8IHBvaW50LnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogXyhGb3JtZXJseSBgZ3JlYXRlclRoYW5FcXVhbFRvYC4pX1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIF9ib3RoXyBjb29yZGluYXRlcyBvZiB0aGlzIHBvaW50IGFyZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhvc2Ugb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgdG8gY29tcGFyZSB0byB0aGlzIHBvaW50XG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdyZWF0ZXJUaGFuT3JFcXVhbFRvOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy54ID49IHBvaW50LnggJiZcbiAgICAgICAgICAgIHRoaXMueSA+PSBwb2ludC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIF8oRm9ybWVybHkgYGxlc3NUaGFuRXF1YWxUb2AuKV9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBfYm90aF8gY29vcmRpbmF0ZXMgb2YgdGhpcyBwb2ludCBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRob3NlIG9mIGdpdmVuIGBwb2ludGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludC5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgbGVzc1RoYW5PckVxdWFsVG86IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnggPD0gcG9pbnQueCAmJlxuICAgICAgICAgICAgdGhpcy55IDw9IHBvaW50LnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogXyhGb3JtZXJseSBgaXNDb250YWluZWRXaXRoaW5SZWN0YW5nbGVgLilfXG4gICAgICogQHBhcmFtIHJlY3Qge1JlY3RhbmdsZX0gLSBSZWN0YW5nbGUgdG8gdGVzdCB0aGlzIHBvaW50IGFnYWluc3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgdGhpcyBwb2ludCBpcyB3aXRoaW4gZ2l2ZW4gYHJlY3RgLlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB3aXRoaW46IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgdmFyIG1pblggPSByZWN0Lm9yaWdpbi54LFxuICAgICAgICAgICAgbWF4WCA9IG1pblggKyByZWN0LmV4dGVudC54O1xuICAgICAgICB2YXIgbWluWSA9IHJlY3Qub3JpZ2luLnksXG4gICAgICAgICAgICBtYXhZID0gbWluWSArIHJlY3QuZXh0ZW50Lnk7XG5cbiAgICAgICAgaWYgKHJlY3QuZXh0ZW50LnggPCAwKSB7XG4gICAgICAgICAgICBtaW5YID0gbWF4WDtcbiAgICAgICAgICAgIG1heFggPSByZWN0Lm9yaWdpbi54O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlY3QuZXh0ZW50LnkgPCAwKSB7XG4gICAgICAgICAgICBtaW5ZID0gbWF4WTtcbiAgICAgICAgICAgIG1heFkgPSByZWN0Lm9yaWdpbi55O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG1pblggPD0gdGhpcy54ICYmIHRoaXMueCA8IG1heFggJiZcbiAgICAgICAgICAgIG1pblkgPD0gdGhpcy55ICYmIHRoaXMueSA8IG1heFlcbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuRVEgPSBQb2ludC5wcm90b3R5cGUuZXF1YWxzO1xuUG9pbnQucHJvdG90eXBlLkdUID0gUG9pbnQucHJvdG90eXBlLmdyZWF0ZXJUaGFuO1xuUG9pbnQucHJvdG90eXBlLkxUID0gUG9pbnQucHJvdG90eXBlLmxlc3NUaGFuO1xuUG9pbnQucHJvdG90eXBlLkdFID0gUG9pbnQucHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbFRvO1xuUG9pbnQucHJvdG90eXBlLkxFID0gUG9pbnQucHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbFRvO1xuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIFJlY3RhbmdsZVxuICpcbiAqIEBkZXNjIFRoaXMgb2JqZWN0IHJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIHdpdGhpbiBhbiBhYnN0cmFjdCAyLWRpbWVuc2lvbmFsIG1hdHJpeC5cbiAqXG4gKiBUaGUgdW5pdCBvZiBtZWFzdXJlIGlzIHR5cGljYWxseSBwaXhlbHMuXG4gKiAoSWYgdXNlZCB0byBtb2RlbCBjb21wdXRlciBncmFwaGljcywgdmVydGljYWwgY29vcmRpbmF0ZXMgYXJlIHR5cGljYWxseSBtZWFzdXJlZCBkb3dud2FyZHNcbiAqIGZyb20gdGhlIHRvcCBvZiB0aGUgd2luZG93LiBUaGlzIGNvbnZlbnRpb24gaG93ZXZlciBpcyBub3QgaW5oZXJlbnQgaW4gdGhpcyBvYmplY3QuKVxuICpcbiAqIE5vcm1hbGx5LCB0aGUgYHhgIGFuZCBgeWAgcGFyYW1ldGVycyB0byB0aGUgY29uc3RydWN0b3IgZGVzY3JpYmUgdGhlIHVwcGVyIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0LlxuICogSG93ZXZlciwgbmVnYXRpdmUgdmFsdWVzIG9mIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGdpdmVuIGB4YCBhbmQgYHlgLiBUaGF0IGlzLFxuICogYSBuZWdhdGl2ZSB2YWx1ZSBvZiB0aGUgYHdpZHRoYCBwYXJhbWV0ZXIgd2lsbCBleHRlbmQgdGhlIHJlY3QgdG8gdGhlIGxlZnQgb2YgdGhlIGdpdmVuIGB4YCBhbmRcbiAqIGEgbmVnYXRpdmUgdmFsdWUgb2YgdGhlIGBoZWlnaHRgIHBhcmFtZXRlciB3aWxsIGV4dGVuZCB0aGUgcmVjdCBhYm92ZSB0aGUgZ2l2ZW4gYHlgLlxuICogSW4gYW55IGNhc2UsIGFmdGVyIGluc3RhbnRpYXRpb24gdGhlIGZvbGxvd2luZyBhcmUgZ3VhcmFudGVlZCB0byBhbHdheXMgYmUgdHJ1ZTpcbiAqICogVGhlIGBleHRlbnRgLCBgd2lkdGhgLCBhbmQgYGhlaWdodGAgcHJvcGVydGllcyBfYWx3YXlzXyBnaXZlIHBvc2l0aXZlIHZhbHVlcy5cbiAqICogVGhlIGBvcmlnaW5gLCBgdG9wYCwgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzIF9hbHdheXNfIHJlZmxlY3QgdGhlIHVwcGVyIGxlZnQgY29ybmVyLlxuICogKiBUaGUgYGNvcm5lcmAsIGBib3R0b21gLCBhbmQgYHJpZ2h0YCBwcm9wZXJ0aWVzIF9hbHdheXNfIHJlZmxlY3QgdGhlIGxvd2VyIHJpZ2h0IGNvcm5lci5cbiAqXG4gKiBOb3RlOiBUaGlzIG9iamVjdCBzaG91bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBjb29yZGluYXRlIG9mIHNvbWUgY29ybmVyIG9mIHRoZSByZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgY29vcmRpbmF0ZSBvZiBzb21lIGNvcm5lciBvZiB0aGUgcmVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9MF0gLSBXaWR0aCBvZiB0aGUgbmV3IHJlY3QuIE1heSBiZSBuZWdhdGl2ZSAoc2VlIGFib3ZlKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PTBdIC0gSGVpZ2h0IG9mIHRoZSBuZXcgcmVjdC4gTWF5IGJlIG5lZ2F0aXZlIChzZWUgYWJvdmUpLlxuICovXG5mdW5jdGlvbiBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG4gICAgeCA9IE51bWJlcih4KSB8fCAwO1xuICAgIHkgPSBOdW1iZXIoeSkgfHwgMDtcbiAgICB3aWR0aCA9IE51bWJlcih3aWR0aCkgfHwgMDtcbiAgICBoZWlnaHQgPSBOdW1iZXIoaGVpZ2h0KSB8fCAwO1xuXG4gICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICB4ICs9IHdpZHRoO1xuICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICB9XG5cbiAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICB5ICs9IGhlaWdodDtcbiAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBvcmlnaW5cbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQHN1bW1hcnkgVXBwZXIgbGVmdCBjb3JuZXIgb2YgdGhpcyByZWN0LlxuICAgICAqIEBkZXNjIENyZWF0ZWQgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmtwbGFpbiBSZWN0YW5nbGV8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgYWRkUmVhZE9ubHlQcm9wZXJ0eS5jYWxsKHRoaXMsICdvcmlnaW4nLCBuZXcgUG9pbnQoeCwgeSkpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgZXh0ZW50XG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBzdW1tYXJ5IHRoaXMgcmVjdCdzIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICogQGRlc2MgVW5saWtlIHRoZSBvdGhlciBgUG9pbnRgIHByb3BlcnRpZXMsIGBleHRlbnRgIGlzIG5vdCBhIGdsb2JhbCBjb29yZGluYXRlIHBhaXI7IHJhdGhlciBpdCBjb25zaXN0cyBvZiBhIF93aWR0aF8gKGB4YCwgYWx3YXlzIHBvc2l0aXZlKSBhbmQgYSBfaGVpZ2h0XyAoYHlgLCBhbHdheXMgcG9zaXRpdmUpLlxuICAgICAqXG4gICAgICogVGhpcyBvYmplY3QgbWlnaHQgYmUgbW9yZSBsZWdpdGltYXRlbHkgdHlwZWQgYXMgc29tZXRoaW5nIGxpa2UgYEFyZWFgIHdpdGggcHJvcGVydGllcyBgd2lkdGhgIGFuZCBgaGVpZ2h0YDsgaG93ZXZlciB3ZSB3YW50ZWQgaXQgdG8gYmUgYWJsZSB0byB1c2UgaXQgZWZmaWNpZW50bHkgd2l0aCBhIHBvaW50J3MgYHBsdXNgIGFuZCBgbWludXNgIG1ldGhvZHMgKHRoYXQgaXMsIHdpdGhvdXQgdGhvc2UgbWV0aG9kcyBoYXZpbmcgdG8gY2hlY2sgYW5kIGJyYW5jaCBvbiB0aGUgdHlwZSBvZiBpdHMgcGFyYW1ldGVyKS5cbiAgICAgKlxuICAgICAqIENyZWF0ZWQgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmtwbGFpbiBSZWN0YW5nbGV8Y29uc3RydWN0b3J9LlxuICAgICAqIEBzZWUgVGhlIHtAbGluayBSZWN0YW5nbGUjY29ybmVyfGNvcm5lcn0gbWV0aG9kLlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgYWRkUmVhZE9ubHlQcm9wZXJ0eS5jYWxsKHRoaXMsICdleHRlbnQnLCBuZXcgUG9pbnQod2lkdGgsIGhlaWdodCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgY29ybmVyXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBzdW1tYXJ5IExvd2VyIHJpZ2h0IGNvcm5lciBvZiB0aGlzIHJlY3QuXG4gICAgICogQGRlc2MgVGhpcyBpcyBhIGNhbGN1bGF0ZWQgdmFsdWUgY3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGlua3BsYWluIFJlY3RhbmdsZXxjb25zdHJ1Y3Rvcn0uIEl0IGlzIGBvcmlnaW5gIG9mZnNldCBieSBgZXh0ZW50YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGVzZSBjb29yZGluYXRlcyBhY3R1YWxseSBwb2ludCB0byB0aGUgcGl4ZWwgb25lIGJlbG93IGFuZCBvbmUgdG8gdGhlIHJpZ2h0IG9mIHRoZSByZWN0J3MgYWN0dWFsIGxvd2VyIHJpZ2h0IHBpeGVsLlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgYWRkUmVhZE9ubHlQcm9wZXJ0eS5jYWxsKHRoaXMsICdjb3JuZXInLCBuZXcgUG9pbnQoeCArIHdpZHRoLCB5ICsgaGVpZ2h0KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBjZW50ZXJcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQHN1bW1hcnkgQ2VudGVyIG9mIHRoaXMgcmVjdC5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rcGxhaW4gUmVjdGFuZ2xlfGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIGFkZFJlYWRPbmx5UHJvcGVydHkuY2FsbCh0aGlzLCAnY2VudGVyJywgbmV3IFBvaW50KHggKyAod2lkdGggLyAyKSwgeSArIChoZWlnaHQgLyAyKSkpO1xuXG59XG5cblJlY3RhbmdsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZXNjIF8oRm9ybWVybHkgYSBmdW5jdGlvbjsgbm93IGEgZ2V0dGVyLilfXG4gICAgICogQHN1bW1hcnkgTWluaW11bSB2ZXJ0aWNhbCBjb29yZGluYXRlIG9mIHRoaXMgcmVjdC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCB0b3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbi55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZXNjIF8oRm9ybWVybHkgYSBmdW5jdGlvbjsgbm93IGEgZ2V0dGVyLilfXG4gICAgICogQHN1bW1hcnkgTWluaW11bSBob3Jpem9udGFsIGNvb3JkaW5hdGUgb2YgdGhpcyByZWN0LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbi54O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZXNjIF8oRm9ybWVybHkgYSBmdW5jdGlvbjsgbm93IGEgZ2V0dGVyLilfXG4gICAgICogQHN1bW1hcnkgTWF4aW11bSB2ZXJ0aWNhbCBjb29yZGluYXRlIG9mIHRoaXMgcmVjdCArIDEuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQgYm90dG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3JuZXIueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVzYyBfKEZvcm1lcmx5IGEgZnVuY3Rpb247IG5vdyBhIGdldHRlci4pX1xuICAgICAqIEBzdW1tYXJ5IE1heGltdW0gaG9yaXpvbnRhbCBjb29yZGluYXRlIG9mIHRoaXMgcmVjdCArIDEuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcm5lci54O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZXNjIF8oRm9ybWVybHkgYSBmdW5jdGlvbjsgbm93IGEgZ2V0dGVyLilfXG4gICAgICogQHN1bW1hcnkgV2lkdGggb2YgdGhpcyByZWN0IChhbHdheXMgcG9zaXRpdmUpLlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlbnQueDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVzYyBfKEZvcm1lcmx5IGEgZnVuY3Rpb247IG5vdyBhIGdldHRlci4pX1xuICAgICAqIEBzdW1tYXJ5IEhlaWdodCBvZiB0aGlzIHJlY3QgKGFsd2F5cyBwb3NpdGl2ZSkuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlbnQueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVzYyBfKEZvcm1lcmx5IGEgZnVuY3Rpb247IG5vdyBhIGdldHRlci4pX1xuICAgICAqIEBzdW1tYXJ5IEFyZWEgb2YgdGhpcyByZWN0LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0IGFyZWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IEEgY29weSBvZiB0aGlzIHJlY3QgYnV0IHdpdGggaG9yaXpvbnRhbCBwb3NpdGlvbiByZXNldCB0byBnaXZlbiBgeGAgYW5kIG5vIHdpZHRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gSG9yaXpvbnRhbCBjb29yZGluYXRlIG9mIHRoZSBuZXcgcmVjdC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGZsYXR0ZW5YQXQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoeCwgdGhpcy5vcmlnaW4ueSwgMCwgdGhpcy5leHRlbnQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IEEgY29weSBvZiB0aGlzIHJlY3QgYnV0IHdpdGggdmVydGljYWwgcG9zaXRpb24gcmVzZXQgdG8gZ2l2ZW4gYHlgIGFuZCBubyBoZWlnaHQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBWZXJ0aWNhbCBjb29yZGluYXRlIG9mIHRoZSBuZXcgcmVjdC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGZsYXR0ZW5ZQXQ6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy5vcmlnaW4ueCwgeSwgdGhpcy5leHRlbnQueCwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIGdpdmVuIGBwb2ludGAgZW50aXJlbHkgY29udGFpbmVkIHdpdGhpbiB0aGlzIHJlY3QuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRPclJlY3QgLSBUaGUgcG9pbnQgb3IgcmVjdCB0byB0ZXN0IGZvciBjb250YWlubWVudC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNvbnRhaW5zOiBmdW5jdGlvbihwb2ludE9yUmVjdCkge1xuICAgICAgICByZXR1cm4gcG9pbnRPclJlY3Qud2l0aGluKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBfKEZvcm1lcmx5IGBpc0NvbnRhaW5lZFdpdGhpblJlY3RhbmdsZWAuKV9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBgdGhpc2AgcmVjdCBpcyBlbnRpcmVseSBjb250YWluZWQgd2l0aGluIGdpdmVuIGByZWN0YC5cbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdCAtIFJlY3RhbmdsZSB0byB0ZXN0IGFnYWluc3QgdGhpcyByZWN0LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgd2l0aGluOiBmdW5jdGlvbihyZWN0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICByZWN0Lm9yaWdpbi5sZXNzVGhhbk9yRXF1YWxUbyh0aGlzLm9yaWdpbikgJiZcbiAgICAgICAgICAgIHJlY3QuY29ybmVyLmdyZWF0ZXJUaGFuT3JFcXVhbFRvKHRoaXMuY29ybmVyKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBfKEZvcm1lcmx5OiBgaW5zZXRCeWAuKV9cbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBUaGF0IGlzIGVubGFyZ2VkL3NocnVuayBieSBnaXZlbiBgcGFkZGluZ2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmcgLSBBbW91bnQgYnkgd2hpY2ggdG8gaW5jcmVhc2UgKCspIG9yIGRlY3JlYXNlICgtKSB0aGlzIHJlY3RcbiAgICAgKiBAc2VlIFRoZSB7QGxpbmsgUmVjdGFuZ2xlI3Nocmlua0J5fHNocmlua0J5fSBtZXRob2QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBncm93Qnk6IGZ1bmN0aW9uKHBhZGRpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICB0aGlzLm9yaWdpbi54ICsgcGFkZGluZyxcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLnkgKyBwYWRkaW5nLFxuICAgICAgICAgICAgdGhpcy5leHRlbnQueCAtIHBhZGRpbmcgLSBwYWRkaW5nLFxuICAgICAgICAgICAgdGhpcy5leHRlbnQueSAtIHBhZGRpbmcgLSBwYWRkaW5nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gVGhhdCBpcyBlbmxhcmdlZC9zaHJ1bmsgYnkgZ2l2ZW4gYHBhZGRpbmdgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nIC0gQW1vdW50IGJ5IHdoaWNoIHRvIGRlY3JlYXNlICgrKSBvciBpbmNyZWFzZSAoLSkgdGhpcyByZWN0LlxuICAgICAqIEBzZWUgVGhlIHtAbGluayBSZWN0YW5nbGUjZ3Jvd0J5fGdyb3dCeX0gbWV0aG9kLlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgc2hyaW5rQnk6IGZ1bmN0aW9uKHBhZGRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3Jvd0J5KC1wYWRkaW5nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gQm91bmRpbmcgcmVjdCB0aGF0IGNvbnRhaW5zIGJvdGggdGhpcyByZWN0IGFuZCB0aGUgZ2l2ZW4gYHJlY3RgLlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byB1bmlvbiB3aXRoIHRoaXMgcmVjdC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHVuaW9uOiBmdW5jdGlvbihyZWN0KSB7XG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbi5taW4ocmVjdC5vcmlnaW4pLFxuICAgICAgICAgICAgY29ybmVyID0gdGhpcy5jb3JuZXIubWF4KHJlY3QuY29ybmVyKSxcbiAgICAgICAgICAgIGV4dGVudCA9IGNvcm5lci5taW51cyhvcmlnaW4pO1xuXG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgICAgb3JpZ2luLngsIG9yaWdpbi55LFxuICAgICAgICAgICAgZXh0ZW50LngsIGV4dGVudC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGl0ZXJhdGUgb3ZlciBhbGwgcG9pbnRzIHdpdGhpbiB0aGlzIHJlY3QsIGludm9raW5nIGBpdGVyYXRlZWAgZm9yIGVhY2guXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyKX0gaXRlcmF0ZWUgLSBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHBvaW50LlxuICAgICAqIEJvdW5kIHRvIGBjb250ZXh0YCB3aGVuIGdpdmVuOyBvdGhlcndpc2UgaXQgaXMgYm91bmQgdG8gdGhpcyByZWN0LlxuICAgICAqIEVhY2ggaW52b2NhdGlvbiBvZiBgaXRlcmF0ZWVgIGlzIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHM6XG4gICAgICogdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHQ9dGhpc10gLSBDb250ZXh0IHRvIGJpbmQgdG8gYGl0ZXJhdGVlYCAod2hlbiBub3QgYHRoaXNgKS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG4gICAgICAgIGZvciAodmFyIHggPSB0aGlzLm9yaWdpbi54LCB4MiA9IHRoaXMuY29ybmVyLng7IHggPCB4MjsgeCsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gdGhpcy5vcmlnaW4ueSwgeTIgPSB0aGlzLmNvcm5lci55OyB5IDwgeTI7IHkrKykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdGVlLmNhbGwoY29udGV4dCwgeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gT25lIG9mOlxuICAgICAqICogX0lmIHRoaXMgcmVjdCBpbnRlcnNlY3RzIHdpdGggdGhlIGdpdmVuIGByZWN0YDpfXG4gICAgICogICAgICBhIG5ldyByZWN0IHJlcHJlc2VudGluZyB0aGF0IGludGVyc2VjdGlvbi5cbiAgICAgKiAqIF9JZiBpdCBkb2Vzbid0IGludGVyc2VjdCBhbmQgYGlmTm9uZUFjdGlvbmAgZGVmaW5lZDpfXG4gICAgICogICAgICByZXN1bHQgb2YgY2FsbGluZyBgaWZOb25lQWN0aW9uYC5cbiAgICAgKiAqIF9JZiBpdCBkb2Vzbid0IGludGVyc2VjdCBhbmQgYGlmTm9uZUFjdGlvbmAgdW5kZWZpbmVkOl9cbiAgICAgKiAgICAgIGBudWxsYC5cbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gaW50ZXJzZWN0IHdpdGggdGhpcyByZWN0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oUmVjdGFuZ2xlKX0gW2lmTm9uZUFjdGlvbl0gLSBXaGVuIG5vIGludGVyc2VjdGlvbiwgaW52b2tlIGFuZCByZXR1cm4gcmVzdWx0LlxuICAgICAqIEJvdW5kIHRvIGBjb250ZXh0YCB3aGVuIGdpdmVuOyBvdGhlcndpc2UgYm91bmQgdG8gdGhpcyByZWN0LlxuICAgICAqIEludm9rZWQgd2l0aCBgcmVjdGAgYXMgc29sZSBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0PXRoaXNdIC0gQ29udGV4dCB0byBiaW5kIHRvIGBpZk5vbmVBY3Rpb25gICh3aGVuIG5vdCBgdGhpc2ApLlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbihyZWN0LCBpZk5vbmVBY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGwsXG4gICAgICAgICAgICBvcmlnaW4gPSB0aGlzLm9yaWdpbi5tYXgocmVjdC5vcmlnaW4pLFxuICAgICAgICAgICAgY29ybmVyID0gdGhpcy5jb3JuZXIubWluKHJlY3QuY29ybmVyKSxcbiAgICAgICAgICAgIGV4dGVudCA9IGNvcm5lci5taW51cyhvcmlnaW4pO1xuXG4gICAgICAgIGlmIChleHRlbnQueCA+IDAgJiYgZXh0ZW50LnkgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgIG9yaWdpbi54LCBvcmlnaW4ueSxcbiAgICAgICAgICAgICAgICBleHRlbnQueCwgZXh0ZW50LnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlmTm9uZUFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gaWZOb25lQWN0aW9uLmNhbGwoY29udGV4dCB8fCB0aGlzLCByZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIHRoaXMgcmVjdCBvdmVybGFwcyB3aXRoIGdpdmVuIGByZWN0YC5cbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gaW50ZXJzZWN0IHdpdGggdGhpcyByZWN0LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgaW50ZXJzZWN0czogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcmVjdC5jb3JuZXIueCA+IHRoaXMub3JpZ2luLnggJiZcbiAgICAgICAgICAgIHJlY3QuY29ybmVyLnkgPiB0aGlzLm9yaWdpbi55ICYmXG4gICAgICAgICAgICByZWN0Lm9yaWdpbi54IDwgdGhpcy5jb3JuZXIueCAmJlxuICAgICAgICAgICAgcmVjdC5vcmlnaW4ueSA8IHRoaXMuY29ybmVyLnlcbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG4vLyBJbnRlcmZhY2VcbmV4cG9ydHMuUG9pbnQgPSBQb2ludDtcbmV4cG9ydHMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgLy8gYSByZWdleCBzZWFyY2ggcGF0dGVybiB0aGF0IG1hdGNoZXMgYWxsIHRoZSByZXNlcnZlZCBjaGFycyBvZiBhIHJlZ2V4IHNlYXJjaCBwYXR0ZXJuXG4gICAgcmVzZXJ2ZWQgPSAvKFtcXC5cXFxcXFwrXFwqXFw/XFxeXFwkXFwoXFwpXFx7XFx9XFw9XFwhXFw8XFw+XFx8XFw6XFxbXFxdXSkvZyxcblxuICAgIC8vIHJlZ2V4IHdpbGRjYXJkIHNlYXJjaCBwYXR0ZXJuc1xuICAgIFJFR0VYUF9XSUxEQ0FSRCA9ICcuKicsXG4gICAgUkVHRVhQX1dJTERDSEFSID0gJy4nLFxuICAgIFJFR0VYUF9XSUxEQ0FSRF9NQVRDSEVSID0gJygnICsgUkVHRVhQX1dJTERDQVJEICsgJyknLFxuXG4gICAgLy8gTElLRSBzZWFyY2ggcGF0dGVybnNcbiAgICBMSUtFX1dJTERDSEFSID0gJ18nLFxuICAgIExJS0VfV0lMRENBUkQgPSAnJScsXG5cbiAgICAvLyByZWdleCBzZWFyY2ggcGF0dGVybnMgdGhhdCBtYXRjaCBMSUtFIHNlYXJjaCBwYXR0ZXJuc1xuICAgIFJFR0VYUF9MSUtFX1BBVFRFUk5fTUFUQ0hFUiA9IG5ldyBSZWdFeHAoJygnICsgW1xuICAgICAgICBMSUtFX1dJTERDSEFSLFxuICAgICAgICBMSUtFX1dJTERDQVJELFxuICAgICAgICAnXFxcXFtcXFxcXj9bXi1cXFxcXV0rXScsIC8vIG1hdGNoZXMgYSBMSUtFIHNldCAoc2FtZSBzeW50YXggYXMgYSBSZWdFeHAgc2V0KVxuICAgICAgICAnXFxcXFtcXFxcXj9bXi1cXFxcXV1cXFxcLVteXFxcXF1dXScgLy8gbWF0Y2hlcyBhIExJS0UgcmFuZ2UgKHNhbWUgc3ludGF4IGFzIGEgUmVnRXhwIHJhbmdlKVxuICAgIF0uam9pbignfCcpICsgJyknLCAnZycpO1xuXG5mdW5jdGlvbiByZWdFeHBMSUtFKHBhdHRlcm4sIGlnbm9yZUNhc2UpIHtcbiAgICB2YXIgaSwgcGFydHM7XG5cbiAgICAvLyBGaW5kIGFsbCBMSUtFIHBhdHRlcm5zXG4gICAgcGFydHMgPSBwYXR0ZXJuLm1hdGNoKFJFR0VYUF9MSUtFX1BBVFRFUk5fTUFUQ0hFUik7XG5cbiAgICBpZiAocGFydHMpIHtcbiAgICAgICAgLy8gVHJhbnNsYXRlIGZvdW5kIExJS0UgcGF0dGVybnMgdG8gcmVnZXggcGF0dGVybnMsIGVzY2FwZWQgaW50ZXJ2ZW5pbmcgbm9uLXBhdHRlcm5zLCBhbmQgaW50ZXJsZWF2ZSB0aGUgdHdvXG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAvLyBFc2NhcGUgbGVmdCBicmFja2V0cyAodW5wYWlyZWQgcmlnaHQgYnJhY2tldHMgYXJlIE9LKVxuICAgICAgICAgICAgaWYgKHBhcnRzW2ldWzBdID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICBwYXJ0c1tpXSA9IHJlZ0V4cExJS0UucmVzZXJ2ZShwYXJ0c1tpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2UgZWFjaCBmb3VuZCBwYXR0ZXJuIG1hdGNoYWJsZSBieSBlbmNsb3NpbmcgaW4gcGFyZW50aGVzZXNcbiAgICAgICAgICAgIHBhcnRzW2ldID0gJygnICsgcGFydHNbaV0gKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYXRjaCB0aGVzZSBwcmVjaXNlIHBhdHRlcm5zIGFnYWluIHdpdGggdGhlaXIgaW50ZXJ2ZW5pbmcgbm9uLXBhdHRlcm5zIChpLmUuLCB0ZXh0KVxuICAgICAgICBwYXJ0cyA9IHBhdHRlcm4ubWF0Y2gobmV3IFJlZ0V4cChcbiAgICAgICAgICAgIFJFR0VYUF9XSUxEQ0FSRF9NQVRDSEVSICtcbiAgICAgICAgICAgIHBhcnRzLmpvaW4oUkVHRVhQX1dJTERDQVJEX01BVENIRVIpICArXG4gICAgICAgICAgICBSRUdFWFBfV0lMRENBUkRfTUFUQ0hFUlxuICAgICAgICApKTtcblxuICAgICAgICAvLyBEaXNjYXJkIGZpcnN0IG1hdGNoIG9mIG5vbi1nbG9iYWwgc2VhcmNoICh3aGljaCBpcyB0aGUgd2hvbGUgc3RyaW5nKVxuICAgICAgICBwYXJ0cy5zaGlmdCgpO1xuXG4gICAgICAgIC8vIEZvciBlYWNoIHJlLWZvdW5kIHBhdHRlcm4gcGFydCwgdHJhbnNsYXRlICUgYW5kIF8gdG8gcmVnZXggZXF1aXZhbGVudFxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIExJS0VfV0lMRENBUkQ6IHBhcnQgPSBSRUdFWFBfV0lMRENBUkQ7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTElLRV9XSUxEQ0hBUjogcGFydCA9IFJFR0VYUF9XSUxEQ0hBUjsgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGogPSBwYXJ0WzFdID09PSAnXicgPyAyIDogMTtcbiAgICAgICAgICAgICAgICAgICAgcGFydCA9ICdbJyArIHJlZ0V4cExJS0UucmVzZXJ2ZShwYXJ0LnN1YnN0cihqLCBwYXJ0Lmxlbmd0aCAtIChqICsgMSkpKSArICddJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnRzW2ldID0gcGFydDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzID0gW3BhdHRlcm5dO1xuICAgIH1cblxuICAgIC8vIEZvciBlYWNoIHN1cnJvdW5kaW5nIHRleHQgcGFydCwgZXNjYXBlIHJlc2VydmVkIHJlZ2V4IGNoYXJzXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHBhcnRzW2ldID0gcmVnRXhwTElLRS5yZXNlcnZlKHBhcnRzW2ldKTtcbiAgICB9XG5cbiAgICAvLyBKb2luIGFsbCB0aGUgaW50ZXJsZWF2ZWQgcGFydHNcbiAgICBwYXJ0cyA9IHBhcnRzLmpvaW4oJycpO1xuXG4gICAgLy8gT3B0aW1pemUgb3IgYW5jaG9yIHRoZSBwYXR0ZXJuIGF0IGVhY2ggZW5kIGFzIG5lZWRlZFxuICAgIGlmIChwYXJ0cy5zdWJzdHIoMCwgMikgPT09IFJFR0VYUF9XSUxEQ0FSRCkgeyBwYXJ0cyA9IHBhcnRzLnN1YnN0cigyKTsgfSBlbHNlIHsgcGFydHMgPSAnXicgKyBwYXJ0czsgfVxuICAgIGlmIChwYXJ0cy5zdWJzdHIoLTIsIDIpID09PSBSRUdFWFBfV0lMRENBUkQpIHsgcGFydHMgPSBwYXJ0cy5zdWJzdHIoMCwgcGFydHMubGVuZ3RoIC0gMik7IH0gZWxzZSB7IHBhcnRzICs9ICckJzsgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSBuZXcgcmVnZXhcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXJ0cywgaWdub3JlQ2FzZSA/ICdpJyA6IHVuZGVmaW5lZCk7XG59XG5cbnJlZ0V4cExJS0UucmVzZXJ2ZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZShyZXNlcnZlZCwgJ1xcXFwkMScpO1xufTtcblxudmFyIGNhY2hlLCBzaXplO1xuXG4vKipcbiAqIEBzdW1tYXJ5IERlbGV0ZSBhIHBhdHRlcm4gZnJvbSB0aGUgY2FjaGU7IG9yIGNsZWFyIHRoZSB3aG9sZSBjYWNoZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0dGVybl0gLSBUaGUgTElLRSBwYXR0ZXJuIHRvIHJlbW92ZSBmcm9tIHRoZSBjYWNoZS4gRmFpbHMgc2lsZW50bHkgaWYgbm90IGZvdW5kIGluIHRoZSBjYWNoZS4gSWYgcGF0dGVybiBvbWl0dGVkLCBjbGVhcnMgd2hvbGUgY2FjaGUuXG4gKi9cbihyZWdFeHBMSUtFLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAocGF0dGVybikge1xuICAgIGlmICghcGF0dGVybikge1xuICAgICAgICBjYWNoZSA9IHt9O1xuICAgICAgICBzaXplID0gMDtcbiAgICB9IGVsc2UgaWYgKGNhY2hlW3BhdHRlcm5dKSB7XG4gICAgICAgIGRlbGV0ZSBjYWNoZVtwYXR0ZXJuXTtcbiAgICAgICAgc2l6ZS0tO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn0pKCk7IC8vIGluaXQgdGhlIGNhY2hlXG5cbnJlZ0V4cExJS0UuZ2V0Q2FjaGVTaXplID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2l6ZTsgfTtcblxuLyoqXG4gKiBAc3VtbWFyeSBDYWNoZWQgdmVyc2lvbiBvZiBgcmVnRXhwTElLRSgpYC5cbiAqIEBkZXNjIENhY2hlZCBlbnRyaWVzIGFyZSBzdWJqZWN0IHRvIGdhcmJhZ2UgY29sbGVjdGlvbiBpZiBga2VlcGAgaXMgYHVuZGVmaW5lZGAgb3IgYGZhbHNlYCBvbiBpbnNlcnRpb24gb3IgYGZhbHNlYCBvbiBtb3N0IHJlY2VudCByZWZlcmVuY2UuIEdhcmJhZ2UgY29sbGVjdGlvbiB3aWxsIG9jY3VyIGlmZiBgcmVnRXhwTElLRS5jYWNoZU1heGAgaXMgZGVmaW5lZCBhbmQgaXQgZXF1YWxzIHRoZSBudW1iZXIgb2YgY2FjaGVkIHBhdHRlcm5zLiBUaGUgZ2FyYmFnZSBjb2xsZWN0b3Igc29ydHMgdGhlIHBhdHRlcm5zIGJhc2VkIG9uIG1vc3QgcmVjZW50IHJlZmVyZW5jZTsgdGhlIG9sZGVzdCAxMCUgb2YgdGhlIGVudHJpZXMgYXJlIGRlbGV0ZWQuIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gbWFuYWdlIHRoZSBjYWNoZSB5b3Vyc2VsZiB0byBhIGxpbWl0ZWQgZXh0ZW50IChzZWUge0BsaW5rIHJlZ2VFeHBMSUtFLmNsZWFyQ2FjaGV8Y2xlYXJDYWNoZX0pLlxuICogQHBhcmFtIHBhdHRlcm4gLSB0aGUgTElLRSBwYXR0ZXJuICh0byBiZSkgY29udmVydGVkIHRvIGEgUmVnRXhwXG4gKiBAcGFyYW0gW2tlZXBdIC0gSWYgZ2l2ZW4sIGNoYW5nZXMgdGhlIGtlZXAgc3RhdHVzIGZvciB0aGlzIHBhdHRlcm4gYXMgZm9sbG93czpcbiAqICogYHRydWVgIHBlcm1hbmVudGx5IGNhY2hlcyB0aGUgcGF0dGVybiAobm90IHN1YmplY3QgdG8gZ2FyYmFnZSBjb2xsZWN0aW9uKSB1bnRpbCBgZmFsc2VgIGlzIGdpdmVuIG9uIGEgc3Vic2VxdWVudCBjYWxsXG4gKiAqIGBmYWxzZWAgYWxsb3dzIGdhcmJhZ2UgY29sbGVjdGlvbiBvbiB0aGUgY2FjaGVkIHBhdHRlcm5cbiAqICogYHVuZGVmaW5lZGAgbm8gY2hhbmdlIHRvIGtlZXAgc3RhdHVzXG4gKiBAcmV0dXJucyB7UmVnRXhwfVxuICovXG5yZWdFeHBMSUtFLmNhY2hlZCA9IGZ1bmN0aW9uIChrZWVwLCBwYXR0ZXJuLCBpZ25vcmVDYXNlKSB7XG4gICAgaWYgKHR5cGVvZiBrZWVwID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZ25vcmVDYXNlID0gcGF0dGVybjtcbiAgICAgICAgcGF0dGVybiA9IGtlZXA7XG4gICAgICAgIGtlZXAgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHBhdHRlcm5BbmRDYXNlID0gcGF0dGVybiArIChpZ25vcmVDYXNlID8gJ2knIDogJ2MnKSxcbiAgICAgICAgaXRlbSA9IGNhY2hlW3BhdHRlcm5BbmRDYXNlXTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgICBpdGVtLndoZW4gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgaWYgKGtlZXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXRlbS5rZWVwID0ga2VlcDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzaXplID09PSByZWdFeHBMSUtFLmNhY2hlTWF4KSB7XG4gICAgICAgICAgICB2YXIgYWdlID0gW10sIGFnZXMgPSAwLCBrZXksIGk7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBjYWNoZSkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBjYWNoZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICghaXRlbS5rZWVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhZ2VzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLndoZW4gPCBhZ2VbaV0uaXRlbS53aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWdlLnNwbGljZShpLCAwLCB7IGtleToga2V5LCBpdGVtOiBpdGVtIH0pO1xuICAgICAgICAgICAgICAgICAgICBhZ2VzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ0V4cExJS0UocGF0dGVybiwgaWdub3JlQ2FzZSk7IC8vIGNhY2hlIGlzIGZ1bGwhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gTWF0aC5jZWlsKGFnZS5sZW5ndGggLyAxMCk7IC8vIHdpbGwgYWx3YXlzIGJlIGF0IGxlYXN0IDFcbiAgICAgICAgICAgIHNpemUgLT0gaTtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVbYWdlW2ldLmtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXRlbSA9IGNhY2hlW3BhdHRlcm5BbmRDYXNlXSA9IHtcbiAgICAgICAgICAgIHJlZ2V4OiByZWdFeHBMSUtFKHBhdHRlcm4sIGlnbm9yZUNhc2UpLFxuICAgICAgICAgICAga2VlcDoga2VlcCxcbiAgICAgICAgICAgIHdoZW46IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICAgIH07XG4gICAgICAgIHNpemUrKztcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW0ucmVnZXg7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZ0V4cExJS0U7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1lbnYgbm9kZSwgYnJvd3NlciAqL1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkgeyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblxuICAgIC8vIFRoaXMgY2xvc3VyZSBzdXBwb3J0cyBOb2RlSlMtbGVzcyBjbGllbnQgc2lkZSBpbmNsdWRlcyB3aXRoIDxzY3JpcHQ+IHRhZ3MuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L21ubS5cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvciBSYW5nZVNlbGVjdGlvbk1vZGVsXG4gICAgICpcbiAgICAgKiBAZGVzYyBUaGlzIG9iamVjdCBtb2RlbHMgc2VsZWN0aW9uIG9mIFwiY2VsbHNcIiB3aXRoaW4gYW4gYWJzdHJhY3Qgc2luZ2xlLWRpbWVuc2lvbmFsIG1hdHJpeC5cbiAgICAgKlxuICAgICAqIERpc2pvaW50IHNlbGVjdGlvbnMgY2FuIGJlIGJ1aWx0IHdpdGggY2FsbHMgdG8gdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICAgICAqICoge0BsaW5rIFJhbmdlU2VsZWN0aW9uTW9kZWwjc2VsZWN0fHNlbGVjdChzdGFydCwgc3RvcCl9IC0gQWRkIGEgcmFuZ2UgdG8gdGhlIG1hdHJpeC5cbiAgICAgKiAqIHtAbGluayBSYW5nZVNlbGVjdGlvbk1vZGVsI2Rlc2VsZWN0fGRlc2VsZWN0KHN0YXJ0LCBzdG9wKX0gLSBSZW1vdmUgYSByYW5nZSBmcm9tIHRoZSBtYXRyaXguXG4gICAgICpcbiAgICAgKiBUd28gbW9yZSBtZXRob2RzIGFyZSBhdmFpbGFibGU6XG4gICAgICogKiBUZXN0IGEgY2VsbCB0byBzZWUgaWYgaXQge0BsaW5rIFJhbmdlU2VsZWN0aW9uTW9kZWwjaXNTZWxlY3RlZHxpc1NlbGVjdGVkKGNlbGwpfVxuICAgICAqICoge0BsaW5rIFJhbmdlU2VsZWN0aW9uTW9kZWwjY2xlYXJ8Y2xlYXIoKX0gdGhlIG1hdHJpeFxuICAgICAqXG4gICAgICogSW50ZXJuYWxseSwgdGhlIHNlbGVjdGlvbiBpcyBydW4tbGVuZ3RoLWVuY29kZWQuIEl0IGlzIHRoZXJlZm9yZSBhIFwic3BhcnNlXCIgbWF0cml4XG4gICAgICogd2l0aCB1bmRlZmluZWQgYm91bmRzLiBBIHNpbmdsZSBkYXRhIHByb3BlcnR5IGNhbGxlZCBgc2VsZWN0aW9uYCBpcyBhbiBhcnJheSB0aGF0XG4gICAgICogY29udGFpbnMgYWxsIHRoZSBcInJ1bnNcIiAocmFuZ2VzKSBvZiBzZWxlY3RlZCBjZWxscyBhbGJlaXQgaW4gbm8gcGFydGljdWxhciBvcmRlci5cbiAgICAgKiBUaGlzIHByb3BlcnR5IHNob3VsZCBub3Qgbm9ybWFsbHkgbmVlZCB0byBiZSBhY2Nlc3NlZCBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgb2JqZWN0IHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2Agb2JqZWN0KS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSYW5nZVNlbGVjdGlvbk1vZGVsKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgc2VsZWN0aW9uXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS5BcnJheS5udW1iZXJ9XG4gICAgICAgICAqIEBzdW1tYXJ5IFVub3JkZXJlZCBsaXN0IG9mIHJ1bnMuXG4gICAgICAgICAqIEBkZXNjIEEgXCJydW5cIiBpcyBkZWZpbmVkIGFzIGFuIEFycmF5KDIpIHdoZXJlOlxuICAgICAgICAgKiAqIGVsZW1lbnQgWzBdIGlzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJ1blxuICAgICAgICAgKiAqIGVsZW1lbnQgWzFdIGlzIHRoZSBlbmQgb2YgdGhlIHJ1biAoaW5jbHVzaXZlKSBhbmQgaXMgYWx3YXlzID49IGVsZW1lbnQgWzBdXG4gICAgICAgICAqIFRoZSBvcmRlciBvZiB0aGUgcnVucyB3aXRoaW4gaXMgdW5kZWZpbmVkLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IFtdO1xuXG4gICAgICAgIC8vd2UgbmVlZCB0byBiZSBhYmxlIHRvIGdvIGJhY2sgaW4gdGltZVxuICAgICAgICAvL3RoZSBzdGF0ZXMgZmllbGRcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcblxuICAgICAgICAvL2Nsb25lIGFuZCBzdG9yZSBteSBjdXJyZW50IHN0YXRlXG4gICAgICAgIC8vc28gd2UgY2FuIHVud2luZCBjaGFuZ2VzIGlmIG5lZWQgYmVcbiAgICAgICAgdGhpcy5zdG9yZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbHMgPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvcHk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3B5ID0gW10uY29uY2F0KHNlbHNbaV0pO1xuICAgICAgICAgICAgICAgIHN0YXRlLnB1c2goY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgQWRkIGEgY29udGlndW91cyBydW4gb2YgcG9pbnRzIHRvIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAqIEBkZXNjIEluc2VydCBhIG5ldyBydW4gaW50byBgdGhpcy5zZWxlY3Rpb25gLlxuICAgICAgICAgKiBUaGUgbmV3IHJ1biB3aWxsIGJlIG1lcmdlZCB3aXRoIG92ZXJsYXBwaW5nIGFuZCBhZGphY2VudCBydW5zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgdHdvIHBhcmFtZXRlcnMgbWF5IGJlIGdpdmVuIGluIGVpdGhlciBvcmRlci5cbiAgICAgICAgICogVGhlIHN0YXJ0IGFuZCBzdG9wIGVsZW1lbnRzIGluIHRoZSByZXN1bHRpbmcgcnVuIHdpbGwgaG93ZXZlciBhbHdheXMgYmUgb3JkZXJlZC5cbiAgICAgICAgICogKEhvd2V2ZXIsIG5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIHJ1bnMgd2l0aGluIGB0aGlzLnNlbGVjdGlvbmAgaXMgaXRzZWxmIGFsd2F5cyB1bm9yZGVyZWQuKVxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgYHRoaXMuc2VsZWN0aW9uYCBpcyB1cGRhdGVkIGluIHBsYWNlLCBwcmVzZXJ2aW5nIHZhbGlkaXR5IG9mIGFueSBleHRlcm5hbCByZWZlcmVuY2VzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBTdGFydCBvZiBydW4uIE1heSBiZSBncmVhdGVyIHRoYW4gYHN0b3BgLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0b3A9c3RvcF0gLSBFbmQgb2YgcnVuIChpbmNsdXNpdmUpLiBNYXkgYmUgbGVzcyB0aGFuIGBzdGFydGAuXG4gICAgICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2ApLCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0OiBmdW5jdGlvbiAoc3RhcnQsIHN0b3ApIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVTdGF0ZSgpO1xuICAgICAgICAgICAgdmFyIHJ1biA9IG1ha2VSdW4oc3RhcnQsIHN0b3ApO1xuICAgICAgICAgICAgdmFyIHNwbGljZXIgPSBbMCwgMV07XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChlYWNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBzKGVhY2gsIHJ1bikgfHwgYWJ1dHMoZWFjaCwgcnVuKSkge1xuICAgICAgICAgICAgICAgICAgICBydW4gPSBtZXJnZShlYWNoLCBydW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZXIucHVzaChlYWNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNwbGljZXIucHVzaChydW4pO1xuICAgICAgICAgICAgc3BsaWNlclsxXSA9IHRoaXMuc2VsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNwbGljZS5hcHBseSh0aGlzLnNlbGVjdGlvbiwgc3BsaWNlcik7IC8vIHVwZGF0ZSBpbiBwbGFjZSB0byBwcmVzZXJ2ZSBleHRlcm5hbCByZWZlcmVuY2VzXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgUmVtb3ZlIGEgY29udGlndW91cyBydW4gb2YgcG9pbnRzIGZyb20gdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICogQGRlc2MgVHJ1bmNhdGUgYW5kL29yIHJlbW92ZSBydW4ocykgZnJvbSBgdGhpcy5zZWxlY3Rpb25gLlxuICAgICAgICAgKiBSZW1vdmluZyBwYXJ0IG9mIGV4aXN0aW5nIHJ1bnMgd2lsbCAoY29ycmVjdGx5KSBzaG9ydGVuIHRoZW0gb3IgYnJlYWsgdGhlbSBpbnRvIHR3byBmcmFnbWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSB0d28gcGFyYW1ldGVycyBtYXkgYmUgZ2l2ZW4gaW4gZWl0aGVyIG9yZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgYHRoaXMuc2VsZWN0aW9uYCBpcyB1cGRhdGVkIGluIHBsYWNlLCBwcmVzZXJ2aW5nIHZhbGlkaXR5IG9mIGFueSBleHRlcm5hbCByZWZlcmVuY2VzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBTdGFydCBvZiBydW4uIE1heSBiZSBncmVhdGVyIHRoYW4gYHN0b3BgLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0b3A9c3RvcF0gLSBFbmQgb2YgcnVuIChpbmNsdXNpdmUpLiBNYXkgYmUgbGVzcyB0aGFuIGBzdGFydGAuXG4gICAgICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2ApLCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZGVzZWxlY3Q6IGZ1bmN0aW9uIChzdGFydCwgc3RvcCkge1xuICAgICAgICAgICAgdmFyIHJ1biA9IG1ha2VSdW4oc3RhcnQsIHN0b3ApO1xuICAgICAgICAgICAgdmFyIHNwbGljZXIgPSBbMCwgMF07XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChlYWNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBzKGVhY2gsIHJ1bikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpZWNlcyA9IHN1YnRyYWN0KGVhY2gsIHJ1bik7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZXIgPSBzcGxpY2VyLmNvbmNhdChwaWVjZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZXIucHVzaChlYWNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNwbGljZXJbMV0gPSB0aGlzLnNlbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zcGxpY2UuYXBwbHkodGhpcy5zZWxlY3Rpb24sIHNwbGljZXIpOyAvLyB1cGRhdGUgaW4gcGxhY2UgdG8gcHJlc2VydmUgZXh0ZXJuYWwgcmVmZXJlbmNlc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IEVtcHRpZXMgYHRoaXMuc2VsZWN0aW9uYCwgZWZmZWN0aXZlbHkgcmVtb3ZpbmcgYWxsIHJ1bnMuXG4gICAgICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2ApLCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gYGNlbGxgIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBnaXZlbiBgY2VsbGAgaXMgd2l0aGluIGFueSBvZiB0aGUgcnVucyBpbiBgdGhpcy5zZWxlY3Rpb25gLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY2VsbCAtIFRoZSBjZWxsIHRvIHRlc3QgZm9yIGluY2x1c2lvbiBpbiB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uc29tZShmdW5jdGlvbiAoZWFjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlYWNoWzBdIDw9IGNlbGwgJiYgY2VsbCA8PSBlYWNoWzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24ubGVuZ3RoID09PSAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGluZGV4ZXMgdGhhdCBhcmUgc2VsZWN0ZWQuXG4gICAgICAgICAqIEBkZXNjIFJldHVybiB0aGUgaW5kZXhlcyB0aGF0IGFyZSBzZWxlY3RlZC5cbiAgICAgICAgICogQHJldHVybnMge0FycmF5LkFycmF5Lm51bWJlcn1cbiAgICAgICAgICogQG1lbWJlck9mIFJhbmdlU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKGVhY2gpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZWFjaFswXTsgaSA8PSBlYWNoWzFdOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQuc29ydChmdW5jdGlvbiAoYSwgYil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3VtbWFyeSBQcmVwcyBgc3RhcnRgIGFuZCBgc3RvcGAgcGFyYW1zIGludG8gb3JkZXIgYXJyYXlcbiAgICAgKiBAZnVuY3Rpb24gbWFrZVJ1blxuICAgICAqIEBkZXNjIFV0aWxpdHkgZnVuY3Rpb24gY2FsbGVkIGJ5IGJvdGggYHNlbGVjdCgpYCBhbmQgYGRlc2VsZWN0KClgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBzdGFydCAtIFN0YXJ0IG9mIHJ1bi4gaWYgYXJyYXksIGBzdGFydGAgYW5kIGBzdG9wYCBhcmUgdGFrZW4gZnJvbSBmaXJzdCB0d28gZWxlbWVudHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdG9wPXN0YXJ0XSAtIEVuZCBvZiBydW4gKGluY2x1c2l2ZSkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZVJ1bihzdGFydCwgc3RvcCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgc3RhcnQgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICAgID8gbWFrZVJ1bi5hcHBseSh0aGlzLCBzdGFydCkgLy8gZXh0cmFjdCBwYXJhbXMgZnJvbSBnaXZlbiBhcnJheVxuICAgICAgICAgICAgICAgIDogc3RvcCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBbIHN0YXJ0LCBzdGFydCBdIC8vIHNpbmdsZSBwYXJhbSBpcyBhIHJ1biB0aGF0IHN0b3BzIHdoZXJlIGl0IHN0YXJ0c1xuICAgICAgICAgICAgICAgIDogc3RhcnQgPD0gc3RvcFxuICAgICAgICAgICAgICAgID8gWyBzdGFydCwgc3RvcCBdXG4gICAgICAgICAgICAgICAgOiBbIHN0b3AsIHN0YXJ0IF0gLy8gcmV2ZXJzZSBkZXNjZW5kaW5nIHBhcmFtcyBpbnRvIGFzY2VuZGluZyBvcmRlclxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uIG92ZXJsYXBzXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgYHJ1bjFgIG92ZXJsYXBzIGBydW4yYFxuICAgICAqIEBzdW1tYXJ5IENvbXBhcmlzb24gb3BlcmF0b3IgdGhhdCBkZXRlcm1pbmVzIGlmIGdpdmVuIHJ1bnMgb3ZlcmxhcCB3aXRoIG9uZSBhbm90aGVyLlxuICAgICAqIEBkZXNjIEJvdGggcGFyYW1ldGVycyBhcmUgYXNzdW1lZCB0byBiZSBfb3JkZXJlZF8gYXJyYXlzLlxuICAgICAqXG4gICAgICogT3ZlcmxhcCBpcyBkZWZpbmVkIHRvIGluY2x1ZGUgdGhlIGNhc2Ugd2hlcmUgb25lIHJ1biBjb21wbGV0ZWx5IGNvbnRhaW5zIHRoZSBvdGhlci5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgb3BlcmF0b3IgaXMgY29tbXV0YXRpdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcnVuMSAtIGZpcnN0IHJ1blxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjIgLSBzZWNvbmQgcnVuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlcmxhcHMocnVuMSwgcnVuMikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcnVuMVswXSA8PSBydW4yWzBdICYmIHJ1bjJbMF0gPD0gcnVuMVsxXSB8fCAvLyBydW4yJ3Mgc3RhcnQgaXMgd2l0aGluIHJ1bjEgT1IuLi5cbiAgICAgICAgICAgIHJ1bjFbMF0gPD0gcnVuMlsxXSAmJiBydW4yWzFdIDw9IHJ1bjFbMV0gfHwgLy8gcnVuMidzIHN0b3AgaXMgd2l0aGluIHJ1bjEgT1IuLi5cbiAgICAgICAgICAgIHJ1bjJbMF0gPCAgcnVuMVswXSAmJiBydW4xWzFdIDwgIHJ1bjJbMV0gICAgLy8gcnVuMiBjb21wbGV0ZWx5IGNvbnRhaW5zIHJ1bjFcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBhYnV0c1xuICAgICAqIEBzdW1tYXJ5IENvbXBhcmlzb24gb3BlcmF0b3IgdGhhdCBkZXRlcm1pbmVzIGlmIGdpdmVuIHJ1bnMgYXJlIGNvbnNlY3V0aXZlIHdpdGggb25lIGFub3RoZXIuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgYHJ1bjFgIGlzIGNvbnNlY3V0aXZlIHdpdGggYHJ1bjJgXG4gICAgICogQGRlc2MgQm90aCBwYXJhbWV0ZXJzIGFyZSBhc3N1bWVkIHRvIGJlIF9vcmRlcmVkXyBhcnJheXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9wZXJhdG9yIGlzIGNvbW11dGF0aXZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjEgLSBmaXJzdCBydW5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBydW4yIC0gc2Vjb25kIHJ1blxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFidXRzKHJ1bjEsIHJ1bjIpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJ1bjFbMV0gPT09IHJ1bjJbMF0gLSAxIHx8IC8vIHJ1bjEncyB0b3AgaW1tZWRpYXRlbHkgcHJlY2VkZXMgcnVuMidzIHN0YXJ0IE9SLi4uXG4gICAgICAgICAgICBydW4yWzFdID09PSBydW4xWzBdIC0gMSAgICAvLyBydW4yJ3MgdG9wIGltbWVkaWF0ZWx5IHByZWNlZGVzIHJ1bjEncyBzdGFydFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uIHN1YnRyYWN0XG4gICAgICogQHN1bW1hcnkgT3BlcmF0b3IgdGhhdCBzdWJ0cmFjdHMgb25lIHJ1biBmcm9tIGFub3RoZXIuXG4gICAgICogQHJldHVybnMge0FycmF5LkFycmF5Lm51bWJlcn0gVGhlIHJlbWFpbmluZyBwaWVjZXMgb2YgYG1pbnVlbmRgIGFmdGVyIHJlbW92aW5nIGBzdWJ0cmFoZW5kYC5cbiAgICAgKiBAZGVzYyBCb3RoIHBhcmFtZXRlcnMgYXJlIGFzc3VtZWQgdG8gYmUgX29yZGVyZWRfIGFycmF5cy5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gX2RvZXMgbm90IGFzc3VtZXNfIHRoYXQgYG92ZXJsYXAoKWAgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQgd2l0aCB0aGUgc2FtZSBydW5zIGFuZCBoYXMgcmV0dXJuZWQgYHRydWVgLlxuICAgICAqXG4gICAgICogUmV0dXJuZWQgYXJyYXkgY29udGFpbnMgMCwgMSwgb3IgMiBydW5zIHdoaWNoIGFyZSB0aGUgcG9ydGlvbihzKSBvZiBgbWludWVuZGAgdGhhdCBkbyBfbm90XyBpbmNsdWRlIGBzdWJ0cmFoZW5kYC5cbiAgICAgKlxuICAgICAqIENhdmVhdDogVGhpcyBvcGVyYXRvciBpcyAqbm90KiBjb21tdXRhdGl2ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBtaW51ZW5kIC0gYSBydW4gZnJvbSB3aGljaCB0byBcInN1YnRyYWN0XCIgYHN1YnRyYWhlbmRgXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gc3VidHJhaGVuZCAtIGEgcnVuIHRvIFwic3VidHJhY3RlZFwiIGZyb20gYG1pbnVlbmRgXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VidHJhY3QobWludWVuZCwgc3VidHJhaGVuZCkge1xuICAgICAgICB2YXIgbTAgPSBtaW51ZW5kWzBdO1xuICAgICAgICB2YXIgbTEgPSBtaW51ZW5kWzFdO1xuICAgICAgICB2YXIgczAgPSBzdWJ0cmFoZW5kWzBdO1xuICAgICAgICB2YXIgczEgPSBzdWJ0cmFoZW5kWzFdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKHMwIDw9IG0wICYmIHMxIDwgbTEpIHtcbiAgICAgICAgICAgIC8vc3VidHJhaGVuZCBleHRlbmRzIGJlZm9yZSBtaW51ZW5kOiByZXR1cm4gcmVtYWluaW5nIHBpZWNlIG9mIGBtaW51ZW5kYFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goW3MxICsgMSwgbTFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzMCA+IG0wICYmIHMxID49IG0xKSB7XG4gICAgICAgICAgICAvL3N1YnRyYWhlbmQgZXh0ZW5kcyBhZnRlciBtaW51ZW5kOiByZXR1cm4gcmVtYWluaW5nIHBpZWNlIG9mIGBtaW51ZW5kYFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goW20wLCBzMCAtIDFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChtMCA8IHMwICYmIHMxIDwgbTEpIHtcbiAgICAgICAgICAgIC8vY29tcGxldGVseSBpbnNpZGU6IHJldHVybiAyIHNtYWxsZXIgcGllY2VzIHJlc3VsdGluZyBmcm9tIHRoZSBob2xlXG4gICAgICAgICAgICByZXN1bHQucHVzaChbbTAsIHMwIC0gMV0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW3MxICsgMSwgbTFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzMSA8IG0wIHx8IHMwID4gbTEpIHtcbiAgICAgICAgICAgIC8vIGNvbXBsZXRlbHkgb3V0c2lkZTogcmV0dXJuIGBtaW51ZW5kYCB1bnRvdWNoZWRcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1pbnVlbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9lbHNlIHN1YnRyYWhlbmQgbXVzdCBjb21wbGV0ZWx5IG92ZXJsYXAgbWludWVuZCBzbyByZXR1cm4gbm8gcGllY2VzXG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cblxuICAgIC8vIExvY2FsIHV0aWxpdHkgZnVuY3Rpb25zXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBtZXJnZVxuICAgICAqIEBzdW1tYXJ5IE9wZXJhdG9yIHRoYXQgbWVyZ2VzIGdpdmVuIHJ1bnMuXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBBIHNpbmdsZSBtZXJnZWQgcnVuLlxuICAgICAqIEBkZXNjIEJvdGggcGFyYW1ldGVycyBhcmUgYXNzdW1lZCB0byBiZSBfb3JkZXJlZF8gYXJyYXlzLlxuICAgICAqXG4gICAgICogVGhlIHJ1bnMgYXJlIGFzc3VtZWQgdG8gYmUgb3ZlcmxhcHBpbmcgb3IgYWRqYWNlbnQgdG8gb25lIGFub3RoZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9wZXJhdG9yIGlzIGNvbW11dGF0aXZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjEgLSBhIHJ1biB0byBtZXJnZSB3aXRoIGBydW4yYFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjIgLSBhIHJ1biB0byBtZXJnZSB3aXRoIGBydW4xYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlKHJ1bjEsIHJ1bjIpIHtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKE1hdGgubWluLmFwcGx5KE1hdGgsIHJ1bjEpLCBNYXRoLm1pbi5hcHBseShNYXRoLCBydW4yKSk7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heChNYXRoLm1heC5hcHBseShNYXRoLCBydW4xKSwgTWF0aC5tYXguYXBwbHkoTWF0aCwgcnVuMikpO1xuICAgICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9XG5cbiAgICAvLyBJbnRlcmZhY2VcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJhbmdlU2VsZWN0aW9uTW9kZWw7XG59KShcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUgfHwgKHdpbmRvdy5SYW5nZVNlbGVjdGlvbk1vZGVsID0ge30pLFxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzIHx8ICh3aW5kb3cuUmFuZ2VTZWxlY3Rpb25Nb2RlbC5leHBvcnRzID0ge30pXG4pIHx8IChcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyB8fCAod2luZG93LlJhbmdlU2VsZWN0aW9uTW9kZWwgPSB3aW5kb3cuUmFuZ2VTZWxlY3Rpb25Nb2RlbC5leHBvcnRzKVxuKTtcblxuLyogQWJvdXQgdGhlIGFib3ZlIElJRkU6XG4gKiBUaGlzIGZpbGUgaXMgYSBcIm1vZGlmaWVkIG5vZGUgbW9kdWxlLlwiIEl0IGZ1bmN0aW9ucyBhcyB1c3VhbCBpbiBOb2RlLmpzICphbmQqIGlzIGFsc28gdXNhYmxlIGRpcmVjdGx5IGluIHRoZSBicm93c2VyLlxuICogMS4gTm9kZS5qczogVGhlIElJRkUgaXMgc3VwZXJmbHVvdXMgYnV0IGlubm9jdW91cy5cbiAqIDIuIEluIHRoZSBicm93c2VyOiBUaGUgSUlGRSBjbG9zdXJlIHNlcnZlcyB0byBrZWVwIGludGVybmFsIGRlY2xhcmF0aW9ucyBwcml2YXRlLlxuICogMi5hLiBJbiB0aGUgYnJvd3NlciBhcyBhIGdsb2JhbDogVGhlIGxvZ2ljIGluIHRoZSBhY3R1YWwgcGFyYW1ldGVyIGV4cHJlc3Npb25zICsgdGhlIHBvc3QtaW52b2NhdGlvbiBleHByZXNzaW9uXG4gKiB3aWxsIHB1dCB5b3VyIEFQSSBpbiBgd2luZG93LlJhbmdlU2VsZWN0aW9uTW9kZWxgLlxuICogMi5iLiBJbiB0aGUgYnJvd3NlciBhcyBhIG1vZHVsZTogSWYgeW91IHByZWRlZmluZSBhIGB3aW5kb3cubW9kdWxlYCBvYmplY3QsIHRoZSByZXN1bHRzIHdpbGwgYmUgaW4gYG1vZHVsZS5leHBvcnRzYC5cbiAqIFRoZSBib3dlciBjb21wb25lbnQgYG1ubWAgbWFrZXMgdGhpcyBlYXN5IGFuZCBhbHNvIHByb3ZpZGVzIGEgZ2xvYmFsIGByZXF1aXJlKClgIGZ1bmN0aW9uIGZvciByZWZlcmVuY2luZyB5b3VyIG1vZHVsZVxuICogZnJvbSBvdGhlciBjbG9zdXJlcy4gSW4gZWl0aGVyIGNhc2UsIHRoaXMgd29ya3Mgd2l0aCBib3RoIE5vZGVKcy1zdHlsZSBleHBvcnQgbWVjaGFuaXNtcyAtLSBhIHNpbmdsZSBBUEkgYXNzaWdubWVudCxcbiAqIGBtb2R1bGUuZXhwb3J0cyA9IHlvdXJBUElgICpvciogYSBzZXJpZXMgb2YgaW5kaXZpZHVhbCBwcm9wZXJ0eSBhc3NpZ25tZW50cywgYG1vZHVsZS5leHBvcnRzLnByb3BlcnR5ID0gcHJvcGVydHlgLlxuICpcbiAqIEJlZm9yZSB0aGUgSUlGRSBydW5zLCB0aGUgYWN0dWFsIHBhcmFtZXRlciBleHByZXNzaW9ucyBhcmUgZXhlY3V0ZWQ6XG4gKiAxLiBJZiBgd2luZG93YCBvYmplY3QgdW5kZWZpbmVkLCB3ZSdyZSBpbiBOb2RlSnMgc28gYXNzdW1lIHRoZXJlIGlzIGEgYG1vZHVsZWAgb2JqZWN0IHdpdGggYW4gYGV4cG9ydHNgIHByb3BlcnR5XG4gKiAyLiBJZiBgd2luZG93YCBvYmplY3QgZGVmaW5lZCwgd2UncmUgaW4gYnJvd3NlclxuICogMi5hLiBJZiBgbW9kdWxlYCBvYmplY3QgcHJlZGVmaW5lZCwgdXNlIGl0XG4gKiAyLmIuIElmIGBtb2R1bGVgIG9iamVjdCB1bmRlZmluZWQsIGNyZWF0ZSBhIGBSYW5nZVNlbGVjdGlvbk1vZGVsYCBvYmplY3RcbiAqXG4gKiBBZnRlciB0aGUgSUlGRSByZXR1cm5zOlxuICogQmVjYXVzZSBpdCBhbHdheXMgcmV0dXJucyB1bmRlZmluZWQsIHRoZSBleHByZXNzaW9uIGFmdGVyIHRoZSB8fCB3aWxsIGV4ZWN1dGU6XG4gKiAxLiBJZiBgd2luZG93YCBvYmplY3QgdW5kZWZpbmVkLCB0aGVuIHdlJ3JlIGluIE5vZGVKcyBzbyB3ZSdyZSBkb25lXG4gKiAyLiBJZiBgd2luZG93YCBvYmplY3QgZGVmaW5lZCwgdGhlbiB3ZSdyZSBpbiBicm93c2VyXG4gKiAyLmEuIElmIGBtb2R1bGVgIG9iamVjdCBwcmVkZWZpbmVkLCB3ZSdyZSBkb25lOyByZXN1bHRzIGFyZSBpbiBgbW91ZHVsZS5leHBvcnRzYFxuICogMi5iLiBJZiBgbW9kdWxlYCBvYmplY3QgdW5kZWZpbmVkLCByZWRlZmluZWBSYW5nZVNlbGVjdGlvbk1vZGVsYCB0byBiZSB0aGUgYFJhbmdlU2VsZWN0aW9uTW9kZWwuZXhwb3J0c2Agb2JqZWN0XG4gKi9cbiIsIi8vIHRhYnogbm9kZSBtb2R1bGVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25laXQvdGFielxuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3NzSW5qZWN0b3IgPSByZXF1aXJlKCdjc3MtaW5qZWN0b3InKTtcblxuLyoqXG4gKiBSZWdpc3Rlci9kZXJlZ2lzdGVyIGNsaWNrIGhhbmRsZXIgb24gYWxsIHRhYiBjb2xsZWN0aW9ucy5cbiAqIEBwYXJhbSB7RWxlbWVudH0gW29wdGlvbnMucm9vdD1kb2N1bWVudF0gLSBXaGVyZSB0byBsb29rIGZvciB0YWIgcGFuZWxzIChgLnRhYnpgIGVsZW1lbnRzKSBjb250YWluaW5nIHRhYnMgYW5kIGZvbGRlcnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnVuaG9vaz1mYWxzZV0gLSBSZW1vdmUgZXZlbnQgbGlzdGVuZXIgZnJvbSB0YWIgcGFuZWxzIChgLnRhYnpgIGVsZW1lbnRzKS5cbiAqIEBwYXJhbSB7RWxlbWVudH0gW29wdGlvbnMucmVmZXJlbmNlRWxlbWVudF0gLSBQYXNzZWQgdG8gY3NzSW5qZWN0b3IncyBpbnNlcnRCZWZvcmUoKSBjYWxsLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlZmF1bHRUYWJTZWxlY3Rvcj0nLmRlZmF1bHQtdGFiJ10gLSAuY2xhc3NuYW1lIG9yICNpZCBvZiB0aGUgdGFiIHRvIHNlbGVjdCBieSBkZWZhdWx0XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMub25FbmFibGVdIC0gSGFuZGxlciBpbXBsZW1lbnRhdGlvbi4gU2VlIHtAbGluayBUYWJ6I29uRW5hYmxlfG9uRW5hYmxlfS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5vbkRpc2FibGVdIC0gSGFuZGxlciBpbXBsZW1lbnRhdGlvbi4gU2VlIHtAbGluayBUYWJ6I29uRGlzYWJsZXxvbkVuYWJsZX0uXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMub25FbmFibGVkXSAtIEhhbmRsZXIgaW1wbGVtZW50YXRpb24uIFNlZSB7QGxpbmsgVGFieiNvbkVuYWJsZWR8b25FbmFibGV9LlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm9uRGlzYWJsZWRdIC0gSGFuZGxlciBpbXBsZW1lbnRhdGlvbi4gU2VlIHtAbGluayBUYWJ6I29uRGlzYWJsZWR8b25FbmFibGV9LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRhYnoob3B0aW9ucykge1xuICAgIHZhciBpLCBlbDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciByb290ID0gb3B0aW9ucy5yb290IHx8IGRvY3VtZW50LFxuICAgICAgICB1bmhvb2sgPSBvcHRpb25zLnVuaG9vayxcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IG9wdGlvbnMucmVmZXJlbmNlRWxlbWVudCxcbiAgICAgICAgZGVmYXVsdFRhYlNlbGVjdG9yID0gb3B0aW9ucy5kZWZhdWx0VGFiU2VsZWN0b3IgfHwgJy5kZWZhdWx0LXRhYic7XG5cbiAgICBpZiAoIXVuaG9vaykge1xuICAgICAgICB2YXIgY3NzO1xuICAgICAgICAvKiBpbmplY3Q6Y3NzICovXG4gICAgICAgIGNzcyA9ICcudGFientwb3NpdGlvbjpyZWxhdGl2ZTt2aXNpYmlsaXR5OmhpZGRlbjtoZWlnaHQ6MTAwJX0udGFiej5oZWFkZXJ7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7YmFja2dyb3VuZC1jb2xvcjojZmZmO21hcmdpbi1sZWZ0OjFlbTtwYWRkaW5nOjVweCAuNmVtO2JvcmRlcjoxcHggc29saWQgIzY2Njtib3JkZXItYm90dG9tLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1yYWRpdXM6NnB4IDZweCAwIDA7Y3Vyc29yOmRlZmF1bHQ7dXNlci1zZWxlY3Q6bm9uZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lfS50YWJ6PmhlYWRlcitzZWN0aW9ue3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7bWFyZ2luLXRvcDotMXB4O3BhZGRpbmc6OHB4O2JvcmRlcjoxcHggc29saWQgIzY2Njtib3JkZXItcmFkaXVzOjZweDtsZWZ0OjA7cmlnaHQ6MDtib3R0b206MDt0b3A6MDt6LWluZGV4OjB9LnRhYno+aGVhZGVyK3NlY3Rpb24udGFiei1lbmFibGV7ei1pbmRleDoxfS50YWJ6PmhlYWRlci50YWJ6LWVuYWJsZXt6LWluZGV4OjJ9LnRhYnotYmcwe2JhY2tncm91bmQtY29sb3I6I2VlZSFpbXBvcnRhbnR9LnRhYnotYmcxe2JhY2tncm91bmQtY29sb3I6I2VlZiFpbXBvcnRhbnR9LnRhYnotYmcye2JhY2tncm91bmQtY29sb3I6I2VmZSFpbXBvcnRhbnR9LnRhYnotYmcze2JhY2tncm91bmQtY29sb3I6I2VmZiFpbXBvcnRhbnR9LnRhYnotYmc0e2JhY2tncm91bmQtY29sb3I6I2ZlZSFpbXBvcnRhbnR9LnRhYnotYmc1e2JhY2tncm91bmQtY29sb3I6I2ZlZiFpbXBvcnRhbnR9LnRhYnotYmc2e2JhY2tncm91bmQtY29sb3I6I2ZmZSFpbXBvcnRhbnR9JztcbiAgICAgICAgLyogZW5kaW5qZWN0ICovXG5cbiAgICAgICAgaWYgKCFyZWZlcmVuY2VFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBmaW5kIGZpcnN0IDxsaW5rPiBvciA8c3R5bGU+IGluIDxoZWFkPlxuICAgICAgICAgICAgdmFyIGhlYWRTdHVmZiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKS5jaGlsZHJlbjtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7ICFyZWZlcmVuY2VFbGVtZW50ICYmIGkgPCBoZWFkU3R1ZmYubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBlbCA9IGhlYWRTdHVmZltpXTtcbiAgICAgICAgICAgICAgICBpZiAoZWwudGFnTmFtZSA9PT0gJ1NUWUxFJyB8fCBlbC50YWdOYW1lID09PSAnTElOSycgJiYgZWwucmVsID09PSAnc3R5bGVzaGVldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjc3NJbmplY3Rvcihjc3MsICd0YWJ6LWNzcy1iYXNlJywgcmVmZXJlbmNlRWxlbWVudCk7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2tleV0gPT09IG5vb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgVGhlIGNvbnRleHQgb2YgdGhpcyB0YWIgb2JqZWN0LlxuICAgICAgICAgKiBAZGVzYyBUaGUgY29udGV4dCBtYXkgZW5jb21wYXNzIGFueSBudW1iZXIgb2YgdGFiIHBhbmVscyAoYC50YWJ6YCBlbGVtZW50cykuXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRG9jdW1lbnxIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG5cbiAgICAgICAgLy8gZW5hYmxlIGZpcnN0IHRhYiBvbiBlYWNoIHRhYiBwYW5lbCAoYC50YWJ6YCBlbGVtZW50KVxuICAgICAgICBmb3JFYWNoRWwoJy50YWJ6PmhlYWRlcjpmaXJzdC1vZi10eXBlLC50YWJ6PnNlY3Rpb246Zmlyc3Qtb2YtdHlwZScsIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCd0YWJ6LWVuYWJsZScpO1xuICAgICAgICB9LCByb290KTtcblxuICAgICAgICAvLyBlbmFibGUgZGVmYXVsdCB0YWIgYW5kIGFsbCBpdHMgcGFyZW50cyAobXVzdCBiZSBhIHRhYilcbiAgICAgICAgdGhpcy50YWJUbyhyb290LnF1ZXJ5U2VsZWN0b3IoJy50YWJ6ID4gaGVhZGVyJyArIGRlZmF1bHRUYWJTZWxlY3RvcikpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3JFYWNoRWwoJy50YWJ6ID4gc2VjdGlvbicsIGZ1bmN0aW9uKGVsKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTdGVwIDE6IEEgYnVnIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSAobGlrZSB2NDApIHRoYXQgaW5zZXJ0ZWQgYSBicmVhayBhdCBtYXJrLXVwIGxvY2F0aW9uIG9mIGFuIGFic29sdXRlIHBvc2l0aW9uZWQgYmxvY2suIFRoZSB3b3JrLWFyb3VuZCBpcyB0byBoaWRlIHRob3NlIGJsb2NrcyB1bnRpbCBhZnRlciBmaXJzdCByZW5kZXI7IHRoZW4gc2hvdyB0aGVtLiBJIGRvbid0IGtub3cgd2h5IHRoaXMgd29ya3MgYnV0IGl0IGRvZXMuIFNlZW1zIHRvIGJlIGR1cmFibGUuXG4gICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgICAgICAgICAgICAvLyBTdGVwIDI6IEFkanVzdCBhYnNvbHV0ZSB0b3Agb2YgZWFjaCByZW5kZXJlZCBmb2xkZXIgdG8gdGhlIGJvdHRvbSBvZiBpdHMgdGFiXG4gICAgICAgICAgICAgICAgZWwuc3R5bGUudG9wID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gLSBlbC5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArICdweCc7XG5cbiAgICAgICAgICAgIH0sIHJvb3QpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICB2YXIgbWV0aG9kID0gdW5ob29rID8gJ3JlbW92ZUV2ZW50TGlzdGVuZXInIDogJ2FkZEV2ZW50TGlzdGVuZXInO1xuICAgIHZhciBib3VuZENsaWNrSGFuZGxlciA9IG9uY2xpY2suYmluZCh0aGlzKTtcbiAgICBmb3JFYWNoRWwoJy50YWJ6JywgZnVuY3Rpb24odGFiQmFyKSB7XG4gICAgICAgIHRhYkJhci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICB0YWJCYXJbbWV0aG9kXSgnY2xpY2snLCBib3VuZENsaWNrSGFuZGxlcik7XG4gICAgfSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIG9uY2xpY2soZXZ0KSB7XG4gICAgY2xpY2suY2FsbCh0aGlzLCBldnQuY3VycmVudFRhcmdldCwgZXZ0LnRhcmdldCk7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgU2VsZWN0cyB0aGUgZ2l2ZW4gdGFiLlxuICogQGRlc2MgSWYgaXQgaXMgYSBuZXN0ZWQgdGFiLCBhbHNvIHJldmVhbHMgYWxsIGl0cyBhbmNlc3RvciB0YWJzLlxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEVsZW1lbnR9IFtlbF0gLSBNYXkgYmUgb25lIG9mOlxuICogKiBgSFRNTEVsZW1lbnRgXG4gKiAgICogYDxoZWFkZXI+YCAtIHRhYiBlbGVtZW50XG4gKiAgICogYDxzZWN0aW9uPmAgLSBmb2xkZXIgZWxlbWVudFxuICogKiBgc3RyaW5nYCAtIENTUyBzZWxlY3RvciB0byBvbmUgb2YgdGhlIGFib3ZlXG4gKiAqIGZhbHN5IC0gZmFpbHMgc2lsZW50bHlcbiAqIEBtZW1iZXJPZiBUYWJ6LnByb3RvdHlwZVxuICovXG5UYWJ6LnByb3RvdHlwZS50YWJUbyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgd2hpbGUgKChlbCA9IHRoaXMudGFiKGVsKSkpIHtcbiAgICAgICAgY2xpY2suY2FsbCh0aGlzLCBlbC5wYXJlbnRFbGVtZW50LCBlbCk7XG4gICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50OyAvLyBsb29wIHRvIGNsaWNrIG9uIGVhY2ggY29udGFpbmluZyB0YWIuLi5cbiAgICB9XG59O1xuXG4vKipcbiAqIEN1cnJlbnQgc2VsZWN0ZWQgdGFiLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxudW1iZXJ9IGVsIC0gQW4gZWxlbWVudCB0aGF0IGlzIChvciBpcyB3aXRoaW4pIHRoZSB0YWIgcGFuZWwgKGAudGFiemAgZWxlbWVudCkgdG8gbG9vayBpbi5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8SFRNTEVsZW1lbnR9IFJldHVybnMgdGFiIChgPGhlYWRlcj5gKSBlbGVtZW50LiAgUmV0dXJucyBgdW5kZWZpbmVkYCBpZiBgZWxgIGlzIG5laXRoZXIgb2YgdGhlIGFib3ZlIG9yIGFuIG91dCBvZiByYW5nZSBpbmRleC5cbiAqL1xuVGFiei5wcm90b3R5cGUuZW5hYmxlZFRhYiA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgZWwgPSB0aGlzLnBhbmVsKGVsKTtcbiAgICByZXR1cm4gZWwgJiYgZWwucXVlcnlTZWxlY3RvcignOnNjb3BlPmhlYWRlci50YWJ6LWVuYWJsZScpO1xufTtcblxuLyoqXG4gKiBAc3VtbWFyeSBHZXQgdGFiIGVsZW1lbnQuXG4gKiBAZGVzYyBHZXQgdGFiIGVsZW1lbnQgaWYgZ2l2ZW4gdGFiIG9yIGZvbGRlciBlbGVtZW50OyBvciBhbiBlbGVtZW50IHdpdGhpbiBzdWNoOyBvciBmaW5kIHRhYi5cbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR9IFtlbF0gLSBNYXkgYmUgb25lIG9mOlxuICogKiBhIHRhYiAoYSBgPGhlYWRlcj5gIGVsZW1lbnQpXG4gKiAqIGEgZm9sZGVyIChhIGA8c2VjdGlvbj5gIGVsZW1lbnQpXG4gKiAqIGFuIGVsZW1lbnQgd2l0aGluIG9uZSBvZiB0aGUgYWJvdmVcbiAqICogYHN0cmluZ2AgLSBDU1Mgc2VsZWN0b3IgdG8gb25lIG9mIHRoZSBhYm92ZSwgc2VhcmNoaW5nIHdpdGhpbiB0aGUgcm9vdCBvciBkb2N1bWVudFxuICogQHJldHVybnMge251bGx8RWxlbWVudH0gdGFiIChgPGhlYWRlcj4uLi48L2hlYWRlcj5gKSBlbGVtZW50IG9yIGBudWxsYCBpZiBub3QgZm91bmRcbiAqIEBtZW1iZXJPZiBUYWJ6LnByb3RvdHlwZVxuICovXG5UYWJ6LnByb3RvdHlwZS50YWIgPSBmdW5jdGlvbihlbCkge1xuICAgIGVsID0gbG9va0ZvckVsLmNhbGwodGhpcywgZWwpO1xuICAgIHJldHVybiAhKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpID8gbnVsbCA6IGVsLnRhZ05hbWUgPT09ICdIRUFERVInID8gZWwgOiBlbC50YWdOYW1lID09PSAnU0VDVElPTicgPyBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIDogbnVsbDtcbn07XG5cbi8qKlxuICogQHN1bW1hcnkgR2V0IGZvbGRlciBlbGVtZW50LlxuICogQGRlc2MgR2V0IGZvbGRlciBlbGVtZW50IGlmIGdpdmVuIHRhYiBvciBmb2xkZXIgZWxlbWVudDsgb3IgYW4gZWxlbWVudCB3aXRoaW4gc3VjaDsgb3IgZmluZCBmb2xkZXIuXG4gKiBAcGFyYW0ge3N0cmluZ3xFbGVtZW50fSBbZWxdIC0gTWF5IGJlIG9uZSBvZjpcbiAqICogYSB0YWIgKGEgYDxoZWFkZXI+YCBlbGVtZW50KVxuICogKiBhIGZvbGRlciAoYSBgPHNlY3Rpb24+YCBlbGVtZW50KVxuICogKiBhbiBlbGVtZW50IHdpdGhpbiBvbmUgb2YgdGhlIGFib3ZlXG4gKiAqIGBzdHJpbmdgIC0gQ1NTIHNlbGVjdG9yIHRvIG9uZSBvZiB0aGUgYWJvdmUsIHNlYXJjaGluZyB3aXRoaW4gdGhlIHJvb3Qgb3IgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtudWxsfEVsZW1lbnR9IHRhYiAoYDxoZWFkZXI+Li4uPC9oZWFkZXI+YCkgZWxlbWVudCBvciBgbnVsbGAgaWYgbm90IGZvdW5kXG4gKiBAbWVtYmVyT2YgVGFiei5wcm90b3R5cGVcbiAqL1xuVGFiei5wcm90b3R5cGUuZm9sZGVyID0gZnVuY3Rpb24oZWwpIHtcbiAgICBlbCA9IGxvb2tGb3JFbC5jYWxsKHRoaXMsIGVsKTtcbiAgICByZXR1cm4gIShlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSA/IG51bGwgOiBlbC50YWdOYW1lID09PSAnU0VDVElPTicgPyBlbCA6IGVsLnRhZ05hbWUgPT09ICdIRUFERVInID8gZWwubmV4dEVsZW1lbnRTaWJsaW5nIDogbnVsbDtcbn07XG5cbi8qKlxuICogQHN1bW1hcnkgR2V0IHRhYiBwYW5lbCBlbGVtZW50LlxuICogQGRlc2MgR2V0IHBhbmVsIGVsZW1lbnQgaWYgZ2l2ZW4gdGFiIHBhbmVsIGVsZW1lbnQ7IG9yIGFuIGVsZW1lbnQgd2l0aGluIGEgdGFiIHBhbmVsOyBvciBmaW5kIHRhYiBwYW5lbC5cbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR9IFtlbF0gLSBNYXkgYmUgb25lIG9mOlxuICogKiBhIHRhYiBwYW5lbCAoYW4gYEhUTUxFbGVtZW50YCB3aXRoIGNsYXNzIGB0YWJ6YClcbiAqICogYW4gZWxlbWVudCB3aXRoaW4gYSB0YWIgcGFuZWxcbiAqICogYHN0cmluZ2AgLSBDU1Mgc2VsZWN0b3IgdG8gb25lIGEgdGFiIHBhbmVsLCBzZWFyY2hpbmcgd2l0aGluIHRoZSByb290IG9yIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7bnVsbHxFbGVtZW50fSB0YWIgcGFuZWwgZWxlbWVudCBvciBgbnVsbGAgaWYgbm90IGZvdW5kXG4gKiBAbWVtYmVyT2YgVGFiei5wcm90b3R5cGVcbiAqL1xuVGFiei5wcm90b3R5cGUucGFuZWwgPSBmdW5jdGlvbihlbCkge1xuICAgIHdoaWxlIChlbCAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCd0YWJ6JykpIHtcbiAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gIShlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSA/IG51bGwgOiBlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3RhYnonKSA/IGVsIDogbnVsbDtcbn07XG5cbmZ1bmN0aW9uIGxvb2tGb3JFbChlbCkge1xuICAgIGlmIChlbCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgd2hpbGUgKGVsICYmIGVsLnRhZ05hbWUgIT09ICdIRUFERVInICYmIGVsLnRhZ05hbWUgIT09ICdTRUNUSU9OJykge1xuICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWwgPSB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbn1cblxuLyoqIEVuYWJsZXMgdGhlIHRhYi9mb2xkZXIgcGFpciBvZiB0aGUgY2xpY2tlZCB0YWIuXG4gKiBEaXNhYmxlcyBhbGwgdGhlIG90aGVyIHBhaXJzIGluIHRoaXMgc2NvcGUgd2hpY2ggd2lsbCBpbmNsdWRlIHRoZSBwcmV2aW91c2x5IGVuYWJsZWQgcGFpci5cbiAqIEBwcml2YXRlXG4gKiBAdGhpcyBUYWJ6XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRpdiAtIFRoZSB0YWIgcGFuZWwgKGAudGFiemAgZWxlbWVudCkgdGhhdCdzIGhhbmRsaW5nIHRoZSBjbGljayBldmVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gVGhlIGVsZW1lbnQgdGhhdCByZWNlaXZlZCB0aGUgY2xpY2suXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEVsZW1lbnR9IFRoZSBgPGhlYWRlcj5gIGVsZW1lbnQgKHRhYikgdGhlIHdhcyBjbGlja2VkOyBvciBgdW5kZWZpbmVkYCB3aGVuIGNsaWNrIHdhcyBub3Qgd2l0aGluIGEgdGFiLlxuICovXG5mdW5jdGlvbiBjbGljayhkaXYsIHRhcmdldCkge1xuICAgIHZhciBuZXdUYWIsIG9sZFRhYjtcblxuICAgIGZvckVhY2hFbCgnOnNjb3BlPmhlYWRlcjpub3QoLnRhYnotZW5hYmxlKScsIGZ1bmN0aW9uKHRhYikgeyAvLyB0b2RvOiB1c2UgYSAuZmluZCgpIHBvbHlmaWxsIGhlcmVcbiAgICAgICAgaWYgKHRhYi5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICBuZXdUYWIgPSB0YWI7XG4gICAgICAgIH1cbiAgICB9LCBkaXYpO1xuXG4gICAgaWYgKG5ld1RhYikge1xuICAgICAgICBvbGRUYWIgPSB0aGlzLmVuYWJsZWRUYWIoZGl2KTtcbiAgICAgICAgdG9nZ2xlVGFiLmNhbGwodGhpcywgb2xkVGFiLCBmYWxzZSk7XG4gICAgICAgIHRvZ2dsZVRhYi5jYWxsKHRoaXMsIG5ld1RhYiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1RhYjtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHRoaXMgVGFielxuICogQHBhcmFtIHtFbGVtZW50fSB0YWIgLSBUaGUgYDxoZWFkZXI+YCBlbGVtZW50IG9mIHRoZSB0YWIgdG8gZW5hYmxlIG9yIGRpc2FibGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZSAtIEVuYWJsZSAodnMuIGRpc2FibGUpIHRoZSB0YWIuXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZVRhYih0YWIsIGVuYWJsZSkge1xuICAgIGlmICh0YWIpIHtcbiAgICAgICAgdmFyIGZvbGRlciA9IHRoaXMuZm9sZGVyKHRhYiksXG4gICAgICAgICAgICBtZXRob2QgPSBlbmFibGUgPyAnb25FbmFibGUnIDogJ29uRGlzYWJsZSc7XG5cbiAgICAgICAgdGhpc1ttZXRob2RdLmNhbGwodGhpcywgdGFiLCBmb2xkZXIpO1xuXG4gICAgICAgIHRhYi5jbGFzc0xpc3QudG9nZ2xlKCd0YWJ6LWVuYWJsZScsIGVuYWJsZSk7XG4gICAgICAgIGZvbGRlci5jbGFzc0xpc3QudG9nZ2xlKCd0YWJ6LWVuYWJsZScsIGVuYWJsZSk7XG5cbiAgICAgICAgbWV0aG9kICs9ICdkJztcbiAgICAgICAgdGhpc1ttZXRob2RdLmNhbGwodGhpcywgdGFiLCBmb2xkZXIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB0YWJFdmVudFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHt0YWJFdmVudE9iamVjdH1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHRhYkV2ZW50T2JqZWN0XG4gKiBAcHJvcGVydHkge1RhYnp9IHRhYnogLSBUaGUgdGFiIG9iamVjdCBpc3N1aW5nIHRoZSBjYWxsYmFjay5cbiAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gdGFyZ2V0IC0gVGhlIHRhYiAoYDxoZWFkZXI+YCBlbGVtZW50KS5cbiAqL1xuXG4vKipcbiAqIENhbGxlZCBiZWZvcmUgYSBwcmV2aW91c2x5IGRpc2FibGVkIHRhYiBpcyBlbmFibGVkLlxuICogQHR5cGUge3RhYkV2ZW50fVxuICogQGFic3RyYWN0XG4gKiBAbWVtYmVyT2YgVGFiei5wcm90b3R5cGVcbiAqL1xuVGFiei5wcm90b3R5cGUub25FbmFibGUgPSBub29wO1xuXG4vKipcbiAqIENhbGxlZCBiZWZvcmUgYSBwcmV2aW91c2x5IGVuYWJsZWQgdGFiIGlzIGRpc2FibGVkIGJ5IGFub3RoZXIgdGFiIGJlaW5nIGVuYWJsZWQuXG4gKiBAdHlwZSB7dGFiRXZlbnR9XG4gKiBAYWJzdHJhY3RcbiAqIEBtZW1iZXJPZiBUYWJ6LnByb3RvdHlwZVxuICovXG5UYWJ6LnByb3RvdHlwZS5vbkRpc2FibGUgPSBub29wO1xuXG4vKipcbiAqIENhbGxlZCBhZnRlciBhIHByZXZpb3VzbHkgZGlzYWJsZWQgdGFiIGlzIGVuYWJsZWQuXG4gKiBAdHlwZSB7dGFiRXZlbnR9XG4gKiBAYWJzdHJhY3RcbiAqIEBtZW1iZXJPZiBUYWJ6LnByb3RvdHlwZVxuICovXG5UYWJ6LnByb3RvdHlwZS5vbkVuYWJsZWQgPSBub29wO1xuXG4vKipcbiAqIENhbGxlZCBhZnRlciBhIHByZXZpb3VzbHkgZW5hYmxlZCB0YWIgaXMgZGlzYWJsZWQgYnkgYW5vdGhlciB0YWIgYmVpbmcgZW5hYmxlZC5cbiAqIEB0eXBlIHt0YWJFdmVudH1cbiAqIEBhYnN0cmFjdFxuICogQG1lbWJlck9mIFRhYnoucHJvdG90eXBlXG4gKi9cblRhYnoucHJvdG90eXBlLm9uRGlzYWJsZWQgPSBub29wO1xuXG5mdW5jdGlvbiBub29wKCkge30gLy8gbnVsbCBwYXR0ZXJuXG5cbmZ1bmN0aW9uIGZvckVhY2hFbChzZWxlY3RvciwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbCgoY29udGV4dCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksIGl0ZXJhdGVlKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRhYno7XG4iLCIvLyB0ZW1wbGV4IG5vZGUgbW9kdWxlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L3RlbXBsZXhcblxuLyogZXNsaW50LWVudiBub2RlICovXG5cbi8qKlxuICogTWVyZ2VzIHZhbHVlcyBvZiBleGVjdXRpb24gY29udGV4dCBwcm9wZXJ0aWVzIG5hbWVkIGluIHRlbXBsYXRlIGJ5IHtwcm9wMX0sXG4gKiB7cHJvcDJ9LCBldGMuLCBvciBhbnkgamF2YXNjcmlwdCBleHByZXNzaW9uIGluY29ycG9yYXRpbmcgc3VjaCBwcm9wIG5hbWVzLlxuICogVGhlIGNvbnRleHQgYWx3YXlzIGluY2x1ZGVzIHRoZSBnbG9iYWwgb2JqZWN0LiBJbiBhZGRpdGlvbiB5b3UgY2FuIHNwZWNpZnkgYSBzaW5nbGVcbiAqIGNvbnRleHQgb3IgYW4gYXJyYXkgb2YgY29udGV4dHMgdG8gc2VhcmNoIChpbiB0aGUgb3JkZXIgZ2l2ZW4pIGJlZm9yZSBmaW5hbGx5XG4gKiBzZWFyY2hpbmcgdGhlIGdsb2JhbCBjb250ZXh0LlxuICpcbiAqIE1lcmdlIGV4cHJlc3Npb25zIGNvbnNpc3Rpbmcgb2Ygc2ltcGxlIG51bWVyaWMgdGVybXMsIHN1Y2ggYXMgezB9LCB7MX0sIGV0Yy4sIGRlcmVmXG4gKiB0aGUgZmlyc3QgY29udGV4dCBnaXZlbiwgd2hpY2ggaXMgYXNzdW1lZCB0byBiZSBhbiBhcnJheS4gQXMgYSBjb252ZW5pZW5jZSBmZWF0dXJlLFxuICogaWYgYWRkaXRpb25hbCBhcmdzIGFyZSBnaXZlbiBhZnRlciBgdGVtcGxhdGVgLCBgYXJndW1lbnRzYCBpcyB1bnNoaWZ0ZWQgb250byB0aGUgY29udGV4dFxuICogYXJyYXksIHRodXMgbWFraW5nIGZpcnN0IGFkZGl0aW9uYWwgYXJnIGF2YWlsYWJsZSBhcyB7MX0sIHNlY29uZCBhcyB7Mn0sIGV0Yy4sIGFzIGluXG4gKiBgdGVtcGxleCgnSGVsbG8sIHsxfSEnLCAnV29ybGQnKWAuICh7MH0gaXMgdGhlIHRlbXBsYXRlIHNvIGNvbnNpZGVyIHRoaXMgdG8gYmUgMS1iYXNlZC4pXG4gKlxuICogSWYgeW91IHByZWZlciBzb21ldGhpbmcgb3RoZXIgdGhhbiBicmFjZXMsIHJlZGVmaW5lIGB0ZW1wbGV4LnJlZ2V4cGAuXG4gKlxuICogU2VlIHRlc3RzIGZvciBleGFtcGxlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBbYXJnc11cbiAqL1xuZnVuY3Rpb24gdGVtcGxleCh0ZW1wbGF0ZSkge1xuICAgIHZhciBjb250ZXh0cyA9IHRoaXMgaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMgOiBbdGhpc107XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7IGNvbnRleHRzLnVuc2hpZnQoYXJndW1lbnRzKTsgfVxuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKHRlbXBsZXgucmVnZXhwLCB0ZW1wbGV4Lm1lcmdlci5iaW5kKGNvbnRleHRzKSk7XG59XG5cbnRlbXBsZXgucmVnZXhwID0gL1xceyguKj8pXFx9L2c7XG5cbnRlbXBsZXgud2l0aCA9IGZ1bmN0aW9uIChpLCBzKSB7XG4gICAgcmV0dXJuICd3aXRoKHRoaXNbJyArIGkgKyAnXSl7JyArIHMgKyAnfSc7XG59O1xuXG50ZW1wbGV4LmNhY2hlID0gW107XG5cbnRlbXBsZXguZGVyZWYgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCEodGhpcy5sZW5ndGggaW4gdGVtcGxleC5jYWNoZSkpIHtcbiAgICAgICAgdmFyIGNvZGUgPSAncmV0dXJuIGV2YWwoZXhwciknO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29kZSA9IHRlbXBsZXgud2l0aChpLCBjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBsZXguY2FjaGVbdGhpcy5sZW5ndGhdID0gZXZhbCgnKGZ1bmN0aW9uKGV4cHIpeycgKyBjb2RlICsgJ30pJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuICAgIH1cbiAgICByZXR1cm4gdGVtcGxleC5jYWNoZVt0aGlzLmxlbmd0aF0uY2FsbCh0aGlzLCBrZXkpO1xufTtcblxudGVtcGxleC5tZXJnZXIgPSBmdW5jdGlvbiAobWF0Y2gsIGtleSkge1xuICAgIC8vIEFkdmFuY2VkIGZlYXR1cmVzOiBDb250ZXh0IGNhbiBiZSBhIGxpc3Qgb2YgY29udGV4dHMgd2hpY2ggYXJlIHNlYXJjaGVkIGluIG9yZGVyLlxuICAgIHZhciByZXBsYWNlbWVudDtcblxuICAgIHRyeSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gaXNOYU4oa2V5KSA/IHRlbXBsZXguZGVyZWYuY2FsbCh0aGlzLCBrZXkpIDogdGhpc1swXVtrZXldO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSAneycgKyBrZXkgKyAnfSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcGxhY2VtZW50O1xufTtcblxuLy8gdGhpcyBpbnRlcmZhY2UgY29uc2lzdHMgc29sZWx5IG9mIHRoZSB0ZW1wbGV4IGZ1bmN0aW9uIChhbmQgaXQncyBwcm9wZXJ0aWVzKVxubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGV4O1xuIiwiLy8gQ3JlYXRlZCBieSBKb25hdGhhbiBFaXRlbiBvbiAxLzcvMTYuXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBWZXJ5IGZhc3QgYXJyYXkgdGVzdC5cbiAqIEZvciBjcm9zcy1mcmFtZSBzY3JpcHRpbmc7IHVzZSBgY3Jvc3NGcmFtZXNJc0FycmF5YCBpbnN0ZWFkLlxuICogQHBhcmFtIHsqfSBhcnIgLSBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xudW5zdHJ1bmdpZnkuaXNBcnJheSA9IGZ1bmN0aW9uKGFycikgeyByZXR1cm4gYXJyLmNvbnN0cnVjdG9yID09PSBBcnJheTsgfTtcblxuLyoqXG4gKiBAc3VtbWFyeSBXYWxrIGEgaGllcmFyY2hpY2FsIG9iamVjdCBhcyBKU09OLnN0cmluZ2lmeSBkb2VzIGJ1dCB3aXRob3V0IHNlcmlhbGl6aW5nLlxuICpcbiAqIEBkZXNjIFVzYWdlOlxuICogKiB2YXIgbXlEaXN0aWxsZWRPYmplY3QgPSB1bnN0cnVuZ2lmeS5jYWxsKG15T2JqZWN0KTtcbiAqICogdmFyIG15RGlzdGlsbGVkT2JqZWN0ID0gbXlBcGkuZ2V0U3RhdGUoKTsgLy8gd2hlcmUgbXlBcGkucHJvdG90eXBlLmdldFN0YXRlID0gdW5zdHJ1bmdpZnlcbiAqXG4gKiBSZXN1bHQgZXF1aXZhbGVudCB0byBgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzKSlgLlxuICpcbiAqID4gRG8gbm90IHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGdldCBhIEpTT04gc3RyaW5nOyB1c2UgYEpTT04uc3RyaW5naWZ5KHRoaXMpYCBpbnN0ZWFkLlxuICpcbiAqIEB0aGlzIHsqfG9iamVjdHwqW119IC0gT2JqZWN0IHRvIHdhbGs7IHR5cGljYWxseSBhbiBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5udWxsRWxlbWVudHM9PWZhbHNlXSAtIFByZXNlcnZlIHVuZGVmaW5lZCBhcnJheSBlbGVtZW50cyBhcyBgbnVsbGBzLlxuICogVXNlIHRoaXMgd2hlbiBwcmVjaXNlIGluZGV4IG1hdHRlcnMgKG5vdCBtZXJlbHkgdGhlIG9yZGVyIG9mIHRoZSBlbGVtZW50cykuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5udWxsUHJvcGVydGllcz09ZmFsc2VdIC0gUHJlc2VydmUgdW5kZWZpbmVkIG9iamVjdCBwcm9wZXJ0aWVzIGFzIGBudWxsYHMuXG4gKlxuICogQHJldHVybnMge29iamVjdH0gLSBEaXN0aWxsZWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiB1bnN0cnVuZ2lmeShvcHRpb25zKSB7XG4gICAgdmFyIGNsb25lLCBwcmVzZXJ2ZSxcbiAgICAgICAgb2JqZWN0ID0gKHR5cGVvZiB0aGlzLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLnRvSlNPTigpIDogdGhpcztcblxuICAgIGlmICh1bnN0cnVuZ2lmeS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgY2xvbmUgPSBbXTtcbiAgICAgICAgcHJlc2VydmUgPSBvcHRpb25zICYmIG9wdGlvbnMubnVsbEVsZW1lbnRzO1xuICAgICAgICBvYmplY3QuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHVuc3RydW5naWZ5LmNhbGwob2JqKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXNlcnZlKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUucHVzaChudWxsKTsgLy8gdW5kZWZpbmVkIG5vdCBhIHZhbGlkIEpTT04gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY2xvbmUgPSB7fTtcbiAgICAgICAgcHJlc2VydmUgPSBvcHRpb25zICYmIG9wdGlvbnMubnVsbFByb3BlcnRpZXM7XG4gICAgICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuc3RydW5naWZ5LmNhbGwob2JqZWN0W2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjbG9uZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXNlcnZlKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVba2V5XSA9IG51bGw7IC8vIHVuZGVmaW5lZCBub3QgYSB2YWxpZCBKU09OIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb25lID0gb2JqZWN0O1xuICAgIH1cblxuICAgIHJldHVybiBjbG9uZTtcbn1cblxuLyoqXG4gKiBWZXJ5IHNsb3cgYXJyYXkgdGVzdC4gU3VpdGFibGUgZm9yIGNyb3NzLWZyYW1lIHNjcmlwdGluZy5cbiAqXG4gKiBTdWdnZXN0aW9uOiBJZiB5b3UgbmVlZCB0aGlzIGFuZCBoYXZlIGpRdWVyeSBsb2FkZWQsIHVzZSBgalF1ZXJ5LmlzQXJyYXlgIGluc3RlYWQgd2hpY2ggaXMgcmVhc29uYWJseSBmYXN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gYXJyIC0gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnVuc3RydW5naWZ5LmNyb3NzRnJhbWVzSXNBcnJheSA9IGZ1bmN0aW9uKGFycikgeyByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09PSBhcnJTdHJpbmc7IH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZywgYXJyU3RyaW5nID0gJ1tvYmplY3QgQXJyYXldJztcblxubW9kdWxlLmV4cG9ydHMgPSB1bnN0cnVuZ2lmeTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vbGliL3BvbHlmaWxscycpOyAvLyBJbnN0YWxscyBtaXNjLiBwb2x5ZmlsbHMgaW50byBnbG9iYWwgb2JqZWN0cywgYXMgbmVlZGVkXG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtbWUnKTtcbmV4dGVuZC5kZWJ1ZyA9IHRydWU7XG5cbnZhciBGaW5CYXIgPSByZXF1aXJlKCdmaW5iYXJzJyk7XG52YXIgQ2FudmFzID0gcmVxdWlyZSgnZmluY2FudmFzJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdyZWN0YW5ndWxhcicpLlBvaW50O1xudmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJ3JlY3Rhbmd1bGFyJykuUmVjdGFuZ2xlO1xudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7IC8vIGZ5aTogaW5zdGFsbHMgdGhlIEFycmF5LnByb3RvdHlwZS5maW5kIHBvbHlmaWxsLCBhcyBuZWVkZWRcblxudmFyIGRlcHJlY2F0ZWQgPSByZXF1aXJlKCcuL2xpYi9kZXByZWNhdGVkJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG52YXIgUmVuZGVyZXIgPSByZXF1aXJlKCcuL2xpYi9SZW5kZXJlcicpO1xudmFyIFNlbGVjdGlvbk1vZGVsID0gcmVxdWlyZSgnLi9saWIvU2VsZWN0aW9uTW9kZWwnKTtcbnZhciBzdHlsZXNoZWV0ID0gcmVxdWlyZSgnLi9saWIvc3R5bGVzaGVldCcpO1xudmFyIExvY2FsaXphdGlvbiA9IHJlcXVpcmUoJy4vbGliL0xvY2FsaXphdGlvbicpO1xudmFyIGJlaGF2aW9ycyA9IHJlcXVpcmUoJy4vYmVoYXZpb3JzJyk7XG52YXIgQ2VsbFJlbmRlcmVycyA9IHJlcXVpcmUoJy4vY2VsbFJlbmRlcmVycycpO1xudmFyIENlbGxFZGl0b3JzID0gcmVxdWlyZSgnLi9jZWxsRWRpdG9ycycpO1xuXG52YXIgdGhlbWVJbml0aWFsaXplZCA9IGZhbHNlLFxuICAgIHBvbHltZXJUaGVtZSA9IE9iamVjdC5jcmVhdGUoZGVmYXVsdHMpLFxuICAgIGdsb2JhbFByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKHBvbHltZXJUaGVtZSk7XG5cbi8qKnNcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd8RWxlbWVudH0gZGl2IC0gQ1NTIHNlbGVjdG9yIG9yIEVsZW1lbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLkJlaGF2aW9yPWJlaGF2aW9ycy5KU09OXSAtIEEgYmVoYXZpb3IgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufG9iamVjdFtdfSBbb3B0aW9ucy5kYXRhXSAtIFBhc3NlZCB0byBiZWhhdmlvciBjb25zdHJ1Y3Rvci4gTWF5IGJlOlxuICogKiBBbiBhcnJheSBvZiBjb25ncnVlbnQgcmF3IGRhdGEgb2JqZWN0c1xuICogKiBBIGZ1bmN0aW9uIHJldHVybmluZyBzYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufG1lbnVJdGVtW119IFtvcHRpb25zLnNjaGVtYT1kZXJpdmVkU2NoZW1hXSAtIFBhc3NlZCB0byBiZWhhdmlvciBjb25zdHJ1Y3Rvci4gTWF5IGJlOlxuICogKiBBIHNjaGVtYSBhcnJheVxuICogKiBBIGZ1bmN0aW9uIHJldHVybmluZyBhIHNjaGVtYSBhcnJheS4gQ2FsbGVkIGF0IGZpbHRlciByZXNldCB0aW1lIHdpdGggYmVoYXZpb3IgYXMgY29udGV4dC5cbiAqICogT21pdCB0byBnZW5lcmF0ZSBhIGJhc2ljIHNjaGVtYSBmcm9tIGB0aGlzLmJlaGF2aW9yLmNvbHVtbnNgLlxuICogQHBhcmFtIHtCZWhhdmlvcn0gW29wdGlvbnMuQmVoYXZpb3I9SlNPTl0gLSBBIGdyaWQgYmVoYXZpb3IgKGRlc2NlbmRhbnQgb2YgQmVoYXZpb3IgXCJjbGFzc1wiKS4gV2lsbCBiZSB1c2VkIGlmIGBnZXRCZWhhdmlvcmAgb21pdHRlZCwgaW4gd2hpY2ggY2FzZSBgb3B0aW9ucy5kYXRhYCAod2hpY2ggaGFzIG5vIGRlZmF1bHQpICptdXN0KiBhbHNvIGJlIHByb3ZpZGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsaXphdGlvbj1IeXBlcmdyaWQubG9jYWxpemF0aW9uXVxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFtvcHRpb25zLmxvY2FsaXphdGlvbi5sb2NhbGU9SHlwZXJncmlkLmxvY2FsaXphdGlvbi5sb2NhbGVdIC0gVGhlIGRlZmF1bHQgbG9jYWxlIHRvIHVzZSB3aGVuIGFuIGV4cGxpY2l0IGBsb2NhbGVgIGlzIG9taXR0ZWQgZnJvbSBsb2NhbGl6ZXIgY29uc3RydWN0b3IgY2FsbHMuIFBhc3NlZCB0byBJbnRsLk51bWJlckZvbXJhdGAgYW5kIGBJbnRsLkRhdGVGb21yYXRgLiBTZWUge0AgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50bCNMb2NhbGVfaWRlbnRpZmljYXRpb25fYW5kX25lZ290aWF0aW9ufExvY2FsZSBpZGVudGlmaWNhdGlvbiBhbmQgbmVnb3RpYXRpb259IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsaXphdGlvbi5udW1iZXJPcHRpb25zPUh5cGVyZ3JpZC5sb2NhbGl6YXRpb24ubnVtYmVyT3B0aW9uc10gLSBPcHRpb25zIHBhc3NlZCB0byBgSW50bC5OdW1iZXJGb21yYXRgIGZvciBjcmVhdGluZyB0aGUgYmFzaWMgXCJudW1iZXJcIiBsb2NhbGl6ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYWxpemF0aW9uLmRhdGVPcHRpb25zPUh5cGVyZ3JpZC5sb2NhbGl6YXRpb24uZGF0ZU9wdGlvbnNdIC0gT3B0aW9ucyBwYXNzZWQgdG8gYEludGwuRGF0ZUZvbXJhdGAgZm9yIGNyZWF0aW5nIHRoZSBiYXNpYyBcImRhdGVcIiBsb2NhbGl6ZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMubWFyZ2luXSAtIG9wdGlvbmFsIGNhbnZhcyBtYXJnaW5zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWFyZ2luLnRvcD0wXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmdpbi5yaWdodD0nLTIwMHB4J11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tYXJnaW4uYm90dG9tPTBdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWFyZ2luLmxlZnQ9MF1cbiAqL1xuZnVuY3Rpb24gSHlwZXJncmlkKGRpdiwgb3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuZGl2ID0gKHR5cGVvZiBkaXYgPT09ICdzdHJpbmcnKSA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZGl2KSA6IGRpdjtcblxuICAgIHN0eWxlc2hlZXQuaW5qZWN0KCdncmlkJyk7XG5cbiAgICB0aGlzLmxhc3RFZGdlU2VsZWN0aW9uID0gWzAsIDBdO1xuXG4gICAgdGhpcy5sbmZQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShnbG9iYWxQcm9wZXJ0aWVzKTtcblxuICAgIHRoaXMuaXNXZWJraXQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignd2Via2l0JykgPiAtMTtcbiAgICB0aGlzLnNlbGVjdGlvbk1vZGVsID0gbmV3IFNlbGVjdGlvbk1vZGVsKHRoaXMpO1xuICAgIHRoaXMucmVuZGVyT3ZlcnJpZGVzQ2FjaGUgPSB7fTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBkYXRhID0gdHlwZW9mIG9wdGlvbnMuZGF0YSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZGF0YSgpIDogb3B0aW9ucy5kYXRhO1xuICAgIHZhciBCZWhhdmlvciA9IG9wdGlvbnMuQmVoYXZpb3IgfHwgYmVoYXZpb3JzLkpTT047XG4gICAgdGhpcy5iZWhhdmlvciA9IG5ldyBCZWhhdmlvcih0aGlzLCBvcHRpb25zLnNjaGVtYSwgZGF0YSk7XG5cbiAgICB2YXIgbG9jID0gb3B0aW9ucy5sb2NhbGl6YXRpb24gfHwge307XG4gICAgdGhpcy5sb2NhbGl6YXRpb24gPSBuZXcgTG9jYWxpemF0aW9uKFxuICAgICAgICBsb2MubG9jYWxlIHx8IEh5cGVyZ3JpZC5sb2NhbGl6YXRpb24ubG9jYWxlLFxuICAgICAgICBsb2MubnVtYmVyT3B0aW9ucyB8fCBIeXBlcmdyaWQubG9jYWxpemF0aW9uLm51bWJlck9wdGlvbnMsXG4gICAgICAgIGxvYy5kYXRlT3B0aW9ucyB8fCBIeXBlcmdyaWQubG9jYWxpemF0aW9uLmRhdGVPcHRpb25zXG4gICAgKTtcblxuICAgIC8vcHJldmVudCB0aGUgZGVmYXVsdCBjb250ZXh0IG1lbnUgZm9yIGFwcGVhcmluZ1xuICAgIHRoaXMuZGl2Lm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuY2xlYXJNb3VzZURvd24oKTtcbiAgICB0aGlzLmRyYWdFeHRlbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgdGhpcy5udW1Sb3dzID0gMDtcbiAgICB0aGlzLm51bUNvbHVtbnMgPSAwO1xuXG4gICAgLy9pbnN0YWxsIGFueSBwbHVnaW5zXG4gICAgdGhpcy5wbHVnaW5zRG8oZnVuY3Rpb24oZWFjaCkge1xuICAgICAgICBpZiAoZWFjaC5pbnN0YWxsT24pIHtcbiAgICAgICAgICAgIGVhY2guaW5zdGFsbE9uKHNlbGYpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgbWFyZ2luID0gb3B0aW9ucy5tYXJnaW4gfHwge307XG4gICAgbWFyZ2luLnRvcCA9IG1hcmdpbi50b3AgfHwgMDtcbiAgICBtYXJnaW4ucmlnaHQgPSBtYXJnaW4ucmlnaHQgfHwgJy0yMDBweCc7XG4gICAgbWFyZ2luLmJvdHRvbSA9IG1hcmdpbi5ib3R0b20gfHwgMDtcbiAgICBtYXJnaW4ubGVmdCA9IG1hcmdpbi5sZWZ0IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q2VsbFJlbmRlcmVyc31cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRoaXMuY2VsbFJlbmRlcmVycyA9IG5ldyBDZWxsUmVuZGVyZXJzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q2VsbEVkaXRvcnN9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0aGlzLmNlbGxFZGl0b3JzID0gbmV3IENlbGxFZGl0b3JzKHRoaXMpO1xuXG4gICAgdGhpcy5hbGxvd0V2ZW50SGFuZGxlcnMgPSB0cnVlO1xuXG4gICAgLy9pbml0aWFsaXplIG91ciB2YXJpb3VzIHBpZWNlc1xuICAgIGlmICghdGhlbWVJbml0aWFsaXplZCkge1xuICAgICAgICB0aGVtZUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgYnVpbGRQb2x5bWVyVGhlbWUoKTtcbiAgICB9XG4gICAgdGhpcy5pbml0UmVuZGVyZXIoKTtcbiAgICB0aGlzLmluaXRDYW52YXMobWFyZ2luKTtcbiAgICB0aGlzLmluaXRTY3JvbGxiYXJzKCk7XG5cbiAgICAvL1JlZ2lzdGVyIGEgbGlzdGVuZXIgZm9yIHRoZSBjb3B5IGV2ZW50IHNvIHdlIGNhbiBjb3B5IG91ciBzZWxlY3RlZCByZWdpb24gdG8gdGhlIHBhc3RlYnVmZmVyIGlmIGNvbmRpdGlvbnMgYXJlIHJpZ2h0LlxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY29weScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBzZWxmLmNoZWNrQ2xpcGJvYXJkQ29weShldnQpO1xuICAgIH0pO1xuICAgIHRoaXMuZ2V0Q2FudmFzKCkucmVzaXplKCk7XG59XG5cbkh5cGVyZ3JpZC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IEh5cGVyZ3JpZC5wcm90b3R5cGUuY29uc3RydWN0b3IsXG5cbiAgICBkZXByZWNhdGVkOiBkZXByZWNhdGVkLFxuICAgIHJlZ2lzdGVyQ2VsbEVkaXRvcjogZnVuY3Rpb24oQ29uc3RydWN0b3IsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5kZXByZWNhdGVkKCdyZWdpc3RlckNlbGxFZGl0b3IoQ29uc3RydWN0b3IsIG5hbWUpJywgJ2NlbGxFZGl0b3JzLmFkZChuYW1lLCBDb25zdHJ1Y3RvciknLCAnMS4wLjYnLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgY3JlYXRlQ2VsbEVkaXRvcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ2NyZWF0ZUNlbGxFZGl0b3IobmFtZSknLCAnY2VsbEVkaXRvcnMuY3JlYXRlKG5hbWUpJywgJzEuMC42JywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGdldENlbGxQcm92aWRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ2dldENlbGxQcm92aWRlcigpJywgJ2NlbGxSZW5kZXJlcnMnLCAnMS4wLjYnLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJMb2NhbGl6ZXI6IGZ1bmN0aW9uKG5hbWUsIGxvY2FsaXplciwgYmFzZUNsYXNzTmFtZSwgbmV3Q2xhc3NOYW1lKSB7XG4gICAgICAgIHRoaXMuZGVwcmVjYXRlZCgncmVnaXN0ZXJMb2NhbGl6ZXIobmFtZSwgbG9jYWxpemVyLCBiYXNlQ2xhc3NOYW1lLCBuZXdDbGFzc05hbWUpJywgJ2xvY2FsaXphdGlvbi5hZGQobmFtZSwgbG9jYWxpemVyKScsICcxLjAuNicsIGFyZ3VtZW50cyxcbiAgICAgICAgICAgICdTVFJVQ1RVUkFMIENIQU5HRTogTm8gbG9uZ2VyIHN1cHBvcnRzIGRlcml2aW5nIGFuZCByZWdpc3RlcmluZyBhIG5ldyBjZWxsIGVkaXRvciBjbGFzcy4gVXNlIC5jZWxsRWRpdG9ycy5nZXQoYmFzZUNsYXNzTmFtZSkuZXh0ZW5kKG5ld0NsYXNzTmFtZSB8fCBuYW1lLCB7Li4ufSkgZm9yIHRoYXQuJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQSBudWxsIG9iamVjdCBiZWhhdmlvciBzZXJ2ZXMgYXMgYSBwbGFjZSBob2xkZXIuXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGJlaGF2aW9yOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIHJlc3VsYW59XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpc1dlYmtpdDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiBhbiBpbml0aWFsIG1vdXNlZG93biBjbGljaywgZWl0aGVyIGZvciBlZGl0aW5nIGEgY2VsbCBvciBmb3IgZHJhZ2dpbmcgYSBzZWxlY3Rpb24uXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgbW91c2VEb3duOiBbXSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBleHRlbnQgZnJvbSB0aGUgbW91c2Vkb3duIHBvaW50IGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgZHJhZ0V4dGVudDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEEgZmxvYXQgdmFsdWUgYmV0d2VlbiAwLjAgLSAxLjAgb2YgdGhlIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgdlNjcm9sbFZhbHVlOiAwLFxuXG4gICAgLyoqXG4gICAgICogQSBmbG9hdCB2YWx1ZSBiZXR3ZWVuIDAuMCAtIDEuMCBvZiB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGhTY3JvbGxWYWx1ZTogMCxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7ZmluLWh5cGVyZ3JpZC1zZWxlY3Rpb24tbW9kZWx9IHNlbGVjdGlvbk1vZGVsIC0gQSBbZmluLWh5cGVyZ3JpZC1zZWxlY3Rpb24tbW9kZWxdKG1vZHVsZS0uX3NlbGVjdGlvbi1tb2RlbC5odG1sKSBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNlbGVjdGlvbk1vZGVsOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtmaW4taHlwZXJncmlkLWNlbGwtZWRpdG9yfSBjZWxsRWRpdG9yIC0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgW2Zpbi1oeXBlcmdyaWQtY2VsbC1lZGl0b3JdKG1vZHVsZS1jZWxsLWVkaXRvcnNfYmFzZS5odG1sKS5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNlbGxFZGl0b3I6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Zpbi12YW1waXJlLWJhcn0gc2JIU2Nyb2xsZXIgLSBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL29wZW5maW4vZmluYmFyc3xGaW5CYXJ9LlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JIU2Nyb2xsZXI6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Zpbi12YW1waXJlLWJhcn0gc2JWU2Nyb2xsZXIgLSBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL29wZW5maW4vZmluYmFyc3xGaW5CYXJ9LlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JWU2Nyb2xsZXI6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJldmlvdXMgdmFsdWUgb2Ygc2JWU2Nyb2xsVmFsLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYlByZXZWU2Nyb2xsVmFsdWU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJldmlvdXMgdmFsdWUgb2Ygc2JIU2Nyb2xsVmFsdWUuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiUHJldkhTY3JvbGxWYWx1ZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGlzIHRoZSBzaG9ydCB0ZXJtIG1lbW9yeSBvZiB3aGF0IGNvbHVtbiBJIG1pZ2h0IGJlIGRyYWdnaW5nIGFyb3VuZFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIHJlbmRlck92ZXJyaWRlc0NhY2hlOiB7fSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgY3VycmVudCBob3ZlcmVkIGNlbGwuXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgaG92ZXJDZWxsOiBudWxsLFxuXG4gICAgc2Nyb2xsaW5nTm93OiBmYWxzZSxcblxuICAgIGxhc3RFZGdlU2VsZWN0aW9uOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICBjbGVhciBvdXQgdGhlIExSVSBjYWNoZSBvZiB0ZXh0IHdpZHRoc1xuICAgICAqL1xuICAgIHNldEF0dHJpYnV0ZTogZnVuY3Rpb24oYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgY2xlYXIgb3V0IGFsbCBzdGF0ZSBhbmQgZGF0YSBvZiB0aGUgZ3JpZFxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5sYXN0RWRnZVNlbGVjdGlvbiA9IFswLCAwXTtcbiAgICAgICAgdGhpcy5sbmZQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShnbG9iYWxQcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbCA9IG5ldyBTZWxlY3Rpb25Nb2RlbCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW5kZXJPdmVycmlkZXNDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLmNsZWFyTW91c2VEb3duKCk7XG4gICAgICAgIHRoaXMuZHJhZ0V4dGVudCA9IG5ldyBQb2ludCgwLCAwKTtcblxuICAgICAgICB0aGlzLm51bVJvd3MgPSAwO1xuICAgICAgICB0aGlzLm51bUNvbHVtbnMgPSAwO1xuXG4gICAgICAgIHRoaXMudlNjcm9sbFZhbHVlID0gMDtcbiAgICAgICAgdGhpcy5oU2Nyb2xsVmFsdWUgPSAwO1xuXG4gICAgICAgIHRoaXMuY2VsbEVkaXRvciA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5zYlByZXZWU2Nyb2xsVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLnNiUHJldkhTY3JvbGxWYWx1ZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5ob3ZlckNlbGwgPSBudWxsO1xuICAgICAgICB0aGlzLnNjcm9sbGluZ05vdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RFZGdlU2VsZWN0aW9uID0gWzAsIDBdO1xuXG4gICAgICAgIHRoaXMuYmVoYXZpb3IucmVzZXQoKTtcbiAgICAgICAgdGhpcy5nZXRSZW5kZXJlcigpLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkucmVzaXplKCk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JDaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8vcmVzZXRUZXh0V2lkdGhDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgLy8gICAgdGV4dFdpZHRoQ2FjaGUgPSBuZXcgTFJVQ2FjaGUoMjAwMCk7XG4gICAgLy99LFxuXG4gICAgZ2V0UHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBfZ2V0UHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxuZlByb3BlcnRpZXM7XG4gICAgfSxcblxuICAgIGNvbXB1dGVDZWxsc0JvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICAgICAgICByZW5kZXJlci5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgcG9pbnRlciBpcyBvdmVyIHRoZSBnaXZlbiBjZWxsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY2VsbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgY2VsbCBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIGlzSG92ZXJlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0SG92ZXJDZWxsKCk7XG4gICAgICAgIHJldHVybiBwICYmIHAueCA9PT0geCAmJiBwLnkgPT09IHk7XG4gICAgfSxcblxuICAgIGdldEZvcm1hdHRlcjogZnVuY3Rpb24obG9jYWxpemVyTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KGxvY2FsaXplck5hbWUpLmZvcm1hdDtcbiAgICB9LFxuXG4gICAgZm9ybWF0VmFsdWU6IGZ1bmN0aW9uKGxvY2FsaXplck5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSB0aGlzLmdldEZvcm1hdHRlcihsb2NhbGl6ZXJOYW1lKTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlcih2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgYm9vbGVhbn0gVGhlIHBvaW50ZXIgaXMgaG92ZXJpbmcgb3ZlciB0aGUgZ2l2ZW4gY29sdW1uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGhvcml6b250YWwgY2VsbCBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIGlzQ29sdW1uSG92ZXJlZDogZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0SG92ZXJDZWxsKCk7XG4gICAgICAgIHJldHVybiBwICYmIHAueCA9PT0geDtcbiAgICB9LFxuXG4gICAgaXNSb3dSZXNpemVhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdyb3dSZXNpemUnKTtcbiAgICB9LFxuXG4gICAgaXNDaGVja2JveE9ubHlSb3dTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdjaGVja2JveE9ubHlSb3dTZWxlY3Rpb25zJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIHBvaW50ZXIgaXMgaG92ZXJpbmcgb3ZlciB0aGUgcm93IGB5YC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB2ZXJ0aWNhbCBjZWxsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgaXNSb3dIb3ZlcmVkOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5nZXRIb3ZlckNlbGwoKTtcbiAgICAgICAgcmV0dXJuIHAgJiYgcC55ID09PSB5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gVGhlIGNlbGwgb3ZlciB3aGljaCB0aGUgY3Vyc29yIGlzIGhvdmVyaW5nLlxuICAgICAqL1xuICAgIGdldEhvdmVyQ2VsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdmVyQ2VsbDtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNldCB0aGUgY2VsbCB1bmRlciB0aGUgY3Vyc29yLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XG4gICAgICovXG4gICAgc2V0SG92ZXJDZWxsOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzLmhvdmVyQ2VsbDtcbiAgICAgICAgdmFyIG5ld1BvaW50ID0gbmV3IFBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICBpZiAobWUgJiYgbWUuZXF1YWxzKG5ld1BvaW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaG92ZXJDZWxsID0gbmV3UG9pbnQ7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY09uQ2VsbEVudGVyRXZlbnQobmV3UG9pbnQpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBbW1lbmQgcHJvcGVydGllcyBmb3IgYWxsIGh5cGVyZ3JpZHMgaW4gdGhpcyBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gQSBzaW1wbGUgcHJvcGVydGllcyBoYXNoLlxuICAgICAqL1xuICAgIGFkZEdsb2JhbFByb3BlcnRpZXM6IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgLy93ZSBjaGVjayBmb3IgZXhpc3RlbmNlIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uIGluIGluaXRpYWxpemF0aW9uXG4gICAgICAgIGlmICghZ2xvYmFsUHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFkZEdsb2JhbFByb3BlcnRpZXMocHJvcGVydGllcyk7XG4gICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRHbG9iYWxQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBbW1lbmQgcHJvcGVydGllcyBmb3IgYWxsIGh5cGVyZ3JpZHMgaW4gdGhpcyBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gQSBzaW1wbGUgcHJvcGVydGllcyBoYXNoLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZEdsb2JhbFByb3BlcnRpZXM6IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgXyhwcm9wZXJ0aWVzKS5lYWNoKGZ1bmN0aW9uKHByb3BlcnR5LCBrZXkpIHtcbiAgICAgICAgICAgIGdsb2JhbFByb3BlcnRpZXNba2V5XSA9IHByb3BlcnR5O1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBVdGlsaXR5IGZ1bmN0aW9uIHRvIHB1c2ggb3V0IHByb3BlcnRpZXMgaWYgd2UgY2hhbmdlIHRoZW0uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBBbiBvYmplY3Qgb2YgdmFyaW91cyBrZXkgdmFsdWUgcGFpcnMuXG4gICAgICovXG5cbiAgICByZWZyZXNoUHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHRoaXMuY2FudmFzID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2Zpbi1jYW52YXMnKTtcbiAgICAgICAgLy90aGlzLmNhbnZhcyA9IG5ldyBDYW52YXModGhpcy5kaXZDYW52YXMsIHRoaXMucmVuZGVyZXIpOyAvL1RPRE86IERvIHdlIHJlYWxseSBuZWVkIHRvIGJlIHJlY3JlYXRpbmcgaXQgaGVyZT9cbiAgICAgICAgdGhpcy5yZW5kZXJlci5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5jaGVja1Njcm9sbGJhclZpc2liaWxpdHkoKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5kZWZhdWx0Um93SGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNDb2x1bW5BdXRvc2l6aW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3IuYXV0b3NpemVBbGxDb2x1bW5zKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBbW1lbmQgcHJvcGVydGllcyBmb3IgdGhpcyBoeXBlcmdyaWQgb25seS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbW9yZVByb3BlcnRpZXMgLSBBIHNpbXBsZSBwcm9wZXJ0aWVzIGhhc2guXG4gICAgICovXG4gICAgYWRkUHJvcGVydGllczogZnVuY3Rpb24obW9yZVByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLmdldFByb3BlcnRpZXMoKTtcbiAgICAgICAgYWRkRGVlcFByb3BlcnRpZXMocHJvcGVydGllcywgbW9yZVByb3BlcnRpZXMpO1xuICAgICAgICB0aGlzLnJlZnJlc2hQcm9wZXJ0aWVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdH0gVGhlIHN0YXRlIG9iamVjdCBmb3IgcmVtZW1iZXJpbmcgb3VyIHN0YXRlLlxuICAgICAqIEBzZWUgW01lbWVudG8gcGF0dGVybl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZW1lbnRvX3BhdHRlcm4pXG4gICAgICovXG4gICAgZ2V0UHJpdmF0ZVN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBzdGF0ZSBvYmplY3QgdG8gcmV0dXJuIHRvIHRoZSBnaXZlbiB1c2VyIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIC0gQSBtZW1lbnRvIG9iamVjdC5cbiAgICAgKiBAc2VlIFtNZW1lbnRvIHBhdHRlcm5dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVtZW50b19wYXR0ZXJuKVxuICAgICAqL1xuICAgIHNldFN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5iZWhhdmlvckNoYW5nZWQoKTtcbiAgICAgICAgICAgIHNlbGYuc3luY2hyb25pemVTY3JvbGxpbmdCb3VuZHJpZXMoKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9LFxuXG4gICAgZ2V0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRTdGF0ZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgaW5pdGlhbCBtb3VzZSBwb3NpdGlvbiBvbiBhIG1vdXNlIGRvd24gZXZlbnQgZm9yIGNlbGwgZWRpdGluZyBvciBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0TW91c2VEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLm1vdXNlRG93bi5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1vdXNlRG93bltsYXN0XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZW1vdmUgdGhlIGxhc3QgaXRlbSBmcm9tIHRoZSBtb3VzZSBkb3duIHN0YWNrLlxuICAgICAqL1xuICAgIHBvcE1vdXNlRG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlRG93bi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubW91c2VEb3duLmxlbmd0aCA9IHRoaXMubW91c2VEb3duLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBFbXB0eSBvdXQgdGhlIG1vdXNlIGRvd24gc3RhY2suXG4gICAgICovXG4gICAgY2xlYXJNb3VzZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm1vdXNlRG93biA9IFtuZXcgUG9pbnQoLTEsIC0xKV07XG4gICAgICAgIHRoaXMuZHJhZ0V4dGVudCA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbW91c2UgcG9pbnQgdGhhdCBpbml0aWF0ZWQgYSBjZWxsIGVkaXQgb3IgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldE1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdGhpcy5tb3VzZURvd24ucHVzaChwb2ludCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1BvaW50fSBUaGUgZXh0ZW50IHBvaW50IG9mIHRoZSBjdXJyZW50IGRyYWcgc2VsZWN0aW9uIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICBnZXREcmFnRXh0ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0V4dGVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTZXQgdGhlIGV4dGVudCBwb2ludCBvZiB0aGUgY3VycmVudCBkcmFnIHNlbGVjdGlvbiBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICAgKi9cbiAgICBzZXREcmFnRXh0ZW50OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB0aGlzLmRyYWdFeHRlbnQgPSBwb2ludDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBJdGVyYXRlIG92ZXIgdGhlIHBsdWdpbnMgaW52b2tpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uIHdpdGggZWFjaC5cbiAgICAgKiBAdG9kbyBXZSBuZWVkIGEgbmV3IHBsdWdpbiBtZWNoYW5pc20hXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyAtIFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugb24gYWxsIHRoZSBwbHVnaW5zLlxuICAgICAqL1xuICAgIHBsdWdpbnNEbzogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAvL1RPRE86IFdlIG5lZWQgYSBuZXcgcGx1Z2luIG1lY2hhbmlzbSFcbiAgICAgICAgLy92YXIgdXNlclBsdWdpbnMgPSB0aGlzLmNoaWxkcmVuLmFycmF5KCk7XG4gICAgICAgIC8vdmFyIHBsdWdpbnNUYWcgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignZmluLXBsdWdpbnMnKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy92YXIgcGx1Z2lucyA9IHVzZXJQbHVnaW5zO1xuICAgICAgICAvL2lmIChwbHVnaW5zVGFnKSB7XG4gICAgICAgIC8vICAgIHZhciBzeXN0ZW1QbHVnaW5zID0gcGx1Z2luc1RhZy5jaGlsZHJlbi5hcnJheSgpO1xuICAgICAgICAvLyAgICBwbHVnaW5zID0gc3lzdGVtUGx1Z2lucy5jb25jYXQocGx1Z2lucyk7XG4gICAgICAgIC8vfVxuICAgICAgICAvL1xuICAgICAgICAvL3BsdWdpbnMuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcbiAgICAgICAgLy8gICAgZnVuYyhwbHVnaW4pO1xuICAgICAgICAvL30pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoaXMgZnVuY3Rpb24gaXMgYSBjYWxsYmFjayBmcm9tIHRoZSBIeXBlcmdyaWRSZW5kZXJlciBzdWItY29tcG9uZW50LiBJdCBpcyBjYWxsZWQgYWZ0ZXIgZWFjaCBwYWludCBvZiB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIGdyaWRSZW5kZXJlZE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUmVuZGVyZWRTaXplcygpO1xuICAgICAgICBpZiAodGhpcy5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxFZGl0b3IuZ3JpZFJlbmRlcmVkTm90aWZpY2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0NvbHVtbkF1dG9zaXppbmcoKTtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljR3JpZFJlbmRlcmVkRXZlbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgZ3JpZCBoYXMganVzdCBiZWVuIHJlbmRlcmVkLCBtYWtlIHN1cmUgdGhlIGNvbHVtbiB3aWR0aHMgYXJlIG9wdGltYWwuXG4gICAgICovXG4gICAgY2hlY2tDb2x1bW5BdXRvc2l6aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5iZWhhdmlvcjtcbiAgICAgICAgYmVoYXZpb3IuYXV0b1NpemVSb3dOdW1iZXJDb2x1bW4oKTtcbiAgICAgICAgaWYgKHRoaXMuaXNDb2x1bW5BdXRvc2l6aW5nKCkpIHtcbiAgICAgICAgICAgIGJlaGF2aW9yLmNoZWNrQ29sdW1uQXV0b3NpemluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgTm90aWZ5IHRoZSBHcmlkQmVoYXZpb3IgaG93IG1hbnkgcm93cyBhbmQgY29sdW1ucyB3ZSBqdXN0IHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHVwZGF0ZVJlbmRlcmVkU2l6ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2FkZCBvbmUgdG8gZWFjaCBvZiB0aGVzZSB2YWx1ZXMgYXMgd2Ugd2FudCBhbHNvIHRvIGluY2x1ZGVcbiAgICAgICAgLy90aGUgY29sdW1ucyBhbmQgcm93cyB0aGF0IGFyZSBwYXJ0aWFsbHkgdmlzaWJsZVxuICAgICAgICB0aGlzLmJlaGF2aW9yLnNldFJlbmRlcmVkQ29sdW1uQ291bnQodGhpcy5nZXRWaXNpYmxlQ29sdW1ucygpICsgMSk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0UmVuZGVyZWRSb3dDb3VudCh0aGlzLmdldFZpc2libGVSb3dzKCkgKyAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBDb25kaXRpb25hbGx5IGNvcHkgdG8gY2xpcGJvYXJkLlxuICAgICAqIEBkZXNjIElmIHdlIGhhdmUgZm9jdXMsIGNvcHkgb3VyIGN1cnJlbnQgc2VsZWN0aW9uIGRhdGEgdG8gdGhlIHN5c3RlbSBjbGlwYm9hcmQuXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgY29weSBzeXN0ZW0gZXZlbnQuXG4gICAgICovXG4gICAgY2hlY2tDbGlwYm9hcmRDb3B5OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAodGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIGNzdkRhdGEgPSB0aGlzLmdldFNlbGVjdGlvbkFzVFNWKCk7XG4gICAgICAgICAgICBldmVudC5jbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLCBjc3ZEYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXZSBoYXZlIGFueSBzZWxlY3Rpb25zLlxuICAgICAqL1xuICAgIGhhc1NlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gd2VyZSBub3QgZnVsbHkgaW5pdGlhbGl6ZWQgeWV0XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWwuaGFzU2VsZWN0aW9ucygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRhYiBzZXBhcmF0ZWQgdmFsdWUgc3RyaW5nIGZyb20gdGhlIHNlbGVjdGlvbiBhbmQgb3VyIGRhdGEuXG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uQXNUU1Y6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc20gPSB0aGlzLnNlbGVjdGlvbk1vZGVsO1xuICAgICAgICBpZiAoc20uaGFzU2VsZWN0aW9ucygpKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9uTWF0cml4KCk7XG4gICAgICAgICAgICBzZWxlY3Rpb25zID0gc2VsZWN0aW9uc1tzZWxlY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF0cml4U2VsZWN0aW9uQXNUU1Yoc2VsZWN0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc20uaGFzUm93U2VsZWN0aW9ucygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXRyaXhTZWxlY3Rpb25Bc1RTVih0aGlzLmdldFJvd1NlbGVjdGlvbk1hdHJpeCgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChzbS5oYXNDb2x1bW5TZWxlY3Rpb25zKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1hdHJpeFNlbGVjdGlvbkFzVFNWKHRoaXMuZ2V0Q29sdW1uU2VsZWN0aW9uTWF0cml4KCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldE1hdHJpeFNlbGVjdGlvbkFzVFNWOiBmdW5jdGlvbihzZWxlY3Rpb25zKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgICAgICAvL29ubHkgdXNlIHRoZSBkYXRhIGZyb20gdGhlIGxhc3Qgc2VsZWN0aW9uXG4gICAgICAgIGlmIChzZWxlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2VsZWN0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2VsZWN0aW9uc1swXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgYXJlYSA9IHdpZHRoICogaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxhc3RDb2wgPSB3aWR0aCAtIDEsXG4gICAgICAgICAgICAgICAgLy9XaGl0ZXNwYWNlIHdpbGwgb25seSBiZSBhZGRlZCBvbiBub24tc2luZ3VsYXIgcm93cywgc2VsZWN0aW9uc1xuICAgICAgICAgICAgICAgIHdoaXRlU3BhY2VEZWxpbWl0ZXJGb3JSb3cgPSAoaGVpZ2h0ID4gMSA/ICdcXG4nIDogJycpO1xuXG4gICAgICAgICAgICAvL2Rpc2FsbG93IGlmIHNlbGVjdGlvbiBpcyB0b28gYmlnXG4gICAgICAgICAgICBpZiAoYXJlYSA+IDIwMDAwKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoJ3NlbGVjdGlvbiBzaXplIGlzIHRvbyBiaWcgdG8gY29weSB0byB0aGUgcGFzdGUgYnVmZmVyJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgaGVpZ2h0OyBoKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IHdpZHRoOyB3KyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHNlbGVjdGlvbnNbd11baF0gKyAodyA8IGxhc3RDb2wgPyAnXFx0JyA6IHdoaXRlU3BhY2VEZWxpbWl0ZXJGb3JSb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdlIGhhdmUgZm9jdXMuXG4gICAgICovXG4gICAgaGFzRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYW52YXMoKS5oYXNGb2N1cygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIENsZWFyIGFsbCB0aGUgc2VsZWN0aW9ucy5cbiAgICAgKi9cbiAgICBjbGVhclNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZG9udENsZWFyUm93cyA9IHRoaXMuaXNDaGVja2JveE9ubHlSb3dTZWxlY3Rpb25zKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuY2xlYXIoZG9udENsZWFyUm93cyk7XG4gICAgICAgIHRoaXMuY2xlYXJNb3VzZURvd24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBDbGVhciB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb250Q2xlYXJSb3dzID0gdGhpcy5pc0NoZWNrYm94T25seVJvd1NlbGVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oZG9udENsZWFyUm93cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgQ2xlYXIgdGhlIG1vc3QgcmVjZW50IGNvbHVtbiBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgY2xlYXJNb3N0UmVjZW50Q29sdW1uU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhck1vc3RSZWNlbnRDb2x1bW5TZWxlY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBDbGVhciB0aGUgbW9zdCByZWNlbnQgcm93IHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBjbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL3RoaXMuc2VsZWN0aW9uTW9kZWwuY2xlYXJNb3N0UmVjZW50Um93U2VsZWN0aW9uKCk7IC8vIGNvbW1lbnRlZCBvZmYgYXMgcGVyIEdSSUQtMTEyXG4gICAgfSxcblxuICAgIGNsZWFyUm93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhclJvd1NlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmRhdGFNb2RlbC5jbGVhclNlbGVjdGVkRGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNlbGVjdCBnaXZlbiByZWdpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG94IC0gb3JpZ2luIHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3kgLSBvcmlnaW4geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleCAtIGV4dGVudCB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4IC0gZXh0ZW50IHlcbiAgICAgKi9cbiAgICBzZWxlY3Q6IGZ1bmN0aW9uKG94LCBveSwgZXgsIGV5KSB7XG4gICAgICAgIGlmIChveCA8IDAgfHwgb3kgPCAwKSB7XG4gICAgICAgICAgICAvL3dlIGRvbid0IHNlbGVjdCBuZWdhdGl2ZSBhcmVhXG4gICAgICAgICAgICAvL2Fsc28gdGhpcyBtZWFucyB0aGVyZSBpcyBubyBvcmlnaW4gbW91c2UgZG93biBmb3IgYSBzZWxlY3Rpb24gcmVjdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0KG94LCBveSwgZXgsIGV5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gR2l2ZW4gcG9pbnQgaXMgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5pc1NlbGVjdGVkKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY29sdW1uIGlzIHNlbGVjdGVkIGFueXdoZXJlIGluIHRoZSBlbnRpcmUgdGFibGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbCAtIFRoZSBjb2x1bW4gaW5kZXguXG4gICAgICovXG4gICAgaXNDZWxsU2VsZWN0ZWRJblJvdzogZnVuY3Rpb24oY29sKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25Nb2RlbCA9IHRoaXMuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIHZhciBpc1NlbGVjdGVkID0gc2VsZWN0aW9uTW9kZWwuaXNDZWxsU2VsZWN0ZWRJblJvdyhjb2wpO1xuICAgICAgICByZXR1cm4gaXNTZWxlY3RlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIHJvdyBpcyBzZWxlY3RlZCBhbnl3aGVyZSBpbiB0aGUgZW50aXJlIHRhYmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgLSBUaGUgcm93IGluZGV4LlxuICAgICAqL1xuICAgIGlzQ2VsbFNlbGVjdGVkSW5Db2x1bW46IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICB2YXIgc2VsZWN0aW9uTW9kZWwgPSB0aGlzLnNlbGVjdGlvbk1vZGVsO1xuICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IHNlbGVjdGlvbk1vZGVsLmlzQ2VsbFNlbGVjdGVkSW5Db2x1bW4ocm93KTtcbiAgICAgICAgcmV0dXJuIGlzU2VsZWN0ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSBCZWhhdmlvciAobW9kZWwpIG9iamVjdCBmb3IgdGhpcyBncmlkIGNvbnRyb2wuXG4gICAgICogQGRlc2MgVGhpcyBjYW4gYmUgZG9uZSBkeW5hbWljYWxseS5cbiAgICAgKiBAcGFyYW0ge0JlaGF2aW9yfSBiZWhhdmlvciAtIFRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqL1xuICAgIHNldEJlaGF2aW9yOiBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgICAgICBiZWhhdmlvci5jaGFuZ2VkID0gdGhpcy5iZWhhdmlvckNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgYmVoYXZpb3Iuc2hhcGVDaGFuZ2VkID0gdGhpcy5iZWhhdmlvclNoYXBlQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICBiZWhhdmlvci5zdGF0ZUNoYW5nZWQgPSB0aGlzLmJlaGF2aW9yU3RhdGVDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IgPSBiZWhhdmlvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBJJ3ZlIGJlZW4gbm90aWZpZWQgdGhhdCB0aGUgYmVoYXZpb3IgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgYmVoYXZpb3JDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubnVtQ29sdW1ucyAhPT0gdGhpcy5nZXRDb2x1bW5Db3VudCgpIHx8IHRoaXMubnVtUm93cyAhPT0gdGhpcy5nZXRSb3dDb3VudCgpKSB7XG4gICAgICAgICAgICB0aGlzLm51bUNvbHVtbnMgPSB0aGlzLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgICAgICB0aGlzLm51bVJvd3MgPSB0aGlzLmdldFJvd0NvdW50KCk7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yU2hhcGVDaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gTXkgYm91bmRzLlxuICAgICAqL1xuICAgIGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyICYmIHJlbmRlcmVyLmdldEJvdW5kcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB2YWx1ZSBvZiBhIGxuZiBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gQSBsb29rLWFuZC1mZWVsIGtleS5cbiAgICAgKi9cbiAgICByZXNvbHZlUHJvcGVydHk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgcHJvcCA9IHRoaXMuZ2V0UHJvcGVydGllcygpO1xuICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHsgcHJvcCA9IHByb3Bba2V5cy5zaGlmdCgpXTsgfVxuICAgICAgICByZXR1cm4gcHJvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgZ3JpZCBkYXRhIGhhdmUgY2hhbmdlZC4gWW91J3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICovXG4gICAgYmVoYXZpb3JTaGFwZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRyaWVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGdyaWQgZGF0YSBoYXZlIGNoYW5nZWQuIFlvdSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqL1xuICAgIGJlaGF2aW9yU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5nZXRSZW5kZXJlcigpLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgcmVwYWludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgncmVwYWludEltbWVkaWF0ZWx5Jyk7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICBpZiAobm93ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLnBhaW50Tm93KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5yZXBhaW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBQYWludCBpbW1lZGlhdGVseSBpbiB0aGlzIG1pY3JvdGFzay5cbiAgICAgKi9cbiAgICBwYWludE5vdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgICAgICBjYW52YXMucGFpbnROb3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSW4gSGlEUEkgbW9kZSAoaGFzIGFuIGF0dHJpYnV0ZSBhcyBzdWNoKS5cbiAgICAgKi9cbiAgICB1c2VIaURQSTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgndXNlSGlEUEknKSAhPT0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgSW5pdGlhbGl6ZSBkcmF3aW5nIHN1cmZhY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0Q2FudmFzOiBmdW5jdGlvbihtYXJnaW4pIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGRpdkNhbnZhcyA9IHRoaXMuZGl2Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKGRpdkNhbnZhcyk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gbmV3IENhbnZhcyhkaXZDYW52YXMsIHRoaXMucmVuZGVyZXIpO1xuICAgICAgICB0aGlzLmNhbnZhcy5jYW52YXMuY2xhc3NMaXN0LmFkZCgnaHlwZXJncmlkJyk7XG5cbiAgICAgICAgdmFyIHN0eWxlID0gZGl2Q2FudmFzLnN0eWxlO1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHN0eWxlLnRvcCA9IG1hcmdpbi50b3A7XG4gICAgICAgIHN0eWxlLnJpZ2h0ID0gbWFyZ2luLnJpZ2h0O1xuICAgICAgICBzdHlsZS5ib3R0b20gPSBtYXJnaW4uYm90dG9tO1xuICAgICAgICBzdHlsZS5sZWZ0ID0gbWFyZ2luLmxlZnQ7XG5cbiAgICAgICAgdGhpcy5jYW52YXMucmVzaXplTm90aWZpY2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnJlc2l6ZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtbW91c2Vtb3ZlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmVzb2x2ZVByb3BlcnR5KCdyZWFkT25seScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vdXNlID0gZS5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB2YXIgbW91c2VFdmVudCA9IHNlbGYuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludChtb3VzZSk7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50ID0gZTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVNb3VzZU1vdmUobW91c2VFdmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1tb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3NlbGYuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5rZXlzID0gZS5kZXRhaWwua2V5cztcbiAgICAgICAgICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlO1xuICAgICAgICAgICAgc2VsZi5tb3VzZURvd25TdGF0ZSA9IG1vdXNlRXZlbnQ7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlTW91c2VEb3duKG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljTW91c2VEb3duRXZlbnQobW91c2VFdmVudCk7XG4gICAgICAgICAgICBzZWxmLnJlcGFpbnQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLWNsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmVzb2x2ZVByb3BlcnR5KCdyZWFkT25seScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9zZWxmLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlO1xuICAgICAgICAgICAgbW91c2VFdmVudC5rZXlzID0gZS5kZXRhaWwua2V5czsgLy8gdG9kbzogdGhpcyB3YXMgaW4gZmluLXRhcCBidXQgd2Fzbid0IGhlcmVcbiAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY0NsaWNrRXZlbnQobW91c2VFdmVudCk7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlQ2xpY2sobW91c2VFdmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1tb3VzZXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmVzb2x2ZVByb3BlcnR5KCdyZWFkT25seScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0U2Nyb2xsaW5nTm93KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9zZWxmLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlO1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZU1vdXNlVXAobW91c2VFdmVudCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5tb3VzZURvd25TdGF0ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY0J1dHRvblByZXNzZWRFdmVudChzZWxmLm1vdXNlRG93blN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYubW91c2VEb3duU3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljTW91c2VVcEV2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtZGJsY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlO1xuICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljRG91YmxlQ2xpY2tFdmVudChtb3VzZUV2ZW50LCBlKTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVEb3VibGVDbGljayhtb3VzZUV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLWRyYWcnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5wcmltaXRpdmVFdmVudCA9IGU7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlTW91c2VEcmFnKG1vdXNlRXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMta2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY0tleWRvd25FdmVudChlKTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVLZXlEb3duKGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMta2V5dXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmZpcmVTeW50aGV0aWNLZXl1cEV2ZW50KGUpO1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZUtleVVwKGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtd2hlZWxtb3ZlZCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5wcmltaXRpdmVFdmVudCA9IGUuZGV0YWlsLnByaW1pdGl2ZUV2ZW50O1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZVdoZWVsTW92ZWQobW91c2VFdmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1tb3VzZW91dCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5wcmltaXRpdmVFdmVudCA9IGUuZGV0YWlsLnByaW1pdGl2ZUV2ZW50O1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZU1vdXNlRXhpdChtb3VzZUV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLWNvbnRleHQtbWVudScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5wcmltaXRpdmVFdmVudCA9IGUuZGV0YWlsLnByaW1pdGl2ZUV2ZW50O1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZUNvbnRleHRNZW51KG1vdXNlRXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmRpdi5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG5cbiAgICB9LFxuXG4gICAgY29udmVydFZpZXdQb2ludFRvRGF0YVBvaW50OiBmdW5jdGlvbih2aWV3UG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuY29udmVydFZpZXdQb2ludFRvRGF0YVBvaW50KHZpZXdQb2ludCk7XG4gICAgfSxcblxuICAgIGNvbnZlcnREYXRhUG9pbnRUb1ZpZXdQb2ludDogZnVuY3Rpb24oZGF0YVBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmNvbnZlcnREYXRhUG9pbnRUb1ZpZXdQb2ludChkYXRhUG9pbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gVGhlIHR5cGUgb2YgZXZlbnQgd2UgYXJlIGludGVyZXN0ZWQgaW4uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZXZlbnQgaGFuZGxlci5cbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGRlY29yYXRvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmFsbG93RXZlbnRIYW5kbGVycyl7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBkZWNvcmF0b3IpO1xuICAgIH0sXG5cbiAgICBhbGxvd0V2ZW50czogZnVuY3Rpb24oYWxsb3cpe1xuICAgICAgICBpZiAoKHRoaXMuYWxsb3dFdmVudEhhbmRsZXJzID0gISFhbGxvdykpe1xuICAgICAgICAgICAgdGhpcy5iZWhhdmlvci5mZWF0dXJlQ2hhaW4uYXR0YWNoQ2hhaW4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3IuZmVhdHVyZUNoYWluLmRldGFjaENoYWluKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJlaGF2aW9yLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgYWRkRmluRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zb2xlLndhcm4oJy5hZGRGaW5FdmVudExpc3RlbmVyKCkgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYXMgb2YgdjAuMi4gVXNlIC5hZGRFdmVudExpc3RlbmVyKCkgaW5zdGVhZC4gKFdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiknKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNldCBmb3IgYHNjcm9sbGluZ05vd2AgZmllbGQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0l0Tm93IC0gVGhlIHR5cGUgb2YgZXZlbnQgd2UgYXJlIGludGVyZXN0ZWQgaW4uXG4gICAgICovXG4gICAgc2V0U2Nyb2xsaW5nTm93OiBmdW5jdGlvbihpc0l0Tm93KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsaW5nTm93ID0gaXNJdE5vdztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGBzY3JvbGxpbmdOb3dgIGZpZWxkLlxuICAgICAqL1xuICAgIGlzU2Nyb2xsaW5nTm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsaW5nTm93O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgY29sdW1uIGRpdmlkZXIgdW5kZXIgdGhlIG1vdXNlIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VFdmVudCAtIFRoZSBldmVudCB0byBpbnRlcm9nYXRlLlxuICAgICAqL1xuICAgIG92ZXJDb2x1bW5EaXZpZGVyOiBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgICAgIHZhciB4ID0gbW91c2VFdmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueDtcbiAgICAgICAgdmFyIHdoaWNoQ29sID0gdGhpcy5nZXRSZW5kZXJlcigpLm92ZXJDb2x1bW5EaXZpZGVyKHgpO1xuICAgICAgICByZXR1cm4gd2hpY2hDb2w7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSByb3cgZGl2aWRlciB1bmRlciB0aGUgbW91c2UgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gVGhlIGV2ZW50IHRvIGludGVyb2dhdGUuXG4gICAgICovXG4gICAgb3ZlclJvd0RpdmlkZXI6IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdmFyIHkgPSBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS55O1xuICAgICAgICB2YXIgd2hpY2ggPSB0aGlzLmdldFJlbmRlcmVyKCkub3ZlclJvd0RpdmlkZXIoeSk7XG4gICAgICAgIHJldHVybiB3aGljaDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTd2l0Y2ggdGhlIGN1cnNvciBmb3IgdGhlIGdyaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGN1cnNvck5hbWUgLSBBIHdlbGwga25vdyBjdXJzb3IgbmFtZS5cbiAgICAgKiBAc2VlIFtjdXJzb3IgbmFtZXNdKGh0dHA6Ly93d3cuamF2YXNjcmlwdGVyLm5ldC9mYXEvc3R5bGVzYy5odG0pXG4gICAgICovXG4gICAgYmVDdXJzb3I6IGZ1bmN0aW9uKGN1cnNvck5hbWUpIHtcbiAgICAgICAgaWYgKCFjdXJzb3JOYW1lKSB7XG4gICAgICAgICAgICBjdXJzb3JOYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IGN1cnNvck5hbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRGVsZWdhdGUgdGhlIHdoZWVsIG1vdmVkIGV2ZW50IHRvIHRoZSBiZWhhdmlvci5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBwZXJ0aW5lbnQgZXZlbnQuXG4gICAgICovXG4gICAgZGVsZWdhdGVXaGVlbE1vdmVkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLm9uV2hlZWxNb3ZlZCh0aGlzLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRGVsZWdhdGUgTW91c2VFeGl0IHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIHBlcnRpbmVudCBldmVudC5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZU1vdXNlRXhpdDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5oYW5kbGVNb3VzZUV4aXQodGhpcywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIERlbGVnYXRlIE1vdXNlRXhpdCB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBwZXJ0aW5lbnQgZXZlbnQuXG4gICAgICovXG4gICAgZGVsZWdhdGVDb250ZXh0TWVudTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICB0aGlzLiBiZWhhdmlvci5vbkNvbnRleHRNZW51KHRoaXMsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBNb3VzZU1vdmUgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZU1vdXNlTW92ZTogZnVuY3Rpb24obW91c2VEZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25Nb3VzZU1vdmUodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBtb3VzZWRvd24gdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZU1vdXNlRG93bjogZnVuY3Rpb24obW91c2VEZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuaGFuZGxlTW91c2VEb3duKHRoaXMsIG1vdXNlRGV0YWlscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRGVsZWdhdGUgbW91c2V1cCB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlTW91c2VVcDogZnVuY3Rpb24obW91c2VEZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25Nb3VzZVVwKHRoaXMsIG1vdXNlRGV0YWlscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRGVsZWdhdGUgY2xpY2sgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZUNsaWNrOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbkNsaWNrKHRoaXMsIG1vdXNlRGV0YWlscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRGVsZWdhdGUgbW91c2VEcmFnIHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7bW91c2VEZXRhaWxzfSBtb3VzZURldGFpbHMgLSBBbiBlbnJpY2hlZCBtb3VzZSBldmVudCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICovXG4gICAgZGVsZWdhdGVNb3VzZURyYWc6IGZ1bmN0aW9uKG1vdXNlRGV0YWlscykge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLm9uTW91c2VEcmFnKHRoaXMsIG1vdXNlRGV0YWlscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgV2UndmUgYmVlbiBkb3VibGVjbGlja2VkIG9uLiBEZWxlZ2F0ZSB0aHJvdWdoIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7bW91c2VEZXRhaWxzfSBtb3VzZURldGFpbHMgLSBBbiBlbnJpY2hlZCBtb3VzZSBldmVudCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICovXG4gICAgZGVsZWdhdGVEb3VibGVDbGljazogZnVuY3Rpb24obW91c2VEZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25Eb3VibGVDbGljayh0aGlzLCBtb3VzZURldGFpbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEdlbmVyYXRlIGEgZnVuY3Rpb24gbmFtZSBhbmQgY2FsbCBpdCBvbiBzZWxmLlxuICAgICAqIEBkZXNjIFRoaXMgc2hvdWxkIGFsc28gYmUgZGVsZWdhdGVkIHRocm91Z2ggQmVoYXZpb3Iga2VlcGluZyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBoZXJlIHRob3VnaC5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBldmVudCAtIFRoZSBwZXJ0aW5lbnQgZXZlbnQuXG4gICAgICovXG4gICAgZGVsZWdhdGVLZXlEb3duOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLm9uS2V5RG93bih0aGlzLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgR2VuZXJhdGUgYSBmdW5jdGlvbiBuYW1lIGFuZCBjYWxsIGl0IG9uIHNlbGYuXG4gICAgICogQGRlc2MgVGhpcyBzaG91bGQgYWxzbyBiZSBkZWxlZ2F0ZWQgdGhyb3VnaCBCZWhhdmlvciBrZWVwaW5nIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGhlcmUgdGhvdWdoLlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IC0gVGhlIHBlcnRpbmVudCBldmVudC5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZUtleVVwOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLm9uS2V5VXAodGhpcywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNodXQgZG93biB0aGUgY3VycmVudCBjZWxsIGVkaXRvciBhbmQgc2F2ZSB0aGUgZWRpdGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgd2Ugd2VyZSBlZGl0aW5nOyBgZmFsc2VgIGlmIHdlIHdlcmUgbm90LlxuICAgICAqL1xuICAgIHN0b3BFZGl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHdhc0VkaXRpbmcgPSAhIXRoaXMuY2VsbEVkaXRvcjtcbiAgICAgICAgaWYgKHdhc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5zdG9wRWRpdGluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YXNFZGl0aW5nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNodXQgZG93biB0aGUgY3VycmVudCBjZWxsIGVkaXRvciB3aXRob3V0IHNhdmluZyB0aGUgZWRpdGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgd2Ugd2VyZSBlZGl0aW5nOyBgZmFsc2VgIGlmIHdlIHdlcmUgbm90LlxuICAgICAqL1xuICAgIGNhbmNlbEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgd2FzRWRpdGluZyA9ICEhdGhpcy5jZWxsRWRpdG9yO1xuICAgICAgICBpZiAod2FzRWRpdGluZykge1xuICAgICAgICAgICAgdGhpcy5jZWxsRWRpdG9yLmNhbmNlbEVkaXRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FzRWRpdGluZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBUaGUgcGl4ZWwgY29vcmRpbmF0ZXMgb2YganVzdCB0aGUgY2VudGVyICdtYWluXCIgZGF0YSBhcmVhLlxuICAgICAqL1xuICAgIGdldERhdGFCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sRE5ESGFja1dpZHRoID0gMjAwOyAvL3RoaXMgd2FzIGEgaGFjayB0byBoZWxwIHdpdGggY29sdW1uIGRuZCwgbmVlZCB0byBmYWN0b3IgdGhpcyBpbnRvIGEgc2hhcmVkIHZhcmlhYmxlXG4gICAgICAgIHZhciBiID0gdGhpcy5jYW52YXMuYm91bmRzO1xuXG4gICAgICAgIC8vdmFyIHggPSB0aGlzLmdldFJvd051bWJlcnNXaWR0aCgpO1xuICAgICAgICAvLyB2YXIgeSA9IGJlaGF2aW9yLmdldEZpeGVkUm93c0hlaWdodCgpICsgMjtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFJlY3RhbmdsZSgwLCAwLCBiLm9yaWdpbi54ICsgYi5leHRlbnQueCAtIGNvbEROREhhY2tXaWR0aCwgYi5vcmlnaW4ueSArIGIuZXh0ZW50LnkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRSb3dOdW1iZXJzV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Nob3dSb3dOdW1iZXJzKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVyKCkuZ2V0Um93TnVtYmVyc1dpZHRoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtDYW52YXN9IE91ciBmaW4tY2FudmFzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBPcGVuIHRoZSBjZWxsLWVkaXRvciBhdCB0aGUgcHJvdmlkZWQgbW9kZWwgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtQb2ludH0gZWRpdFBvaW50IC0gVGhlIG1vZGVsIGNvb3JkaW5hdGVzIG9mIHRoZSBjZWxsIHRvIGVkaXQuIFRoaXMgaXMgdGhlIGdyaWQgY29vcmRpbmF0ZXMgcmVnYXJkbGVzcyBvZiBzY3JvbGwgcG9zaXRpb24uXG4gICAgICogQHJldHVybiB7dW5kZWZpbmVkfENlbGxFZGl0b3J9IFRoZSBjZWxsRWRpdG9yIGRldGVybWluZWQgZnJvbSB0aGUgY2VsbCdzIHJlbmRlciBwcm9wZXJ0aWVzLCB3aGljaCBtYXkgYmUgbW9kaWZpZWQgYnkgbG9naWMgYWRkZWQgYnkgb3ZlcnJpZGluZyB7QGxpbmsgRGF0YU1vZGVsI2dldENlbGxFZGl0b3JBdHxnZXRDZWxsRWRpdG9yQXR9LlxuICAgICAqL1xuICAgIGVkaXRBdDogZnVuY3Rpb24oZWRpdFBvaW50KSB7XG4gICAgICAgIHZhciBjZWxsRWRpdG9yO1xuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdlZGl0QXQoY2VsbEVkaXRvciwgZWRpdFBvaW50KScsICdlZGl0QXQoZWRpdFBvaW50KScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0b3BFZGl0aW5nKCk7IC8vb3RoZXIgZWRpdG9yIGlzIG9wZW4sIGNsb3NlIGl0IGZpcnN0XG5cbiAgICAgICAgaWYgKGVkaXRQb2ludC54ID49IDAgJiYgZWRpdFBvaW50LnkgPj0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNFZGl0YWJsZSgpIHx8IHRoaXMuaXNGaWx0ZXJSb3coZWRpdFBvaW50LnkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNb3VzZURvd24oZWRpdFBvaW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERyYWdFeHRlbnQobmV3IFBvaW50KDAsIDApKTtcbiAgICAgICAgICAgICAgICBjZWxsRWRpdG9yID0gdGhpcy5nZXRDZWxsRWRpdG9yQXQoZWRpdFBvaW50KTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbEVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICBjZWxsRWRpdG9yLmJlZ2luRWRpdGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZWxsRWRpdG9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY29sdW1uIGlzIGZ1bGx5IHZpc2libGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtib29sYW59IFZpc2libGUuXG4gICAgICovXG4gICAgaXNDb2x1bW5WaXNpYmxlOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLmlzQ29sdW1uVmlzaWJsZShjb2x1bW5JbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiByb3cgaXMgZnVsbHkgdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgcm93IGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEByZXR1cm4ge2Jvb2xhbn0gVmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc0RhdGFSb3dWaXNpYmxlOiBmdW5jdGlvbihyb3dJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLmlzUm93VmlzaWJsZShyb3dJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjZWxsIGlzIGZ1bGx5IGlzIHZpc2libGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgcm93IGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IERhdGEgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc0RhdGFWaXNpYmxlOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgcm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEYXRhUm93VmlzaWJsZShyb3dJbmRleCkgJiYgdGhpcy5pc0NvbHVtblZpc2libGUoY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNjcm9sbCBpbiB0aGUgYG9mZnNldFhgIGRpcmVjdGlvbiBpZiBjb2x1bW4gaW5kZXggYGNvbEluZGV4YCBpcyBub3QgdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXggLSBUaGUgY29sdW1uIGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0gVGhlIGRpcmVjdGlvbiBhbmQgbWFnbml0dWRlIHRvIHNjcm9sbCBpZiB3ZSBuZWVkIHRvLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbHVtbiBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIGluc3VyZU1vZGVsQ29sSXNWaXNpYmxlOiBmdW5jdGlvbihjb2xJbmRleCwgb2Zmc2V0WCkge1xuICAgICAgICB2YXIgbWF4Q29scyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDEsIC8vIC0xIGV4Y2x1ZGVzIHBhcnRpYWxseSB2aXNpYmxlIGNvbHVtbnNcbiAgICAgICAgICAgIGluZGV4VG9DaGVjayA9IGNvbEluZGV4ICsgKG9mZnNldFggPiAwKSxcbiAgICAgICAgICAgIHZpc2libGUgPSAhdGhpcy5pc0NvbHVtblZpc2libGUoaW5kZXhUb0NoZWNrKSB8fCBjb2xJbmRleCA9PT0gbWF4Q29scztcblxuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgLy90aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIHRoZSBsZWZ0bW9zdCBjb2x1bW5cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQnkob2Zmc2V0WCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgaW4gdGhlIGBvZmZzZXRZYCBkaXJlY3Rpb24gaWYgY29sdW1uIGluZGV4IGMgaXMgbm90IHZpc2libGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVGhlIGNvbHVtbiBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIFRoZSBkaXJlY3Rpb24gYW5kIG1hZ25pdHVkZSB0byBzY3JvbGwgaWYgd2UgbmVlZCB0by5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSb3cgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpbnN1cmVNb2RlbFJvd0lzVmlzaWJsZTogZnVuY3Rpb24ocm93SW5kZXgsIG9mZnNldFkpIHtcbiAgICAgICAgdmFyIG1heFJvd3MgPSB0aGlzLmdldFJvd0NvdW50KCkgLSAxLCAvLyAtMSBleGNsdWRlcyBwYXJ0aWFsbHkgdmlzaWJsZSByb3dzXG4gICAgICAgICAgICBpbmRleFRvQ2hlY2sgPSByb3dJbmRleCArIChvZmZzZXRZID4gMCksXG4gICAgICAgICAgICB2aXNpYmxlID0gIXRoaXMuaXNEYXRhUm93VmlzaWJsZShpbmRleFRvQ2hlY2spIHx8IHJvd0luZGV4ID09PSBtYXhSb3dzO1xuXG4gICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICAvL3RoZSBzY3JvbGwgcG9zaXRpb24gaXMgdGhlIHRvcG1vc3Qgcm93XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJ5KDAsIG9mZnNldFkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZpc2libGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2Nyb2xsIGhvcml6b250YWwgYW5kIHZlcnRpY2FsbHkgYnkgdGhlIHByb3ZpZGVkIG9mZnNldHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSBTY3JvbGwgaW4gdGhlIHggZGlyZWN0aW9uIHRoaXMgbXVjaC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIFNjcm9sbCBpbiB0aGUgeSBkaXJlY3Rpb24gdGhpcyBtdWNoLlxuICAgICAqL1xuICAgIHNjcm9sbEJ5OiBmdW5jdGlvbihvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsSEJ5KG9mZnNldFgpO1xuICAgICAgICB0aGlzLnNjcm9sbFZCeShvZmZzZXRZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgdmVydGljYWxseSBieSB0aGUgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0gU2Nyb2xsIGluIHRoZSB5IGRpcmVjdGlvbiB0aGlzIG11Y2guXG4gICAgICovXG4gICAgc2Nyb2xsVkJ5OiBmdW5jdGlvbihvZmZzZXRZKSB7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLnNiVlNjcm9sbGVyLnJhbmdlLm1heDtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5nZXRWU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gTWF0aC5taW4obWF4LCBNYXRoLm1heCgwLCBvbGRWYWx1ZSArIG9mZnNldFkpKTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRWU2Nyb2xsVmFsdWUobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2Nyb2xsIGhvcml6b250YWxseSBieSB0aGUgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0gU2Nyb2xsIGluIHRoZSB4IGRpcmVjdGlvbiB0aGlzIG11Y2guXG4gICAgICovXG4gICAgc2Nyb2xsSEJ5OiBmdW5jdGlvbihvZmZzZXRYKSB7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLnNiSFNjcm9sbGVyLnJhbmdlLm1heDtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gTWF0aC5taW4obWF4LCBNYXRoLm1heCgwLCBvbGRWYWx1ZSArIG9mZnNldFgpKTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRIU2Nyb2xsVmFsdWUobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNjcm9sbFRvTWFrZVZpc2libGU6IGZ1bmN0aW9uKGMsIHIpIHtcbiAgICAgICAgdmFyIGxlZnRDb2x1bW4gPSB0aGlzLnJlbmRlcmVyLmdldFNjcm9sbExlZnQoKSxcbiAgICAgICAgICAgIHRvcFJvdyA9IHRoaXMucmVuZGVyZXIuZ2V0U2Nyb2xsVG9wKCksXG4gICAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICAgIG51bU9mR3JpZEN0cmxDb2xzID0gMiwgLy9UT0RPOiBHZXQgcmlkIG9mIEFMTCBtYWdpYyBhbmQgaGFyZGNvZGVkIG51bWJlcnMuXG4gICAgICAgICAgICBudW1vZkdyaWRDdHJsUm93cyA9IDMsXG4gICAgICAgICAgICBhZGp1c3RtZW50Rm9yUGFydGlhbGx5VmlzQ29scyA9IC0xO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIHRhcmdldCBpcyBvZmYgdG8gbGVmdDsgbmVnYXRpdmUgZGVsdGEgc2Nyb2xscyBsZWZ0XG4gICAgICAgICAgICAoZGVsdGEgPSBjIC0gKGxlZnRDb2x1bW4gKyB0aGlzLnJlbmRlcmVyLmdldEZpeGVkQ29sdW1uQ291bnQoKSkpIDwgMCB8fFxuXG4gICAgICAgICAgICAvLyB0YXJnZXQgaXMgb2ZmIHRvIHJpZ2h0OyBwb3NpdGl2ZSBkZWx0YSBzY3JvbGxzIHJpZ2h0XG4gICAgICAgICAgICAoZGVsdGEgPSBjIC0gKGxlZnRDb2x1bW4gKyB0aGlzLmdldFZpc2libGVDb2x1bW5zQ291bnQoKSAtIG51bU9mR3JpZEN0cmxDb2xzICsgYWRqdXN0bWVudEZvclBhcnRpYWxseVZpc0NvbHMpKSA+IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnNiSFNjcm9sbGVyLmluZGV4ICs9IGRlbHRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gdGFyZ2V0IGlzIGFib3ZlIHRvcDsgbmVnYXRpdmUgZGVsdGEgc2Nyb2xscyB1cFxuICAgICAgICAgICAgKGRlbHRhID0gciAtICh0b3BSb3cgKyB0aGlzLnJlbmRlcmVyLmdldEZpeGVkUm93Q291bnQoKSkpIDwgMCB8fFxuXG4gICAgICAgICAgICAvLyB0YXJnZXQgaXMgYmVsb3cgYm90dG9tOyBwb3NpdGl2ZSBkZWx0YSBzY3JvbGxzIGRvd25cbiAgICAgICAgICAgIChkZWx0YSA9IHIgLSAodG9wUm93ICsgdGhpcy5yZW5kZXJlci5yb3dFZGdlcy5sZW5ndGggLSBudW1vZkdyaWRDdHJsUm93cykpID4gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIuaW5kZXggKz0gZGVsdGE7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VsZWN0Q2VsbEFuZFNjcm9sbFRvTWFrZVZpc2libGU6IGZ1bmN0aW9uKGMsIHIpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RDZWxsKGMsIHIsIHRydWUpO1xuICAgICAgICB0aGlzLnNjcm9sbFRvTWFrZVZpc2libGUoYywgcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgQW5zd2VyIHdoaWNoIGRhdGEgY2VsbCBpcyB1bmRlciBhIHBpeGVsIHZhbHVlIG1vdXNlIHBvaW50LlxuICAgICAqIEBwYXJhbSB7bW91c2VQb2ludH0gbW91c2UgLSBUaGUgbW91c2UgcG9pbnQgdG8gaW50ZXJyb2dhdGUuXG4gICAgICovXG5cbiAgICBnZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50OiBmdW5jdGlvbihtb3VzZSkge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IFRoZSBwaXhlbCBiYXNlZCBib3VuZHMgcmVjdGFuZ2xlIGdpdmVuIGEgZGF0YSBjZWxsIHBvaW50LlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGwgLSBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIG1vdXNlLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Qm91bmRzT2ZDZWxsOiBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5nZXRSZW5kZXJlcigpLmdldEJvdW5kc09mQ2VsbChjZWxsKTtcblxuICAgICAgICAvL3dlIG5lZWQgdG8gY29udmVydCB0aGlzIHRvIGEgcHJvcGVyIHJlY3RhbmdsZVxuICAgICAgICB2YXIgbmV3Qm91bmRzID0gbmV3IFJlY3RhbmdsZShiLngsIGIueSwgYi53aWR0aCwgYi5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gbmV3Qm91bmRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBmaW4tY2FudmFzIHdoZW4gYSByZXNpemUgb2NjdXJzLlxuICAgICAqL1xuICAgIHJlc2l6ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRyaWVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgQSBjbGljayBldmVudCBvY2N1cmVkLlxuICAgICAqIEBkZXNjIERldGVybWluZSB0aGUgY2VsbCBhbmQgZGVsZWdhdGUgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIFRoZSBtb3VzZSBldmVudCB0byBpbnRlcnJvZ2F0ZS5cbiAgICAgKi9cbiAgICBjZWxsQ2xpY2tlZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGNlbGwgPSBldmVudC5ncmlkQ2VsbDtcblxuICAgICAgICAvL2NsaWNrIG9jY3VycmVkIGluIGJhY2tncm91bmQgYXJlYVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjZWxsLnggPD0gdGhpcy5nZXRDb2x1bW5Db3VudCgpICYmXG4gICAgICAgICAgICBjZWxsLnkgPD0gdGhpcy5nZXRSb3dDb3VudCgpXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGhvdmVyZWQgPSB0aGlzLmdldEhvdmVyQ2VsbCgpLFxuICAgICAgICAgICAgICAgIHggPSBob3ZlcmVkLngsXG4gICAgICAgICAgICAgICAgeSA9IGhvdmVyZWQueTtcblxuICAgICAgICAgICAgLy8gaWYgKHggPj0gMCkge1xuICAgICAgICAgICAgLy8gICAgIHggPSBiZWhhdmlvci50cmFuc2xhdGVDb2x1bW5JbmRleCh4ICsgdGhpcy5nZXRIU2Nyb2xsVmFsdWUoKSk7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIGlmICh5ID49IDApIHtcbiAgICAgICAgICAgICAgICB5ICs9IHRoaXMuZ2V0VlNjcm9sbFZhbHVlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3IuY2VsbENsaWNrZWQobmV3IFBvaW50KHgsIHkpLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIGNvbHVtbiBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdG90YWxzIHJvdyBpbmRleCBsb2NhbCB0byB0aGUgdG90YWxzIGFyZWFcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbYXJlYXM9Wyd0b3AnLCAnYm90dG9tJ11dIC0gbWF5IGluY2x1ZGUgYCd0b3AnYCBhbmQvb3IgYCdib3R0b20nYFxuICAgICAqL1xuICAgIHNldFRvdGFsc1ZhbHVlTm90aWZpY2F0aW9uOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSwgYXJlYXMpIHtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljU2V0VG90YWxzVmFsdWUoeCwgeSwgdmFsdWUsIGFyZWFzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIGNvbHVtbiBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdG90YWxzIHJvdyBpbmRleCBsb2NhbCB0byB0aGUgdG90YWxzIGFyZWFcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbYXJlYXM9Wyd0b3AnLCAnYm90dG9tJ11dIC0gbWF5IGluY2x1ZGUgYCd0b3AnYCBhbmQvb3IgYCdib3R0b20nYFxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNTZXRUb3RhbHNWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUsIGFyZWFzKSB7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tc2V0LXRvdGFscy12YWx1ZScsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgYXJlYXM6IGFyZWFzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljRWRpdG9yS2V5VXBFdmVudDogZnVuY3Rpb24oaW5wdXRDb250cm9sLCBrZXlFdmVudCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWVkaXRvci1rZXl1cCcsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlucHV0OiBpbnB1dENvbnRyb2wsXG4gICAgICAgICAgICAgICAga2V5RXZlbnQ6IGtleUV2ZW50LFxuICAgICAgICAgICAgICAgIGNoYXI6IHRoaXMuY2FudmFzLmdldENoYXJNYXAoKVtrZXlFdmVudC5rZXlDb2RlXVtrZXlFdmVudC5zaGlmdEtleSA/IDEgOiAwXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0VkaXRvcktleURvd25FdmVudDogZnVuY3Rpb24oaW5wdXRDb250cm9sLCBrZXlFdmVudCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWVkaXRvci1rZXlkb3duJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0Q29udHJvbCxcbiAgICAgICAgICAgICAgICBrZXlFdmVudDoga2V5RXZlbnQsXG4gICAgICAgICAgICAgICAgY2hhcjogdGhpcy5jYW52YXMuZ2V0Q2hhck1hcCgpW2tleUV2ZW50LmtleUNvZGVdW2tleUV2ZW50LnNoaWZ0S2V5ID8gMSA6IDBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljRWRpdG9yS2V5UHJlc3NFdmVudDogZnVuY3Rpb24oaW5wdXRDb250cm9sLCBrZXlFdmVudCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWVkaXRvci1rZXlwcmVzcycsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlucHV0OiBpbnB1dENvbnRyb2wsXG4gICAgICAgICAgICAgICAga2V5RXZlbnQ6IGtleUV2ZW50LFxuICAgICAgICAgICAgICAgIGNoYXI6IHRoaXMuY2FudmFzLmdldENoYXJNYXAoKVtrZXlFdmVudC5rZXlDb2RlXVtrZXlFdmVudC5zaGlmdEtleSA/IDEgOiAwXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0VkaXRvckRhdGFDaGFuZ2VFdmVudDogZnVuY3Rpb24oaW5wdXRDb250cm9sLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1lZGl0b3ItZGF0YS1jaGFuZ2UnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogaW5wdXRDb250cm9sLFxuICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1yb3ctc2VsZWN0aW9uLWNoYW5nZWRgIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNSb3dTZWxlY3Rpb25DaGFuZ2VkRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1yb3ctc2VsZWN0aW9uLWNoYW5nZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICByb3dzOiB0aGlzLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uczogdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCksXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KHNlbGVjdGlvbkV2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0NvbHVtblNlbGVjdGlvbkNoYW5nZWRFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25FdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWNvbHVtbi1zZWxlY3Rpb24tY2hhbmdlZCcsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIHJvd3M6IHRoaXMuZ2V0U2VsZWN0ZWRSb3dzKCksXG4gICAgICAgICAgICAgICAgY29sdW1uczogdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25zOiB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChzZWxlY3Rpb25FdmVudCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGRpc3BhdGNoIGEgYGZpbi1zZWxlY3Rpb24tY2hhbmdlZGAgZXZlbnQuXG4gICAgICovXG4gICAgc2VsZWN0aW9uQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZFJvd3MgPSB0aGlzLmdldFNlbGVjdGVkUm93cygpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1zZWxlY3Rpb24tY2hhbmdlZCcsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIHJvd3M6IHNlbGVjdGVkUm93cyxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnM6IHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChzZWxlY3Rpb25FdmVudCk7XG4gICAgfSxcblxuXG4gICAgZ2V0Um93U2VsZWN0aW9uOiBmdW5jdGlvbihpbmNsdWRlSGlkZGVuQ29sdW1ucykge1xuICAgICAgICB2YXIgYywgY29sdW1uLCBjb2x1bW5WYWx1ZXMsIGdldENvbHVtbixcbiAgICAgICAgICAgIHNlbGVjdGVkUm93SW5kZXhlcyA9IHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0ZWRSb3dzKCksXG4gICAgICAgICAgICBudW1Db2x1bW5zID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpLFxuICAgICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgICAgaWYgKGluY2x1ZGVIaWRkZW5Db2x1bW5zKSB7XG4gICAgICAgICAgICBudW1Db2x1bW5zICs9IHRoaXMuZ2V0SGlkZGVuQ29sdW1ucygpLmxlbmd0aDtcbiAgICAgICAgICAgIGdldENvbHVtbiA9IHRoaXMuYmVoYXZpb3IuZ2V0Q29sdW1uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0Q29sdW1uID0gdGhpcy5iZWhhdmlvci5nZXRBY3RpdmVDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q29sdW1uID0gZ2V0Q29sdW1uLmJpbmQodGhpcy5iZWhhdmlvcik7XG5cbiAgICAgICAgZm9yIChjID0gMDsgYyA8IG51bUNvbHVtbnM7IGMrKykge1xuICAgICAgICAgICAgY29sdW1uID0gZ2V0Q29sdW1uKGMpO1xuICAgICAgICAgICAgY29sdW1uVmFsdWVzID0gbmV3IEFycmF5KHNlbGVjdGVkUm93SW5kZXhlcy5sZW5ndGgpO1xuICAgICAgICAgICAgc2VsZWN0ZWRSb3dJbmRleGVzLmZvckVhY2goc2V0Q29sdW1uVmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0W2NvbHVtbi5uYW1lXSA9IGNvbHVtblZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldENvbHVtblZhbHVlKHNlbGVjdGVkUm93SW5kZXgsIGopIHtcbiAgICAgICAgICAgIGNvbHVtblZhbHVlc1tqXSA9IHZhbE9yRnVuYyhjb2x1bW4uZ2V0VmFsdWUoc2VsZWN0ZWRSb3dJbmRleCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0SGlkZGVuQ29sdW1uczogZnVuY3Rpb24oKXtcbiAgICAgICAgLy9BIG5vbiBpbi1tZW1vcnkgYmVoYXZpb3Igd2lsbCBiZSBtb3JlIHRyb3VibGVzb21lXG4gICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRIaWRkZW5Db2x1bW5zKCk7XG4gICAgfSxcblxuICAgIGdldFJvd1NlbGVjdGlvbk1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjLCBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHNlbGVjdGVkUm93SW5kZXhlcyA9IHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0ZWRSb3dzKCksXG4gICAgICAgICAgICBudW1Db2xzID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpLFxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KG51bUNvbHMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFZhbHVlKHNlbGVjdGVkUm93SW5kZXgsIHIpIHtcbiAgICAgICAgICAgIHJlc3VsdFtjXVtyXSA9IHZhbE9yRnVuYyhzZWxmLmdldFZhbHVlKGMsIHNlbGVjdGVkUm93SW5kZXgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoYyA9IDA7IGMgPCBudW1Db2xzOyBjKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtjXSA9IG5ldyBBcnJheShzZWxlY3RlZFJvd0luZGV4ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHNlbGVjdGVkUm93SW5kZXhlcy5mb3JFYWNoKGdldFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldENvbHVtblNlbGVjdGlvbk1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZENvbHVtbkluZGV4ZXMgPSB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpO1xuICAgICAgICB2YXIgbnVtUm93cyA9IHRoaXMuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShzZWxlY3RlZENvbHVtbkluZGV4ZXMubGVuZ3RoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzZWxlY3RlZENvbHVtbkluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3RlZENvbHVtbkluZGV4LCBjKSB7XG4gICAgICAgICAgICByZXN1bHRbY10gPSBuZXcgQXJyYXkobnVtUm93cyk7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IG51bVJvd3M7IHIrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtjXVtyXSA9IHZhbE9yRnVuYyhzZWxmLmdldFZhbHVlKHNlbGVjdGVkQ29sdW1uSW5kZXgsIHIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldENvbHVtblNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZENvbHVtbkluZGV4ZXMgPSB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHZhciByb3dDb3VudCA9IHRoaXMuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzZWxlY3RlZENvbHVtbkluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3RlZENvbHVtbkluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gbmV3IEFycmF5KHJvd0NvdW50KTtcbiAgICAgICAgICAgIHJlc3VsdFtzZWxmLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbihzZWxlY3RlZENvbHVtbkluZGV4KS5uYW1lXSA9IGNvbHVtbjtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcm93Q291bnQ7IHIrKykge1xuICAgICAgICAgICAgICAgIGNvbHVtbltyXSA9IHZhbE9yRnVuYyhzZWxmLmdldFZhbHVlKHNlbGVjdGVkQ29sdW1uSW5kZXgsIHIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShzZWxlY3Rpb25zLmxlbmd0aCk7XG4gICAgICAgIHNlbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3Rpb25SZWN0LCBpKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBzZWxmLl9nZXRTZWxlY3Rpb24oc2VsZWN0aW9uUmVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBfZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbihyZWN0KSB7XG4gICAgICAgIHJlY3QgPSBub3JtYWxpemVSZWN0KHJlY3QpO1xuICAgICAgICB2YXIgY29sQ291bnQgPSByZWN0LmV4dGVudC54ICsgMTtcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gcmVjdC5leHRlbnQueSArIDE7XG4gICAgICAgIHZhciBveCA9IHJlY3Qub3JpZ2luLng7XG4gICAgICAgIHZhciBveSA9IHJlY3Qub3JpZ2luLnk7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyIHI7XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29sQ291bnQ7IGMrKykge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IG5ldyBBcnJheShyb3dDb3VudCk7XG4gICAgICAgICAgICByZXN1bHRbdGhpcy5iZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oYyArIG94KS5uYW1lXSA9IGNvbHVtbjtcbiAgICAgICAgICAgIGZvciAociA9IDA7IHIgPCByb3dDb3VudDsgcisrKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uW3JdID0gdmFsT3JGdW5jKHRoaXMuZ2V0VmFsdWUob3ggKyBjLCBveSArIHIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoc2VsZWN0aW9ucy5sZW5ndGgpO1xuICAgICAgICBzZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0aW9uUmVjdCwgaSkge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gc2VsZi5fZ2V0U2VsZWN0aW9uTWF0cml4KHNlbGVjdGlvblJlY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2dldFNlbGVjdGlvbk1hdHJpeDogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICByZWN0ID0gbm9ybWFsaXplUmVjdChyZWN0KTtcbiAgICAgICAgdmFyIGNvbENvdW50ID0gcmVjdC5leHRlbnQueCArIDE7XG4gICAgICAgIHZhciByb3dDb3VudCA9IHJlY3QuZXh0ZW50LnkgKyAxO1xuICAgICAgICB2YXIgb3ggPSByZWN0Lm9yaWdpbi54O1xuICAgICAgICB2YXIgb3kgPSByZWN0Lm9yaWdpbi55O1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29sQ291bnQ7IGMrKykge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IG5ldyBBcnJheShyb3dDb3VudCk7XG4gICAgICAgICAgICByZXN1bHRbY10gPSBjb2x1bW47XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJvd0NvdW50OyByKyspIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5bcl0gPSB2YWxPckZ1bmModGhpcy5nZXRWYWx1ZShveCArIGMsIG95ICsgcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWNvbnRleHQtbWVudWAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2tleUV2ZW50fSBldmVudCAtIFRoZSBjYW52YXMgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0NvbnRleHRNZW51RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5ncmlkQ2VsbCA9IHRoaXMuY29udmVydFZpZXdQb2ludFRvRGF0YVBvaW50KGUuZ3JpZENlbGwpO1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1jb250ZXh0LW1lbnUnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBncmlkQ2VsbDogZS5ncmlkQ2VsbCxcbiAgICAgICAgICAgICAgICBtb3VzZVBvaW50OiBlLm1vdXNlUG9pbnQsXG4gICAgICAgICAgICAgICAgdmlld1BvaW50OiBlLnZpZXdQb2ludCxcbiAgICAgICAgICAgICAgICBwcmltaXRpdmVFdmVudDogZS5wcmltaXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgICByb3dzOiB0aGlzLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uczogdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljTW91c2VVcEV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLW1vdXNldXAnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBncmlkQ2VsbDogZS5ncmlkQ2VsbCxcbiAgICAgICAgICAgICAgICBtb3VzZVBvaW50OiBlLm1vdXNlUG9pbnQsXG4gICAgICAgICAgICAgICAgdmlld1BvaW50OiBlLnZpZXdQb2ludCxcbiAgICAgICAgICAgICAgICBwcmltaXRpdmVFdmVudDogZS5wcmltaXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgICByb3dzOiB0aGlzLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uczogdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljTW91c2VEb3duRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5zdG9wRWRpdGluZygpO1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1tb3VzZWRvd24nLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBncmlkQ2VsbDogZS5ncmlkQ2VsbCxcbiAgICAgICAgICAgICAgICBtb3VzZVBvaW50OiBlLm1vdXNlUG9pbnQsXG4gICAgICAgICAgICAgICAgdmlld1BvaW50OiBlLnZpZXdQb2ludCxcbiAgICAgICAgICAgICAgICBwcmltaXRpdmVFdmVudDogZS5wcmltaXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgICByb3dzOiB0aGlzLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uczogdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0sXG5cbiAgICBpc1ZpZXdhYmxlQnV0dG9uOiBmdW5jdGlvbihjLCByKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVyKCkuaXNWaWV3YWJsZUJ1dHRvbihjLCByKTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0J1dHRvblByZXNzZWRFdmVudDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciBkYXRhQ2VsbCA9IGV2dC5kYXRhQ2VsbDtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZ0LmdyaWRDZWxsO1xuICAgICAgICBpZiAodGhpcy5pc1ZpZXdhYmxlQnV0dG9uKGRhdGFDZWxsLngsIGRhdGFDZWxsLnkpKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1idXR0b24tcHJlc3NlZCcsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZENlbGw6IGdyaWRDZWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1jb2x1bW4tZHJhZy1zdGFydGAgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY09uQ29sdW1uc0NoYW5nZWRFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZXRhaWwgPSB7XG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZ3JpZDogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tY29sdW1uLWNoYW5nZWQtZXZlbnQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2coJ2NvbHVtbiBjaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY0V2ZW50KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4ta2V5ZG93bmAgZXZlbnQuXG4gICAgICogQHBhcmFtIHtrZXlFdmVudH0gZXZlbnQgLSBUaGUgY2FudmFzIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNLZXlkb3duRXZlbnQ6IGZ1bmN0aW9uKGtleUV2ZW50KSB7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4ta2V5ZG93bicsIHtcbiAgICAgICAgICAgIGRldGFpbDoga2V5RXZlbnQuZGV0YWlsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWtleXVwYCBldmVudC5cbiAgICAgKiBAcGFyYW0ge2tleUV2ZW50fSBldmVudCAtIFRoZSBjYW52YXMgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0tleXVwRXZlbnQ6IGZ1bmN0aW9uKGtleUV2ZW50KSB7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4ta2V5dXAnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGtleUV2ZW50LmRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0ZpbHRlckFwcGxpZWRFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaWx0ZXJFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWZpbHRlci1hcHBsaWVkJyk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZmlsdGVyRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWNlbGwtZW50ZXJgIGV2ZW50XG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgY2VsbCBpbiB3aGljaCB0aGUgY2xpY2sgZXZlbnQgb2NjdXJyZWQuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIFRoZSBzeXN0ZW0gbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY09uQ2VsbEVudGVyRXZlbnQ6IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IHtcbiAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGdyaWQ6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1jZWxsLWVudGVyJywge1xuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNHcm91cHNDaGFuZ2VkRXZlbnQ6IGZ1bmN0aW9uKGdyb3Vwcykge1xuICAgICAgICB2YXIgZGV0YWlsID0ge1xuICAgICAgICAgICAgZ3JvdXBzOiBncm91cHMsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZ3JpZDogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWdyb3Vwcy1jaGFuZ2VkJywge1xuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tY2VsbC1leGl0YCBldmVudC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBjZWxsIGluIHdoaWNoIHRoZSBjbGljayBldmVudCBvY2N1cmVkLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBUaGUgc3lzdGVtIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNPbkNlbGxFeGl0RXZlbnQ6IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IHtcbiAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGdyaWQ6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1jZWxsLWV4aXQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1jZWxsLWNsaWNrYCBldmVudC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBjZWxsIGluIHdoaWNoIHRoZSBjbGljayBldmVudCBvY2N1cmVkLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBUaGUgc3lzdGVtIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNDbGlja0V2ZW50OiBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgICAgIHZhciBjZWxsID0gbW91c2VFdmVudC5ncmlkQ2VsbDtcbiAgICAgICAgdmFyIGRldGFpbCA9IHtcbiAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgbW91c2VQb2ludDogbW91c2VFdmVudC5tb3VzZVBvaW50LFxuICAgICAgICAgICAga2V5czogbW91c2VFdmVudC5rZXlzLFxuICAgICAgICAgICAgcHJpbWl0aXZlRXZlbnQ6IG1vdXNlRXZlbnQsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZ3JpZDogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmVuaGFuY2VEb3VibGVDbGlja0V2ZW50KGRldGFpbCk7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tY2xpY2snLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1kb3VibGUtY2xpY2tgIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBUaGUgc3lzdGVtIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNEb3VibGVDbGlja0V2ZW50OiBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgdmFyIGNlbGwgPSBtb3VzZUV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB2YXIgZGV0YWlsID0ge1xuICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICBtb3VzZVBvaW50OiBtb3VzZUV2ZW50Lm1vdXNlUG9pbnQsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZ3JpZDogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmVuaGFuY2VEb3VibGVDbGlja0V2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWRvdWJsZS1jbGljaycsIHtcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmNlbGxEb3VibGVDbGlja2VkKGNlbGwsIG1vdXNlRXZlbnQpO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSByZW5kZXJlZCBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljR3JpZFJlbmRlcmVkRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1ncmlkLXJlbmRlcmVkJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgICAgIHRpbWU6IERhdGUubm93KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgc2Nyb2xsIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gU2hvdWxkIGJlIGVpdGhlciBgZmluLXNjcm9sbC14YCBvciBgZmluLXNjcm9sbC15YC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2xkVmFsdWUgLSBUaGUgb2xkIHNjcm9sbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VmFsdWUgLSBUaGUgbmV3IHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmaXJlU2Nyb2xsRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQodHlwZSwge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNldCB0aGUgdmVydGljYWwgc2Nyb2xsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSAtIFRoZSBuZXcgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIHNldFZTY3JvbGxWYWx1ZTogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHkgPSBNYXRoLm1pbih0aGlzLnNiVlNjcm9sbGVyLnJhbmdlLm1heCwgTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCh5KSkpO1xuICAgICAgICBpZiAoeSAhPT0gdGhpcy52U2Nyb2xsVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3IuX3NldFNjcm9sbFBvc2l0aW9uWSh5KTtcbiAgICAgICAgICAgIHZhciBvbGRZID0gdGhpcy52U2Nyb2xsVmFsdWU7XG4gICAgICAgICAgICB0aGlzLnZTY3JvbGxWYWx1ZSA9IHk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBzZWxmLnNiVlJhbmdlQWRhcHRlci5zdWJqZWN0Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyZVNjcm9sbEV2ZW50KCdmaW4tc2Nyb2xsLXknLCBvbGRZLCB5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmVydGljYWwgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIGdldFZTY3JvbGxWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZTY3JvbGxWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIGhvcml6b250YWwgc2Nyb2xsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSAtIFRoZSBuZXcgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIHNldEhTY3JvbGxWYWx1ZTogZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHggPSBNYXRoLm1pbih0aGlzLnNiSFNjcm9sbGVyLnJhbmdlLm1heCwgTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCh4KSkpO1xuICAgICAgICBpZiAoeCAhPT0gdGhpcy5oU2Nyb2xsVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3IuX3NldFNjcm9sbFBvc2l0aW9uWCh4KTtcbiAgICAgICAgICAgIHZhciBvbGRYID0gdGhpcy5oU2Nyb2xsVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmhTY3JvbGxWYWx1ZSA9IHg7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvL3NlbGYuc2JIUmFuZ2VBZGFwdGVyLnN1YmplY3RDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJlU2Nyb2xsRXZlbnQoJ2Zpbi1zY3JvbGwteCcsIG9sZFgsIHgpO1xuICAgICAgICAgICAgICAgIC8vc2VsZi5zeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kcmllcygpOyAvLyB0b2RvOiBDb21tZW50ZWQgb2ZmIHRvIHByZXZlbnQgdGhlIGdyaWQgZnJvbSBib3VuY2luZyBiYWNrLCBidXQgdGhlcmUgbWF5IGJlIHJlcHVyY3Vzc2lvbnMuLi5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgVGhlIHZlcnRpY2FsIHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRIU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oU2Nyb2xsVmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVxdWVzdCBpbnB1dCBmb2N1cy5cbiAgICAgKi9cbiAgICB0YWtlRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RvcEVkaXRpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRDYW52YXMoKS50YWtlRm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlcXVlc3QgZm9jdXMgZm9yIG91ciBjZWxsIGVkaXRvci5cbiAgICAgKi9cbiAgICBlZGl0b3JUYWtlRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsRWRpdG9yLnRha2VGb2N1cygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgSW5pdGlhbGl6ZSB0aGUgc2Nyb2xsIGJhcnMuXG4gICAgICovXG4gICAgaW5pdFNjcm9sbGJhcnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgaG9yekJhciA9IG5ldyBGaW5CYXIoe1xuICAgICAgICAgICAgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgIG9uY2hhbmdlOiBzZWxmLnNldEhTY3JvbGxWYWx1ZS5iaW5kKHNlbGYpLFxuICAgICAgICAgICAgY3NzU3R5bGVzaGVldFJlZmVyZW5jZUVsZW1lbnQ6IHRoaXMuZGl2XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB2ZXJ0QmFyID0gbmV3IEZpbkJhcih7XG4gICAgICAgICAgICBvcmllbnRhdGlvbjogJ3ZlcnRpY2FsJyxcbiAgICAgICAgICAgIG9uY2hhbmdlOiBzZWxmLnNldFZTY3JvbGxWYWx1ZS5iaW5kKHNlbGYpLFxuICAgICAgICAgICAgcGFnaW5nOiB7XG4gICAgICAgICAgICAgICAgdXA6IHNlbGYucGFnZVVwLmJpbmQoc2VsZiksXG4gICAgICAgICAgICAgICAgZG93bjogc2VsZi5wYWdlRG93bi5iaW5kKHNlbGYpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIgPSBob3J6QmFyO1xuICAgICAgICB0aGlzLnNiVlNjcm9sbGVyID0gdmVydEJhcjtcblxuICAgICAgICB2YXIgaFByZWZpeCA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdoU2Nyb2xsYmFyQ2xhc3NQcmVmaXgnKTtcbiAgICAgICAgdmFyIHZQcmVmaXggPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgndlNjcm9sbGJhckNsYXNzUHJlZml4Jyk7XG5cbiAgICAgICAgaWYgKGhQcmVmaXggJiYgaFByZWZpeCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIuY2xhc3NQcmVmaXggPSBoUHJlZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZQcmVmaXggJiYgdlByZWZpeCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIuY2xhc3NQcmVmaXggPSB2UHJlZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQoaG9yekJhci5iYXIpO1xuICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZCh2ZXJ0QmFyLmJhcik7XG5cbiAgICAgICAgdGhpcy5yZXNpemVTY3JvbGxiYXJzKCk7XG5cbiAgICB9LFxuXG4gICAgcmVzaXplU2Nyb2xsYmFyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIuc2hvcnRlbkJ5KHRoaXMuc2JWU2Nyb2xsZXIpLnJlc2l6ZSgpO1xuICAgICAgICAvL3RoaXMuc2JWU2Nyb2xsZXIuc2hvcnRlbkJ5KHRoaXMuc2JIU2Nyb2xsZXIpO1xuICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLnJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNjcm9sbCB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLCB3ZSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqL1xuICAgIHNldFZTY3JvbGxiYXJWYWx1ZXM6IGZ1bmN0aW9uKG1heCkge1xuICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLnJhbmdlID0ge1xuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiBtYXhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgc2V0SFNjcm9sbGJhclZhbHVlczogZnVuY3Rpb24obWF4KSB7XG4gICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIucmFuZ2UgPSB7XG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IG1heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBzY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLmhTY3JvbGxWYWx1ZSA9PT0gdGhpcy5zYlByZXZIU2Nyb2xsVmFsdWUgJiYgdGhpcy52U2Nyb2xsVmFsdWUgPT09IHRoaXMuc2JQcmV2VlNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNiUHJldkhTY3JvbGxWYWx1ZSA9IHRoaXMuaFNjcm9sbFZhbHVlO1xuICAgICAgICB0aGlzLnNiUHJldlZTY3JvbGxWYWx1ZSA9IHRoaXMudlNjcm9sbFZhbHVlO1xuXG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5zY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tcHV0ZUNlbGxzQm91bmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgR2V0IGRhdGEgdmFsdWUgYXQgZ2l2ZW4gY2VsbC5cbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZXMgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRWYWx1ZSh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgYSBkYXRhIHZhbHVlIGludG8gdGhlIGJlaGF2aW9yIChtb2RlbCkgYXQgdGhlIGdpdmVuIHBvaW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5BbGlnbm1lbnQ6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Q29sdW1uQWxpZ25tZW50KGMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSBkYXRhIGRpbWVuc2lvbnMgaGF2ZSBjaGFuZ2VkLCBvciBvdXIgcGl4ZWwgYm91bmRyaWVzIGhhdmUgY2hhbmdlZC5cbiAgICAgKiBBZGp1c3QgdGhlIHNjcm9sbGJhciBwcm9wZXJ0aWVzIGFzIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBzeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kcmllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIG51bUZpeGVkUm93cyA9IHRoaXMuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgIHZhciBudW1Db2x1bW5zID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgbnVtUm93cyA9IHRoaXMuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgICAgaWYgKCFib3VuZHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Nyb2xsYWJsZUhlaWdodCA9IGJvdW5kcy5oZWlnaHQgLSB0aGlzLmJlaGF2aW9yLmdldEZpeGVkUm93c01heEhlaWdodCgpIC0gMTU7IC8vNXB4IHBhZGRpbmcgYXQgYm90dG9tIGFuZCByaWdodCBzaWRlXG4gICAgICAgIHZhciBzY3JvbGxhYmxlV2lkdGggPSAoYm91bmRzLndpZHRoIC0gMjAwKSAtIHRoaXMuYmVoYXZpb3IuZ2V0Rml4ZWRDb2x1bW5zTWF4V2lkdGgoKSAtIDE1O1xuXG4gICAgICAgIHZhciBsYXN0UGFnZUNvbHVtbkNvdW50ID0gMDtcbiAgICAgICAgdmFyIGNvbHVtbnNXaWR0aCA9IDA7XG4gICAgICAgIGZvciAoOyBsYXN0UGFnZUNvbHVtbkNvdW50IDwgbnVtQ29sdW1uczsgbGFzdFBhZ2VDb2x1bW5Db3VudCsrKSB7XG4gICAgICAgICAgICB2YXIgZWFjaFdpZHRoID0gdGhpcy5nZXRDb2x1bW5XaWR0aChudW1Db2x1bW5zIC0gbGFzdFBhZ2VDb2x1bW5Db3VudCAtIDEpO1xuICAgICAgICAgICAgY29sdW1uc1dpZHRoICs9IGVhY2hXaWR0aDtcbiAgICAgICAgICAgIGlmIChjb2x1bW5zV2lkdGggPiBzY3JvbGxhYmxlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0UGFnZVJvd0NvdW50ID0gMDtcbiAgICAgICAgdmFyIHJvd3NIZWlnaHQgPSAwO1xuICAgICAgICBmb3IgKDsgbGFzdFBhZ2VSb3dDb3VudCA8IG51bVJvd3M7IGxhc3RQYWdlUm93Q291bnQrKykge1xuICAgICAgICAgICAgdmFyIGVhY2hIZWlnaHQgPSB0aGlzLmdldFJvd0hlaWdodChudW1Sb3dzIC0gbGFzdFBhZ2VSb3dDb3VudCAtIDEpO1xuICAgICAgICAgICAgcm93c0hlaWdodCArPSBlYWNoSGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHJvd3NIZWlnaHQgPiBzY3JvbGxhYmxlSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaE1heCA9IE1hdGgubWF4KDAsIG51bUNvbHVtbnMgLSBudW1GaXhlZENvbHVtbnMgLSBsYXN0UGFnZUNvbHVtbkNvdW50KTtcbiAgICAgICAgdGhpcy5zZXRIU2Nyb2xsYmFyVmFsdWVzKGhNYXgpO1xuXG4gICAgICAgIHZhciB2TWF4ID0gMSArIE1hdGgubWF4KDAsIG51bVJvd3MgLSBudW1GaXhlZFJvd3MgLSBsYXN0UGFnZVJvd0NvdW50KTtcbiAgICAgICAgdGhpcy5zZXRWU2Nyb2xsYmFyVmFsdWVzKHZNYXgpO1xuXG4gICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKE1hdGgubWluKHRoaXMuZ2V0SFNjcm9sbFZhbHVlKCksIGhNYXgpKTtcbiAgICAgICAgdGhpcy5zZXRWU2Nyb2xsVmFsdWUoTWF0aC5taW4odGhpcy5nZXRWU2Nyb2xsVmFsdWUoKSwgdk1heCkpO1xuXG4gICAgICAgIC8vdGhpcy5nZXRDYW52YXMoKS5yZXNpemUoKTtcbiAgICAgICAgdGhpcy5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG5cbiAgICAgICAgdGhpcy5yZXNpemVTY3JvbGxiYXJzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgTm90ZSB0aGF0IFwidmlld2FibGUgcm93c1wiIGluY2x1ZGVzIGFueSBwYXJ0aWFsbHkgdmlld2FibGUgcm93cy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHZpZXdhYmxlIHJvd3MuXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZVJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLmdldFZpc2libGVSb3dzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgTm90ZSB0aGF0IFwidmlld2FibGUgY29sdW1uc1wiIGluY2x1ZGVzIGFueSBwYXJ0aWFsbHkgdmlld2FibGUgY29sdW1ucy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHZpZXdhYmxlIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLmdldFZpc2libGVDb2x1bW5zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgSW5pdGlhbGl6ZSB0aGUgcmVuZGVyZXIgc3ViLWNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBpbml0UmVuZGVyZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtSZW5kZXJlcn0gc3ViLWNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldFJlbmRlcmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSBnaXZlbiBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gVGhlIHVudHJhbnNsYXRlZCBjb2x1bW4gaW5kZXguXG4gICAgICovXG4gICAgZ2V0Q29sdW1uV2lkdGg6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldENvbHVtbldpZHRoKGNvbHVtbkluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIHdpZHRoIG9mIHRoZSBnaXZlbiBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gVGhlIHVudHJhbnNsYXRlZCBjb2x1bW4gaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbldpZHRoIC0gVGhlIHdpZHRoIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBzZXRDb2x1bW5XaWR0aDogZnVuY3Rpb24oY29sdW1uSW5kZXgsIGNvbHVtbldpZHRoKSB7XG4gICAgICAgIHRoaXMuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRDb2x1bW5XaWR0aChjb2x1bW5JbmRleCwgY29sdW1uV2lkdGgpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5FZGdlOiBmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldENvbHVtbkVkZ2UoYywgdGhpcy5nZXRSZW5kZXJlcigpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdG90YWwgd2lkdGggb2YgYWxsIHRoZSBmaXhlZCBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uc1dpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Rml4ZWRDb2x1bW5zV2lkdGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSBnaXZlbiByb3dcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgdW50cmFuc2xhdGVkIGZpeGVkIGNvbHVtbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRSb3dIZWlnaHQ6IGZ1bmN0aW9uKHJvd0luZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFJvd0hlaWdodChyb3dJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBoZWlnaHQgb2YgdGhlIGdpdmVuIHJvdy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgcm93IGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dIZWlnaHQgLSBUaGUgd2lkdGggaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIHNldFJvd0hlaWdodDogZnVuY3Rpb24ocm93SW5kZXgsIHJvd0hlaWdodCkge1xuICAgICAgICB0aGlzLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0Um93SGVpZ2h0KHJvd0luZGV4LCByb3dIZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0b3RhbCBmaXhlZCByb3dzIGhlaWdodFxuICAgICAqL1xuICAgIGdldEZpeGVkUm93c0hlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEZpeGVkUm93c0hlaWdodCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgX3Zpc2libGVfIGNvbHVtbnMuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRBY3RpdmVDb2x1bW5Db3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgcm93cy5cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiB1bmZpbHRlcmVkIHJvd3MuXG4gICAgICovXG4gICAgZ2V0VW5maWx0ZXJlZFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0VW5maWx0ZXJlZFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBmaXhlZCBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBmaXhlZCByb3dzLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgVGhlIHRvcCBsZWZ0IGFyZWEgaGFzIGJlZW4gY2xpY2tlZCBvblxuICAgICAqIEBkZXNjIERlbGVnYXRlcyB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICB0b3BMZWZ0Q2xpY2tlZDogZnVuY3Rpb24obW91c2UpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci50b3BMZWZ0Q2xpY2tlZCh0aGlzLCBtb3VzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgQSBmaXhlZCByb3cgaGFzIGJlZW4gY2xpY2tlZC5cbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZXMgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGRldGFpbHMuXG4gICAgICovXG4gICAgcm93SGVhZGVyQ2xpY2tlZDogZnVuY3Rpb24obW91c2UpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5yb3dIZWFkZXJDbGlja2VkKHRoaXMsIG1vdXNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBBIGZpeGVkIGNvbHVtbiBoYXMgYmVlbiBjbGlja2VkLlxuICAgICAqIEBkZXNjIERlbGVnYXRlcyB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJDbGlja2VkOiBmdW5jdGlvbihtb3VzZSkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmNvbHVtbkhlYWRlckNsaWNrZWQodGhpcywgbW91c2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFuIGVkaXQgZXZlbnQgaGFzIG9jY3VycmVkLiBBY3RpdmF0ZSB0aGUgZWRpdG9yIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQuZ3JpZENlbGwueCAtIFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LmdyaWRDZWxsLnkgLSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtldmVudC5wcmltaXRpdmVFdmVudC50eXBlXVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8Q2VsbEVkaXRvcn0gVGhlIGVkaXRvciBvYmplY3Qgb3IgYHVuZGVmaW5lZGAgaWYgbm8gZWRpdG9yIG9yIGVkaXRvciBhbHJlYWR5IG9wZW4uXG4gICAgICovXG4gICAgb25FZGl0b3JBY3RpdmF0ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRBdChwb2ludCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBjZWxsIGVkaXRvci5cbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZXMgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBjZWxsIGVkaXRvciBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtQb2ludH0gZWRpdFBvaW50IC0gVGhlIGdyaWQgY2VsbCBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBnZXRDZWxsRWRpdG9yQXQ6IGZ1bmN0aW9uKGVkaXRQb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRDZWxsRWRpdG9yQXQoZWRpdFBvaW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBUb2dnbGUgSGlEUEkgc3VwcG9ydC5cbiAgICAgKiBAZGVzYyBIaURQSSBzdXBwb3J0IGlzIG5vdyAqb24qIGJ5IGRlZmF1bHQuXG4gICAgICogPiBUaGVyZSB1c2VkIHRvIGJlIGEgYnVnIGluIENocm9tZSB0aGF0IGNhdXNlZCBzZXZlcmUgc2xvdyBkb3duIG9uIGJpdCBibGl0IG9mIGxhcmdlIGltYWdlcywgc28gdGhpcyBIaURQSSBuZWVkZWQgdG8gYmUgb3B0aW9uYWwuXG4gICAgICovXG4gICAgdG9nZ2xlSGlEUEk6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy51c2VIaURQSSgpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnaGlkcGknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoaWRwaScsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FudmFzLnJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRlIEhpRFBJIHJhdGlvLlxuICAgICAqL1xuICAgIGdldEhpRFBJOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICYmIHRoaXMudXNlSGlEUEkoKSkge1xuICAgICAgICAgICAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICAgICAgdmFyIGJhY2tpbmdTdG9yZVJhdGlvID0gY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gICAgICAgICAgICB2YXIgcmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgICAgICAgICByZXR1cm4gcmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgZ2l2ZW4gKHJlY2VudGx5IHJlbmRlcmVkKSBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4IC0gVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZFdpZHRoOiBmdW5jdGlvbihjb2xJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRSZW5kZXJlZFdpZHRoKGNvbEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSBnaXZlbiAocmVjZW50bHkgcmVuZGVyZWQpIHJvdy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUdGhlIHJvdyBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZEhlaWdodDogZnVuY3Rpb24ocm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0UmVuZGVyZWRIZWlnaHQocm93SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFVwZGF0ZSB0aGUgY3Vyc29yIHVuZGVyIHRoZSBob3ZlciBjZWxsLlxuICAgICAqL1xuICAgIHVwZGF0ZUN1cnNvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmJlaGF2aW9yLmdldEN1cnNvckF0KC0xLCAtMSk7XG4gICAgICAgIHZhciBob3ZlckNlbGwgPSB0aGlzLmdldEhvdmVyQ2VsbCgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBob3ZlckNlbGwgJiZcbiAgICAgICAgICAgIGhvdmVyQ2VsbC54ID4gLTEgJiZcbiAgICAgICAgICAgIGhvdmVyQ2VsbC55ID4gLTFcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGhvdmVyQ2VsbC54ICsgdGhpcy5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgICAgIGN1cnNvciA9IHRoaXMuYmVoYXZpb3IuZ2V0Q3Vyc29yQXQoeCwgaG92ZXJDZWxsLnkgKyB0aGlzLmdldFZTY3JvbGxWYWx1ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlQ3Vyc29yKGN1cnNvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVwYWludCB0aGUgZ2l2ZW4gY2VsbC5cbiAgICAgKiBAcGFyYW0ge3h9IHggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7eX0geSAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIHJlcGFpbnRDZWxsOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHRoaXMuZ2V0UmVuZGVyZXIoKS5yZXBhaW50Q2VsbCh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIHVzZXIgaXMgY3VycmVudGx5IGRyYWdnaW5nIGEgY29sdW1uIHRvIHJlb3JkZXIgaXQuXG4gICAgICovXG4gICAgaXNEcmFnZ2luZ0NvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTY3JvbGwgdXAgb25lIGZ1bGwgcGFnZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHBhZ2VVcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByb3dOdW0gPSB0aGlzLmdldFJlbmRlcmVyKCkuZ2V0UGFnZVVwUm93KCk7XG4gICAgICAgIHRoaXMuc2V0VlNjcm9sbFZhbHVlKHJvd051bSk7XG4gICAgICAgIHJldHVybiByb3dOdW07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2Nyb2xsIGRvd24gb25lIGZ1bGwgcGFnZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHBhZ2VEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJvd051bSA9IHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRQYWdlRG93blJvdygpO1xuICAgICAgICB0aGlzLnNldFZTY3JvbGxWYWx1ZShyb3dOdW0pO1xuICAgICAgICByZXR1cm4gcm93TnVtO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIE5vdCB5ZXQgaW1wbGVtZW50ZWQuXG4gICAgICovXG4gICAgcGFnZUxlZnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZygncGFnZSBsZWZ0Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgTm90IHlldCBpbXBsZW1lbnRlZC5cbiAgICAgKi9cbiAgICBwYWdlUmlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZygncGFnZSByaWdodCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX0gT2JqZWN0cyB3aXRoIHRoZSB2YWx1ZXMgdGhhdCB3ZXJlIGp1c3QgcmVuZGVyZWQuXG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYXNzdW1lcyBvbmUgcm93IG9mIGhlYWRlcnNcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5iZWhhdmlvcixcbiAgICAgICAgICAgIHJlbmRlcmVyID0gdGhpcy5nZXRSZW5kZXJlcigpLFxuICAgICAgICAgICAgY29sQ291bnQgPSB0aGlzLmdldENvbHVtbkNvdW50KCksXG4gICAgICAgICAgICByb3dDb3VudCA9IHJlbmRlcmVyLmdldFZpc2libGVSb3dzKCksXG4gICAgICAgICAgICBoZWFkZXJzID0gbmV3IEFycmF5KGNvbENvdW50KSxcbiAgICAgICAgICAgIHJlc3VsdHMgPSBuZXcgQXJyYXkocm93Q291bnQpLFxuICAgICAgICAgICAgcm93O1xuXG4gICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIsIGMpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbY10gPSBiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oYykuaGVhZGVyO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24ocmVzdWx0LCByKSB7XG4gICAgICAgICAgICByb3cgPSByZXN1bHRzW3JdID0ge1xuICAgICAgICAgICAgICAgIGhpZXJhcmNoeTogYmVoYXZpb3IuZ2V0Rml4ZWRDb2x1bW5WYWx1ZSgwLCByKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgYykge1xuICAgICAgICAgICAgICAgIHJvd1tmaWVsZF0gPSBiZWhhdmlvci5nZXRWYWx1ZShjLCByKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50bHkgc2VsZWN0aW9uIHJvdy5cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxzID0gdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmIChzZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5iZWhhdmlvcixcbiAgICAgICAgICAgICAgICBjb2xDb3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgICAgICB0b3BSb3cgPSBzZWxzWzBdLm9yaWdpbi55LFxuICAgICAgICAgICAgICAgIHJvdyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy9oaWVyYXJjaHk6IGJlaGF2aW9yLmdldEZpeGVkQ29sdW1uVmFsdWUoMCwgdG9wUm93KVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29sQ291bnQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHJvd1tiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oYykuaGVhZGVyXSA9IGJlaGF2aW9yLmdldFZhbHVlKGMsIHRvcFJvdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmlyZVJlcXVlc3RDZWxsRWRpdDogZnVuY3Rpb24oY2VsbCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1yZXF1ZXN0LWNlbGwtZWRpdCcsIHtcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7IC8vSSB3YXNuJ3QgY2FuY2VsbGVkXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBmaW4tYmVmb3JlLWNlbGwtZWRpdCBldmVudC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHgseSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSBUaGUgY3VycmVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmaXJlQmVmb3JlQ2VsbEVkaXQ6IGZ1bmN0aW9uKGNlbGwsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgY29udHJvbCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWJlZm9yZS1jZWxsLWVkaXQnLCB7XG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICBncmlkQ2VsbDogY2VsbCxcbiAgICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIGlucHV0OiBjb250cm9sLFxuICAgICAgICAgICAgICAgIHJvdzogdGhpcy5nZXRSb3coY2VsbC55KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHByb2NlZWQgPSB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgICAgICByZXR1cm4gcHJvY2VlZDsgLy9JIHdhc24ndCBjYW5jZWxsZWRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IHN1Yi1jb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHgseSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWUgLSBUaGUgb2xkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZSAtIFRoZSBuZXcgdmFsdWUuXG4gICAgICovXG4gICAgZmlyZUFmdGVyQ2VsbEVkaXQ6IGZ1bmN0aW9uKGNlbGwsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgY29udHJvbCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWFmdGVyLWNlbGwtZWRpdCcsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICBpbnB1dDogY29udHJvbCxcbiAgICAgICAgICAgICAgICByb3c6IHRoaXMuZ2V0Um93KGNlbGwueSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgQXV0b3NpemUgdGhlIGNvbHVtbiBhdCBjb2xJbmRleCBmb3IgYmVzdCBmaXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCB0byBtb2RpZnkgYXRcbiAgICAgKi9cbiAgICBhdXRvc2l6ZUNvbHVtbjogZnVuY3Rpb24oYWN0aXZlQ29sdW1uSW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuYmVoYXZpb3IuZ2V0QWN0aXZlQ29sdW1uKGFjdGl2ZUNvbHVtbkluZGV4KTtcbiAgICAgICAgY29sdW1uLmNoZWNrQ29sdW1uQXV0b3NpemluZyh0cnVlKTtcbiAgICAgICAgdGhpcy5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBFbmFibGUvZGlzYWJsZSBpZiB0aGlzIGNvbXBvbmVudCBjYW4gcmVjZWl2ZSB0aGUgZm9jdXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSAtIGNhblJlY2VpdmVGb2N1c1xuICAgICAqL1xuICAgIHNldEZvY3VzYWJsZTogZnVuY3Rpb24oY2FuUmVjZWl2ZUZvY3VzKSB7XG4gICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuc2V0Rm9jdXNhYmxlKGNhblJlY2VpdmVGb2N1cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBjb2x1bW5zIHRoYXQgd2VyZSBqdXN0IHJlbmRlcmVkXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnNDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVyKCkuZ2V0VmlzaWJsZUNvbHVtbnNDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygcm93cyB0aGF0IHdlcmUganVzdCByZW5kZXJlZFxuICAgICAqL1xuICAgIGdldFZpc2libGVSb3dzQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLmdldFZpc2libGVSb3dzQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICB1cGRhdGUgdGhlIHNpemUgb2YgdGhlIGdyaWRcbiAgICAgKlxuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIHVwZGF0ZVNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5jaGVja3NpemUoKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN0b3AgdGhlIGdsb2JhbCByZXBhaW50aW5nIGZsYWcgdGhyZWFkLlxuICAgICAqL1xuICAgIHN0b3BQYWludFRocmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0b3BQYWludFRocmVhZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN0b3AgdGhlIGdsb2JhbCByZXNpemUgY2hlY2sgZmxhZyB0aHJlYWQuXG4gICAgICovXG4gICAgc3RvcFJlc2l6ZVRocmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0b3BSZXNpemVUaHJlYWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXN0YXJ0IHRoZSBnbG9iYWwgcmVzaXplIGNoZWNrIGZsYWcgdGhyZWFkLlxuICAgICAqL1xuICAgIHJlc3RhcnRSZXNpemVUaHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5yZXN0YXJ0UmVzaXplVGhyZWFkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVzdGFydCB0aGUgZ2xvYmFsIHJlcGFpbnRpbmcgY2hlY2sgZmxhZyB0aHJlYWQuXG4gICAgICovXG4gICAgcmVzdGFydFBhaW50VGhyZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMucmVzdGFydFBhaW50VGhyZWFkKCk7XG4gICAgfSxcblxuICAgIHN3YXBDb2x1bW5zOiBmdW5jdGlvbihzb3VyY2UsIHRhcmdldCkge1xuICAgICAgICAvL1R1cm5zIG91dCB0aGlzIGlzIGNhbGxlZCBkdXJpbmcgZHJhZ2dlZCAnaS5lJyB3aGVuIHRoZSBmbG9hdGVyIGNvbHVtbiBpcyByZXNodWZmbGVkXG4gICAgICAgIC8vYnkgdGhlIGN1cnJlbnRseSBkcmFnZ2VkIGNvbHVtbi4gVGhlIGNvbHVtbiBwb3NpdGlvbnMgYXJlIGNvbnN0YW50bHkgcmVzaHVmZmxlZFxuICAgICAgICB0aGlzLmJlaGF2aW9yLnN3YXBDb2x1bW5zKHNvdXJjZSwgdGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgZW5kRHJhZ0NvbHVtbk5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuZW5kRHJhZ0NvbHVtbk5vdGlmaWNhdGlvbigpO1xuICAgIH0sXG5cbiAgICBnZXRGaXhlZENvbHVtbnNNYXhXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEZpeGVkQ29sdW1uc01heFdpZHRoKCk7XG4gICAgfSxcblxuICAgIGlzTW91c2VEb3duSW5IZWFkZXJBcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG51bUhlYWRlckNvbHVtbnMgPSB0aGlzLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBudW1IZWFkZXJSb3dzID0gdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgbW91c2VEb3duID0gdGhpcy5nZXRNb3VzZURvd24oKTtcbiAgICAgICAgcmV0dXJuIG1vdXNlRG93bi54IDwgbnVtSGVhZGVyQ29sdW1ucyB8fCBtb3VzZURvd24ueSA8IG51bUhlYWRlclJvd3M7XG4gICAgfSxcblxuICAgIGlzSGVhZGVyV3JhcHBpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2hlYWRlclRleHRXcmFwcGluZycpO1xuICAgIH0sXG5cbiAgICBfZ2V0Qm91bmRzT2ZDZWxsOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVyKCkuX2dldEJvdW5kc09mQ2VsbCh4LCB5KTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uUHJvcGVydGllczogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Q29sdW1uUHJvcGVydGllcyhjb2x1bW5JbmRleCk7XG4gICAgfSxcblxuICAgIHNldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKGNvbHVtbkluZGV4LCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0Q29sdW1uUHJvcGVydGllcyhjb2x1bW5JbmRleCwgcHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIG1vdmVTaW5nbGVTZWxlY3Q6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5tb3ZlU2luZ2xlU2VsZWN0KHRoaXMsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RDZWxsOiBmdW5jdGlvbih4LCB5LCBzaWxlbnQpIHtcbiAgICAgICAgdmFyIGRvbnRDbGVhclJvd3MgPSB0aGlzLmlzQ2hlY2tib3hPbmx5Um93U2VsZWN0aW9ucygpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyKGRvbnRDbGVhclJvd3MpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLnNlbGVjdCh4LCB5LCAwLCAwLCBzaWxlbnQpO1xuICAgIH0sXG5cbiAgICBnZXRIZWFkZXJDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIHRvZ2dsZVNvcnQ6IGZ1bmN0aW9uKHgsIGtleXMpIHtcbiAgICAgICAgdGhpcy5zdG9wRWRpdGluZygpO1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmJlaGF2aW9yO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGJlaGF2aW9yLnRvZ2dsZVNvcnQoeCwga2V5cyk7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuc3luY2hyb25pemVTY3JvbGxpbmdCb3VuZHJpZXMoKTtcbiAgICAgICAgICAgIC8vc2VsZi5iZWhhdmlvckNoYW5nZWQoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmlzQ29sdW1uQXV0b3NpemluZygpKSB7XG4gICAgICAgICAgICAgICAgYmVoYXZpb3IuYXV0b3NpemVBbGxDb2x1bW5zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnJlcGFpbnQoKTtcbiAgICAgICAgfSwgMTApO1xuICAgIH0sXG5cbiAgICB0b2dnbGVTZWxlY3RDb2x1bW46IGZ1bmN0aW9uKHgsIGtleXMpIHtcbiAgICAgICAga2V5cyA9IGtleXMgfHwgW107XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIHZhciBhbHJlYWR5U2VsZWN0ZWQgPSBtb2RlbC5pc0NvbHVtblNlbGVjdGVkKHgpO1xuICAgICAgICB2YXIgaGFzQ1RSTCA9IGtleXMuaW5kZXhPZignQ1RSTCcpID4gLTE7XG4gICAgICAgIHZhciBoYXNTSElGVCA9IGtleXMuaW5kZXhPZignU0hJRlQnKSA+IC0xO1xuICAgICAgICBpZiAoIWhhc0NUUkwgJiYgIWhhc1NISUZUKSB7XG4gICAgICAgICAgICBtb2RlbC5jbGVhcigpO1xuICAgICAgICAgICAgaWYgKCFhbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5zZWxlY3RDb2x1bW4oeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzQ1RSTCkge1xuICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGVzZWxlY3RDb2x1bW4oeCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc2VsZWN0Q29sdW1uKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNTSElGVCkge1xuICAgICAgICAgICAgICAgIG1vZGVsLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgbW9kZWwuc2VsZWN0Q29sdW1uKHRoaXMubGFzdEVkZ2VTZWxlY3Rpb25bMF0sIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYWxyZWFkeVNlbGVjdGVkICYmICFoYXNTSElGVCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0RWRnZVNlbGVjdGlvblswXSA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0NvbHVtblNlbGVjdGlvbkNoYW5nZWRFdmVudCgpO1xuICAgIH0sXG5cbiAgICB0b2dnbGVTZWxlY3RSb3c6IGZ1bmN0aW9uKHksIGtleXMpIHtcbiAgICAgICAgLy93ZSBjYW4gc2VsZWN0IHRoZSB0b3RhbHMgcm93cyBpZiB0aGV5IGV4aXN0LCBidXQgbm90IHJvd3MgYWJvdmUgdGhhdFxuICAgICAgICBpZiAoeSA+IHRoaXMuZ2V0RmlsdGVyUm93SW5kZXgoKSkge1xuICAgICAgICAgICAga2V5cyA9IGtleXMgfHwgW107XG5cbiAgICAgICAgICAgIHZhciBzbSA9IHRoaXMuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgICAgICB2YXIgYWxyZWFkeVNlbGVjdGVkID0gc20uaXNSb3dTZWxlY3RlZCh5KTtcbiAgICAgICAgICAgIHZhciBoYXNTSElGVCA9IGtleXMuaW5kZXhPZignU0hJRlQnKSA+PSAwO1xuXG4gICAgICAgICAgICBpZiAoYWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgc20uZGVzZWxlY3RSb3coeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2luZ2xlU2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgc20uc2VsZWN0Um93KHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFzU0hJRlQpIHtcbiAgICAgICAgICAgICAgICBzbS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHNtLnNlbGVjdFJvdyh0aGlzLmxhc3RFZGdlU2VsZWN0aW9uWzFdLCB5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFhbHJlYWR5U2VsZWN0ZWQgJiYgIWhhc1NISUZUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0RWRnZVNlbGVjdGlvblsxXSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzaW5nbGVTZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXNDaGVja2JveE9ubHlSb3dTZWxlY3Rpb25zID0gdGhpcy5pc0NoZWNrYm94T25seVJvd1NlbGVjdGlvbnMoKSxcbiAgICAgICAgICAgIGlzU2luZ2xlUm93U2VsZWN0aW9uTW9kZSA9IHRoaXMuaXNTaW5nbGVSb3dTZWxlY3Rpb25Nb2RlKCksXG4gICAgICAgICAgICBoYXNDVFJMID0gZmFsc2UsXG4gICAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgICAgaWYgKHRoaXMubW91c2VEb3duU3RhdGUpe1xuICAgICAgICAgICAgLy90cmlnZ2VyZWQgcHJvZ3JhbW1hdGljYWxseVxuICAgICAgICAgICAgaGFzQ1RSTCA9IHRoaXMubW91c2VEb3duU3RhdGUucHJpbWl0aXZlRXZlbnQuZGV0YWlsLnByaW1pdGl2ZUV2ZW50LmN0cmxLZXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSAoXG4gICAgICAgICAgICBpc0NoZWNrYm94T25seVJvd1NlbGVjdGlvbnMgJiYgaXNTaW5nbGVSb3dTZWxlY3Rpb25Nb2RlIHx8XG4gICAgICAgICAgICAhaXNDaGVja2JveE9ubHlSb3dTZWxlY3Rpb25zICYmICghaGFzQ1RSTCB8fCBpc1NpbmdsZVJvd1NlbGVjdGlvbk1vZGUpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhclJvd1NlbGVjdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgc2VsZWN0Vmlld3BvcnRDZWxsOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5nZXRSZW5kZXJlcigpO1xuICAgICAgICB2YXIgcmVhbFggPSByZW5kZXJlci5nZXRWaXNpYmxlQ29sdW1ucygpW3hdO1xuICAgICAgICB2YXIgcmVhbFkgPSByZW5kZXJlci5nZXRWaXNpYmxlUm93cygpW3ldO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICB0aGlzLnNlbGVjdChyZWFsWCwgcmVhbFkgKyBoZWFkZXJSb3dDb3VudCwgMCwgMCk7XG4gICAgICAgIHRoaXMuc2V0TW91c2VEb3duKHRoaXMubmV3UG9pbnQocmVhbFgsIHJlYWxZICsgaGVhZGVyUm93Q291bnQpKTtcbiAgICAgICAgdGhpcy5zZXREcmFnRXh0ZW50KHRoaXMubmV3UG9pbnQoMCwgMCkpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0VG9WaWV3cG9ydENlbGw6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbnMgJiYgc2VsZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgICAgIHZhciByZWFsWCA9IHJlbmRlcmVyLmdldFZpc2libGVDb2x1bW5zKClbeF07XG4gICAgICAgICAgICB2YXIgcmVhbFkgPSByZW5kZXJlci5nZXRWaXNpYmxlUm93cygpW3ldICsgaGVhZGVyUm93Q291bnQ7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc2VsZWN0aW9uc1swXTtcbiAgICAgICAgICAgIHZhciBvcmlnaW4gPSBzZWxlY3Rpb24ub3JpZ2luO1xuICAgICAgICAgICAgdGhpcy5zZXREcmFnRXh0ZW50KHRoaXMubmV3UG9pbnQocmVhbFggLSBvcmlnaW4ueCwgcmVhbFkgLSBvcmlnaW4ueSkpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Qob3JpZ2luLngsIG9yaWdpbi55LCByZWFsWCAtIG9yaWdpbi54LCByZWFsWSAtIG9yaWdpbi55KTtcbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlbGVjdEZpbmFsQ2VsbE9mQ3VycmVudFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpIC0gMTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLmdldFNlbGVjdGVkUm93cygpWzBdO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSB0aGlzLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsQnkodGhpcy5nZXRDb2x1bW5Db3VudCgpLCAwKTtcbiAgICAgICAgdGhpcy5zZWxlY3QoeCwgeSArIGhlYWRlclJvd0NvdW50LCAwLCAwKTtcbiAgICAgICAgdGhpcy5zZXRNb3VzZURvd24odGhpcy5uZXdQb2ludCh4LCB5ICsgaGVhZGVyUm93Q291bnQpKTtcbiAgICAgICAgdGhpcy5zZXREcmFnRXh0ZW50KHRoaXMubmV3UG9pbnQoMCwgMCkpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0VG9GaW5hbENlbGxPZkN1cnJlbnRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICBpZiAoc2VsZWN0aW9ucyAmJiBzZWxlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGlvbnNbMF07XG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gc2VsZWN0aW9uLm9yaWdpbjtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSBzZWxlY3Rpb24uZXh0ZW50O1xuICAgICAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCeShjb2x1bW5Db3VudCwgMCk7XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChvcmlnaW4ueCwgb3JpZ2luLnksIGNvbHVtbkNvdW50IC0gb3JpZ2luLnggLSAxLCBleHRlbnQueSk7XG5cbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlbGVjdEZpcnN0Q2VsbE9mQ3VycmVudFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgdmFyIHkgPSB0aGlzLmdldFNlbGVjdGVkUm93cygpWzBdO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSB0aGlzLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKDApO1xuICAgICAgICB0aGlzLnNlbGVjdCh4LCB5ICsgaGVhZGVyUm93Q291bnQsIDAsIDApO1xuICAgICAgICB0aGlzLnNldE1vdXNlRG93bih0aGlzLm5ld1BvaW50KHgsIHkgKyBoZWFkZXJSb3dDb3VudCkpO1xuICAgICAgICB0aGlzLnNldERyYWdFeHRlbnQodGhpcy5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RUb0ZpcnN0Q2VsbE9mQ3VycmVudFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb25zICYmIHNlbGVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc2VsZWN0aW9uc1swXTtcbiAgICAgICAgICAgIHZhciBvcmlnaW4gPSBzZWxlY3Rpb24ub3JpZ2luO1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHNlbGVjdGlvbi5leHRlbnQ7XG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Qob3JpZ2luLngsIG9yaWdpbi55LCAtb3JpZ2luLngsIGV4dGVudC55KTtcbiAgICAgICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKDApO1xuICAgICAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VsZWN0RmluYWxDZWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RDZWxsKHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDEsIHRoaXMuZ2V0Um93Q291bnQoKSAtIDEpO1xuICAgICAgICB0aGlzLnNjcm9sbEJ5KHRoaXMuZ2V0Q29sdW1uQ291bnQoKSwgdGhpcy5nZXRSb3dDb3VudCgpKTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIHNlbGVjdFRvRmluYWxDZWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbnMgJiYgc2VsZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzZWxlY3Rpb25zWzBdO1xuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHNlbGVjdGlvbi5vcmlnaW47XG4gICAgICAgICAgICB2YXIgY29sdW1uQ291bnQgPSB0aGlzLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgICAgICB2YXIgcm93Q291bnQgPSB0aGlzLmdldFJvd0NvdW50KCk7XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChvcmlnaW4ueCwgb3JpZ2luLnksIGNvbHVtbkNvdW50IC0gb3JpZ2luLnggLSAxLCByb3dDb3VudCAtIG9yaWdpbi55IC0gMSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJ5KGNvbHVtbkNvdW50LCByb3dDb3VudCk7XG4gICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpc1Nob3dSb3dOdW1iZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdzaG93Um93TnVtYmVycycpO1xuICAgIH0sXG4gICAgaXNFZGl0YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnZWRpdGFibGUnKSA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIGlzU2hvd0ZpbHRlclJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnc2hvd0ZpbHRlclJvdycpO1xuICAgIH0sXG4gICAgaXNTaG93SGVhZGVyUm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdzaG93SGVhZGVyUm93Jyk7XG4gICAgfSxcbiAgICBnZXRIZWFkZXJSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgfSxcbiAgICBpc0ZpbHRlclJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4geSA9PT0gdGhpcy5nZXRGaWx0ZXJSb3dJbmRleCgpO1xuICAgIH0sXG4gICAgZ2V0RmlsdGVyUm93SW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNTaG93RmlsdGVyUm93KCkgPyAtMSA6IHRoaXMuaXNTaG93SGVhZGVyUm93KCkgPyAxIDogMDtcbiAgICB9LFxuICAgIHNldEdyb3VwczogZnVuY3Rpb24oYXJyYXlPZkNvbHVtbkluZGV4ZXMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRHcm91cHMoYXJyYXlPZkNvbHVtbkluZGV4ZXMpO1xuICAgIH0sXG4gICAgaGFzSGllcmFyY2h5Q29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuaGFzSGllcmFyY2h5Q29sdW1uKCk7XG4gICAgfSxcbiAgICBpc0hpZXJhcmNoeUNvbHVtbjogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWVyYXJjaHlDb2x1bW4oKSAmJiB4ID09PSAwO1xuICAgIH0sXG4gICAgY2hlY2tTY3JvbGxiYXJWaXNpYmlsaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gdmFyIGhvdmVyQ2xhc3NPdmVyID0gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGJhckhvdmVyT3ZlcicpO1xuICAgICAgICAvLyB2YXIgaG92ZXJDbGFzc09mZiA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxiYXJIb3Zlck9mZicpO1xuXG4gICAgICAgIC8vIGlmIChob3ZlckNsYXNzT2ZmID09PSAndmlzaWJsZScpIHtcbiAgICAgICAgLy8gICAgIHRoaXMuc2JIU2Nyb2xsZXIuY2xhc3NMaXN0LnJlbW92ZShob3ZlckNsYXNzT3Zlcik7XG4gICAgICAgIC8vICAgICB0aGlzLnNiVlNjcm9sbGVyLmNsYXNzTGlzdC5yZW1vdmUoaG92ZXJDbGFzc09mZik7XG4gICAgICAgIC8vICAgICB0aGlzLnNiSFNjcm9sbGVyLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgLy8gICAgIHRoaXMuc2JWU2Nyb2xsZXIuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuICAgICAgICAvLyB9XG4gICAgfSxcbiAgICBpc0NvbHVtbk9yUm93U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5pc0NvbHVtbk9yUm93U2VsZWN0ZWQoKTtcbiAgICB9LFxuICAgIHNlbGVjdENvbHVtbjogZnVuY3Rpb24oeDEsIHgyKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0Q29sdW1uKHgxLCB4Mik7XG4gICAgfSxcbiAgICBzZWxlY3RSb3c6IGZ1bmN0aW9uKHkxLCB5Mikge1xuICAgICAgICB2YXIgc20gPSB0aGlzLnNlbGVjdGlvbk1vZGVsO1xuICAgICAgICB2YXIgc2VsZWN0aW9uRWRnZSA9IHRoaXMuZ2V0RmlsdGVyUm93SW5kZXgoKSArIDE7XG5cbiAgICAgICAgaWYgKHRoaXMuc2luZ2xlU2VsZWN0KCkpIHtcbiAgICAgICAgICAgIHkxID0geTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBtdWx0aXBsZSByb3cgc2VsZWN0aW9uXG4gICAgICAgICAgICB5MiA9IHkyIHx8IHkxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbih5MSwgeTIpO1xuICAgICAgICBpZiAobWluID49IHNlbGVjdGlvbkVkZ2UpIHtcbiAgICAgICAgICAgIHZhciBtYXggPSBNYXRoLm1heCh5MSwgeTIpO1xuICAgICAgICAgICAgc20uc2VsZWN0Um93KG1pbiwgbWF4KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaXNSb3dOdW1iZXJBdXRvc2l6aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdyb3dOdW1iZXJBdXRvc2l6aW5nJyk7XG4gICAgfSxcbiAgICBpc1Jvd1NlbGVjdGVkOiBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmlzUm93U2VsZWN0ZWQocik7XG4gICAgfSxcbiAgICBpc0NvbHVtblNlbGVjdGVkOiBmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmlzQ29sdW1uU2VsZWN0ZWQoYyk7XG4gICAgfSxcbiAgICBsb29rdXBGZWF0dXJlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IubG9va3VwRmVhdHVyZShrZXkpO1xuICAgIH0sXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFJvdyh5KTtcbiAgICB9LFxuICAgIGlzQ2VsbFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnY2VsbFNlbGVjdGlvbicpID09PSB0cnVlO1xuICAgIH0sXG4gICAgaXNSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ3Jvd1NlbGVjdGlvbicpID09PSB0cnVlO1xuICAgIH0sXG4gICAgaXNDb2x1bW5TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2NvbHVtblNlbGVjdGlvbicpID09PSB0cnVlO1xuICAgIH0sXG4gICAgZ2V0Q29tcHV0ZWRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Q29tcHV0ZWRSb3coeSk7XG4gICAgfSxcbiAgICBpc0NvbHVtbkF1dG9zaXppbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2NvbHVtbkF1dG9zaXppbmcnKSA9PT0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBmaWx0ZXIgYXR0YWNoZWQgdG8gdGhlIEh5cGVyZ3JpZC5cbiAgICAgKiBAcmV0dXJucyB7RmlsdGVyVHJlZX1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldEdsb2JhbEZpbHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEdsb2JhbEZpbHRlcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBdHRhY2gvZGV0YWNoIGEgZmlsdGVyIHRvIGEgSHlwZXJncmlkLlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZX0gW2ZpbHRlcl0gLSBUaGUgZmlsdGVyIG9iamVjdC4gSWYgdW5kZWZpbmVkLCBhbnkgYXR0YWNoZWQgZmlsdGVyIGlzIHJlbW92ZWQuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRHbG9iYWxGaWx0ZXI6IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLnNldEdsb2JhbEZpbHRlcihmaWx0ZXIpO1xuICAgICAgICB0aGlzLmJlaGF2aW9yQ2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZXQgdGhlIGNhc2Ugc2Vuc2l0aXZpdHkgb2YgZmlsdGVyIHRlc3RzIGFnYWluc3QgZGF0YS5cbiAgICAgKiBAZGVzYyBDYXNlIHNlbnNpdGl2aXR5IHBlcnRhaW5zIHRvIHN0cmluZyBjb21wYXJlcyBvbmx5LiBUaGlzIGluY2x1ZGVzIHVudHlwZWQgY29sdW1ucywgY29sdW1ucyB0eXBlZCBhcyBzdHJpbmdzLCB0eXBlZCBjb2x1bW5zIGNvbnRhaW5pbmcgZGF0YSB0aGF0IGNhbm5vdCBiZSBjb2VyY2VkIHRvIHR5cGUgb3Igd2hlbiB0aGUgZmlsdGVyIGV4cHJlc3Npb24gb3BlcmFuZCBjYW5ub3QgYmUgY29lcmNlZC5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgYSBzaGFyZWQgcHJvcGVydHkgYW5kIGFmZmVjdHMgYWxsIGdyaWQgbWFuYWdlZCBieSB0aGlzIGluc3RhbmNlIG9mIHRoZSBhcHAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1NlbnNpdGl2ZVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0R2xvYmFsRmlsdGVyQ2FzZVNlbnNpdGl2aXR5OiBmdW5jdGlvbihpc1NlbnNpdGl2ZSkge1xuICAgICAgICAvLyB0aGlzIHNldHRpbmcgYWZmZWN0cyBhbGwgZ3JpZHNcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRHbG9iYWxGaWx0ZXJDYXNlU2Vuc2l0aXZpdHkoaXNTZW5zaXRpdmUpO1xuICAgICAgICB0aGlzLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuICAgICAgICB0aGlzLmJlaGF2aW9yQ2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGNvbHVtbkluZGV4T3JOYW1lIC0gVGhlIF9jb2x1bW4gZmlsdGVyXyB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlR2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIHtAbGluayBEZWZhdWx0RmlsdGVyI2dldFN0YXRlfGdldFN0YXRlfSBtZXRob2QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zeW50YXg9J0NRTCddIC0gVGhlIHN5bnRheCB0byB1c2UgdG8gZGVzY3JpYmUgdGhlIGZpbHRlciBzdGF0ZS4gTm90ZSB0aGF0IGBnZXRGaWx0ZXJgJ3MgZGVmYXVsdCBzeW50YXgsIGAnQ1FMJ2AsIGRpZmZlcnMgZnJvbSB0aGUgb3RoZXIgZ2V0IHN0YXRlIG1ldGhvZHMuXG4gICAgICogQHJldHVybnMge0ZpbHRlclRyZWVTdGF0ZU9iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldEZpbHRlcjogZnVuY3Rpb24oY29sdW1uSW5kZXhPck5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0RmlsdGVyKGNvbHVtbkluZGV4T3JOYW1lLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2V0IGEgcGFydGljdWxhciBjb2x1bW4gZmlsdGVyJ3Mgc3RhdGUuXG4gICAgICogQGRlc2MgQWZ0ZXIgc2V0dGluZyB0aGUgbmV3IGZpbHRlciBzdGF0ZTpcbiAgICAgKiAqIFJlYXBwbGllcyB0aGUgZmlsdGVyIHRvIHRoZSBkYXRhIHNvdXJjZS5cbiAgICAgKiAqIENhbGxzIGBiZWhhdmlvckNoYW5nZWQoKWAgdG8gdXBkYXRlIHRoZSBncmlkIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGNvbHVtbkluZGV4T3JOYW1lIC0gVGhlIF9jb2x1bW4gZmlsdGVyXyB0byBzZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBbc3RhdGVdIC0gQSBmaWx0ZXIgdHJlZSBvYmplY3Qgb3IgYSBKU09OLCBTUUwsIG9yIENRTCBzdWJleHByZXNzaW9uIHN0cmluZyB0aGF0IGRlc2NyaWJlcyB0aGUgYSBuZXcgc3RhdGUgZm9yIHRoZSBuYW1lZCBjb2x1bW4gZmlsdGVyLiBUaGUgZXhpc3RpbmcgY29sdW1uIGZpbHRlciBzdWJleHByZXNzaW9uIGlzIHJlcGxhY2VkIHdpdGggYSBuZXcgbm9kZSBiYXNlZCBvbiB0aGlzIHN0YXRlLiBJZiBpdCBkb2VzIG5vdCBleGlzdCwgdGhlIG5ldyBzdWJleHByZXNzaW9uIGlzIGFkZGVkIHRvIHRoZSBjb2x1bW4gZmlsdGVycyBzdWJ0cmVlIChgZmlsdGVyLmNvbHVtbkZpbHRlcnNgKS5cbiAgICAgKlxuICAgICAqIElmIHVuZGVmaW5lZCwgcmVtb3ZlcyB0aGUgZW50aXJlIGNvbHVtbiBmaWx0ZXIgc3ViZXhwcmVzc2lvbiBmcm9tIHRoZSBjb2x1bW4gZmlsdGVycyBzdWJ0cmVlLlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVNldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyBbc2V0U3RhdGVde0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL0ZpbHRlclRyZWUuaHRtbCNzZXRTdGF0ZX0gbWV0aG9kLiBZb3UgbWF5IG1peCBpbiBtZW1iZXJzIG9mIHRoZSB7QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvZ2xvYmFsLmh0bWwjRmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fEZpbHRlclRyZWVWYWxpZGF0aW9uT3B0aW9uc09iamVjdH1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3ludGF4PSdDUUwnXSAtIFRoZSBzeW50YXggdG8gdXNlIHRvIGRlc2NyaWJlIHRoZSBmaWx0ZXIgc3RhdGUuIE5vdGUgdGhhdCBgc2V0RmlsdGVyYCdzIGRlZmF1bHQgc3ludGF4LCBgJ0NRTCdgLCBkaWZmZXJzIGZyb20gdGhlIG90aGVyIGdldCBzdGF0ZSBtZXRob2RzLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8RXJyb3J8c3RyaW5nfSBgdW5kZWZpbmVkYCBpbmRpY2F0ZXMgc3VjY2Vzcy5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldEZpbHRlcjogZnVuY3Rpb24oY29sdW1uSW5kZXhPck5hbWUsIHN0YXRlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5oaWRlRWRpdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRGaWx0ZXIoY29sdW1uSW5kZXhPck5hbWUsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvckNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlR2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIHtAbGluayBEZWZhdWx0RmlsdGVyI2dldFN0YXRlfGdldFN0YXRlfSBtZXRob2QuXG4gICAgICogQHJldHVybnMge0ZpbHRlclRyZWVTdGF0ZU9iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldEZpbHRlcnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0RmlsdGVycyhvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9IHN0YXRlXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIFtzZXRTdGF0ZV17QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvRmlsdGVyVHJlZS5odG1sI3NldFN0YXRlfSBtZXRob2QuIFlvdSBtYXkgbWl4IGluIG1lbWJlcnMgb2YgdGhlIHtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9nbG9iYWwuaHRtbCNGaWx0ZXJUcmVlVmFsaWRhdGlvbk9wdGlvbnNPYmplY3R8RmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8RXJyb3J8c3RyaW5nfSBgdW5kZWZpbmVkYCBpbmRpY2F0ZXMgc3VjY2Vzcy5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldEZpbHRlcnM6IGZ1bmN0aW9uKHN0YXRlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5oaWRlRWRpdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRGaWx0ZXJzKHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvckNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlR2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIHtAbGluayBEZWZhdWx0RmlsdGVyI2dldFN0YXRlfGdldFN0YXRlfSBtZXRob2QuXG4gICAgICogQHJldHVybnMge0ZpbHRlclRyZWVTdGF0ZU9iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldFRhYmxlRmlsdGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFRhYmxlRmlsdGVyKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWVTdGF0ZU9iamVjdH0gc3RhdGVcbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWVTZXRTdGF0ZU9wdGlvbnNPYmplY3R9IFtvcHRpb25zXSAtIFBhc3NlZCB0byB0aGUgZmlsdGVyJ3MgW3NldFN0YXRlXXtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9GaWx0ZXJUcmVlLmh0bWwjc2V0U3RhdGV9IG1ldGhvZC4gWW91IG1heSBtaXggaW4gbWVtYmVycyBvZiB0aGUge0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL2dsb2JhbC5odG1sI0ZpbHRlclRyZWVWYWxpZGF0aW9uT3B0aW9uc09iamVjdHxGaWx0ZXJUcmVlVmFsaWRhdGlvbk9wdGlvbnNPYmplY3R9XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxFcnJvcnxzdHJpbmd9IGB1bmRlZmluZWRgIGluZGljYXRlcyBzdWNjZXNzLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0VGFibGVGaWx0ZXI6IGZ1bmN0aW9uKHN0YXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0VGFibGVGaWx0ZXIoc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJlaGF2aW9yQ2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RSb3dzRnJvbUNlbGxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2hlY2tib3hPbmx5Um93U2VsZWN0aW9ucygpKSB7XG4gICAgICAgICAgICB2YXIgbGFzdCxcbiAgICAgICAgICAgICAgICBoYXNDVFJMID0gdGhpcy5tb3VzZURvd25TdGF0ZS5wcmltaXRpdmVFdmVudC5kZXRhaWwucHJpbWl0aXZlRXZlbnQuY3RybEtleTtcblxuICAgICAgICAgICAgaWYgKGhhc0NUUkwgJiYgIXRoaXMuaXNTaW5nbGVSb3dTZWxlY3Rpb25Nb2RlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLnNlbGVjdFJvd3NGcm9tQ2VsbHMoMCwgaGFzQ1RSTCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChsYXN0ID0gdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRMYXN0U2VsZWN0aW9uKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RSb3cobnVsbCwgbGFzdC5jb3JuZXIueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJSb3dTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0Q29sdW1uc0Zyb21DZWxsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0Q29sdW1uc0Zyb21DZWxscygpO1xuICAgIH0sXG4gICAgZ2V0U2VsZWN0ZWRSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgfSxcbiAgICBnZXRTZWxlY3RlZENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRTZWxlY3RlZENvbHVtbnMoKTtcbiAgICB9LFxuICAgIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRTZWxlY3Rpb25zKCk7XG4gICAgfSxcbiAgICBnZXRMYXN0U2VsZWN0aW9uVHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldExhc3RTZWxlY3Rpb25UeXBlKCk7XG4gICAgfSxcbiAgICBpc0NlbGxTZWxlY3RlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5pc0NlbGxTZWxlY3RlZCh4LCB5KTtcbiAgICB9LFxuICAgIGlzSW5DdXJyZW50U2VsZWN0aW9uUmVjdGFuZ2xlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmlzSW5DdXJyZW50U2VsZWN0aW9uUmVjdGFuZ2xlKHgsIHkpO1xuICAgIH0sXG4gICAgc2VsZWN0QWxsUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0QWxsUm93cygpO1xuICAgIH0sXG4gICAgYXJlQWxsUm93c1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWwuYXJlQWxsUm93c1NlbGVjdGVkKCk7XG4gICAgfSxcbiAgICB0b2dnbGVTZWxlY3RBbGxSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXJlQWxsUm93c1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0QWxsUm93cygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG4gICAgaXNTaW5nbGVSb3dTZWxlY3Rpb25Nb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdzaW5nbGVSb3dTZWxlY3Rpb25Nb2RlJyk7XG4gICAgfSxcbiAgICBuZXdQb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xuICAgIH0sXG4gICAgbmV3UmVjdGFuZ2xlOiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgZ2V0Rm9ybWF0dGVkVmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0VmFsdWUoXG4gICAgICAgICAgICB0aGlzLmdldENvbHVtblByb3BlcnRpZXMoeCkuZm9ybWF0LFxuICAgICAgICAgICAgdGhpcy5nZXRWYWx1ZSh4LCB5ICsgdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTdGlja3kgaGFzaCBvZiBkaWFsb2cgb3B0aW9ucyBvYmplY3RzLlxuICAgICAqIEBkZXNjIEVhY2gga2V5IGlzIGEgZGlhbG9nIG5hbWU7IHRoZSB2YWx1ZSBpcyB0aGUgb3B0aW9ucyBvYmplY3QgZm9yIHRoYXQgZGlhbG9nLlxuICAgICAqIFRoZSBkZWZhdWx0IGRpYWxvZyBvcHRpb25zIG9iamVjdCBoYXMgdGhlIGtleSBgJ3VuZGVmaW5lZCdgLCB3aGljaCBpcyB1bmRlZmluZWQgYnkgZGVmYXVsdDsgaXQgaXMgc2V0IGJ5IGNhbGxpbmcgYHNldERpYWxvZ09wdGlvbnNgIHdpdGggbm8gYGRpYWxvZ05hbWVgIHBhcmFtZXRlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRpYWxvZ09wdGlvbnM6IHt9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2V0IGFuZC9vciByZXR1cm4gYSBzcGVjaWZpYyBkaWFsb2cgb3B0aW9ucyBvYmplY3QgKm9yKiBhIGRlZmF1bHQgZGlhbG9nIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGRlc2MgSWYgYG9wdGlvbnNgIGRlZmluZWQ6XG4gICAgICogKiBJZiBgZGlhbG9nTmFtZWAgZGVmaW5lZDogU2F2ZSB0aGUgc3BlY2lmaWMgZGlhbG9nJ3Mgb3B0aW9ucyBvYmplY3QuXG4gICAgICogKiBJZiBgZGlhbG9nTmFtZWAgdW5kZWZpbmVkOiBTYXZlIHRoZSBkZWZhdWx0IGRpYWxvZyBvcHRpb25zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIElmIGBvcHRpb25zYCBpcyBfbm90XyBkZWZpbmVkLCBubyBuZXcgZGlhbG9nIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgc2F2ZWQ7IGJ1dCBhIHByZXZpb3VzbHkgc2F2ZWQgcHJlc2V0IHdpbGwgYmUgcmV0dXJuZWQgKGFmdGVyIG1peGluZyBpbiB0aGUgZGVmYXVsdCBwcmVzZXQgaWYgdGhlcmUgaXMgb25lKS5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGRpYWxvZyBvcHRpb25zIG9iamVjdCBpcyB1c2VkIGluIHR3byB3YXlzOlxuICAgICAqICogd2hlbiBhIGRpYWxvZyBoYXMgbm8gb3B0aW9ucyBvYmplY3RcbiAgICAgKiAqIGFzIGEgbWl4LWluIGJhc2Ugd2hlbiBhIGRpYWxvZyBkb2VzIGhhdmUgYW4gb3B0aW9ucyBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZGlhbG9nTmFtZV0gSWYgdW5kZWZpbmVkLCBgb3B0aW9uc2AgZGVmaW5lcyB0aGUgZGVmYXVsdCBkaWFsb2cgb3B0aW9ucyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIElmIGRlZmluZWQsIHByZXNldCB0aGUgbmFtZWQgZGlhbG9nIG9wdGlvbnMgb2JqZWN0IG9yIHRoZSBkZWZhdWx0IGRpYWxvZyBvcHRpb25zIG9iamVjdCBpZiBuYW1lIGlzIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IE9uZSBvZjpcbiAgICAgKiAqIFdoZW4gYG9wdGlvbnNgIHVuZGVmaW5lZCwgZmlyc3Qgb2Y6XG4gICAgICogICAqIHByZXZpb3VzIHByZXNldFxuICAgICAqICAgKiBkZWZhdWx0IHByZXNldFxuICAgICAqICAgKiBlbXB0eSBvYmplY3RcbiAgICAgKiAqIFdoZW4gYG9wdGlvbnNgIGRlZmluZWQsIGZpcnN0IG9mOlxuICAgICAqICAgKiBtaXgtaW46IGRlZmF1bHQgcHJlc2V0IG1lbWJlcnMgKyBgb3B0aW9uc2AgbWVtYmVyc1xuICAgICAqICAgKiBgb3B0aW9uc2AgdmVyYmF0aW0gd2hlbiBkZWZhdWx0IHByZXNldCB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBzZXREaWFsb2dPcHRpb25zOiBmdW5jdGlvbihkaWFsb2dOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGlhbG9nTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkaWFsb2dOYW1lO1xuICAgICAgICAgICAgZGlhbG9nTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB0aGlzLmRpYWxvZ09wdGlvbnMudW5kZWZpbmVkO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCBkaWFsb2dOYW1lICYmIHRoaXMuZGlhbG9nT3B0aW9uc1tkaWFsb2dOYW1lXTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlhbG9nT3B0aW9uc1tkaWFsb2dOYW1lXSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gXyh7fSkuZXh0ZW5kKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTsgLy8gbWFrZSBhIG1peC1pblxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIG9iamVjdHMgYXJlIHJlbWVtYmVyZWQgZm9yIHN1YnNlcXVlbnQgdXNlLiBBbHRlcm5hdGl2ZWx5LCB0aGV5IGNhbiBiZSBwcmVzZXQgYnkgY2FsbGluZyB7QGxpbmsgSHlwZXJncmlkI3NldERpYWxvZ09wdGlvbnN8c2V0RGlhbG9nT3B0aW9uc30uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpYWxvZ05hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gSWYgb21pdHRlZCwgdXNlIHRoZSBvcHRpb25zIG9iamVjdCBwcmV2aW91c2x5IGdpdmVuIGhlcmUgKG9yIHRvIHtAbGluayBIeXBlcmdyaWQjc2V0RGlhbG9nT3B0aW9uc3xzZXREaWFsb2dPcHRpb25zfSksIGlmIGFueS4gSW4gYW55IGNhc2UsIHRoZSByZXN1bHRhbnQgb3B0aW9ucyBvYmplY3QsIGlmIGFueSwgaXMgbWl4ZWQgaW50byB0aGUgZGVmYXVsdCBvcHRpb25zIG9iamVjdCwgaWYgdGhlcmUgaXMgb25lLlxuICAgICAqL1xuICAgIG9wZW5EaWFsb2c6IGZ1bmN0aW9uKGRpYWxvZ05hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdG9wRWRpdGluZygpO1xuICAgICAgICBvcHRpb25zID0gdGhpcy5zZXREaWFsb2dPcHRpb25zKGRpYWxvZ05hbWUsIG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLnRlcm1pbmF0ZSA9IGZ1bmN0aW9uKCkgeyAvLyB3aGVuIGFib3V0LXRvLWJlLW9wZW5lZCBkaWFsb2cgaXMgZXZlbnR1YWxseSBjbG9zZWRcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRpYWxvZztcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRpYWxvZyA9IHRoaXMuYmVoYXZpb3Iub3BlbkRpYWxvZyhkaWFsb2dOYW1lLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gYWx0aG91Z2ggeW91IGNhbiBoYXZlIG11bHRpcGxlIGRpYWxvZ3Mgb3BlbiBhdCB0aGUgc2FtZSB0aW1lLCB0aGUgZm9sbG93aW5nIGVuZm9yY2VzIG9uZSBhdCBhIHRpbWUgKGZvciBub3cpXG4gICAgdG9nZ2xlRGlhbG9nOiBmdW5jdGlvbihuZXdEaWFsb2dOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkaWFsb2cgPSB0aGlzLmRpYWxvZyxcbiAgICAgICAgICAgIG9sZERpYWxvZ05hbWUgPSBkaWFsb2cgJiYgZGlhbG9nLiQkQ0xBU1NfTkFNRTtcbiAgICAgICAgaWYgKCFkaWFsb2cgfHwgIXRoaXMuZGlhbG9nLmNsb3NlKCkgJiYgb2xkRGlhbG9nTmFtZSAhPT0gbmV3RGlhbG9nTmFtZSkge1xuICAgICAgICAgICAgaWYgKCFkaWFsb2cpIHtcbiAgICAgICAgICAgICAgICAvLyBvcGVuIG5ldyBkaWFsb2cgbm93XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuRGlhbG9nKG5ld0RpYWxvZ05hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBvcGVuIG5ldyBkaWFsb2cgd2hlbiBhbHJlYWR5LW9wZW5lZCBkaWFsb2cgZmluaXNoZXMgY2xvc2luZyBkdWUgdG8gLmNsb3NlRGlhbG9nKCkgYWJvdmVcbiAgICAgICAgICAgICAgICBkaWFsb2cudGVybWluYXRlID0gdGhpcy5vcGVuRGlhbG9nLmJpbmQodGhpcywgbmV3RGlhbG9nTmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gT25lIG9mOlxuICAgICAqICogYCdhY3RpdmUnYCAtIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBkZWZpbmVkIGZpbHRlciAobGVhZiBub2RlKSBpbiB0aGUgZmlsdGVyIHRyZWUuXG4gICAgICogKiBgJ2luYWN0aXZlJ2AgLSBUaGVyZSBhcmUgbm8gZGVmaW5lZCBmaWx0ZXJzIChubyBsZWFmIG5vZGVzKSBpbiB0aGUgZmlsdGVyIHRyZWUuXG4gICAgICogKiBgJ2Vycm9yJ2AgLSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcGFydGlhbGx5IGRlZmluZWQgZmlsdGVyLlxuICAgICAqL1xuICAgIGdldEZpbHRlclN0YXR1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmdldEdsb2JhbEZpbHRlcigpLFxuICAgICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAgIGlmIChmaWx0ZXIuaW52YWxpZCgpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAnZXJyb3InO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbHRlci5maWx0ZXJDb3VudCgpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAnYWN0aXZlJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICdpbmFjdGl2ZSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbi8qKlxuICogQHN1bW1hcnkgVXBkYXRlIGRlZXAgcHJvcGVydGllcyB3aXRoIG5ldyB2YWx1ZXMuXG4gKiBAZGVzYyBUaGlzIGZ1bmN0aW9uIGlzIGEgcmVjdXJzaXZlIHByb3BlcnR5IHNldHRlciB3aGljaCB1cGRhdGVzIGEgZGVlcCBwcm9wZXJ0eSBpbiBhIGRlc3RpbmF0aW9uIG9iamVjdCB3aXRoIHRoZSB2YWx1ZSBvZiBhIGNvbmdydWVudCBwcm9wZXJ0eSBpbiBhIHNvdXJjZSBvYmplY3QuXG4gKlxuICogPiBUZXJtaW5vbG9neTogQSBkZWVwIHByb3BlcnR5IGlzIGEgXCJ0ZXJtaW5hbCBub2RlXCIgKHByaW1pdGl2ZSB2YWx1ZSkgbmVzdGVkIGF0IHNvbWUgZGVwdGggKGkuZS4sIGRlcHRoID4gMSkgaW5zaWRlIGEgY29tcGxleCBvYmplY3QgKGFuIG9iamVjdCBjb250YWluaW5nIG5lc3RlZCBvYmplY3RzKS4gQSBjb25ncnVlbnQgcHJvcGVydHkgaXMgYSBwcm9wZXJ0eSBpbiBhbm90aGVyIG9iamVjdCB3aXRoIHRoZSBzYW1lIG5hbWUgYW5kIGF0IHRoZSBzYW1lIGxldmVsIG9mIG5lc3RpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBzaW1wbGUgYW5kIGVsZWdhbnQuIEkgcmVjb21tZW5kIHlvdSBzdHVkeSB0aGUgY29kZSwgd2hpY2ggbm9uZXRoZWxlc3MgaW1wbGllcyBhbGwgb2YgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAqIElmIHRoZSBkZWVwIHByb3BlcnR5IGlzIF9ub3RfIGZvdW5kIGluIGBkZXN0aW5hdGlvbmAsIGl0IHdpbGwgYmUgY3JlYXRlZC5cbiAqICogSWYgdGhlIGRlZXAgcHJvcGVydHkgaXMgZm91bmQgaW4gYGRlc3RpbmF0aW9uYCBfYW5kXyBpcyBhIHByaW1pdGl2ZSB0eXBlLCBpdCB3aWxsIGJlIG1vZGlmaWVkIChvdmVyd3JpdHRlbiB3aXRoIHRoZSB2YWx1ZSBmcm9tIGBzb3VyY2VgKS5cbiAqICogSWYgdGhlIGRlZXAgcHJvcGVydHkgaXMgZm91bmQgaW4gYGRlc3RpbmF0aW9uYCBfYnV0XyBpcyBub3QgYSBwcmltaXRpdmUgdHlwZSAoaS5lLiwgaXMgYSBuZXN0ZWQgb2JqZWN0KSwgaXQgd2lsbCBfYWxzb18gYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgKHByaW1pdGl2ZSkgdmFsdWUgZnJvbSBgc291cmNlYC5cbiAqICogSWYgdGhlIG5lc3RlZCBvYmplY3QgdGhlIGRlZXAgcHJvcGVydHkgaW5oYWJpdHMgaW4gYHNvdXJjZWAgaXMgbm90IGZvdW5kIGluIGBkZXN0aW5hdGlvbmAsIGl0IHdpbGwgYmUgY3JlYXRlZC5cbiAqICogSWYgdGhlIG5lc3RlZCBvYmplY3QgdGhlIGRlZXAgcHJvcGVydHkgaW5oYWJpdHMgaW4gYHNvdXJjZWAgaXMgZm91bmQgaW4gYGRlc3RpbmF0aW9uYCBidXQgaXMgbm90IGluIGZhY3QgYW4gb2JqZWN0IChpLmUuLCBpdCBpcyBhIHByaW1pdGl2ZSB2YWx1ZSksIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCBhIHJlZmVyZW5jZSB0byB0aGF0IG9iamVjdC5cbiAqICogSWYgdGhlIHByaW1pdGl2ZSB2YWx1ZSBpcyBgdW5kZWZpbmVkYCwgdGhlIGRlc3RpbmF0aW9uIHByb3BlcnR5IGlzIGRlbGV0ZWQuXG4gKiAqIGBzb3VyY2VgIG1heSBjb250YWluIG11bHRpcGxlIHByb3BlcnRpZXMgdG8gdXBkYXRlLlxuICpcbiAqIFRoYXQgb25lIHJ1bGUgaXMgc2ltcGx5IHRoaXM6IElmIGJvdGggdGhlIHNvdXJjZSBfYW5kXyB0aGUgZGVzdGluYXRpb24gcHJvcGVydGllcyBhcmUgb2JqZWN0cywgdGhlbiByZWN1cnNlOyBlbHNlIG92ZXJ3cml0ZSB0aGUgZGVzdGluYXRpb24gcHJvcGVydHkgd2l0aCB0aGUgc291cmNlIHByb3BlcnR5LlxuICpcbiAqID4gQ2F2ZWF0OiBUaGlzIGlzIF9ub3RfIGVxdWl2YWxlbnQgdG8gYSBkZWVwIGV4dGVuZCBmdW5jdGlvbi4gV2hpbGUgYm90aCBhIGRlZXAgZXh0ZW5kIGFuZCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmVjdXJzZSBvdmVyIGEgY29tcGxleCBvYmplY3QsIHRoZXkgYXJlIGZ1bmRhbWVudGFsbHkgZGlmZmVyZW50OiBBIGRlZXAgZXh0ZW5kIGNsb25lcyB0aGUgbmVzdGVkIG9iamVjdHMgYXMgaXQgZmluZHMgdGhlbTsgdGhpcyBmdW5jdGlvbiBtZXJlbHkgdXBkYXRlcyB0aGVtIChvciBjcmVhdGVzIHRoZW0gd2hlcmUgdGhleSBkb24ndCBleGlzdCkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRlc3RpbmF0aW9uIC0gQW4gb2JqZWN0IHRvIHVwZGF0ZSB3aXRoIG5ldyBvciBtb2RpZmllZCBwcm9wZXJ0eSB2YWx1ZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2UgLSBBIGNvbmdydWVudCBvYmplY3QgY29udGluYWx5IChvbmx5KSB0aGUgbmV3IG9yIG1vZGlmaWVkIHByb3BlcnR5IHZhbHVlcy5cbiAqIEByZXR1cm5zIHtvYmplY3R9IEFsd2F5cyByZXR1cm5zIGBkZXN0aW5hdGlvbmAuXG4gKi9cbmZ1bmN0aW9uIGFkZERlZXBQcm9wZXJ0aWVzKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICBfKHNvdXJjZSkuZWFjaChmdW5jdGlvbihwcm9wZXJ0eSwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb25ba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb3BlcnR5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYWRkRGVlcFByb3BlcnRpZXMoZGVzdGluYXRpb25ba2V5XSwgcHJvcGVydHkpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkZXN0aW5hdGlvbltrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHByb3BlcnR5O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVSZWN0KHJlY3QpIHtcbiAgICB2YXIgbyA9IHJlY3Qub3JpZ2luO1xuICAgIHZhciBjID0gcmVjdC5jb3JuZXI7XG5cbiAgICB2YXIgb3ggPSBNYXRoLm1pbihvLngsIGMueCk7XG4gICAgdmFyIG95ID0gTWF0aC5taW4oby55LCBjLnkpO1xuXG4gICAgdmFyIGN4ID0gTWF0aC5tYXgoby54LCBjLngpO1xuICAgIHZhciBjeSA9IE1hdGgubWF4KG8ueSwgYy55KTtcblxuICAgIHZhciByZXN1bHQgPSBuZXcgUmVjdGFuZ2xlKG94LCBveSwgY3ggLSBveCwgY3kgLSBveSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBidWlsZFBvbHltZXJUaGVtZSgpIHtcbiAgICBjbGVhck9iamVjdFByb3BlcnRpZXMocG9seW1lclRoZW1lKTtcbiAgICB2YXIgcGIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwYXBlci1idXR0b24nKTtcblxuICAgIHBiLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgcGIuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocGIpO1xuICAgIHZhciBwID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGIpO1xuXG4gICAgdmFyIHNlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWN0aW9uJyk7XG4gICAgc2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHNlY3Rpb24uc2V0QXR0cmlidXRlKCdoZXJvJywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzZWN0aW9uKTtcblxuICAgIHZhciBoID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaHRtbCcpKTtcbiAgICB2YXIgaGIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sLCBib2R5JykpO1xuICAgIHZhciBzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc2VjdGlvbik7XG5cbiAgICBwb2x5bWVyVGhlbWUuY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbG9yID0gcC5jb2xvcjtcbiAgICBwb2x5bWVyVGhlbWUucm93SGVhZGVyQmFja2dyb3VuZENvbG9yID0gcC5jb2xvcjtcbiAgICBwb2x5bWVyVGhlbWUudG9wTGVmdEJhY2tncm91bmRDb2xvciA9IHAuY29sb3I7XG4gICAgcG9seW1lclRoZW1lLmxpbmVDb2xvciA9IHAuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgcG9seW1lclRoZW1lLmJhY2tncm91bmRDb2xvcjIgPSBoYi5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICBwb2x5bWVyVGhlbWUuY29sb3IgPSBoLmNvbG9yO1xuICAgIHBvbHltZXJUaGVtZS5mb250RmFtaWx5ID0gaC5mb250RmFtaWx5O1xuICAgIHBvbHltZXJUaGVtZS5iYWNrZ3JvdW5kQ29sb3IgPSBzLmJhY2tncm91bmRDb2xvcjtcblxuICAgIHBiLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgcGIuc2V0QXR0cmlidXRlKCdzZWNvbmRhcnknLCB0cnVlKTtcbiAgICBwYi5zZXRBdHRyaWJ1dGUoJ3JhaXNlZCcsIHRydWUpO1xuICAgIHAgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYik7XG5cbiAgICBwb2x5bWVyVGhlbWUuY29sdW1uSGVhZGVyQ29sb3IgPSBwLmNvbG9yO1xuICAgIHBvbHltZXJUaGVtZS5yb3dIZWFkZXJDb2xvciA9IHAuY29sb3I7XG4gICAgcG9seW1lclRoZW1lLnRvcExlZnRDb2xvciA9IHAuY29sb3I7XG5cblxuICAgIHBvbHltZXJUaGVtZS5iYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSBwLmJhY2tncm91bmRDb2xvcjtcbiAgICBwb2x5bWVyVGhlbWUuZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gcC5jb2xvcjtcblxuICAgIHBiLnNldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5JywgZmFsc2UpO1xuICAgIHBiLnNldEF0dHJpYnV0ZSgnd2FybmluZycsIHRydWUpO1xuXG4gICAgcG9seW1lclRoZW1lLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuY29sb3I7XG4gICAgcG9seW1lclRoZW1lLmNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuYmFja2dyb3VuZENvbG9yO1xuICAgIHBvbHltZXJUaGVtZS5yb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSBwLmNvbG9yO1xuICAgIHBvbHltZXJUaGVtZS5maXhlZENvbHVtbkJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgLy9jaGVjayBpZiB0aGVyZSBpcyBhY3R1YWxseSBhIHRoZW1lIGxvYWRlZCBpZiBub3QsIGNsZWFyIG91dCBhbGwgYm9ndXMgdmFsdWVzXG4gICAgLy9mcm9tIG15IGNhY2hlXG4gICAgaWYgKHBvbHltZXJUaGVtZS5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPT09ICdyZ2JhKDAsIDAsIDAsIDApJyB8fFxuICAgICAgICBwb2x5bWVyVGhlbWUubGluZUNvbG9yID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgIGNsZWFyT2JqZWN0UHJvcGVydGllcyhwb2x5bWVyVGhlbWUpO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocGIpO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2VjdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNsZWFyT2JqZWN0UHJvcGVydGllcyhvYmopIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2YWxPckZ1bmModmYpIHtcbiAgICB2YXIgcmVzdWx0ID0gKHR5cGVvZiB2ZilbMF0gPT09ICdmJyA/IHZmKCkgOiB2ZjtcbiAgICByZXR1cm4gcmVzdWx0IHx8IHJlc3VsdCA9PT0gMCA/IHJlc3VsdCA6ICcnO1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5IFNoYXJlZCBsb2NhbGl6YXRpb24gZGVmYXVsdHMgZm9yIGFsbCBncmlkIGluc3RhbmNlcy5cbiAqIEBkZXNjIFRoZXNlIHByb3BlcnR5IHZhbHVlcyBhcmUgb3ZlcnJpZGRlbiBieSB0aG9zZSBzdXBwbGllZCBpbiB0aGUgYEh5cGVyZ3JpZGAgY29uc3RydWN0b3IncyBgb3B0aW9ucy5sb2NhbGl6YXRpb25gLlxuICogQHByb3BlcnR5IHtzdHJpbmd8c3RyaW5nW119IFtvcHRpb25zLmxvY2FsaXphdGlvbi5kZWZhdWx0TG9jYWxlXSAtIFRoZSBkZWZhdWx0IGxvY2FsZSB0byB1c2Ugd2hlbiBhbiBleHBsaWNpdCBgbG9jYWxlYCBpcyBvbWl0dGVkIGZyb20gbG9jYWxpemVyIGNvbnN0cnVjdG9yIGNhbGxzLiBQYXNzZWQgdG8gSW50bC5OdW1iZXJGb21yYXRgIGFuZCBgSW50bC5EYXRlRm9tcmF0YC4gU2VlIHtAIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludGwjTG9jYWxlX2lkZW50aWZpY2F0aW9uX2FuZF9uZWdvdGlhdGlvbnxMb2NhbGUgaWRlbnRpZmljYXRpb24gYW5kIG5lZ290aWF0aW9ufSBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gT21pdHRpbmcgd2lsbCB1c2UgdGhlIHJ1bnRpbWUncyBsb2NhbCBsYW5ndWFnZSBhbmQgcmVnaW9uLlxuICogQHByb3BlcnR5IHtvYmplY3R9IFtvcHRpb25zLmxvY2FsaXphdGlvbi5udW1iZXJPcHRpb25zXSAtIE9wdGlvbnMgcGFzc2VkIHRvIGBJbnRsLk51bWJlckZvbXJhdGAgZm9yIGNyZWF0aW5nIHRoZSBiYXNpYyBcIm51bWJlclwiIGxvY2FsaXplci5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbb3B0aW9ucy5sb2NhbGl6YXRpb24uZGF0ZU9wdGlvbnNdIC0gT3B0aW9ucyBwYXNzZWQgdG8gYEludGwuRGF0ZUZvbXJhdGAgZm9yIGNyZWF0aW5nIHRoZSBiYXNpYyBcImRhdGVcIiBsb2NhbGl6ZXIuXG4gKi9cblxuSHlwZXJncmlkLmxvY2FsaXphdGlvbiA9IHtcbiAgICBsb2NhbGU6ICdlbi1VUycsXG4gICAgbnVtYmVyT3B0aW9uczogeyBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIeXBlcmdyaWQ7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBPbmx5IDEgY2hvaWNlIGZyb20gZWFjaCBibG9jayBiZWxvdyBzaG91bGQgYmUgZXhwb3NlZCAodW5jb21tZW50ZWQpOlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuXHRhbmFseXRpY3M6IHJlcXVpcmUoJ2h5cGVyLWFuYWx5dGljcycpLCAvLyBucG1cbiAgICAvL2FuYWx5dGljczogcmVxdWlyZSgnLi4vLi4vaHlwZXItYW5hbHl0aWNzL3NyYycpLCAvLyBkZXZlbG9wZXJzXG5cbiAgICBGaWx0ZXJUcmVlOiByZXF1aXJlKCdmaWx0ZXItdHJlZScpLCAvLyBucG1cbiAgICAvL0ZpbHRlclRyZWU6IHJlcXVpcmUoJy4uLy4uL2ZpbHRlci10cmVlJyksIC8vIGRldmVsb3BlcnNcblxufTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcbnZhciBCYXNlID0gcmVxdWlyZSgnLi4vbGliL0Jhc2UnKTtcblxudmFyIENvbHVtbiA9IHJlcXVpcmUoJy4vQ29sdW1uJyk7XG52YXIgZGlhbG9ncyA9IHJlcXVpcmUoJy4uL2RpYWxvZ3MnKTtcbnZhciBEZWZhdWx0RmlsdGVyID0gcmVxdWlyZSgnLi4vZmlsdGVyL0RlZmF1bHRGaWx0ZXInKTtcblxudmFyIG5vRXhwb3J0UHJvcGVydGllcyA9IFtcbiAgICAnY29sdW1uSGVhZGVyJyxcbiAgICAnY29sdW1uSGVhZGVyQ29sdW1uU2VsZWN0aW9uJyxcbiAgICAnZmlsdGVyUHJvcGVydGllcycsXG4gICAgJ3Jvd0hlYWRlcicsXG4gICAgJ3Jvd0hlYWRlclJvd1NlbGVjdGlvbicsXG4gICAgJ3Jvd051bWJlcnNQcm9wZXJ0aWVzJyxcbiAgICAndHJlZUNvbHVtblByb3BlcnRpZXMnLFxuICAgICd0cmVlQ29sdW1uUHJvcGVydGllc0NvbHVtblNlbGVjdGlvbicsXG5dO1xuXG52YXIgaXNOdWxsID0ge1xuICAgIGlzTnVsbDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhYnN0cmFjdFxuICogQGRlc2MgQSBzb3J0IG9mIFwibW9kZWwrKy5cIiBJdCBjb250YWlucyBhbGwgY29kZS9kYXRhIHRoYXQncyBuZWNlc3NhcnkgZm9yIGVhc2lseSBpbXBsZW1lbnRpbmcgYSB2aXJ0dWFsIGRhdGEgc291cmNlIGFuZCBpdHMgbWFuaXB1bGF0aW9uL2FuYWx5dGljcy5cbiAqXG4gKi9cbnZhciBCZWhhdmlvciA9IEJhc2UuZXh0ZW5kKCdCZWhhdmlvcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHRoaXMgaXMgdGhlIGNhbGxiYWNrIGZvciB0aGUgcGx1Z2luIHBhdHRlcm4gb2YgbmVzdGVkIHRhZ3NcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258bWVudUl0ZW1bXX0gW3NjaGVtYT1kZXJpdmVkU2NoZW1hXSAtIFBhc3NlZCB0byBiZWhhdmlvciBjb25zdHJ1Y3Rvci4gTWF5IGJlOlxuICAgICAqICogQSBzY2hlbWEgYXJyYXlcbiAgICAgKiAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc2NoZW1hIGFycmF5LiBDYWxsZWQgYXQgZmlsdGVyIHJlc2V0IHRpbWUgd2l0aCBiZWhhdmlvciBhcyBjb250ZXh0LlxuICAgICAqICogT21pdCB0byBnZW5lcmF0ZSBhIGJhc2ljIHNjaGVtYSBmcm9tIGB0aGlzLmNvbHVtbnNgLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkLCBzY2hlbWEsIGRhdGFSb3dzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SHlwZXJncmlkfVxuICAgICAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyaWQgPSBncmlkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7RGF0YU1vZGVsfVxuICAgICAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGFNb2RlbCA9IHRoaXMuZ2V0TmV3RGF0YU1vZGVsKCk7XG5cbiAgICAgICAgZ3JpZC5zZXRCZWhhdmlvcih0aGlzKTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgdGhpcy5pbml0aWFsaXplRmVhdHVyZUNoYWluKGdyaWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBjcmVhdGUgdGhlIGZlYXR1cmUgY2hhaW4gLSB0aGlzIGlzIHRoZSBbY2hhaW4gb2YgcmVzcG9uc2liaWxpdHldKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/Q2hhaW5PZlJlc3BvbnNpYmlsaXR5UGF0dGVybikgcGF0dGVybi5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplRmVhdHVyZUNoYWluOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgSGFzaCBvZiBmZWF0dXJlIGNsYXNzIG5hbWVzLlxuICAgICAgICAgKiBAZGVzYyBCdWlsdCBoZXJlIGJ1dCBvdGhlcndpc2Ugbm90IGluIHVzZS5cbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mZWF0dXJlTWFwID0ge307XG5cbiAgICAgICAgdGhpcy5mZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKEZlYXR1cmVDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdmFyIG5ld0ZlYXR1cmUgPSBuZXcgRmVhdHVyZUNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgc2VsZi5mZWF0dXJlTWFwW25ld0ZlYXR1cmUuJCRDTEFTU19OQU1FXSA9IG5ld0ZlYXR1cmU7XG4gICAgICAgICAgICBpZiAoc2VsZi5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmZlYXR1cmVDaGFpbi5zZXROZXh0KG5ld0ZlYXR1cmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAc3VtbWFyeSBDb250cm9sbGVyIGNoYWluIG9mIGNvbW1hbmQuXG4gICAgICAgICAgICAgICAgICogQGRlc2MgRWFjaCBmZWF0dXJlIGlzIGxpbmtlZCB0byB0aGUgbmV4dCBmZWF0dXJlLlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtGZWF0dXJlfVxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzZWxmLmZlYXR1cmVDaGFpbiA9IG5ld0ZlYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmluaXRpYWxpemVPbihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmZWF0dXJlczogW10sIC8vIG92ZXJyaWRlIGluIGltcGxlbWVudGluZyBjbGFzcyB1bmxlc3Mgbm8gZmVhdHVyZXNcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZENvbHVtbkNvdW50ID0gMzA7XG4gICAgICAgIHRoaXMucmVuZGVyZWRSb3dDb3VudCA9IDYwO1xuICAgICAgICB0aGlzLmRhdGFVcGRhdGVzID0ge307IC8vZm9yIG92ZXJyaWRpbmcgd2l0aCBlZGl0IHZhbHVlcztcbiAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvblggPSB0aGlzLnNjcm9sbFBvc2l0aW9uWSA9IDA7XG4gICAgICAgIHRoaXMuY2xlYXJDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuY2xlYXJTdGF0ZSgpO1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5yZXNldCgpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgY2xlYXJDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtDb2x1bW5bXX1cbiAgICAgICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2x1bW5zID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtDb2x1bW5bXX1cbiAgICAgICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zID0gW107XG5cbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zWy0xXSA9IHRoaXMuY29sdW1uc1stMV0gPSB0aGlzLm5ld0NvbHVtbigtMSk7XG4gICAgICAgIHRoaXMuYWxsQ29sdW1uc1stMl0gPSB0aGlzLmNvbHVtbnNbLTJdID0gdGhpcy5uZXdDb2x1bW4oLTIpO1xuXG4gICAgICAgIHRoaXMuY29sdW1uRW51bSA9IHt9O1xuICAgIH0sXG5cbiAgICBnZXRBY3RpdmVDb2x1bW46IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uc1t4XTtcbiAgICB9LFxuICAgIGdldFZpc2libGVDb2x1bW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ2dldFZpc2libGVDb2x1bW4oeCknLCAnZ2V0QWN0aXZlQ29sdW1uKHgpJywgJzEuMC42JywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGdldFZpc2libGVDb2x1bW5OYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kZXByZWNhdGVkKCdnZXRWaXNpYmxlQ29sdW1uTmFtZSh4KScsICdnZXRBY3RpdmVDb2x1bW4oeCkubmFtZScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBnZXRDb2x1bW5JZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGVwcmVjYXRlZCgnZ2V0Q29sdW1uSWQoeCknLCAnZ2V0QWN0aXZlQ29sdW1uKHgpLmhlYWRlcicsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBnZXRIZWFkZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ2dldEhlYWRlcih4KScsICdnZXRBY3RpdmVDb2x1bW4oeCkuaGVhZGVyJywgJzEuMC42JywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbENvbHVtbnNbeF07XG4gICAgfSxcblxuICAgIG5ld0NvbHVtbjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgY29sdW1uID0gbmV3IENvbHVtbih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5nZXRQcml2YXRlU3RhdGUoKS5jb2x1bW5Qcm9wZXJ0aWVzW2NvbHVtbi5pbmRleF0gPSB0aGlzLmNyZWF0ZUNvbHVtblByb3BlcnRpZXMoKTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICB9LFxuXG4gICAgYWRkQ29sdW1uOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLm5ld0NvbHVtbihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICB9LFxuXG4gICAgY3JlYXRlQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vY29uY3JldGUgaW1wbGVtZW50YXRpb24gaGVyZVxuICAgIH0sXG5cbiAgICBjcmVhdGVDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRhYmxlU3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUodGFibGVTdGF0ZSk7XG5cbiAgICAgICAgcHJvcGVydGllcy5yb3dOdW1iZXJzUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUocHJvcGVydGllcywge1xuICAgICAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb3BlcnRpZXMucm93SGVhZGVyID0gT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckZvbnQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93SGVhZGVyRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvcGVydGllcy5jb2x1bW5IZWFkZXIgPSBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMsIHtcbiAgICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyRm9udDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJGb250ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmVncm91bmRTZWxlY3Rpb25Gb250OiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Gb250O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Gb250ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwcm9wZXJ0aWVzLmNvbHVtbkhlYWRlckNvbHVtblNlbGVjdGlvbiA9IE9iamVjdC5jcmVhdGUocHJvcGVydGllcy5jb2x1bW5IZWFkZXIsIHtcbiAgICAgICAgICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyRm9yZWdyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwcm9wZXJ0aWVzLnJvd0hlYWRlclJvd1NlbGVjdGlvbiA9IE9iamVjdC5jcmVhdGUocHJvcGVydGllcy5yb3dIZWFkZXIsIHtcbiAgICAgICAgICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJGb3JlZ3JvdW5kUm93U2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93SGVhZGVyRm9yZWdyb3VuZFJvd1NlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJCYWNrZ3JvdW5kUm93U2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93SGVhZGVyQmFja2dyb3VuZFJvd1NlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwcm9wZXJ0aWVzLmZpbHRlclByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMsIHtcbiAgICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyRm9udDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJGb250ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyQmFja2dyb3VuZENvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNlbGxCb3JkZXJTdHlsZToge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJDZWxsQm9yZGVyU3R5bGU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyQ2VsbEJvcmRlclN0eWxlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNlbGxCb3JkZXJUaGlja25lc3M6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQ2VsbEJvcmRlclRoaWNrbmVzcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJDZWxsQm9yZGVyVGhpY2tuZXNzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwcm9wZXJ0aWVzLnRyZWVDb2x1bW5Qcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWVDb2x1bW5Gb250O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVDb2x1bW5Gb250ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWVDb2x1bW5Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWVDb2x1bW5CYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUNvbHVtbkJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZUNvbHVtbkZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVDb2x1bW5CYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb3BlcnRpZXMudHJlZUNvbHVtblByb3BlcnRpZXNDb2x1bW5TZWxlY3Rpb24gPSBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMudHJlZUNvbHVtblByb3BlcnRpZXMsIHtcbiAgICAgICAgICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uRm9yZWdyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVDb2x1bW5Gb3JlZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWVDb2x1bW5CYWNrZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUNvbHVtbkJhY2tncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfSxcblxuICAgIGdldENvbHVtbldpZHRoOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdldEFjdGl2ZUNvbHVtbih4KTtcbiAgICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnZGVmYXVsdENvbHVtbldpZHRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpZHRoID0gY29sdW1uLmdldFdpZHRoKCk7XG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgc2V0Q29sdW1uV2lkdGg6IGZ1bmN0aW9uKHgsIHdpZHRoKSB7XG4gICAgICAgIHRoaXMuZ2V0QWN0aXZlQ29sdW1uKHgpLnNldFdpZHRoKHdpZHRoKTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q2VsbFJlbmRlcmVyOiBmdW5jdGlvbihjb25maWcsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZlQ29sdW1uKHgpLmdldENlbGxSZW5kZXJlcihjb25maWcsIHkpO1xuICAgIH0sXG4gICAgZ2V0Q2VsbFByb3ZpZGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuZGVwcmVjYXRlZCgnZ2V0Q2VsbFByb3ZpZGVyKCknLCAnZ3JpZC5jZWxsUmVuZGVyZXJzJywgJzEuMC42JywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGNyZWF0ZUNlbGxQcm92aWRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdnZXRDZWxsUHJvdmlkZXIoKSBpcyBkZXByZWNhdGVkIGFzIG9mIHYxLjAuNi4gTm8gcmVwbGFjZW1lbnQ7IGRvIG5vdCBjYWxsLiBQcmV2aW91c2x5IGNhbGxlZCBieSBgQmVoYXZpb3JgIGNvbnN0cnVjdG9yOyBgbmV3IENlbGxSZW5kZXJlcnMoKWAgaXMgbm93IGNhbGxlZCBieSBgSHlwZXJncmlkYCBjb25zdHJ1Y3RvciBpbnN0ZWFkLicsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGFwcGx5QW5hbHl0aWNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuYXBwbHlBbmFseXRpY3MoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgZnVuY3Rpb24gdG8gZW1wdHkgYW4gb2JqZWN0IG9mIGl0cyBtZW1iZXJzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gZW1wdHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtleHBvcnRQcm9wc11cbiAgICAgKiAqIGB1bmRlZmluZWRgIChvbWl0dGVkKSAtIGRlbGV0ZSAqYWxsKiBwcm9wZXJ0aWVzXG4gICAgICogKiAqKmZhbHN5KiogLSBkZWxldGUgKm9ubHkqIHRoZSBleHBvcnQgcHJvcGVydGllc1xuICAgICAqICogKip0cnV0aHkqKiAtIGRlbGV0ZSBhbGwgcHJvcGVydGllcyAqZXhjZXB0KiB0aGUgZXhwb3J0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBjbGVhck9iamVjdFByb3BlcnRpZXM6IGZ1bmN0aW9uKG9iaiwgZXhwb3J0UHJvcHMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0UHJvcHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAhZXhwb3J0UHJvcHMgJiYgbm9FeHBvcnRQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA+PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydFByb3BzICYmIG5vRXhwb3J0UHJvcGVydGllcy5pbmRleE9mKGtleSkgPCAwXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnZXR0ZXIgZm9yIGEgW01lbWVudG9dKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/TWVtZW50b1BhdHRlcm4pIE9iamVjdFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0UHJpdmF0ZVN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRhYmxlU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudGFibGVTdGF0ZSA9IHRoaXMuZ2V0RGVmYXVsdFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGFibGVTdGF0ZTtcbiAgICB9LFxuXG4gICAgLy90aGlzIGlzIGVmZmVjdGl2ZWx5IGEgY2xvbmUsIHdpdGggY2VydGFpbiB0aGluZ3MgcmVtb3ZlZC4uLi5cbiAgICBnZXRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmdldFByaXZhdGVTdGF0ZSgpKSk7XG4gICAgICAgIHRoaXMuY2xlYXJPYmplY3RQcm9wZXJ0aWVzKGNvcHkuY29sdW1uUHJvcGVydGllcywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBjbGVhciBhbGwgdGFibGUgc3RhdGVcbiAgICAgKi9cbiAgICBjbGVhclN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1lbWVudG8gZm9yIHRoZSB1c2VyIGNvbmZpZ3VyZWQgdmlzdWFsIHByb3BlcnRpZXMgb2YgdGhlIHRhYmxlXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFibGVTdGF0ZSA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IE5ld2x5IGNyZWF0ZWQgZGVmYXVsdCBlbXB0eSB0YWJsZXN0YXRlLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0YWJsZVByb3BlcnRpZXMgPSB0aGlzLmdyaWQuX2dldFByb3BlcnRpZXMoKTtcbiAgICAgICAgdmFyIHN0YXRlID0gT2JqZWN0LmNyZWF0ZSh0YWJsZVByb3BlcnRpZXMpO1xuXG4gICAgICAgIF8oc3RhdGUpLmV4dGVuZE93bih7XG4gICAgICAgICAgICByb3dIZWlnaHRzOiB7fSxcbiAgICAgICAgICAgIGNvbHVtblByb3BlcnRpZXM6IFtdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlc3RvcmUgdGhpcyB0YWJsZSB0byBhIHByZXZpb3VzIHN0YXRlLlxuICAgICAqIFNlZSB0aGUgW21lbWVudG8gcGF0dGVybl0oaHR0cDovL2MyLmNvbS9jZ2kvd2lraT9NZW1lbnRvUGF0dGVybikuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1lbWVudG8gLSBhbiBlbmNhcHN1bGF0ZWQgcmVwcmVzZW50YXRpb24gb2YgdGFibGUgc3RhdGVcbiAgICAgKi9cbiAgICBzZXRTdGF0ZTogZnVuY3Rpb24obWVtZW50bykge1xuXG4gICAgICAgIC8vd2UgZG9uJ3Qgd2FudCB0byBjbG9iYmVyIHRoZSBjb2x1bW4gcHJvcGVydGllcyBjb21wbGV0ZWx5XG4gICAgICAgIGlmICghbWVtZW50by5jb2x1bW5JbmRleGVzKSB7XG4gICAgICAgICAgICB2YXIgZmllbGRzID0gdGhpcy5kYXRhTW9kZWwuZ2V0RmllbGRzKCk7XG4gICAgICAgICAgICBtZW1lbnRvLmNvbHVtbkluZGV4ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWVtZW50by5jb2x1bW5JbmRleGVzW2ldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sUHJvcGVydGllcyA9IG1lbWVudG8uY29sdW1uUHJvcGVydGllcztcbiAgICAgICAgZGVsZXRlIG1lbWVudG8uY29sdW1uUHJvcGVydGllcztcbiAgICAgICAgdGhpcy50YWJsZVN0YXRlID0gbnVsbDtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuX3NldENvbHVtbk9yZGVyKG1lbWVudG8uY29sdW1uSW5kZXhlcyk7XG4gICAgICAgIF8oc3RhdGUpLmV4dGVuZE93bihtZW1lbnRvKTtcbiAgICAgICAgdGhpcy5zZXRBbGxDb2x1bW5Qcm9wZXJ0aWVzKGNvbFByb3BlcnRpZXMpO1xuICAgICAgICBtZW1lbnRvLmNvbHVtblByb3BlcnRpZXMgPSBjb2xQcm9wZXJ0aWVzO1xuXG4gICAgICAgIC8vanVzdCB0byBiZSBjbG9zZS8gaXQncyBlYXNpZXIgb24gdGhlIGV5ZXNcbiAgICAgICAgdGhpcy5zZXRDb2x1bW5XaWR0aCgtMSwgMjQuMTkzMzU5Mzc1KTtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuYXBwbHlTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBzZXRBbGxDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKS5jb2x1bW5Qcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgdGhpcy5jbGVhck9iamVjdFByb3BlcnRpZXMoY3VycmVudCwgZmFsc2UpO1xuICAgICAgICAgICAgXyhjdXJyZW50KS5leHRlbmRPd24ocHJvcGVydGllc1tpXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldENvbHVtbk9yZGVyOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbmRleGVzKSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbmRleGVzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbnMubGVuZ3RoID0gaW5kZXhlcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zW2ldID0gdGhpcy5hbGxDb2x1bW5zW2luZGV4ZXNbaV1dO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBmZXRjaCB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkga2V5XG4gICAgICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIGEgcHJvcGVydHkgbmFtZVxuICAgICAqL1xuICAgIHJlc29sdmVQcm9wZXJ0eTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucmVzb2x2ZVByb3BlcnR5KGtleSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBIHNwZWNpZmljIGNlbGwgd2FzIGNsaWNrZWQ7IHlvdSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGwgLSBwb2ludCBvZiBjZWxsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gYWxsIGV2ZW50IGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgY2VsbENsaWNrZWQ6IGZ1bmN0aW9uKGNlbGwsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLmNlbGxDbGlja2VkKGNlbGwsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEEgc3BlY2lmaWMgY2VsbCB3YXMgbGUgZG91YmxlLWNsaWNrZWQ7IHlvdSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGwgLSBwb2ludCBvZiBjZWxsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gYWxsIGV2ZW50IGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgY2VsbERvdWJsZUNsaWNrZWQ6IGZ1bmN0aW9uKGNlbGwsIGV2ZW50KSB7XG5cbiAgICB9LFxuXG4gICAgbG9va3VwRmVhdHVyZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVNYXBba2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldHRlciBmb3IgdGhlIGh5cGVyZ3JpZFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2V0R3JpZDogZnVuY3Rpb24oZ3JpZCkge1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgRmlyc3QgY2hlY2sgdG8gc2VlIGlmIHNvbWV0aGluZyB3YXMgb3ZlcnJpZGRlbi5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgYXQgYHgseWAgZm9yIHRoZSB0b3AgbGVmdCBzZWN0aW9uIG9mIHRoZSBoeXBlcmdyaWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdldEFjdGl2ZUNvbHVtbih4KTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbiAmJiBjb2x1bW4uZ2V0VmFsdWUoeSk7XG4gICAgfSxcblxuICAgIGdldFVuZmlsdGVyZWRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRBY3RpdmVDb2x1bW4oeCk7XG4gICAgICAgIHJldHVybiBjb2x1bW4gJiYgY29sdW1uLmdldFVuZmlsdGVyZWRWYWx1ZSh5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHVwZGF0ZSB0aGUgZGF0YSBhdCBwb2ludCB4LCB5IHdpdGggdmFsdWVcbiAgICAgKiBAcmV0dXJuIFRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gdXNlXG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdldEFjdGl2ZUNvbHVtbih4KTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbiAmJiBjb2x1bW4uc2V0VmFsdWUoeSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICBnZXREYXRhVmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldFZhbHVlKHgsIHkpO1xuICAgIH0sXG5cbiAgICBzZXREYXRhVmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldFZhbHVlKHgsIHksIHZhbHVlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBGaXJzdCBjaGVja3MgdG8gc2VlIGlmIHNvbWV0aGluZyB3YXMgb3ZlcnJpZGRlbi5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgYXQgeCx5IGZvciB0aGUgdG9wIGxlZnQgc2VjdGlvbiBvZiB0aGUgaHlwZXJncmlkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBnZXRDZWxsUHJvcGVydGllczogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5hbGxDb2x1bW5zW3hdO1xuICAgICAgICByZXR1cm4gY29sdW1uICYmIGNvbHVtbi5nZXRDZWxsUHJvcGVydGllcyh5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHVwZGF0ZSB0aGUgZGF0YSBhdCBwb2ludCB4LCB5IHdpdGggdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0geSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIHVzZVxuICAgICAqL1xuICAgIHNldENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5hbGxDb2x1bW5zW3hdO1xuICAgICAgICBpZiAoY29sdW1uKSB7XG4gICAgICAgICAgICBjb2x1bW4uc2V0Q2VsbFByb3BlcnRpZXMoeSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGh5cGVyZ3JpZC5cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICBnZXRVbmZpbHRlcmVkUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0VW5maWx0ZXJlZFJvd0NvdW50KCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaGVpZ2h0IGluIHBpeGVscyBvZiB0aGUgZml4ZWQgcm93cyBhcmVhICBvZiB0aGUgaHlwZXJncmlkLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93c0hlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuICAgICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRvdGFsID0gdG90YWwgKyB0aGlzLmdldFJvd0hlaWdodChpKTtcbiAgICAgICAgfVxuICAgICAgICAvL3ZhciBmb290ZXJIZWlnaHQgPSB0aGlzLmdldERlZmF1bHRSb3dIZWlnaHQoKTtcbiAgICAgICAgLy90b3RhbCA9IHRvdGFsICsgKGZvb3RlckhlaWdodCAqIHRoaXMuZ2V0Rm9vdGVyUm93Q291bnQoKSk7XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGhlaWdodCBpbiBwaXhlbHMgb2YgYSBzcGVjaWZpYyByb3cgaW4gdGhlIGh5cGVyZ3JpZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93TnVtIC0gcm93IGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0Um93SGVpZ2h0OiBmdW5jdGlvbihyb3dOdW0pIHtcbiAgICAgICAgdmFyIHJvd0hlaWdodHMgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpLnJvd0hlaWdodHM7XG4gICAgICAgIHJldHVybiByb3dIZWlnaHRzICYmIHJvd0hlaWdodHNbcm93TnVtXSB8fCB0aGlzLmdldERlZmF1bHRSb3dIZWlnaHQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSB2YWx1ZSBpcyBsYXppbHkgaW5pdGlhbGl6ZWQgYW5kIGNvbWVzIGZyb20gdGhlIHByb3BlcnRpZXMgbWVjaGFuaXNtIGZvciAnYGRlZmF1bHRSb3dIZWlnaHRgJywgd2hpY2ggc2hvdWxkIGJlIH4yMHB4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByb3cgaGVpZ2h0IGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0Um93SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlZmF1bHRSb3dIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFJvd0hlaWdodCA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdkZWZhdWx0Um93SGVpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFJvd0hlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgcGl4ZWwgaGVpZ2h0IG9mIGEgc3BlY2lmaWMgcm93XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd051bSAtIHRoZSByb3cgaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gcGl4ZWwgaGVpZ2h0XG4gICAgICovXG4gICAgc2V0Um93SGVpZ2h0OiBmdW5jdGlvbihyb3dOdW0sIGhlaWdodCkge1xuICAgICAgICB2YXIgdGFibGVTdGF0ZSA9IHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgICAgIHRhYmxlU3RhdGUucm93SGVpZ2h0c1tyb3dOdW1dID0gTWF0aC5tYXgoNSwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoaXMgd2lsbCBhbGxvdyAnZmxvYXRpbmcnIGZpeGVkIHJvd3MuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWF4aW11bSBoZWlnaHQgb2YgdGhlIGZpeGVkIHJvd3MgYXJlYSBpbiB0aGUgaHlwZXJncmlkLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93c01heEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpeGVkUm93c0hlaWdodCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIGZpeGVkIGNvbHVtbiBhcmVhIGluIHRoZSBoeXBlcmdyaWQuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRDb2x1bW5zV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCkpIHtcbiAgICAgICAgICAgIHRvdGFsID0gdGhpcy5nZXRDb2x1bW5XaWR0aCgtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB0b3RhbCA9IHRvdGFsICsgdGhpcy5nZXRDb2x1bW5XaWR0aChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGlzIGV4aXN0cyB0byBzdXBwb3J0IFwiZmxvYXRpbmdcIiBjb2x1bW5zLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRvdGFsIHdpZHRoIG9mIHRoZSBmaXhlZCBjb2x1bW5zIGFyZWEuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRDb2x1bW5zTWF4V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaXhlZENvbHVtbnNXaWR0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gdmVydGljYWwgZGltZW5zaW9uIGFuZCBub3RpZnkgbGlzdGVuZXJzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIG5ldyB5IHZhbHVlXG4gICAgICovXG4gICAgX3NldFNjcm9sbFBvc2l0aW9uWTogZnVuY3Rpb24oeSkge1xuICAgICAgICB0aGlzLnNldFNjcm9sbFBvc2l0aW9uWSh5KTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiBpbiBob3Jpem9udGFsIGRpbWVuc2lvbiBhbmQgbm90aWZ5IGxpc3RlbmVycy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBuZXcgeCB2YWx1ZVxuICAgICAqL1xuICAgIF9zZXRTY3JvbGxQb3NpdGlvblg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxQb3NpdGlvblgoeCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBudW1iZXIgb2YgY29sdW1ucyBqdXN0IHJlbmRlcmVkLCBpbmNsdWRpbmcgcGFydGlhbGx5IHJlbmRlcmVkIGNvbHVtbnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gaG93IG1hbnkgY29sdW1ucyB3ZXJlIGp1c3QgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBzZXRSZW5kZXJlZENvbHVtbkNvdW50OiBmdW5jdGlvbihjb3VudCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVkQ29sdW1uQ291bnQgPSBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNldCB0aGUgbnVtYmVyIG9mIHJvd3MganVzdCByZW5kZXJlZCwgaW5jbHVkaW5nIHBhcnRpYWxseSByZW5kZXJlZCByb3dzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIGhvdyBtYW55IHJvd3Mgd2VyZSBqdXN0IHJlbmRlcmVkXG4gICAgICovXG4gICAgc2V0UmVuZGVyZWRSb3dDb3VudDogZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZFJvd0NvdW50ID0gY291bnQ7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSBmaXhlZCByb3cgYXJlYSBoYXMgYmVlbiBjbGlja2VkLCBtYXNzYWdlIHRoZSBkZXRhaWxzIGFuZCBjYWxsIHRoZSByZWFsIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIF9maXhlZFJvd0NsaWNrZWQ6IGZ1bmN0aW9uKGdyaWQsIG1vdXNlKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy50cmFuc2xhdGVDb2x1bW5JbmRleCh0aGlzLmdldFNjcm9sbFBvc2l0aW9uWCgpICsgbW91c2UuZ3JpZENlbGwueCAtIHRoaXMuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpKTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZWRQb2ludCA9IHRoaXMuZ3JpZC5uZXdQb2ludCh4LCBtb3VzZS5ncmlkQ2VsbC55KTtcbiAgICAgICAgbW91c2UuZ3JpZENlbGwgPSB0cmFuc2xhdGVkUG9pbnQ7XG4gICAgICAgIHRoaXMuZml4ZWRSb3dDbGlja2VkKGdyaWQsIG1vdXNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSBmaXhlZCBjb2x1bW4gYXJlYSBoYXMgYmVlbiBjbGlja2VkLCBtYXNzYWdlIHRoZSBkZXRhaWxzIGFuZCBjYWxsIHRoZSByZWFsIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIF9maXhlZENvbHVtbkNsaWNrZWQ6IGZ1bmN0aW9uKGdyaWQsIG1vdXNlKSB7XG4gICAgICAgIHZhciB0cmFuc2xhdGVkUG9pbnQgPSB0aGlzLmdyaWQubmV3UG9pbnQobW91c2UuZ3JpZENlbGwueCwgdGhpcy5nZXRTY3JvbGxQb3NpdGlvblkoKSArIG1vdXNlLmdyaWRDZWxsLnkgLSB0aGlzLmdldEZpeGVkUm93Q291bnQoKSk7XG4gICAgICAgIG1vdXNlLmdyaWRDZWxsID0gdHJhbnNsYXRlZFBvaW50O1xuICAgICAgICB0aGlzLmZpeGVkQ29sdW1uQ2xpY2tlZChncmlkLCBtb3VzZSk7XG4gICAgfSxcblxuICAgIG1vdmVTaW5nbGVTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIHgsIHkpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIHNldHRpbmcgdGhlIGN1cnNvciB1cCB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2V0Q3Vyc29yOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGdyaWQudXBkYXRlQ3Vyc29yKCk7XG4gICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLnNldEN1cnNvcihncmlkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIG1vdXNlIG1vdmUgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyB0YXAgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25DbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgdGFwIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uQ29udGV4dE1lbnU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBwcm9jZWVkID0gZ3JpZC5maXJlU3ludGhldGljQ29udGV4dE1lbnVFdmVudChldmVudCk7XG4gICAgICAgIGlmIChwcm9jZWVkICYmIHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVDb250ZXh0TWVudShncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgd2hlZWwgbW92ZWQgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25XaGVlbE1vdmVkOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZVdoZWVsTW92ZWQoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIG1vdXNlIHVwIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBtb3VzZSBkcmFnIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcga2V5IGRvd24gdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25LZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIGtleSB1cCB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbktleVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZUtleVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBkb3VibGUgY2xpY2sgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Eb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVEb3VibGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgZG91YmxlIGNsaWNrIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3B0aW9uc10gLSBGb3J3YXJkZWQgdG8gZGlhbG9nIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIG9wZW5EaWFsb2c6IGZ1bmN0aW9uKGRpYWxvZ05hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBkaWFsb2dzW2RpYWxvZ05hbWVdKHRoaXMuZ3JpZCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBtb3VzZSBkb3duIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIG1vdXNlIGV4aXQgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VFeGl0OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZU1vdXNlRXhpdChncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyByZXBsYWNlZCBieSB0aGUgZ3JpZCBvbiBpbml0aWFsaXphdGlvbiBhbmQgc2VydmVzIGFzIHRoZSBjYWxsYmFja1xuICAgICAqL1xuICAgIGNoYW5nZWQ6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyByZXBsYWNlZCBieSB0aGUgZ3JpZCBvbiBpbml0aWFsaXphdGlvbiBhbmQgc2VydmVzIGFzIHRoZSBjYWxsYmFja1xuICAgICAqL1xuICAgIHNoYXBlQ2hhbmdlZDogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBDYW4gcmUtb3JkZXIgY29sdW1ucy5cbiAgICAgKi9cbiAgICBpc0NvbHVtblJlb3JkZXJhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwcm9wZXJ0aWVzIGZvciBhIHNwZWNpZmljIGNvbHVtbi4gVGhlc2UgYXJlIHVzZWQgaWYgbm8gY2VsbCBwcm9wZXJ0aWVzIGFyZSBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHtpbmRleH0gY29sdW1uSW5kZXggLSB0aGUgY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0Q29sdW1uUHJvcGVydGllczogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuY29sdW1uc1tjb2x1bW5JbmRleF07XG4gICAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNOdWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gY29sdW1uLmdldFByb3BlcnRpZXMoKTsgLy9UT0RPOiByZXR1cm5zIGBudWxsYCBvbiBIeXBlcmdyaWQucHJvdG90eXBlLnJlc2V0KCk7XG4gICAgICAgIGlmICghcHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIGlzTnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9LFxuXG4gICAgc2V0Q29sdW1uUHJvcGVydGllczogZnVuY3Rpb24oY29sdW1uSW5kZXgsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuYWxsQ29sdW1uc1tjb2x1bW5JbmRleF07XG4gICAgICAgIHZhciBjb2x1bW5Qcm9wZXJ0aWVzID0gY29sdW1uLmdldFByb3BlcnRpZXMoKTtcbiAgICAgICAgXyhjb2x1bW5Qcm9wZXJ0aWVzKS5leHRlbmRPd24ocHJvcGVydGllcyk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGNlbGwgcHJvcGVydGllcyBvZiBnaXZlbiBjb2x1bW4gb3Igb2YgYWxsIGNvbHVtbnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb2x1bW5JbmRleF0gLSBPbWl0IGZvciBhbGwgY29sdW1ucy5cbiAgICAgKi9cbiAgICBjbGVhckFsbENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICBpZiAoY29sdW1uSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuYWxsQ29sdW1ucy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsQ29sdW1uc1tpXS5jbGVhckFsbENlbGxQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5hbGxDb2x1bW5zW2ldO1xuICAgICAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIGNvbHVtbi5jbGVhckFsbENlbGxQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlYnVpbGQgdGhlIGNvbHVtbiBvcmRlciBpbmRleGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29sdW1uSW5kZXhlcyAtIGxpc3Qgb2YgY29sdW1uIGluZGV4ZXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIC0gd2hldGhlciB0byB0cmlnZ2VyIGNvbHVtbiBjaGFuZ2VkIGV2ZW50XG4gICAgICovXG4gICAgc2V0Q29sdW1uSW5kZXhlczogZnVuY3Rpb24oY29sdW1uSW5kZXhlcywgc2lsZW50KSB7XG4gICAgICAgIHZhciB0YWJsZVN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICAgICAgdGhpcy5fc2V0Q29sdW1uT3JkZXIoY29sdW1uSW5kZXhlcyk7XG4gICAgICAgIHRhYmxlU3RhdGUuY29sdW1uSW5kZXhlcyA9IGNvbHVtbkluZGV4ZXM7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmZpcmVTeW50aGV0aWNPbkNvbHVtbnNDaGFuZ2VkRXZlbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7c3RyaW5nW119IEFsbCB0aGUgY3VycmVudGx5IGhpZGRlbiBjb2x1bW4gaGVhZGVyIGxhYmVscy5cbiAgICAgKi9cbiAgICBnZXRIaWRkZW5Db2x1bW5EZXNjcmlwdG9yczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0YWJsZVN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICAgICAgdmFyIGluZGV4ZXMgPSB0YWJsZVN0YXRlLmNvbHVtbkluZGV4ZXM7XG4gICAgICAgIHZhciBsYWJlbHMgPSBbXTtcbiAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gdGhpcy5nZXRBY3RpdmVDb2x1bW5Db3VudCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbmRleGVzLmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0QWN0aXZlQ29sdW1uKGkpO1xuICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcjogY29sdW1uLmhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGNvbHVtbi5uYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhpZGUgY29sdW1ucyB0aGF0IGFyZSBzcGVjaWZpZWQgYnkgdGhlaXIgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5T2ZJbmRleGVzIC0gYW4gYXJyYXkgb2YgY29sdW1uIGluZGV4ZXMgdG8gaGlkZVxuICAgICAqL1xuICAgIGhpZGVDb2x1bW5zOiBmdW5jdGlvbihhcnJheU9mSW5kZXhlcykge1xuICAgICAgICB2YXIgdGFibGVTdGF0ZSA9IHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgICAgIHZhciBvcmRlciA9IHRhYmxlU3RhdGUuY29sdW1uSW5kZXhlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mSW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVhY2ggPSBhcnJheU9mSW5kZXhlc1tpXTtcbiAgICAgICAgICAgIGlmIChvcmRlci5pbmRleE9mKGVhY2gpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG9yZGVyLnNwbGljZShvcmRlci5pbmRleE9mKGVhY2gpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7aW50ZWdlcn0gVGhlIG51bWJlciBvZiBmaXhlZCBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQcml2YXRlU3RhdGUoKS5maXhlZENvbHVtbkNvdW50IHx8IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIG51bWJlciBvZiBmaXhlZCBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gLSB0aGUgaW50ZWdlciBjb3VudCBvZiBob3cgbWFueSBjb2x1bW5zIHRvIGJlIGZpeGVkXG4gICAgICovXG4gICAgc2V0Rml4ZWRDb2x1bW5Db3VudDogZnVuY3Rpb24obikge1xuICAgICAgICB0aGlzLmdldFByaXZhdGVTdGF0ZSgpLmZpeGVkQ29sdW1uQ291bnQgPSBuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7aW50ZWdlcn0gVGhlIG51bWJlciBvZiBmaXhlZCByb3dzLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudGFibGVTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIHVzZXJzU2l6ZSA9IHRoaXMudGFibGVTdGF0ZS5maXhlZFJvd0NvdW50IHx8IDA7XG4gICAgICAgIHJldHVybiBoZWFkZXJzICsgdXNlcnNTaXplO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBudW1iZXIgb2YgZml4ZWQgcm93cywgd2hpY2ggaW5jbHVkZXMgKHRvcCB0byBib3R0b20gb3JkZXIpOlxuICAgICAqIDEuIFRoZSBoZWFkZXIgcm93c1xuICAgICAqICAgIDEuIFRoZSBoZWFkZXIgbGFiZWxzIHJvdyAob3B0aW9uYWwpXG4gICAgICogICAgMi4gVGhlIGZpbHRlciByb3cgKG9wdGlvbmFsKVxuICAgICAqICAgIDMuIFRoZSB0b3AgdG90YWwgcm93cyAoMCBvciBtb3JlKVxuICAgICAqIDIuIFRoZSBub24tc2Nyb2xsaW5nIHJvd3MgKGV4dGVybmFsbHkgY2FsbGVkIFwidGhlIGZpeGVkIHJvd3NcIilcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFN1bSBvZiB0aGUgYWJvdmUgb3IgMCBpZiBub25lIG9mIHRoZSBhYm92ZSBhcmUgaW4gdXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gLSBUaGUgbnVtYmVyIG9mIHJvd3MuXG4gICAgICovXG4gICAgc2V0Rml4ZWRSb3dDb3VudDogZnVuY3Rpb24obikge1xuICAgICAgICB0aGlzLnRhYmxlU3RhdGUuZml4ZWRSb3dDb3VudCA9IG47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgaGVhZGVyIHJvd3MuXG4gICAgICogQSBwb3J0aW9uIG9mIHRoZSBudW1iZXIgcmV0dXJuZWQgYnkge0BsaW5rIEJlaGF2aW9yI2dldEZpeGVkUm93Q291bnQoKXxnZXRGaXhlZFJvd0NvdW50KCl9LlxuICAgICAqIChUaGUgcmVtYWluaW5nIF9maXhlZCByb3dzXyBhcmUgdGhlIF90b3AgdG90YWxzXyByb3dzLilcbiAgICAgKi9cbiAgICBnZXRIZWFkZXJSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLmdyaWQuaXNTaG93SGVhZGVyUm93KCkgPyAxIDogMDtcbiAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMuZ3JpZC5pc1Nob3dGaWx0ZXJSb3coKSA/IDEgOiAwO1xuICAgICAgICB2YXIgdG90YWxzID0gdGhpcy5nZXRUb3BUb3RhbHMoKS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBoZWFkZXIgKyBmaWx0ZXIgKyB0b3RhbHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZm9vdGVyIHJvd3MsIGNvbnNpc3RpbmcgZW50aXJlbHkgb2YgMCBvciBtb3JlIF9ib3R0b20gdG90YWxzXyByb3dzLlxuICAgICAqL1xuICAgIGdldEZvb3RlclJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm90dG9tVG90YWxzKCkubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBnZXRUb3BUb3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0VG9wVG90YWxzKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSBudW1iZXIgb2YgaGVhZGVyIHJvd3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gLSBUaGUgbnVtYmVyIG9mIF9maXhlZCByb3dzXyB0byByZXNlcnZlIGFzIGhlYWRlciByb3dzLlxuICAgICAqIChUaGUgcmVtYWluaW5nIF9maXhlZCByb3dzXyBhcmUgdGhlIF90b3AgdG90YWxzXyByb3dzLilcbiAgICAgKi9cbiAgICBzZXRIZWFkZXJSb3dDb3VudDogZnVuY3Rpb24obikge1xuICAgICAgICB0aGlzLnRhYmxlU3RhdGUuaGVhZGVyUm93Q291bnQgPSBuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIHJvd3MuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnJlc29sdmVQcm9wZXJ0eSgnaGVhZGVyQ29sdW1uQ291bnQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIHJvd3MuXG4gICAgICovXG4gICAgc2V0SGVhZGVyQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKG51bWJlck9mSGVhZGVyQ29sdW1ucykge1xuICAgICAgICB0aGlzLnRhYmxlU3RhdGUuaGVhZGVyQ29sdW1uQ291bnQgPSBudW1iZXJPZkhlYWRlckNvbHVtbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhIGRuZCBjb2x1bW4gaGFzIGp1c3QgYmVlbiBkcm9wcGVkLCB3ZSd2ZSBiZWVuIG5vdGlmaWVkXG4gICAgICovXG4gICAgZW5kRHJhZ0NvbHVtbk5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudWxsfSB0aGUgY3Vyc29yIGF0IGEgc3BlY2lmaWMgeCx5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBnZXRDdXJzb3JBdDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIF92aXNpYmxlXyBjb2x1bW5zLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB0b3RhbCBudW1iZXIgb2YgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnMubGVuZ3RoO1xuICAgIH0sXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ2dldENvbHVtbkNvdW50KCknLCAnZ2V0QWN0aXZlQ29sdW1uQ291bnQoKScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb2x1bW4gYWxpZ25tZW50IGF0IGNvbHVtbiBgeGA6IGAnbGVmdCdgLCBgJ2NlbnRlcidgICwgb3IgYCdyaWdodCdgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgY29sdW1uIGluZGV4IG9mIGludGVyZXN0LlxuICAgICAqL1xuICAgIGdldENvbHVtbkFsaWdubWVudDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBRdWlldGx5IHNldCB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgbmV3IHBvc2l0aW9uIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBzZXRTY3JvbGxQb3NpdGlvblg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb25YID0geDtcbiAgICB9LFxuXG4gICAgZ2V0U2Nyb2xsUG9zaXRpb25YOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsUG9zaXRpb25YO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgUXVpZXRseSBzZXQgdGhlIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBuZXcgcG9zaXRpb24gaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIHNldFNjcm9sbFBvc2l0aW9uWTogZnVuY3Rpb24oeSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvblkgPSB5O1xuICAgIH0sXG5cbiAgICBnZXRTY3JvbGxQb3NpdGlvblk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxQb3NpdGlvblk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtjZWxsRWRpdG9yfSBUaGUgY2VsbCBlZGl0b3IgZm9yIHRoZSBjZWxsIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBlZGl0UG9pbnQgLSBUaGUgZ3JpZCBjZWxsIGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIGdldENlbGxFZGl0b3JBdDogZnVuY3Rpb24oZWRpdFBvaW50KSB7XG4gICAgICAgIHZhciBjZWxsRWRpdG9yLCBvcHRpb25zLFxuICAgICAgICAgICAgY29sdW1uID0gdGhpcy5nZXRBY3RpdmVDb2x1bW4oZWRpdFBvaW50LngpO1xuXG4gICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgZWRpdFBvaW50OiBlZGl0UG9pbnRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNlbGxFZGl0b3IgPSB0aGlzLmdyaWQuaXNGaWx0ZXJSb3coZWRpdFBvaW50LnkpXG4gICAgICAgICAgICAgICAgPyB0aGlzLmdyaWQuY2VsbEVkaXRvcnMuY3JlYXRlKCdmaWx0ZXJib3gnLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIDogY29sdW1uLmdldENlbGxFZGl0b3JBdChlZGl0UG9pbnQueSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2VsbEVkaXRvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBrZXlzXG4gICAgICovXG4gICAgdG9nZ2xlU29ydDogZnVuY3Rpb24oeCwga2V5cykge1xuICAgICAgICB0aGlzLmdldEFjdGl2ZUNvbHVtbih4KS50b2dnbGVTb3J0KGtleXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHdlIHNob3VsZCBoaWdobGlnaHQgb24gaG92ZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQ29sdW1uSG92ZXJlZCAtIHRoZSBjb2x1bW4gaXMgaG92ZXJlZCBvciBub3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUm93SG92ZXJlZCAtIHRoZSByb3cgaXMgaG92ZXJlZCBvciBub3RcbiAgICAgKi9cbiAgICBoaWdobGlnaHRDZWxsT25Ib3ZlcjogZnVuY3Rpb24oaXNDb2x1bW5Ib3ZlcmVkLCBpc1Jvd0hvdmVyZWQpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29sdW1uSG92ZXJlZCAmJiBpc1Jvd0hvdmVyZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIGEgaG9vayBhbmQgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBwYWludGluZyBvZiBhIGNlbGwgb2NjdXJzXG4gICAgICogQHBhcmFtIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fSBjZWxsXG4gICAgICovXG4gICAgY2VsbFByb3BlcnRpZXNQcmVQYWludE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oY2VsbCkge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIGEgaG9vayBhbmQgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBwYWludGluZyBvZiBhIGZpeGVkIHJvdyBjZWxsIG9jY3Vyc1xuICAgICAqIEBwYXJhbSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH0gY2VsbFxuICAgICAqL1xuICAgIGNlbGxGaXhlZFJvd1ByZVBhaW50Tm90aWZpY2F0aW9uOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gaXMgYSBob29rIGFuZCBpcyBjYWxsZWQganVzdCBiZWZvcmUgdGhlIHBhaW50aW5nIG9mIGEgZml4ZWQgY29sdW1uIGNlbGwgb2NjdXJzXG4gICAgICogQHBhcmFtIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fSBjZWxsXG4gICAgICovXG4gICAgY2VsbEZpeGVkQ29sdW1uUHJlUGFpbnROb3RpZmljYXRpb246IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyBhIGhvb2sgYW5kIGlzIGNhbGxlZCBqdXN0IGJlZm9yZSB0aGUgcGFpbnRpbmcgb2YgYSB0b3AgbGVmdCBjZWxsIG9jY3Vyc1xuICAgICAqIEBwYXJhbSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH0gY2VsbFxuICAgICAqL1xuICAgIGNlbGxUb3BMZWZ0UHJlUGFpbnROb3RpZmljYXRpb246IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBlbmhhbmNlIHRoZSBkb3VibGUgY2xpY2sgZXZlbnQganVzdCBiZWZvcmUgaXQncyBicm9hZGNhc3QgdG8gbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gZXZlbnQgdG8gZW5oYW5jZVxuICAgICAqL1xuICAgIGVuaGFuY2VEb3VibGVDbGlja0V2ZW50OiBmdW5jdGlvbihldmVudCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc3dhcCBzcmMgYW5kIHRhciBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyYyAtIGNvbHVtbiBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXIgLSBjb2x1bW4gaW5kZXhcbiAgICAgKi9cbiAgICBzd2FwQ29sdW1uczogZnVuY3Rpb24oc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSB0aGlzLmNvbHVtbnM7XG4gICAgICAgIHZhciB0bXAgPSBjb2x1bW5zW3NvdXJjZV07XG4gICAgICAgIGNvbHVtbnNbc291cmNlXSA9IGNvbHVtbnNbdGFyZ2V0XTtcbiAgICAgICAgY29sdW1uc1t0YXJnZXRdID0gdG1wO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uRWRnZTogZnVuY3Rpb24oYywgcmVuZGVyZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldENvbHVtbkVkZ2UoYywgcmVuZGVyZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBjb2x1bW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRvdGFscyByb3cgaW5kZXggbG9jYWwgdG8gdGhlIHRvdGFscyBhcmVhXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW2FyZWFzPVsndG9wJywgJ2JvdHRvbSddXSAtIG1heSBpbmNsdWRlIGAndG9wJ2AgYW5kL29yIGAnYm90dG9tJ2BcbiAgICAgKi9cbiAgICBzZXRUb3RhbHNWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUsIGFyZWFzKSB7XG4gICAgICAgIHRoaXMuZ3JpZC5zZXRUb3RhbHNWYWx1ZU5vdGlmaWNhdGlvbih4LCB5LCB2YWx1ZSwgYXJlYXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgb2JqZWN0IGF0IHkgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgcm93IGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRSb3coeSk7XG4gICAgfSxcblxuICAgIGNvbnZlcnRWaWV3UG9pbnRUb0RhdGFQb2ludDogZnVuY3Rpb24odmlld1BvaW50KSB7XG4gICAgICAgIHZhciBuZXdYID0gdGhpcy5nZXRBY3RpdmVDb2x1bW4odmlld1BvaW50LngpLmluZGV4O1xuICAgICAgICB2YXIgbmV3UG9pbnQgPSB0aGlzLmdyaWQubmV3UG9pbnQobmV3WCwgdmlld1BvaW50LnkpO1xuICAgICAgICByZXR1cm4gbmV3UG9pbnQ7XG4gICAgfSxcblxuICAgIHNldEdyb3VwczogZnVuY3Rpb24oYXJyYXlPZkNvbHVtbkluZGV4ZXMpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0R3JvdXBzKGFycmF5T2ZDb2x1bW5JbmRleGVzKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBzZXRBZ2dyZWdhdGVzOiBmdW5jdGlvbihtYXBPZktleXNUb0Z1bmN0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldEFnZ3JlZ2F0ZXMobWFwT2ZLZXlzVG9GdW5jdGlvbnMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuY2hhbmdlZCgpO1xuICAgICAgICB9LCAxMDApO1xuICAgIH0sXG5cbiAgICBoYXNIaWVyYXJjaHlDb2x1bW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHNldFJlbGF0aW9uOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldFJlbGF0aW9uKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNoYXBlQ2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBnZXRSb3dDb250ZXh0RnVuY3Rpb246IGZ1bmN0aW9uKHNlbGVjdGVkUm93cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0aW9uTWF0cml4RnVuY3Rpb246IGZ1bmN0aW9uKHNlbGVjdGVkUm93cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0Q29tcHV0ZWRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldENvbXB1dGVkUm93KHkpO1xuICAgIH0sXG5cbiAgICBhdXRvc2l6ZUFsbENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNoZWNrQ29sdW1uQXV0b3NpemluZyh0cnVlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIGNoZWNrQ29sdW1uQXV0b3NpemluZzogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgZm9yY2UgPSBmb3JjZSA9PT0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hdXRvU2l6ZVJvd051bWJlckNvbHVtbigpO1xuICAgICAgICB0aGlzLmFsbENvbHVtbnNbLTJdLmNoZWNrQ29sdW1uQXV0b3NpemluZyhmb3JjZSk7XG4gICAgICAgIHRoaXMuYWxsQ29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgY29sdW1uLmNoZWNrQ29sdW1uQXV0b3NpemluZyhmb3JjZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBhdXRvU2l6ZVJvd051bWJlckNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmdyaWQuaXNSb3dOdW1iZXJBdXRvc2l6aW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsQ29sdW1uc1stMV0uY2hlY2tDb2x1bW5BdXRvc2l6aW5nKHRydWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldE5ld0ZpbHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuZXdGaWx0ZXIgPSBuZXcgRGVmYXVsdEZpbHRlcih7XG4gICAgICAgICAgICBzY2hlbWE6IHR5cGVvZiB0aGlzLnNjaGVtYSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuc2NoZW1hKHRoaXMuY29sdW1ucykgOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmVDb2x1bW5OYW1lczogdGhpcy5ncmlkLnJlc29sdmVQcm9wZXJ0eSgnZmlsdGVyQ2FzZVNlbnNpdGl2ZUNvbHVtbk5hbWVzJyksXG4gICAgICAgICAgICByZXNvbHZlQWxpYXNlczogdGhpcy5ncmlkLnJlc29sdmVQcm9wZXJ0eSgnZmlsdGVyUmVzb2x2ZUFsaWFzZXMnKSxcbiAgICAgICAgICAgIGRlZmF1bHRDb2x1bW5GaWx0ZXJPcGVyYXRvcjogdGhpcy5ncmlkLnJlc29sdmVQcm9wZXJ0eSgnZmlsdGVyRGVmYXVsdENvbHVtbkZpbHRlck9wZXJhdG9yJylcbiAgICAgICAgfSk7XG4gICAgICAgIG5ld0ZpbHRlci5sb2FkQ29sdW1uUHJvcGVydGllc0Zyb21TY2hlbWEodGhpcy5jb2x1bW5zKTtcbiAgICAgICAgcmV0dXJuIG5ld0ZpbHRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBmaWx0ZXIgYXR0YWNoZWQgdG8gdGhlIEh5cGVyZ3JpZC5cbiAgICAgKiBAcmV0dXJucyB7RmlsdGVyVHJlZX1cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0R2xvYmFsRmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldEdsb2JhbEZpbHRlcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBdHRhY2gvZGV0YWNoIGEgZmlsdGVyIHRvIGEgSHlwZXJncmlkLlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZX0gW2ZpbHRlcl0gLSBUaGUgZmlsdGVyIG9iamVjdC4gSWYgdW5kZWZpbmVkLCBhbnkgYXR0YWNoZWQgZmlsdGVyIGlzIHJlbW92ZWQsIHR1cm5pbmcgZmlsdGVyaW5nIE9GRi5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0R2xvYmFsRmlsdGVyOiBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0R2xvYmFsRmlsdGVyKGZpbHRlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNldCB0aGUgY2FzZSBzZW5zaXRpdml0eSBvZiBmaWx0ZXIgdGVzdHMgYWdhaW5zdCBkYXRhLlxuICAgICAqIEBkZXNjIENhc2Ugc2Vuc2l0aXZpdHkgcGVydGFpbnMgdG8gc3RyaW5nIGNvbXBhcmVzIG9ubHkuIFRoaXMgaW5jbHVkZXMgdW50eXBlZCBjb2x1bW5zLCBjb2x1bW5zIHR5cGVkIGFzIHN0cmluZ3MsIHR5cGVkIGNvbHVtbnMgY29udGFpbmluZyBkYXRhIHRoYXQgY2Fubm90IGJlIGNvZXJjZWQgdG8gdHlwZSBvciB3aGVuIHRoZSBmaWx0ZXIgZXhwcmVzc2lvbiBvcGVyYW5kIGNhbm5vdCBiZSBjb2VyY2VkLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBhIHNoYXJlZCBwcm9wZXJ0eSBhbmQgYWZmZWN0cyBhbGwgZ3JpZCBtYW5hZ2VkIGJ5IHRoaXMgaW5zdGFuY2Ugb2YgdGhlIGFwcC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU2Vuc2l0aXZlXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldEdsb2JhbEZpbHRlckNhc2VTZW5zaXRpdml0eTogZnVuY3Rpb24oaXNTZW5zaXRpdmUpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0R2xvYmFsRmlsdGVyQ2FzZVNlbnNpdGl2aXR5KGlzU2Vuc2l0aXZlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBjb2x1bW5JbmRleE9yTmFtZSAtIFRoZSBfY29sdW1uIGZpbHRlcl8gdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZUdldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyB7QGxpbmsgRGVmYXVsdEZpbHRlciNnZXRTdGF0ZXxnZXRTdGF0ZX0gbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc3ludGF4PSdDUUwnXSAtIFRoZSBzeW50YXggdG8gdXNlIHRvIGRlc2NyaWJlIHRoZSBmaWx0ZXIgc3RhdGUuIE5vdGUgdGhhdCBgZ2V0RmlsdGVyYCdzIGRlZmF1bHQgc3ludGF4LCBgJ0NRTCdgLCBkaWZmZXJzIGZyb20gdGhlIG90aGVyIGdldCBzdGF0ZSBtZXRob2RzLlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9XG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldEZpbHRlcjogZnVuY3Rpb24oY29sdW1uSW5kZXhPck5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldEZpbHRlcihjb2x1bW5JbmRleE9yTmFtZSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNldCBhIHBhcnRpY3VsYXIgY29sdW1uIGZpbHRlcidzIHN0YXRlLlxuICAgICAqIEBkZXNjIEFmdGVyIHNldHRpbmcgdGhlIG5ldyBmaWx0ZXIgc3RhdGUsIHJlYXBwbGllcyB0aGUgZmlsdGVyIHRvIHRoZSBkYXRhIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGNvbHVtbkluZGV4T3JOYW1lIC0gVGhlIF9jb2x1bW4gZmlsdGVyXyB0byBzZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBbc3RhdGVdIC0gQSBmaWx0ZXIgdHJlZSBvYmplY3Qgb3IgYSBKU09OLCBTUUwsIG9yIENRTCBzdWJleHByZXNzaW9uIHN0cmluZyB0aGF0IGRlc2NyaWJlcyB0aGUgYSBuZXcgc3RhdGUgZm9yIHRoZSBuYW1lZCBjb2x1bW4gZmlsdGVyLiBUaGUgZXhpc3RpbmcgY29sdW1uIGZpbHRlciBzdWJleHByZXNzaW9uIGlzIHJlcGxhY2VkIHdpdGggYSBuZXcgbm9kZSBiYXNlZCBvbiB0aGlzIHN0YXRlLiBJZiBpdCBkb2VzIG5vdCBleGlzdCwgdGhlIG5ldyBzdWJleHByZXNzaW9uIGlzIGFkZGVkIHRvIHRoZSBjb2x1bW4gZmlsdGVycyBzdWJ0cmVlIChgZmlsdGVyLmNvbHVtbkZpbHRlcnNgKS5cbiAgICAgKlxuICAgICAqIElmIHVuZGVmaW5lZCwgcmVtb3ZlcyB0aGUgZW50aXJlIGNvbHVtbiBmaWx0ZXIgc3ViZXhwcmVzc2lvbiBmcm9tIHRoZSBjb2x1bW4gZmlsdGVycyBzdWJ0cmVlLlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVNldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyBbc2V0U3RhdGVde0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL0ZpbHRlclRyZWUuaHRtbCNzZXRTdGF0ZX0gbWV0aG9kLiBZb3UgbWF5IG1peCBpbiBtZW1iZXJzIG9mIHRoZSB7QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvZ2xvYmFsLmh0bWwjRmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fEZpbHRlclRyZWVWYWxpZGF0aW9uT3B0aW9uc09iamVjdH1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3ludGF4PSdDUUwnXSAtIFRoZSBzeW50YXggdG8gdXNlIHRvIGRlc2NyaWJlIHRoZSBmaWx0ZXIgc3RhdGUuIE5vdGUgdGhhdCBgc2V0RmlsdGVyYCdzIGRlZmF1bHQgc3ludGF4LCBgJ0NRTCdgLCBkaWZmZXJzIGZyb20gdGhlIG90aGVyIGdldCBzdGF0ZSBtZXRob2RzLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8RXJyb3J8c3RyaW5nfSBgdW5kZWZpbmVkYCBpbmRpY2F0ZXMgc3VjY2Vzcy5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0RmlsdGVyOiBmdW5jdGlvbihjb2x1bW5JbmRleE9yTmFtZSwgc3RhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0RmlsdGVyKGNvbHVtbkluZGV4T3JOYW1lLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZUdldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyB7QGxpbmsgRGVmYXVsdEZpbHRlciNnZXRTdGF0ZXxnZXRTdGF0ZX0gbWV0aG9kLlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9XG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldEZpbHRlcnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldEZpbHRlcnMob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVN0YXRlT2JqZWN0fSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVNldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyBbc2V0U3RhdGVde0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL0ZpbHRlclRyZWUuaHRtbCNzZXRTdGF0ZX0gbWV0aG9kLiBZb3UgbWF5IG1peCBpbiBtZW1iZXJzIG9mIHRoZSB7QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvZ2xvYmFsLmh0bWwjRmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fEZpbHRlclRyZWVWYWxpZGF0aW9uT3B0aW9uc09iamVjdH1cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEVycm9yfHN0cmluZ30gYHVuZGVmaW5lZGAgaW5kaWNhdGVzIHN1Y2Nlc3MuXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldEZpbHRlcnM6IGZ1bmN0aW9uKHN0YXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldEZpbHRlcnMoc3RhdGUsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWVHZXRTdGF0ZU9wdGlvbnNPYmplY3R9IFtvcHRpb25zXSAtIFBhc3NlZCB0byB0aGUgZmlsdGVyJ3Mge0BsaW5rIERlZmF1bHRGaWx0ZXIjZ2V0U3RhdGV8Z2V0U3RhdGV9IG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyB7RmlsdGVyVHJlZVN0YXRlT2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRUYWJsZUZpbHRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0VGFibGVGaWx0ZXIob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVN0YXRlT2JqZWN0fSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVNldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyBbc2V0U3RhdGVde0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL0ZpbHRlclRyZWUuaHRtbCNzZXRTdGF0ZX0gbWV0aG9kLiBZb3UgbWF5IG1peCBpbiBtZW1iZXJzIG9mIHRoZSB7QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvZ2xvYmFsLmh0bWwjRmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fEZpbHRlclRyZWVWYWxpZGF0aW9uT3B0aW9uc09iamVjdH1cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEVycm9yfHN0cmluZ30gYHVuZGVmaW5lZGAgaW5kaWNhdGVzIHN1Y2Nlc3MuXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldFRhYmxlRmlsdGVyOiBmdW5jdGlvbihzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXRUYWJsZUZpbHRlcihzdGF0ZSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGVkUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGVkQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0ZWRDb2x1bW5zKCk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXREYXRhKCk7XG4gICAgfSxcblxuICAgIGdldEZpbHRlcmVkRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRGaWx0ZXJlZERhdGEoKTtcbiAgICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmVoYXZpb3I7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcblxudmFyIHByb3BlcnR5TmFtZXMgPSBbXG4gICAgJ2luZGV4JyxcbiAgICAnbmFtZScsXG4gICAgJ2hlYWRlcicsXG4gICAgJ3R5cGUnXG5dO1xuXG4vKiogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IGBDb2x1bW5gIG9iamVjdC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGJlaGF2aW9yXG4gKiBAcGFyYW0ge251bWJlcnxvYmplY3R9IGluZGV4T3JPcHRpb25zIC0gSWYgYSBudW1iZXIsIHNob3J0aGFuZCBmb3IgYG9wdGlvbnMuaW5kZXhgLlxuICpcbiAqIEZvciBwb3NpdGl2ZSB2YWx1ZXMgb2YgYG9wdGlvbnMuaW5kZXhgLCBzZWUge0BsaW5rIENvbHVtbiNpbml0aWFsaXplfGluaXRpYWxpemV9LiBOb3RlIHRoYXQgZm9yIG5ldyBjb2x1bW5zLCB5b3UgbXVzdCBzdXBwbHkgZWl0aGVyIGBpbmRleGAgb3IgYG5hbWVgLiBJZiB5b3Ugc3VwcGx5IGJvdGgsIHRoZXkgbXVzdCBtYXRjaCB0aGUgZGVmaW5pdGlpb24gaW4gZGF0YSBtb2RlbCdzIGBmaWVsZHNgIGxpc3QuXG4gKlxuICogTmVnYXRpdmUgdmFsdWVzIGFyZSBzcGVjaWFsIGNhc2VzOlxuICogYGluZGV4YCB8IE1lYW5pbmdcbiAqIDotLS0tLTogfCAtLS0tLS0tLVxuICogICAgLTEgICB8IFJvdyBoZWFkZXIgY29sdW1uXG4gKiAgICAtMiAgIHwgVHJlZSAoZHJpbGwtZG93bikgY29sdW1uXG4gKlxuICpcbiAqL1xuZnVuY3Rpb24gQ29sdW1uKGJlaGF2aW9yLCBpbmRleE9yT3B0aW9ucykge1xuICAgIHRoaXMuYmVoYXZpb3IgPSBiZWhhdmlvcjtcbiAgICB0aGlzLmRhdGFNb2RlbCA9IGJlaGF2aW9yLmRhdGFNb2RlbDtcbiAgICB0aGlzLmNlbGxQcm9wZXJ0aWVzID0gW107XG5cbiAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBpbmRleE9yT3B0aW9ucyA9PT0gJ29iamVjdCcgPyBpbmRleE9yT3B0aW9ucyA6IHsgaW5kZXg6IGluZGV4T3JPcHRpb25zIH0sXG4gICAgICAgIGluZGV4ID0gb3B0aW9ucy5pbmRleDtcblxuICAgIHN3aXRjaCAoaW5kZXgpIHtcblxuICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gJyc7XG4gICAgICAgICAgICB0aGlzLmhlYWRlciA9ICcnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAtMjpcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICd0cmVlJztcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyID0gJ1RyZWUnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYGluZGV4YCBvdXQgb2YgcmFuZ2UnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgIH1cbn1cblxuQ29sdW1uLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29sdW1uLnByb3RvdHlwZS5jb25zdHJ1Y3RvcixcblxuICAgIC8qKiBAc3VtbWFyeSBTZXQgb3IgcmVzZXQgdGhlIHByb3BlcnRpZXMgb2YgYSBjb2x1bW4gb2JqZWN0LlxuICAgICAqIEBkZXNjIFdoZW4gKHJlKXNldHRpbmcgYSBjb2x1bW4gb2JqZWN0LCB0aGUgb2JqZWN0IG11c3QgZW5kIHVwIHdpdGggZnVsbHkgZGVmaW5lZCBgaW5kZXhgIGFuZCBgbmFtZWAgcHJvcGVydGllcy4gSWYgb25lIGlzIG1pc3NpbmcgaXQgd2lsbCBiZSBkZXJpdmVkIGZyb20gdGhlIGRhdGEgbW9kZWwncyBgZmllbGRzYCBsaXN0LlxuICAgICAqIE5vdGU6IFRoZXNlIHByb3BlcnRpZXMgb2YgdGhlIGNvbHVtbiBvYmplY3Qgc2hvdWxkIG5vdCBiZSBjb25mdXNlZCB3aXRoIHRoZSBtZW1iZXJzIG9mIHRoZSBjb2x1bW5Qcm9wZXJ0aWVzIG9iamVjdCB3aGljaCBzdXBwb3J0cyBncmlkIHJlbmRlciBhbmQgaXMgc29tZXRoaW5nIGVsc2UgZW50aXJlbHkuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBSZXF1aXJlZCBiZWNhdXNlIHlvdSBtdXN0IHN1cHBseSBhdCBsZWFzdCBgaW5kZXhgIG9yIGBuYW1lYC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaW5kZXhdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm5hbWVdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlYWRlcl1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMudHlwZV1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuZGF0YU1vZGVsLmdldEZpZWxkcygpO1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcztcbiAgICAgICAgcHJvcGVydHlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb24gPT09ICduYW1lJykge1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4ubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5uYW1lID0gZmllbGRzW2NvbHVtbi5pbmRleF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2x1bW4uaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uaW5kZXggPSBmaWVsZHMuaW5kZXhPZihjb2x1bW4ubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5pbmRleCA9PT0gdW5kZWZpbmVkIHx8IGNvbHVtbi5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGNvbHVtbiBuYW1lIG9yIGluZGV4Lic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZHNbY29sdW1uLmluZGV4XSAhPT0gY29sdW1uLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIHRvIGZpbmQgYGNvbHVtbi5uYW1lYCBpbiBwb3NpdGlvbiBgY29sdW1uLmluZGV4YCBpbiBkYXRhIG1vZGVsXFwncyBmaWVsZHMgbGlzdC4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNldCBoZWFkZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGVhZGVyID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLmdldEhlYWRlcnMoKVt0aGlzLmluZGV4XSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXQgaGVhZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyO1xuICAgIH0sXG5cbiAgICBnZXRVbmZpbHRlcmVkVmFsdWU6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldFVuZmlsdGVyZWRWYWx1ZSh0aGlzLmluZGV4LCB5KTtcbiAgICB9LFxuXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldFZhbHVlKHRoaXMuaW5kZXgsIHkpO1xuICAgIH0sXG5cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLnNldFZhbHVlKHRoaXMuaW5kZXgsIHksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuZ2V0UHJvcGVydGllcygpO1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcyAmJiBwcm9wZXJ0aWVzLndpZHRoIHx8IHRoaXMuYmVoYXZpb3IucmVzb2x2ZVByb3BlcnR5KCdkZWZhdWx0Q29sdW1uV2lkdGgnKTtcbiAgICB9LFxuXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgIHRoaXMuZ2V0UHJvcGVydGllcygpLndpZHRoID0gTWF0aC5tYXgoNSwgd2lkdGgpO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsUmVuZGVyZXI6IGZ1bmN0aW9uKGNvbmZpZywgeSkge1xuICAgICAgICBjb25maWcueCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIGNvbmZpZy55ID0geTtcblxuICAgICAgICB2YXIgZGVjbGFyZWRSZW5kZXJlck5hbWUgPVxuICAgICAgICAgICAgdGhpcy5nZXRDZWxsUHJvcGVydGllcyh5KS5yZW5kZXJlciB8fFxuICAgICAgICAgICAgdGhpcy5nZXRQcm9wZXJ0aWVzKCkucmVuZGVyZXI7XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5kYXRhTW9kZWwuZ2V0Q2VsbChjb25maWcsIGRlY2xhcmVkUmVuZGVyZXJOYW1lKTtcbiAgICAgICAgcmVuZGVyZXIuY29uZmlnID0gY29uZmlnO1xuICAgICAgICByZXR1cm4gcmVuZGVyZXI7XG4gICAgfSxcblxuICAgIGdldENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHkgPSB0aGlzLmRhdGFNb2RlbC5nZXREYXRhSW5kZXgoeSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxQcm9wZXJ0aWVzW3ldIHx8IHt9O1xuICAgIH0sXG5cbiAgICBzZXRDZWxsUHJvcGVydGllczogZnVuY3Rpb24oeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jZWxsUHJvcGVydGllc1t5XSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICBjbGVhckFsbENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jZWxsUHJvcGVydGllcy5sZW5ndGggPSAwO1xuICAgIH0sXG5cbiAgICBjaGVja0NvbHVtbkF1dG9zaXppbmc6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5nZXRQcm9wZXJ0aWVzKCk7XG4gICAgICAgIHZhciBhLCBiLCBkO1xuICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgYSA9IHByb3BlcnRpZXMud2lkdGg7XG4gICAgICAgICAgICBiID0gcHJvcGVydGllcy5wcmVmZXJyZWRXaWR0aCB8fCBhO1xuICAgICAgICAgICAgZCA9IHByb3BlcnRpZXMuY29sdW1uQXV0b3NpemVkICYmICFmb3JjZTtcbiAgICAgICAgICAgIGlmIChhICE9PSBiIHx8ICFkKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy53aWR0aCA9ICFkID8gYiA6IE1hdGgubWF4KGEsIGIpO1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMuY29sdW1uQXV0b3NpemVkID0gIWlzTmFOKHByb3BlcnRpZXMud2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldENlbGxUeXBlOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoeSk7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlT2YodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9LFxuXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMuZ2V0UHJvcGVydGllcygpO1xuICAgICAgICB2YXIgdHlwZSA9IHByb3BzLnR5cGU7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgdHlwZSA9IHRoaXMuY29tcHV0ZUNvbHVtblR5cGUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSAndW5rbm93bicpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9LFxuXG4gICAgY29tcHV0ZUNvbHVtblR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSB0aGlzLmJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmJlaGF2aW9yLmdldFJvd0NvdW50KCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoaGVhZGVyUm93Q291bnQpO1xuICAgICAgICB2YXIgZWFjaFR5cGUgPSB0aGlzLnR5cGVPZih2YWx1ZSk7XG4gICAgICAgIGlmICghZWFjaFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGVPZih2YWx1ZSk7XG4gICAgICAgIHZhciBpc051bWJlciA9ICgodHlwZW9mIHZhbHVlKSA9PT0gJ251bWJlcicpO1xuICAgICAgICBmb3IgKHZhciB5ID0gaGVhZGVyUm93Q291bnQ7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldFZhbHVlKHkpO1xuICAgICAgICAgICAgZWFjaFR5cGUgPSB0aGlzLnR5cGVPZih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gZWFjaFR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnZmxvYXQnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbWl4ZWQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9LFxuXG4gICAgdHlwZU9mOiBmdW5jdGlvbihzb21ldGhpbmcpIHtcbiAgICAgICAgaWYgKHNvbWV0aGluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZU9mID0gdHlwZW9mIHNvbWV0aGluZztcbiAgICAgICAgc3dpdGNoICh0eXBlT2YpIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvbWV0aGluZy5jb25zdHJ1Y3Rvci5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChzb21ldGhpbmcpID09PSBzb21ldGhpbmcgPyAnaW50JyA6ICdmbG9hdCc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlT2Y7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFByaXZhdGVTdGF0ZSgpLmNvbHVtblByb3BlcnRpZXNbdGhpcy5pbmRleF07XG4gICAgfSxcblxuICAgIHNldFByb3BlcnRpZXM6IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFByb3BlcnRpZXMoKTtcbiAgICAgICAgdGhpcy5jbGVhck9iamVjdFByb3BlcnRpZXMoY3VycmVudCwgZmFsc2UpO1xuICAgICAgICBfKGN1cnJlbnQpLmV4dGVuZE93bihwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlU29ydDogZnVuY3Rpb24oa2V5cykge1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC50b2dnbGVTb3J0KHRoaXMuaW5kZXgsIGtleXMpO1xuICAgIH0sXG5cbiAgICB1blNvcnQ6IGZ1bmN0aW9uKGRlZmVycmVkKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnVuU29ydENvbHVtbih0aGlzLmluZGV4LCBkZWZlcnJlZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGRldGVybWluZXMgdGhlIHByb3Bvc2VkIGNlbGwgZWRpdG9yIG5hbWUgZnJvbSB0aGUgcmVuZGVyIHByb3BlcnRpZXMuIFRoZSBhbGdvcml0aG0gaXM6XG4gICAgICogMS4gYGVkaXRvcmAgcmVuZGVyIHByb3BlcnR5IChjZWxsIGVkaXRvciBuYW1lKVxuICAgICAqIDIuIGBmb3JtYXRgIHJlbmRlciBwcm9wZXJ0eSAobG9jYWxpemVyIG5hbWUpXG4gICAgICogMy4gYHR5cGVgIGNvbHVtbiBwcm9wZXJ0eSAodHlwZSBuYW1lKVxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IFwicmVuZGVyIHByb3BlcnR5XCIgbWVhbnMgaW4gZWFjaCBjYXNlIHRoZSBmaXJzdCBkZWZpbmVkIHByb3BlcnR5IGZvdW5kIG9uIHRoZSBjZWxsLCBjb2x1bW4sIG9yIGdyaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBvcmlnaW5hbCB1bnRyYW5zbGF0ZWQgcm93IGluZGV4LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gV2lsbCBiZSBkZWNvcmF0ZWQgd2l0aCBgZm9ybWF0YCBhbmQgYGNvbHVtbmAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gb3B0aW9ucy5lZGl0UG9pbnRcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfENlbGxFZGl0b3J9IEZhbHN5IHZhbHVlIG1lYW5zIGVpdGhlciBubyBkZWNsYXJlZCBjZWxsIGVkaXRvciBfb3JfIGluc3RhbnRpYXRpb24gYWJvcnRlZCBieSBmYWxzeSByZXR1cm4gcmV0dXJuIGZyb20gZmlyZVJlcXVlc3RDZWxsRWRpdC5cbiAgICAgKi9cbiAgICBnZXRDZWxsRWRpdG9yQXQ6IGZ1bmN0aW9uKHksIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNlbGxFZGl0b3IsXG4gICAgICAgICAgICBjZWxsUHJvcHMgPSB0aGlzLmdldENlbGxQcm9wZXJ0aWVzKHkpLFxuICAgICAgICAgICAgY29sdW1uUHJvcHMgPSB0aGlzLmdldFByb3BlcnRpZXMoKSxcbiAgICAgICAgICAgIGVkaXRvck5hbWUgPSBjZWxsUHJvcHMuZWRpdG9yIHx8IGNvbHVtblByb3BzLmVkaXRvcjtcblxuICAgICAgICBvcHRpb25zLmZvcm1hdCA9IGNlbGxQcm9wcy5mb3JtYXQgfHwgY29sdW1uUHJvcHMuZm9ybWF0O1xuXG4gICAgICAgIGNlbGxFZGl0b3IgPSB0aGlzLmRhdGFNb2RlbC5nZXRDZWxsRWRpdG9yQXQodGhpcy5pbmRleCwgeSwgZWRpdG9yTmFtZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKGNlbGxFZGl0b3IgJiYgIWNlbGxFZGl0b3IuZ3JpZCkge1xuICAgICAgICAgICAgLy8gY2VsbCBlZGl0b3IgcmV0dXJuZWQgYnV0IG5vdCBmdWxseSBpbnN0YW50aWF0ZWQgKGFib3J0ZWQgYnkgZmFsc3kgcmV0dXJuIGZyb20gZmlyZVJlcXVlc3RDZWxsRWRpdClcbiAgICAgICAgICAgIGNlbGxFZGl0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2VsbEVkaXRvcjtcbiAgICB9LFxuXG4gICAgZ2V0Rm9ybWF0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxvY2FsaXplck5hbWUgPSB0aGlzLmdldFByb3BlcnRpZXMoKS5mb3JtYXQ7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdyaWQubG9jYWxpemF0aW9uLmdldChsb2NhbGl6ZXJOYW1lKS5mb3JtYXQ7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBMb2NhbCA9IHJlcXVpcmUoJy4vTG9jYWwnKTtcbnZhciBEYXRhTW9kZWxKU09OID0gcmVxdWlyZSgnLi4vZGF0YU1vZGVscy9KU09OJyk7XG52YXIgQ29sdW1uU2NoZW1hRmFjdG9yeSA9IHJlcXVpcmUoJy4uL2ZpbHRlci9Db2x1bW5TY2hlbWFGYWN0b3J5Jyk7XG52YXIgZmVhdHVyZXMgPSByZXF1aXJlKCcuLi9mZWF0dXJlcycpO1xudmFyIGFnZ3JlZ2F0aW9ucyA9IHJlcXVpcmUoJy4uL1NoYXJlZC5qcycpLmFuYWx5dGljcy51dGlsLmFnZ3JlZ2F0aW9ucztcblxuLyoqXG4gKiBAbmFtZSBiZWhhdmlvcnMuSlNPTlxuICogQGRlc2MgPiBTYW1lIHBhcmFtZXRlcnMgYXMge0BsaW5rIGJlaGF2aW9ycy5CZWhhdmlvciNpbml0aWFsaXplfGluaXRpYWxpemV9LCB3aGljaCBpcyBjYWxsZWQgYnkgdGhpcyBjb25zdHJ1Y3Rvci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSlNPTiA9IExvY2FsLmV4dGVuZCgnYmVoYXZpb3JzLkpTT04nLCB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb25zdHJ1Y3RvciBsb2dpYywgY2FsbGVkIF9hZnRlcl97QGxpbmsgQmVoYXZpb3IjaW5pdGlhbGl6ZXxCZWhhdmlvci5pbml0aWFsaXplKCl9LlxuICAgICAqIEBkZXNjIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIHVwb24gaW5zdGFudGlhdGlvbiBvZiB0aGlzIGNsYXNzIG9yIG9mIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgZnJvbSB0aGlzIGNsYXNzLlxuICAgICAqID4gQWxsIGBpbml0aWFsaXplKClgIG1ldGhvZHMgaW4gdGhlIGluaGVyaXRhbmNlIGNoYWluIGFyZSBjYWxsZWQsIGluIHR1cm4sIGVhY2ggd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLCBiZWdpbm5pbmcgd2l0aCB0aGF0IG9mIHRoZSBtb3N0IFwic2VuaW9yXCIgY2xhc3MgdGhyb3VnaCB0aGF0IG9mIHRoZSBjbGFzcyBvZiB0aGUgbmV3IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyaWQgLSB0aGUgaHlwZXJncmlkXG4gICAgICogQHBhcmFtIHt1bmRlZmluZWR8ZnVuY3Rpb258bWVudUl0ZW1bXX0gc2NoZW1hIC0gQWxyZWFkeSBjb25zdW1lZCBieSBCZWhhdmlvcidzIHtAbGluayBCZWhhdmlvciNpbml0aWFsaXplfGluaXRpYWxpemV9LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IGRhdGFSb3dzIC0gTWF5IGJlOlxuICAgICAqICogQW4gYXJyYXkgb2YgY29uZ3J1ZW50IHJhdyBkYXRhIG9iamVjdHNcbiAgICAgKiAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHNhbWVcbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZ3JpZCwgc2NoZW1hLCBkYXRhUm93cykge1xuICAgICAgICB0aGlzLnNldERhdGEoZGF0YVJvd3MsIHNjaGVtYSk7XG4gICAgfSxcblxuICAgIGZlYXR1cmVzOiBbXG4gICAgICAgIGZlYXR1cmVzLkNlbGxTZWxlY3Rpb24sXG4gICAgICAgIGZlYXR1cmVzLktleVBhZ2luZyxcbiAgICAgICAgZmVhdHVyZXMuQ29sdW1uUGlja2VyLFxuICAgICAgICBmZWF0dXJlcy5Db2x1bW5SZXNpemluZyxcbiAgICAgICAgZmVhdHVyZXMuUm93UmVzaXppbmcsXG4gICAgICAgIGZlYXR1cmVzLkZpbHRlcnMsXG4gICAgICAgIGZlYXR1cmVzLlJvd1NlbGVjdGlvbixcbiAgICAgICAgZmVhdHVyZXMuQ29sdW1uU2VsZWN0aW9uLFxuICAgICAgICBmZWF0dXJlcy5Db2x1bW5Nb3ZpbmcsXG4gICAgICAgIGZlYXR1cmVzLkNvbHVtblNvcnRpbmcsXG4gICAgICAgIGZlYXR1cmVzLkNlbGxFZGl0aW5nLFxuICAgICAgICBmZWF0dXJlcy5DZWxsQ2xpY2ssXG4gICAgICAgIGZlYXR1cmVzLk9uSG92ZXJcbiAgICBdLFxuXG4gICAgYWdncmVnYXRpb25zOiBhZ2dyZWdhdGlvbnMsXG5cbiAgICBjcmVhdGVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGFNb2RlbCA9IHRoaXMuZGF0YU1vZGVsO1xuICAgICAgICB2YXIgY29sdW1uQ291bnQgPSBkYXRhTW9kZWwuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSBkYXRhTW9kZWwuZ2V0SGVhZGVycygpO1xuICAgICAgICB2YXIgZmllbGRzID0gZGF0YU1vZGVsLmdldEZpZWxkcygpO1xuICAgICAgICB2YXIgUkVHRVhfQ0FNRUxfQ0FTRSA9IC8oW15fQS1aXSkoW0EtWl0rKS9nO1xuICAgICAgICB0aGlzLmNsZWFyQ29sdW1ucygpO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgY29sdW1uQ291bnQ7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBoZWFkZXJzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmFkZENvbHVtbih7IGluZGV4OiBpbmRleCwgaGVhZGVyOiBoZWFkZXIgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkVudW1bY29sdW1uLm5hbWUucmVwbGFjZShSRUdFWF9DQU1FTF9DQVNFLCAnJDFfJDInKS50b1VwcGVyQ2FzZSgpXSA9IGluZGV4O1xuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBjb2x1bW4uZ2V0UHJvcGVydGllcygpO1xuICAgICAgICAgICAgcHJvcGVydGllcy5maWVsZCA9IGZpZWxkc1tpbmRleF07XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmhlYWRlciA9IGhlYWRlcjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuY29tcGxleEZpbHRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0TmV3RGF0YU1vZGVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhTW9kZWxKU09OKHRoaXMuZ3JpZCk7XG4gICAgfSxcblxuICAgIGFwcGx5QW5hbHl0aWNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuYXBwbHlBbmFseXRpY3MoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgdGhlIGhlYWRlciBsYWJlbHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gaGVhZGVyTGFiZWxzIC0gVGhlIGhlYWRlciBsYWJlbHMuXG4gICAgICovXG4gICAgc2V0SGVhZGVyczogZnVuY3Rpb24oaGVhZGVyTGFiZWxzKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldEhlYWRlcnMoaGVhZGVyTGFiZWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgdGhlIGZpZWxkcyBhcnJheS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIC0gVGhlIGZpZWxkIG5hbWVzLlxuICAgICAqL1xuICAgIHNldEZpZWxkczogZnVuY3Rpb24oZmllbGROYW1lcykge1xuICAgICAgICAvL3dlcmUgZGVmaW5pbmcgdGhlIGNvbHVtbnMgYmFzZWQgb24gZmllbGQgbmFtZXMuLi4uXG4gICAgICAgIC8vd2UgbXVzdCByZWJ1aWxkIHRoZSBjb2x1bW4gZGVmaW5pdGlvbnNcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0RmllbGRzKGZpZWxkTmFtZXMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgdGhlIGRhdGEgZmllbGQuXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gZGF0YVJvd3MgLSBBbiBhcnJheSBvZiB1bmlmb3JtIG9iamVjdHMgYmFja2luZyB0aGUgcm93cyBpbiB0aGUgZ3JpZC5cbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihkYXRhUm93cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBncmlkID0gdGhpcy5ncmlkO1xuXG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldERhdGEoZGF0YVJvd3MsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcblxuICAgICAgICB0aGlzLnNjaGVtYSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zY2hlbWEgfHwgZGVyaXZlU2NoZW1hO1xuICAgICAgICB0aGlzLnNldEdsb2JhbEZpbHRlcih0aGlzLmdldE5ld0ZpbHRlcigpKTtcblxuICAgICAgICBpZiAoZ3JpZC5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICBncmlkLmNlbGxFZGl0b3IuY2FuY2VsRWRpdGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyaWQuaXNDb2x1bW5BdXRvc2l6aW5nKCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hdXRvc2l6ZUFsbENvbHVtbnMoKTtcbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICBncmlkLmFsbG93RXZlbnRzKGRhdGFSb3dzLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZ2V0Q29sdW1uKC0xKS5jaGVja0NvbHVtbkF1dG9zaXppbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgZ3JpZC5hbGxvd0V2ZW50cyhkYXRhUm93cy5sZW5ndGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSB0b3AgdG90YWxzLlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wIHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtBcnJheTxBcnJheT59IHRvdGFsUm93cyAtIGFycmF5IG9mIHJvd3MgKGFycmF5cykgb2YgdG90YWxzXG4gICAgICovXG4gICAgc2V0VG9wVG90YWxzOiBmdW5jdGlvbih0b3RhbFJvd3MpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0VG9wVG90YWxzKHRvdGFsUm93cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgdG9wIHRvdGFscy5cbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0FycmF5PEFycmF5Pn1cbiAgICAgKi9cbiAgICBnZXRUb3BUb3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0VG9wVG90YWxzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNldCB0aGUgYm90dG9tIHRvdGFscy5cbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtBcnJheTxBcnJheT59IHRvdGFsUm93cyAtIGFycmF5IG9mIHJvd3MgKGFycmF5cykgb2YgdG90YWxzXG4gICAgICovXG4gICAgc2V0Qm90dG9tVG90YWxzOiBmdW5jdGlvbih0b3RhbFJvd3MpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0Qm90dG9tVG90YWxzKHRvdGFsUm93cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYm90dG9tIHRvdGFscy5cbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0FycmF5PEFycmF5Pn1cbiAgICAgKi9cbiAgICBnZXRCb3R0b21Ub3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0Qm90dG9tVG90YWxzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgdGhlIGZpZWxkcyBhbmQgaGVhZGVycyBmcm9tIHRoZSBzdXBwbGllZCBjb2x1bW4gZGVmaW5pdGlvbnMuXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIG15SnNvbkJlaGF2aW9yLnNldENvbHVtbnMoW1xuICAgICAqICAgICB7IGhlYWRlcjogJ1N0b2NrIE5hbWUnLCBuYW1lOiAnc2hvcnRfZGVzY3JpcHRpb24nIH0sXG4gICAgICogICAgIHsgaGVhZGVyOiAnU3RhdHVzJywgbmFtZTogJ3RyYWRpbmdfcGhhc2UnIH0sXG4gICAgICogICAgIHsgaGVhZGVyOiAnUmVmZXJlbmNlIFByaWNlJywgbmFtZTogJ3JlZmVyZW5jZV9wcmljZScgfVxuICAgICAqIF0pO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbHVtbkRlZmluaXRpb25zIC0gYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGZpZWxkcyAndGl0bGUnLCBhbmQgJ2ZpZWxkJ1xuICAgICAqL1xuICAgIHNldENvbHVtbnM6IGZ1bmN0aW9uKGNvbHVtbkRlZmluaXRpb25zKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldENvbHVtbnMoY29sdW1uRGVmaW5pdGlvbnMpOyAvLyBUT0RPOiB0aGlzIG1ldGhvZCBpcyBtaXNzaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gRW5oYW5jZSB0aGUgZG91YmxlLWNsaWNrIGV2ZW50IGp1c3QgYmVmb3JlIGl0J3MgYnJvYWRjYXN0IHRvIGxpc3RlbmVycy5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBldmVudFxuICAgICAqL1xuICAgIGVuaGFuY2VEb3VibGVDbGlja0V2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5yb3cgPSB0aGlzLmdldFJvdyhldmVudC5ncmlkQ2VsbC55KTtcbiAgICB9LFxuXG4gICAgc2V0RGF0YVByb3ZpZGVyOiBmdW5jdGlvbihkYXRhUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0RGF0YVByb3ZpZGVyKGRhdGFQcm92aWRlcik7XG4gICAgfSxcblxuICAgIGhhc0hpZXJhcmNoeUNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5oYXNIaWVyYXJjaHlDb2x1bW4oKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uQWxpZ25tZW50OiBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICh4ID09PSAwICYmIHRoaXMuaGFzSGllcmFyY2h5Q29sdW1uKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICBnZXRSb3dTZWxlY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKHNlbGVjdGVkUm93cykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0Um93U2VsZWN0aW9uTWF0cml4KHNlbGVjdGVkUm93cyk7XG4gICAgfSxcblxuICAgIGdldENvbHVtblNlbGVjdGlvbk1hdHJpeDogZnVuY3Rpb24oc2VsZWN0ZWRDb2x1bW5zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRDb2x1bW5TZWxlY3Rpb25NYXRyaXgoc2VsZWN0ZWRDb2x1bW5zKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0aW9uTWF0cml4OiBmdW5jdGlvbihzZWxlY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRTZWxlY3Rpb25NYXRyaXgoc2VsZWN0aW9ucyk7XG4gICAgfSxcblxuICAgIGdldFJvd1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZFJvd3MgPSB0aGlzLmdldFNlbGVjdGVkUm93cygpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0Um93U2VsZWN0aW9uKHNlbGVjdGVkUm93cyk7XG4gICAgfSxcblxuICAgIGdldENvbHVtblNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZENvbHVtbnMgPSB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0Q29sdW1uU2VsZWN0aW9uKHNlbGVjdGVkQ29sdW1ucyk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRTZWxlY3Rpb24oc2VsZWN0aW9ucyk7XG4gICAgfSxcblxuICAgIGdldEdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRHcm91cHMoKTtcbiAgICB9LFxuICAgIGdldEF2YWlsYWJsZUdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRBdmFpbGFibGVHcm91cHMoKTtcbiAgICB9LFxuICAgIGdldEhpZGRlbkNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0SGlkZGVuQ29sdW1ucygpO1xuICAgIH0sXG5cbiAgICBnZXRBY3RpdmVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldEFjdGl2ZUNvbHVtbnMoKTtcbiAgICB9LFxuICAgIGdldFZpc2libGVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kZXByZWNhdGVkKCdnZXRWaXNpYmxlQ29sdW1ucygpJywgJ2dldEFjdGl2ZUNvbHVtbnMoKScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGVkUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSAtdGhpcy5ncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGVkUm93cygpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gc2VsZWN0aW9ucy5tYXAoZnVuY3Rpb24oZWFjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGVhY2ggKyBvZmZzZXQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3RlZENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGVkQ29sdW1ucygpO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgfSxcblxuICAgIGdldFNvcnRlZENvbHVtbkluZGV4ZXM6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0U29ydGVkQ29sdW1uSW5kZXhlcygpO1xuICAgIH0sXG5cbiAgICBzb3J0Q2hhbmdlZDogZnVuY3Rpb24oaGlkZGVuQ29sdW1ucyl7XG4gICAgICAgIHZhciBkaXJ0eSA9IHJlbW92ZUhpZGRlbkNvbHVtbnMoXG4gICAgICAgICAgICB0aGlzLmdldFNvcnRlZENvbHVtbkluZGV4ZXMoKSxcbiAgICAgICAgICAgIChoaWRkZW5Db2x1bW5zIHx8IHRoaXMuZ2V0SGlkZGVuQ29sdW1ucygpKVxuICAgICAgICApO1xuICAgICAgICBpZiAoZGlydHkpe1xuICAgICAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcygpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxuXG5mdW5jdGlvbiBkZXJpdmVTY2hlbWEoKSB7XG4gICAgcmV0dXJuIG5ldyBDb2x1bW5TY2hlbWFGYWN0b3J5KHRoaXMuY29sdW1ucykuc2NoZW1hO1xufVxuXG5cbi8vTG9naWMgdG8gbW92ZWQgdG8gYWRhcHRlciBsYXllciBvdXRzaWRlIG9mIEh5cGVyZ3JpZCBDb3JlXG5mdW5jdGlvbiByZW1vdmVIaWRkZW5Db2x1bW5zKG9sZFNvcnRlZCwgaGlkZGVuQ29sdW1ucyl7XG4gICAgdmFyIGRpcnR5ID0gZmFsc2U7XG4gICAgb2xkU29ydGVkLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgaiA9IDAsXG4gICAgICAgICAgICBjb2xJbmRleDtcbiAgICAgICAgd2hpbGUgKGogPCBoaWRkZW5Db2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29sSW5kZXggPSBoaWRkZW5Db2x1bW5zW2pdLmluZGV4ICsgMTsgLy9oYWNrIHRvIGdldCBhcm91bmQgMCBpbmRleFxuICAgICAgICAgICAgaWYgKGNvbEluZGV4ID09PSBpKSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuQ29sdW1uc1tqXS51blNvcnQoKTtcbiAgICAgICAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGlydHk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy92YXIgTGlzdERyYWdvbiA9IHJlcXVpcmUoJ2xpc3QtZHJhZ29uJyk7XG5cbnZhciBCZWhhdmlvciA9IHJlcXVpcmUoJy4vQmVoYXZpb3InKTtcbi8vdmFyIERhdGFNb2RlbEpTT04gPSByZXF1aXJlKCcuLi9kYXRhTW9kZWxzL0pTT04nKTtcbi8vdmFyIGZlYXR1cmVzID0gcmVxdWlyZSgnLi4vZmVhdHVyZXMnKTtcbi8vdmFyIGFnZ3JlZ2F0aW9ucyA9IHJlcXVpcmUoJy4uL2xvY2FsX25vZGVfbW9kdWxlcy9maW5hbmFseXRpY3MnKS5hZ2dyZWdhdGlvbnM7XG5cbi8qKlxuICogQG5hbWUgYmVoYXZpb3JzLkxvY2FsXG4gKiBAZGVzYyA+IFNhbWUgcGFyYW1ldGVycyBhcyB7QGxpbmsgYmVoYXZpb3JzLkJlaGF2aW9yI2luaXRpYWxpemV8aW5pdGlhbGl6ZX0sIHdoaWNoIGlzIGNhbGxlZCBieSB0aGlzIGNvbnN0cnVjdG9yLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBMb2NhbCA9IEJlaGF2aW9yLmV4dGVuZCgnTG9jYWwnLCB7XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmVoYXZpb3IgPSByZXF1aXJlKCcuL0JlaGF2aW9yJyk7XG5cbnZhciBub29wID0gZnVuY3Rpb24oKSB7fSxcbiAgICBuMDBwID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTnVsbCA9IEJlaGF2aW9yLmV4dGVuZCgnTnVsbCcsIHtcblxuICAgIC8vaW5pdGFsaXplOiBmdW5jdGlvbihncmlkLCBjb21wb25lbnQpIHt9LFxuXG4gICAgc2V0U2Nyb2xsUG9zaXRpb25ZOiBub29wLFxuICAgIHNldFNjcm9sbFBvc2l0aW9uWDogbm9vcCxcbiAgICBnZXRBY3RpdmVDb2x1bW5Db3VudDogbjAwcCxcbiAgICBnZXRGaXhlZENvbHVtbkNvdW50OiBuMDBwLFxuICAgIGdldEZpeGVkQ29sdW1uc1dpZHRoOiBuMDBwLFxuICAgIGdldEZpeGVkQ29sdW1uc01heFdpZHRoOiBuMDBwLFxuICAgIHNldFJlbmRlcmVkV2lkdGg6IG4wMHAsXG4gICAgZ2V0Um93Q291bnQ6IG4wMHAsXG4gICAgZ2V0Rml4ZWRSb3dDb3VudDogbjAwcCxcbiAgICBnZXRGaXhlZFJvd3NIZWlnaHQ6IG4wMHAsXG4gICAgZ2V0Rml4ZWRSb3dzTWF4SGVpZ2h0OiBuMDBwLFxuICAgIHNldFJlbmRlcmVkSGVpZ2h0OiBuMDBwLFxuICAgIGdldENlbGxQcm92aWRlcjogbm9vcCxcbiAgICBjbGljazogbm9vcCxcbiAgICBkb3VibGVDbGljazogbm9vcFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTnVsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQmVoYXZpb3I6IHJlcXVpcmUoJy4vQmVoYXZpb3InKSwgLy8gYWJzdHJhY3QgYmFzZSBjbGFzc1xuICAgIEpTT046IHJlcXVpcmUoJy4vSlNPTicpLFxuICAgIE51bGw6IHJlcXVpcmUoJy4vTnVsbCcpXG59OyIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtdXN0YWNoZSA9IHJlcXVpcmUoJ211c3RhY2hlJyk7XG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuLi9saWIvQmFzZScpO1xudmFyIGVmZmVjdHMgPSByZXF1aXJlKCcuLi9saWIvZWZmZWN0cycpO1xudmFyIExvY2FsaXphdGlvbiA9IHJlcXVpcmUoJy4uL2xpYi9Mb2NhbGl6YXRpb24nKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENlbGxFZGl0b3IgPSBCYXNlLmV4dGVuZCgnQ2VsbEVkaXRvcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBncmlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMgLSBQcm9wZXJ0aWVzIGxpc3RlZCBiZWxvdyArIGFyYml0cmFyeSBtdXN0YWNoZSBcInZhcmlhYmxlc1wiIGZvciBtZXJnaW5nIGludG8gdGVtcGxhdGUuXG4gICAgICogQHBhcmFtIHtQb2ludH0gb3B0aW9ucy5lZGl0UG9pbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZm9ybWF0XSAtIE5hbWUgb2YgYSBsb2NhbGl6ZXIgd2l0aCB3aGljaCB0byBvdmVycmlkZSBwcm90b3R5cGUncyBgbG9jYWxpemVyYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkLCBvcHRpb25zKSB7XG5cbiAgICAgICAgLy8gRXN0YWJsaXNoIGB0aGlzLmVkaXRQb2ludGAgYW5kIHBvc3NpYmx5IGB0aGlzLmZvcm1hdGA7IHBsdXMgb3RoZXIgYXJiaXRyYXJ5IHByb3BlcnRpZXMgZm9yIG11c3RhY2hlIHVzZS5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkgJiYgdGhpc1trZXldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gZ3JpZC5iZWhhdmlvci5nZXRWYWx1ZSh0aGlzLmVkaXRQb2ludC54LCB0aGlzLmVkaXRQb2ludC55KTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbMV07IC8vaXQncyBhIG5lc3RlZCBvYmplY3RcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBteSBpbnN0YW5jZSBvZiBoeXBlcmdyaWRcbiAgICAgICAgICogQHR5cGUge0h5cGVyZ3JpZH1cbiAgICAgICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyaWQgPSBncmlkO1xuXG4gICAgICAgIHRoaXMuZ3JpZC5jZWxsRWRpdG9yID0gdGhpcztcblxuICAgICAgICB0aGlzLmxvY2FsZSA9IGdyaWQubG9jYWxpemF0aW9uLmxvY2FsZTsgLy8gZm9yIHRlbXBsYXRlJ3MgYGxhbmdgIGF0dHJpYnV0ZVxuXG4gICAgICAgIC8vIG92ZXJyaWRlIG5hdGl2ZSBsb2NhbGl6ZXIgd2l0aCBsb2NhbGl6ZXIgbmFtZWQgaW4gZm9ybWF0IGlmIGRlZmluZWQgKGZyb20gaW5zdGFudGlhdGlvbiBvcHRpb25zKVxuICAgICAgICBpZiAodGhpcy5mb3JtYXQpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxpemVyID0gdGhpcy5ncmlkLmxvY2FsaXphdGlvbi5nZXQodGhpcy5mb3JtYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBtdXN0YWNoZS5yZW5kZXIodGhpcy50ZW1wbGF0ZSwgdGhpcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgb2JqZWN0J3MgaW5wdXQgY29udHJvbCwgb25lIG9mOlxuICAgICAgICAgKiAqICppbnB1dCBlbGVtZW50KiAtIGFuIGBIVE1MRWxlbWVudGAgdGhhdCBoYXMgYSBgdmFsdWVgIGF0dHJpYnV0ZSwgc3VjaCBhcyBgSFRNTElucHV0RWxlbWVudGAsIGBIVE1MQnV0dG9uRWxlbWVudGAsIGV0Yy5cbiAgICAgICAgICogKiAqY29udGFpbmVyIGVsZW1lbnQqIC0gYW4gYEhUTUxFbGVtZW50YCBjb250YWluaW5nIG9uZSBvciBtb3JlIGlucHV0IGVsZW1lbnRzLCBvbmx5IG9uZSBvZiB3aGljaCBjb250YWlucyB0aGUgZWRpdG9yIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgYWNjZXNzIHRvIHRoZSBpbnB1dCBjb250cm9sIGl0c2VsZiAod2hpY2ggbWF5IG9yIG1heSBub3QgYmUgdGhlIHNhbWUgYXMgYHRoaXMuZWxgKSwgc2VlIGB0aGlzLmlucHV0YC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbCA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuXG4gICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLmVsO1xuXG4gICAgICAgIHRoaXMuZXJyb3JzID0gMDtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmtleXVwLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNFZGl0b3JLZXlEb3duRXZlbnQoc2VsZiwgZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZ3JpZC5maXJlU3ludGhldGljRWRpdG9yS2V5UHJlc3NFdmVudChzZWxmLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWwub25ibHVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgc2VsZi5jYW5jZWxFZGl0aW5nKCk7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGxvY2FsaXplcjogTG9jYWxpemF0aW9uLnByb3RvdHlwZS5udWxsLFxuXG4gICAgc3BlY2lhbEtleXVwczoge1xuICAgICAgICAvLzB4MDg6ICdjbGVhclN0b3BFZGl0aW5nJywgLy8gYmFja3NwYWNlXG4gICAgICAgIDB4MDk6ICdzdG9wRWRpdGluZycsIC8vIHRhYlxuICAgICAgICAweDBkOiAnc3RvcEVkaXRpbmcnLCAvLyByZXR1cm4vZW50ZXJcbiAgICAgICAgMHgxYjogJ2NhbmNlbEVkaXRpbmcnIC8vIGVzY2FwZVxuICAgIH0sXG5cbiAgICBrZXl1cDogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgdmFyIHNwZWNpYWxLZXl1cCA9IHRoaXMuc3BlY2lhbEtleXVwc1tlLmtleUNvZGVdO1xuXG4gICAgICAgICAgICBpZiAoc3BlY2lhbEtleXVwKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW3NwZWNpYWxLZXl1cF0oMykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmlkLnRha2VGb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5ncmlkLmZpcmVTeW50aGV0aWNFZGl0b3JLZXlVcEV2ZW50KHRoaXMsIGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGlmIHRydWUsIGNoZWNrIHRoYXQgdGhlIGVkaXRvciBpcyBpbiB0aGUgcmlnaHQgbG9jYXRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNoZWNrRWRpdG9yUG9zaXRpb25GbGFnOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoaXMgZnVuY3Rpb24gaXMgYSBjYWxsYmFjayBmcm9tIHRoZSBmaW4taHlwZXJncmlkLiAgIEl0IGlzIGNhbGxlZCBhZnRlciBlYWNoIHBhaW50IG9mIHRoZSBjYW52YXMuXG4gICAgICovXG4gICAgZ3JpZFJlbmRlcmVkTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jaGVja0VkaXRvcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzY3JvbGwgdmFsdWVzIGhhdmUgY2hhbmdlZCwgd2UndmUgYmVlbiBub3RpZmllZFxuICAgICAqL1xuICAgIHNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2hlY2tFZGl0b3JQb3NpdGlvbkZsYWcgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBtb3ZlIHRoZSBlZGl0b3IgdG8gdGhlIGN1cnJlbnQgZWRpdG9yIHBvaW50XG4gICAgICovXG4gICAgbW92ZUVkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjZWxsQm91bmRzID0gdGhpcy5ncmlkLl9nZXRCb3VuZHNPZkNlbGwodGhpcy5lZGl0UG9pbnQueCwgdGhpcy5lZGl0UG9pbnQueSk7XG5cbiAgICAgICAgLy9oYWNrIHRvIGFjY29tbW9kYXRlIGJvb3RzdHJhcCBtYXJnaW4gaXNzdWVzLi4uXG4gICAgICAgIHZhciB4T2Zmc2V0ID1cbiAgICAgICAgICAgIHRoaXMuZ3JpZC5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG4gICAgICAgICAgICB0aGlzLmdyaWQuZGl2Q2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cbiAgICAgICAgY2VsbEJvdW5kcy54IC09IHhPZmZzZXQ7XG5cbiAgICAgICAgdGhpcy5zZXRCb3VuZHMoY2VsbEJvdW5kcyk7XG4gICAgfSxcblxuICAgIGJlZ2luRWRpdGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmdyaWQuZmlyZVJlcXVlc3RDZWxsRWRpdCh0aGlzLmVkaXRQb2ludCwgdGhpcy5pbml0aWFsVmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRWRpdG9yUG9zaXRpb25GbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tFZGl0b3IoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYmVnaW5FZGl0QXQ6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuZGVwcmVjYXRlZCgnYmVnaW5FZGl0QXQocG9pbnQpJywgJ2JlZ2luRWRpdGluZygpJywgJzEuMC42Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFB1dCB0aGUgdmFsdWUgaW50byBvdXIgZWRpdG9yLlxuICAgICAqIEBkZXNjIEZvcm1hdHMgdGhlIHZhbHVlIGFuZCBkaXNwbGF5cyBpdC5cbiAgICAgKiBUaGUgbG9jYWxpemVyJ3Mge0BsaW5rIGxvY2FsaXplckludGVyZmFjZSNmb3JtYXR8Zm9ybWF0fSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB5b3VyIGVkaXRvciBoYXMgYWRkaXRpb25hbCBvciBhbHRlcm5hdGl2ZSBHVUkgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgLSBUaGUgcmF3IHVuZm9ybWF0dGVkIHZhbHVlIGZyb20gdGhlIGRhdGEgc291cmNlIHRoYXQgd2Ugd2FudCB0byBlZGl0LlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldEVkaXRvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmlucHV0LnZhbHVlID0gdGhpcy5sb2NhbGl6ZXIuZm9ybWF0KHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGlzcGxheSB0aGUgZWRpdG9yXG4gICAgICovXG4gICAgc2hvd0VkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoaWRlIHRoZSBlZGl0b3JcbiAgICAgKi9cbiAgICBoaWRlRWRpdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH0sXG5cbiAgICAvKiogQHN1bW1hcnkgU3RvcHMgZWRpdGluZy5cbiAgICAgKiBAZGVzYyBCZWZvcmUgc2F2aW5nLCB2YWxpZGF0ZXMgdGhlIGVkaXRlZCB2YWx1ZSBpbiB0d28gcGhhc2VzIGFzIGZvbGxvd3M6XG4gICAgICogMS4gQ2FsbCBgdmFsaWRhdGVFZGl0b3JWYWx1ZWAuIChDYWxscyB0aGUgbG9jYWxpemVyJ3MgYGludmFsaWQoKWAgZnVuY3Rpb24sIGlmIGF2YWlsYWJsZS4pXG4gICAgICogMi4gQ2F0Y2ggYW55IGVycm9ycyB0aHJvd24gYnkgdGhlIHtAbGluayBDZWxsRWRpdG9yI2dldEVkaXRvclZhbHVlfGdldEVkaXRvclZhbHVlfSBtZXRob2QuXG4gICAgICpcbiAgICAgKiAqKklmIHRoZSBlZGl0ZWQgdmFsdWUgcGFzc2VzIGJvdGggcGhhc2VzIG9mIHRoZSB2YWxpZGF0aW9uOioqXG4gICAgICogU2F2ZXMgdGhlIGVkaXRlZCB2YWx1ZSBieSBjYWxsaW5nIHRoZSB7QGxpbmsgQ2VsbEVkaXRvciNzYXZlRWRpdG9yVmFsdWV8c2F2ZUVkaXRvclZhbHVlfSBtZXRob2QuXG4gICAgICpcbiAgICAgKiAqKk9uIHZhbGlkYXRpb24gZmFpbHVyZToqKlxuICAgICAqIDEuIElmIGBmZWVkYmFja2Agd2FzIG9taXR0ZWQsIGNhbmNlbHMgZWRpdGluZywgZGlzY2FyZGluZyB0aGUgZWRpdGVkIHZhbHVlLlxuICAgICAqIDIuIElmIGBmZWVkYmFja2Agd2FzIHByb3ZpZGVkLCBnaXZlcyB0aGUgdXNlciBzb21lIGZlZWRiYWNrIChzZWUgYGZlZWRiYWNrYCwgYmVsb3cpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmZWVkYmFja10gV2hhdCB0byBkbyBvbiB2YWxpZGF0aW9uIGZhaWx1cmU6XG4gICAgICogKiBJZiBvbWl0dGVkLCBzaW1wbHkgY2FuY2VscyBlZGl0aW5nIHdpdGhvdXQgc2F2aW5nIGVkaXRlZCB2YWx1ZS5cbiAgICAgKiAqIElmIDAsIHNob3dzIHRoZSBlcnJvciBmZWVkYmFjayBlZmZlY3QgKHNlZSB0aGUge0BsaW5rIENlbGxFZGl0b3IjZXJyb3JFZmZlY3R8ZXJyb3JFZmZlY3R9IHByb3BlcnR5KS5cbiAgICAgKiAqIElmID4gMCwgc2hvd3MgdGhlIGVycm9yIGZlZWRiYWNrIGVmZmVjdCBfYW5kXyBjYWxscyB0aGUge0BsaW5rIENlbGxFZGl0b3IjZXJyb3JFZmZlY3RFbmR8ZXJyb3JFZmZlY3RFbmR9IG1ldGhvZCkgZXZlcnkgYGZlZWRiYWNrYCBjYWxsKHMpIHRvIGBzdG9wRWRpdGluZ2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydXRoeSBtZWFucyBzdWNjZXNzZnVsIHN0b3AuIEZhbHN5IG1lYW5zIHN5bnRheCBlcnJvciBwcmV2ZW50ZWQgc3RvcC4gTm90ZSB0aGF0IGVkaXRpbmcgaXMgY2FuY2VsZWQgd2hlbiBubyBmZWVkYmFjayByZXF1ZXN0ZWQgYW5kIHN1Y2Nlc3NmdWwgc3RvcCBpbmNsdWRlcyAoc3VjY2Vzc2Z1bCkgY2FuY2VsLlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHN0b3BFZGl0aW5nOiBmdW5jdGlvbihmZWVkYmFjaykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW58c3RyaW5nfEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGVycm9yID0gdGhpcy52YWxpZGF0ZUVkaXRvclZhbHVlKCk7XG5cbiAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldEVkaXRvclZhbHVlKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXJyb3IgJiYgdGhpcy5ncmlkLmZpcmVTeW50aGV0aWNFZGl0b3JEYXRhQ2hhbmdlRXZlbnQodGhpcywgdGhpcy5pbml0aWFsVmFsdWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVFZGl0b3JWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZUVkaXRvcigpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLmNlbGxFZGl0b3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChmZWVkYmFjayA+PSAwKSB7IC8vIG5ldmVyIHRydWUgd2hlbiBgZmVlZGJhY2tgIHVuZGVmaW5lZFxuICAgICAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5lZGl0UG9pbnQ7XG4gICAgICAgICAgICB0aGlzLmdyaWQuc2VsZWN0Vmlld3BvcnRDZWxsKHBvaW50LngsIHBvaW50LnkgLSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKSk7XG4gICAgICAgICAgICB0aGlzLmVycm9yRWZmZWN0QmVnaW4oKyt0aGlzLmVycm9ycyAlIGZlZWRiYWNrID09PSAwICYmIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gaW52YWxpZCBidXQgbm8gZmVlZGJhY2tcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbmNlbEVkaXRpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhZXJyb3I7XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBDYW5jZWxzIGVkaXRpbmcuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFN1Y2Nlc3NmdWwuIChDYW5jZWwgaXMgYWx3YXlzIHN1Y2Nlc3NmdWwuKVxuICAgICAqL1xuICAgIGNhbmNlbEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5ncmlkLmNlbGxFZGl0b3IpIHsgLy8gYmVjYXVzZSBzdG9wRWRpdGluZydzIC5yZW1vdmUgdHJpZ2dlcnMgYmx1ciB3aGljaCBjb21lcyBoZXJlXG4gICAgICAgICAgICB0aGlzLnNldEVkaXRvclZhbHVlKHRoaXMuaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZUVkaXRvcigpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLmNlbGxFZGl0b3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIGVmZmVjdCBmdW5jdGlvbiBpbmRpY2F0ZWQgaW4gdGhlIHtAbGluayBDZWxsRWRpdG9yI2Vycm9yRWZmZWN0fGVycm9yRWZmZWN0fSBwcm9wZXJ0eSB3aGljaCB0cmlnZ2VycyBhIHNlcmllcyBvZiBDU1MgdHJhbnNpdGlvbnMuXG4gICAgICogQHBhcmFtIHtib29sZWFufHN0cmluZ3xFcnJvcn0gW2Vycm9yXSAtIElmIGRlZmluZWQsIGNhbGwgdGhlIHtAbGluayBDZWxsRWRpdG9yI2Vycm9yRWZmZWN0RW5kfGVycm9yRWZmZWN0RW5kfSBtZXRob2QgYXQgdGhlIGVuZCBvZiB0aGUgbGFzdCBlZmZlY3QgdHJhbnNpdGlvbiB3aXRoIHRoaXMgZXJyb3IuXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZXJyb3JFZmZlY3RCZWdpbjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7IGNhbGxiYWNrOiBlcnJvciAmJiB0aGlzLmVycm9yRWZmZWN0RW5kLmJpbmQodGhpcywgZXJyb3IpIH0sXG4gICAgICAgICAgICBlZmZlY3QgPSB0aGlzLmVycm9yRWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZWZmZWN0ID0gdGhpcy5lcnJvckVmZmVjdHNbZWZmZWN0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgXyhvcHRpb25zKS5leHRlbmRPd24oZWZmZWN0Lm9wdGlvbnMpO1xuICAgICAgICAgICAgZWZmZWN0ID0gZWZmZWN0LmVmZmVjdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGB0aGlzLmVycm9yRWZmZWN0YCB0byByZXNvbHZlIHRvIGFuIGVycm9yIGVmZmVjdCBmdW5jdGlvbi4nO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZXhwZWN0cyB0byBiZSBwYXNzZWQgYW4gZXJyb3IuIFRoZXJlIGlzIG5vIHBvaW50IGluIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBpZiB0aGVyZSBpcyBubyBlcnJvci4gTmV2ZXJ0aGVsZXNzLCBpZiBjYWxsZWQgd2l0aCBhIGZhbHN5IGBlcnJvcmAsIHJldHVybnMgd2l0aG91dCBkb2luZyBhbnl0aGluZy5cbiAgICAgKiBAdGhpcyB7Q2VsbEVkaXRvcn1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58c3RyaW5nfEVycm9yfSBbZXJyb3JdXG4gICAgICovXG4gICAgZXJyb3JFZmZlY3RFbmQ6IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIG1zZyA9XG4gICAgICAgICAgICAgICAgJ0ludmFsaWQgdmFsdWUuIFRvIHJlc29sdmUsIGRvIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxcblxcbicgK1xuICAgICAgICAgICAgICAgICcgICAqIENvcnJlY3QgdGhlIGVycm9yIGFuZCB0cnkgYWdhaW4uXFxuJyArXG4gICAgICAgICAgICAgICAgJyAgICAgICAgIC0gb3IgLVxcbicgK1xuICAgICAgICAgICAgICAgICcgICAqIENhbmNlbCBlZGl0aW5nIGJ5IHByZXNzaW5nIHRoZSBcImVzY1wiIChlc2NhcGUpIGtleS4nO1xuXG4gICAgICAgICAgICBlcnJvciA9IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3I7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxpemVyLmV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnJvciA/IGVycm9yICsgJ1xcbicgKyB0aGlzLmxvY2FsaXplci5leHBlY3RhdGlvbiA6IHRoaXMubG9jYWxpemVyLmV4cGVjdGF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdcXG4nICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnJvci5yZXBsYWNlKC9bXFxuXFxyXSsvZywgJ1xcblxcbiAgICogJyk7XG4gICAgICAgICAgICAgICAgbXNnICs9ICdcXG5cXG5BZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgZXJyb3I6JyArIGVycm9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbGVydChtc2cpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWFsZXJ0XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlZGVmIGVmZmVjdE9iamVjdFxuICAgICAqIEBwcm9wZXJ0eSB7ZWZmZWN0RnVuY3Rpb259IGVmZmVjdG9yXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFtvcHRpb25zXSAtIEFuIG9wdGlvbnMgb2JqZWN0IHdpdGggd2hpY2ggdG8gY2FsbCB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTWF5IGJlIG9uZSBvZjpcbiAgICAgKiAqICoqc3RyaW5nKiogLSBOYW1lIG9mIHJlZ2lzdGVyZWQgZXJyb3IgZWZmZWN0LlxuICAgICAqICogKiplZmZlY3RGdW5jdGlvbioqIC0gUmVmZXJlbmNlIHRvIGFuIGVmZmVjdCBmdW5jdGlvbi5cbiAgICAgKiAqICoqZWZmZWN0T2JqZWN0KiogLSBSZWZlcmVuY2UgdG8gYW4gZWZmZWN0T2JqZWN0IGNvbnRhaW5pbmcgYW4ge0BsaW5rIGVmZmVjdEZ1bmN0aW9ufSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdCB3aXRoIHdoaWNoIHRvIGNhbGwgdGhlIGZ1bmN0aW9uLlxuICAgICAqIEB0eXBlIHtzdHJpbmd8ZWZmZWN0RnVuY3Rpb258ZWZmZWN0T2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGVycm9yRWZmZWN0OiAnc2hha2VyJyxcblxuICAgIC8qKlxuICAgICAqIEhhc2ggb2YgcmVnaXN0ZXJlZCB7QGxpbmsgZWZmZWN0RnVuY3Rpb259cyBvciB7QGxpbmsgZWZmZWN0T2JqZWN0fXMuXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZXJyb3JFZmZlY3RzOiB7XG4gICAgICAgIHNoYWtlcjogZWZmZWN0cy5zaGFrZXIsXG4gICAgICAgIGdsb3dlcjogZWZmZWN0cy5nbG93ZXJcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2Mgc2F2ZSB0aGUgbmV3IHZhbHVlIGludG8gdGhlIGJlaGF2aW9yIChtb2RlbClcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYXZlRWRpdG9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMuZWRpdFBvaW50O1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICEodmFsdWUgJiYgdmFsdWUgPT09IHRoaXMuaW5pdGlhbFZhbHVlKSAmJiAvLyBkYXRhIGNoYW5nZWRcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5maXJlQmVmb3JlQ2VsbEVkaXQocG9pbnQsIHRoaXMuaW5pdGlhbFZhbHVlLCB2YWx1ZSwgdGhpcykgLy8gbm90IGFib3J0aW5nXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmJlaGF2aW9yLnNldFZhbHVlKHBvaW50LngsIHBvaW50LnksIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5maXJlQWZ0ZXJDZWxsRWRpdChwb2ludCwgdGhpcy5pbml0aWFsVmFsdWUsIHZhbHVlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBFeHRyYWN0IHRoZSBlZGl0ZWQgdmFsdWUgZnJvbSB0aGUgZWRpdG9yLlxuICAgICAqIEBkZXNjIERlLWZvcm1hdCB0aGUgZWRpdGVkIHN0cmluZyBiYWNrIGludG8gYSBwcmltaXRpdmUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGUgbG9jYWxpemVyJ3Mge0BsaW5rIGxvY2FsaXplckludGVyZmFjZSNwYXJzZXxwYXJzZX0gbWV0aG9kIHdpbGwgYmUgY2FsbGVkIG9uIHRoZSB0ZXh0IGJveCBjb250ZW50cy5cbiAgICAgKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdXIgZWRpdG9yIGhhcyBhZGRpdGlvbmFsIG9yIGFsdGVybmF0aXZlIEdVSSBlbGVtZW50cy4gVGhlIEdVSSBlbGVtZW50cyB3aWxsIGluZmx1ZW5jZSB0aGUgcHJpbWl0aXZlIHZhbHVlLCBlaXRoZXIgYnkgYWx0ZXJpbmcgdGhlIGVkaXRlZCBzdHJpbmcgYmVmb3JlIGl0IGlzIHBhcnNlZCwgb3IgYnkgdHJhbnNmb3JtaW5nIHRoZSBwYXJzZWQgdmFsdWUgYmVmb3JlIHJldHVybmluZyBpdC5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgY3VycmVudCBlZGl0b3IncyB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldEVkaXRvclZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemVyLnBhcnNlKHRoaXMuaW5wdXQudmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSBpcyBubyB2YWxpZGF0b3Igb24gdGhlIGxvY2FsaXplciwgcmV0dXJucyBmYWxzeSAobm90IGludmFsaWQ7IHBvc3NpYmx5IHZhbGlkKS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxzdHJpbmd9IFRydXRoeSB2YWx1ZSBtZWFucyBpbnZhbGlkLiBJZiBhIHN0cmluZywgdGhpcyB3aWxsIGJlIGFuIGVycm9yIG1lc3NhZ2UuIElmIG5vdCBhIHN0cmluZywgaXQgbWVyZWx5IGluZGljYXRlcyBhIGdlbmVyaWMgaW52YWxpZCByZXN1bHQuXG4gICAgICovXG4gICAgdmFsaWRhdGVFZGl0b3JWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXplci5pbnZhbGlkICYmIHRoaXMubG9jYWxpemVyLmludmFsaWQodGhpcy5pbnB1dC52YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlcXVlc3QgZm9jdXMgZm9yIG15IGlucHV0IGNvbnRyb2wuXG4gICAgICogQGRlc2MgU2VlIEdSSUQtOTUgXCJTY3JvbGxiYXIgbW92ZXMgaW53YXJkXCIgZm9yIGlzc3VlIGFuZCB3b3JrLWFyb3VuZCBleHBsYW5hdGlvbi5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0YWtlRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsLFxuICAgICAgICAgICAgbGVmdFdhcyA9IGVsLnN0eWxlLmxlZnQsXG4gICAgICAgICAgICB0b3BXYXMgPSBlbC5zdHlsZS50b3A7XG5cbiAgICAgICAgZWwuc3R5bGUubGVmdCA9IGVsLnN0eWxlLnRvcCA9IDA7IC8vIHdvcmstYXJvdW5kOiBtb3ZlIHRvIHVwcGVyIGxlZnRcblxuICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0QWxsKCk7XG5cbiAgICAgICAgZWwuc3R5bGUubGVmdCA9IGxlZnRXYXM7XG4gICAgICAgIGVsLnN0eWxlLnRvcCA9IHRvcFdhcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2VsZWN0IGV2ZXJ5dGhpbmdcbiAgICAgKi9cbiAgICBzZWxlY3RBbGw6IG51bGxQYXR0ZXJuLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBib3VuZHMgb2YgbXkgaW5wdXQgY29udHJvbFxuICAgICAqIEBwYXJhbSB7cmVjdGFuZ2xlfSByZWN0YW5nbGUgLSB0aGUgYm91bmRzIHRvIG1vdmUgdG9cbiAgICAgKi9cbiAgICBzZXRCb3VuZHM6IGZ1bmN0aW9uKGNlbGxCb3VuZHMpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5lbDtcblxuICAgICAgICBpbnB1dC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGlucHV0LnN0eWxlLmxlZnQgPSBweChjZWxsQm91bmRzLnggLSAxKTtcbiAgICAgICAgaW5wdXQuc3R5bGUudG9wID0gcHgoY2VsbEJvdW5kcy55IC0gMSk7XG4gICAgICAgIGlucHV0LnN0eWxlLndpZHRoID0gcHgoY2VsbEJvdW5kcy53aWR0aCArIDIpO1xuICAgICAgICBpbnB1dC5zdHlsZS5oZWlnaHQgPSBweChjZWxsQm91bmRzLmhlaWdodCArIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBjaGVjayB0aGF0IHRoZSBlZGl0b3IgaXMgaW4gdGhlIGNvcnJlY3QgbG9jYXRpb24sIGFuZCBpcyBzaG93aW5nL2hpZGRlbiBhcHByb3ByaWF0ZWx5XG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgY2hlY2tFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jaGVja0VkaXRvclBvc2l0aW9uRmxhZykge1xuICAgICAgICAgICAgdGhpcy5jaGVja0VkaXRvclBvc2l0aW9uRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZC5pc0RhdGFWaXNpYmxlKHRoaXMuZWRpdFBvaW50LngsIHRoaXMuZWRpdFBvaW50LnkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFZGl0b3JWYWx1ZSh0aGlzLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRha2VGb2N1cygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVFZGl0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhdHRhY2hFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmVsLFxuICAgICAgICAgICAgZGl2ID0gdGhpcy5ncmlkLmRpdixcbiAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUgPSBkaXYucXVlcnlTZWxlY3RvckFsbCgnLmZpbmJhci1ob3Jpem9udGFsLCAuZmluYmFyLXZlcnRpY2FsJyk7XG5cbiAgICAgICAgZGl2Lmluc2VydEJlZm9yZShpbnB1dCwgcmVmZXJlbmNlTm9kZS5sZW5ndGggPyByZWZlcmVuY2VOb2RlWzBdIDogbnVsbCk7XG4gICAgfSxcblxuICAgIHRlbXBsYXRlOiAnJ1xuXG59KTtcblxuZnVuY3Rpb24gbnVsbFBhdHRlcm4oKSB7fVxuZnVuY3Rpb24gcHgobikgeyByZXR1cm4gbiArICdweCc7IH1cblxuXG5DZWxsRWRpdG9yLmFic3RyYWN0ID0gdHJ1ZTsgLy8gZG9uJ3QgaW5zdGFudGlhdGUgZGlyZWN0bHlcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENlbGxFZGl0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsRWRpdG9yID0gcmVxdWlyZSgnLi9DZWxsRWRpdG9yJyk7XG5cbi8qKlxuICogQXMgb2Ygc3ByaW5nIDIwMTY6XG4gKiBGdW5jdGlvbnMgd2VsbCBpbiBDaHJvbWUgYW5kIEZpcmVmb3g7IHVuaW1wbGVtZW50ZWQgaW4gU2FmYXJpLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDb2xvciA9IENlbGxFZGl0b3IuZXh0ZW5kKCdDb2xvcicsIHtcblxuICAgIHRlbXBsYXRlOiAnPGlucHV0IHR5cGU9XCJjb2xvclwiIGxhbmc9XCJ7e2xvY2FsZX19XCIgc3R5bGU9XCJ7e3N0eWxlfX1cIj4nXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xuIiwiLy8gQ29tYm9Cb3guanMgLSBBIGNvbWJvLWJveCBpcyBhIGNvbWJpbmF0aW9uIG9mIGEgdGV4dC1ib3ggYW5kIGEgZHJvcC1kb3duLlxuLy8gVXNlciBtYXkgdHlwZSBpbnRvIGl0IGFuZC9vciBzZWxlY3QgYW4gaXRlbSBmcm9tIHRoZSBkcm9wLWRvd24gKGJ5IGNsaWNraW5nIG9uIHRoZSB0cmlhbmdsZSBhdCB0aGUgcmlnaHQpLlxuLy8gVGhlIGRyb3AtZG93biBoYXMgc2VjdGlvbnMgd2hpY2ggYXJlIHRvZ2dsZWQgZnJvbSBhIGNvbnRyb2wgYXJlYSBiZXR3ZWVuIHRoZSB0ZXh0LWJveCBhbmQgdGhlIGRyb3AtZG93bi5cblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFRleHRmaWVsZCA9IHJlcXVpcmUoJy4vVGV4dGZpZWxkJyk7XG52YXIgcHJvdG90eXBlID0gcmVxdWlyZSgnLi9DZWxsRWRpdG9yJykucHJvdG90eXBlO1xudmFyIFF1ZXVlbGVzcyA9IHJlcXVpcmUoJy4uL2xpYi9xdWV1ZWxlc3MnKTtcbnZhciBlbGZvciA9IHJlcXVpcmUoJy4uL2xpYi9lbGZvcicpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBUT0dHTEVfTU9ERV9QUkVGSVggPSAndG9nZ2xlLW1vZGUtJztcblxudmFyIHN0YXRlVG9BY3Rpb25NYXAgPSB7XG4gICAgaGlkZGVuOiBzbGlkZURvd24sXG4gICAgdmlzaWJsZTogc2xpZGVVcFxufTtcblxuLyoqXG4gKiBBIGNvbWJvIGJveCBpcyBhIHRleHQgYm94IHRoYXQgYWxzbyBoYXMgYSBkcm9wLWRvd24gY29udGFpbmluZyBvcHRpb25zLiBUaGUgZHJvcC1kb3duIGNvbnNpc3RzIG9mIGFuIGFjdHVhbCBkcm9wLWRvd24gbGlzdCAoYSBgPHNlbGVjdD5gIGxpc3QpIHBsdXMgYSBfY29udHJvbCBhcmVhXyBhYm92ZSBpdCBjb250YWluaW5nIHRvZ2dsZXMuIFRoZSB0b2dnbGVzIGNvbnRyb2wgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHZhcmlvdXMgXCJtb2RlIGxpc3RzLlwiXG4gKlxuICogRnVuY3Rpb25zIHdlbGwgaW4gQ2hyb21lLCBTYWZhcmksIEZpcmVmb3gsIGFuZCBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29tYm9Cb3ggPSBUZXh0ZmllbGQuZXh0ZW5kKCdDb21ib0JveCcsIHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgICAgIHRoaXMuaW5wdXQgPSBlbC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICAgICAgICB0aGlzLmRyb3BwZXIgPSBlbC5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICAgICAgICB0aGlzLmNvbnRyb2xzID0gdGhpcy5vcHRpb25zLnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICAgICAgICB0aGlzLmRyb3Bkb3duID0gdGhpcy5vcHRpb25zLnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdCcpO1xuXG4gICAgICAgIHRoaXMuY29udHJvbGxhYmxlID0gdGhpcy5tb2Rlcy5sZW5ndGggPiAxO1xuXG4gICAgICAgIC8vIHNldCB1cCBhIHRyYW5zaXRpb24gZW5kIGNvbnRyb2xsZXJcbiAgICAgICAgdGhpcy5vcHRpb25zVHJhbnNpdGlvbiA9IG5ldyBRdWV1ZWxlc3ModGhpcy5vcHRpb25zLCB0aGlzKTtcblxuICAgICAgICB0aGlzLm1lbnVNb2Rlc1NvdXJjZSA9IHRoaXMuY29sdW1uLm1lbnVNb2RlcyB8fCB7IGRpc3RpbmN0VmFsdWVzOiB0cnVlIH07XG5cbiAgICAgICAgLy8gd2lyZS11cHNcbiAgICAgICAgdGhpcy5kcm9wcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMudG9nZ2xlRHJvcERvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZHJvcGRvd24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIGZ1bmN0aW9uKGUpIHsgZS5zdG9wUHJvcGFnYXRpb24oKTsgfSk7XG4gICAgICAgIHRoaXMuZHJvcGRvd24uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5pbnNlcnRUZXh0LmJpbmQodGhpcykpO1xuICAgICAgICBlbC5vbmJsdXIgPSBudWxsOyAvLyB2b2lkIHRoaXMgb25lLCBzZXQgYnkgc3VwZXIncyBpbml0aWFsaXplXG4gICAgfSxcblxuICAgIHRlbXBsYXRlOiBbXG4nPGRpdiBjbGFzcz1cImh5cGVyZ3JpZC1pbnB1dFwiIHRpdGxlPVwiXCI+JyxcbicgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbGFuZz1cInt7bG9jYWxlfX1cIiBzdHlsZT1cInt7c3R5bGV9fVwiPicsXG4nICAgIDxzcGFuIHRpdGxlPVwiQ2xpY2sgZm9yIG9wdGlvbnNcIj48L3NwYW4+JyxcbicgICAgPGRpdj4nLFxuJyAgICAgICAgPGRpdj48L2Rpdj4nLFxuJyAgICAgICAgPHNlbGVjdCBzaXplPVwiMTJcIiBsYW5nPVwie3tsb2NhbGV9fVwiPjwvc2VsZWN0PicsXG4nICAgIDwvZGl2PicsXG4nPC9kaXY+J1xuICAgIF0uam9pbignXFxuJyksXG5cbiAgICBtb2RlczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnZGlzdGluY3RWYWx1ZXMnLFxuICAgICAgICAgICAgYXBwZW5kT3B0aW9uczogZnVuY3Rpb24ob3B0Z3JvdXApIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGRpc3RpbmN0IGNvbHVtbiB2YWx1ZXMgYW5kIHNvcnQgdGhlbVxuICAgICAgICAgICAgICAgIHZhciBkaXN0aW5jdCA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBkID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbk5hbWUgPSB0aGlzLmNvbHVtbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIgPSB0aGlzLmNvbHVtbi5nZXRGb3JtYXR0ZXIoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5iZWhhdmlvci5nZXREYXRhKCkuZm9yRWFjaChmdW5jdGlvbihkYXRhUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBmb3JtYXR0ZXIoZGF0YVJvd1tjb2x1bW5OYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RpbmN0W3ZhbF0gPSAoZGlzdGluY3RbdmFsXSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGlzdGluY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG9wdGdyb3VwLmZpcnN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwLmZpcnN0RWxlbWVudENoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGQuc29ydCgpLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBuZXcgT3B0aW9uKHZhbCArICcgKCcgKyBkaXN0aW5jdFt2YWxdICsgJyknLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSxcblxuICAgIHNob3dFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWVudU1vZGVzU291cmNlID0gdGhpcy5tZW51TW9kZXNTb3VyY2UsXG4gICAgICAgICAgICBtZW51TW9kZXMgPSB0aGlzLm1lbnVNb2RlcyA9IHt9O1xuXG4gICAgICAgIC8vIGJ1aWxkIHRoZSBwcm94eVxuICAgICAgICB0aGlzLm1vZGVzLmZvckVhY2goZnVuY3Rpb24obW9kZSkge1xuICAgICAgICAgICAgdmFyIG1vZGVOYW1lID0gbW9kZS5uYW1lO1xuICAgICAgICAgICAgaWYgKG1vZGVOYW1lIGluIG1lbnVNb2Rlc1NvdXJjZSkge1xuICAgICAgICAgICAgICAgIG1lbnVNb2Rlc1ttb2RlTmFtZV0gPSBtZW51TW9kZXNTb3VyY2VbbW9kZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3aXJlLXVwc1xuICAgICAgICBpZiAodGhpcy5jb250cm9sbGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbk1vZGVJY29uQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIG1vZGUgdG9nZ2xlc1xuICAgICAgICB0aGlzLm1vZGVzLmZvckVhY2goZnVuY3Rpb24obW9kZSkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGEgdG9nZ2xlXG4gICAgICAgICAgICB2YXIgdG9nZ2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbGxhYmxlKSB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLmNsYXNzTmFtZSA9IFRPR0dMRV9NT0RFX1BSRUZJWCArIG1vZGUubmFtZTtcbiAgICAgICAgICAgICAgICB0b2dnbGUudGl0bGUgPSAnVG9nZ2xlICcgKyAobW9kZS5sYWJlbCB8fCBtb2RlLm5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLnRleHRDb250ZW50ID0gbW9kZS5zeW1ib2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLmFwcGVuZENoaWxkKHRvZ2dsZSk7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbmQgbGFiZWwgYSBuZXcgb3B0Z3JvdXBcbiAgICAgICAgICAgIGlmIChtb2RlLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0Z3JvdXAnKTtcbiAgICAgICAgICAgICAgICBvcHRncm91cC5sYWJlbCA9IG1vZGUubGFiZWw7XG4gICAgICAgICAgICAgICAgb3B0Z3JvdXAuY2xhc3NOYW1lID0gJ3N1Ym1lbnUtJyArIG1vZGUubmFtZTtcbiAgICAgICAgICAgICAgICBvcHRncm91cC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBtb2RlLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmFkZChvcHRncm91cCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldE1vZGVJY29uQW5kT3B0Z3JvdXAuY2FsbCh0aGlzLCB0b2dnbGUsIG1vZGUubmFtZSwgbWVudU1vZGVzW21vZGUubmFtZV0pO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHByb3RvdHlwZS5zaG93RWRpdG9yLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIGhpZGVFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyB0aGlzIGlzIHdoZXJlIHlvdSB3b3VsZCBwZXJzaXN0IHRoaXMubWVudU1vZGVzXG4gICAgICAgIHByb3RvdHlwZS5oaWRlRWRpdG9yLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIHRvZ2dsZURyb3BEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnNUcmFuc2l0aW9uLnRyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZHJvcGRvd24pLnZpc2liaWxpdHk7XG4gICAgICAgICAgICBzdGF0ZVRvQWN0aW9uTWFwW3N0YXRlXS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluc2VydFRleHQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gcmVwbGFjZSB0aGUgaW5wdXQgdGV4dCB3aXRoIHRoZSBkcm9wLWRvd24gdGV4dFxuICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIHRoaXMuaW5wdXQudmFsdWUgPSB0aGlzLmRyb3Bkb3duLnZhbHVlO1xuICAgICAgICB0aGlzLmlucHV0LnNldFNlbGVjdGlvblJhbmdlKDAsIHRoaXMuaW5wdXQudmFsdWUubGVuZ3RoKTtcblxuICAgICAgICAvLyBjbG9zZSB0aGUgZHJvcC1kb3duXG4gICAgICAgIHRoaXMudG9nZ2xlRHJvcERvd24oKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gb25Nb2RlSWNvbkNsaWNrKGUpIHtcbiAgICB2YXIgY3RybCA9IGUudGFyZ2V0O1xuXG4gICAgaWYgKGN0cmwudGFnTmFtZSA9PT0gJ1NQQU4nKSB7XG4gICAgICAgIC8vIGV4dHJhIGN0IHRoZSBtb2RlIG5hbWUgZnJvbSB0aGUgdG9nZ2xlIGNvbnRyb2wncyBjbGFzcyBuYW1lXG4gICAgICAgIHZhciBtb2RlQ2xhc3NOYW1lID0gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChjdHJsLmNsYXNzTGlzdCwgZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzTmFtZS5pbmRleE9mKFRPR0dMRV9NT0RFX1BSRUZJWCkgPT09IDA7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1vZGVOYW1lID0gbW9kZUNsYXNzTmFtZS5zdWJzdHIoVE9HR0xFX01PREVfUFJFRklYLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gdG9nZ2xlIG1vZGUgaW4gdGhlIGZpbHRlclxuICAgICAgICB2YXIgbW9kZVN0YXRlID0gdGhpcy5tZW51TW9kZXNbbW9kZU5hbWVdIF49IDE7XG5cbiAgICAgICAgc2V0TW9kZUljb25BbmRPcHRncm91cC5jYWxsKHRoaXMsIGN0cmwsIG1vZGVOYW1lLCBtb2RlU3RhdGUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0TW9kZUljb25BbmRPcHRncm91cChjdHJsLCBuYW1lLCBzdGF0ZSkge1xuICAgIHZhciBzdHlsZSwgb3B0Z3JvdXAsIHN1bSwgZGlzcGxheSxcbiAgICAgICAgbW9kZSA9IHRoaXMubW9kZXMuZmluZChmdW5jdGlvbihtb2RlKSB7IHJldHVybiBtb2RlLm5hbWUgPT09IG5hbWU7IH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNoYWRvd1xuXG4gICAgLy8gc2V0IGljb24gc3RhdGUgKGNvbG9yKVxuICAgIGN0cmwuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJywgISFzdGF0ZSk7XG5cbiAgICAvLyBlbXB0eSB0aGUgb3B0Z3JvdXAgaWYgaGlkaW5nOyByZWJ1aWxkIGl0IGlmIHNob3dpbmdcbiAgICBpZiAoc3RhdGUpIHsgLy8gcmVidWlsZCBpdFxuICAgICAgICAvLyBzaG93IHByb2dyZXNzIGN1cnNvciBmb3IgKGF0IGxlYXN0KSAxLzMgc2Vjb25kXG4gICAgICAgIHN0eWxlID0gdGhpcy5lbC5zdHlsZTtcbiAgICAgICAgc3R5bGUuY3Vyc29yID0gJ3Byb2dyZXNzJztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgc3R5bGUuY3Vyc29yID0gbnVsbDsgfSwgMzMzKTtcblxuICAgICAgICBpZiAobW9kZS5zZWxlY3Rvcikge1xuICAgICAgICAgICAgb3B0Z3JvdXAgPSB0aGlzLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3IobW9kZS5zZWxlY3Rvcik7XG4gICAgICAgICAgICBzdW0gPSBtb2RlLmFwcGVuZE9wdGlvbnMuY2FsbCh0aGlzLCBvcHRncm91cCk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBzdW1cbiAgICAgICAgICAgIG9wdGdyb3VwLmxhYmVsID0gb3B0Z3JvdXAubGFiZWwucmVwbGFjZSgvIFxcKFxcZCtcXCkkLywgJycpOyAvLyByZW1vdmUgb2xkIHN1bVxuICAgICAgICAgICAgb3B0Z3JvdXAubGFiZWwgKz0gJyAoJyArIHN1bSArICcpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1bSA9IG1vZGUuYXBwZW5kT3B0aW9ucy5jYWxsKHRoaXMsIHRoaXMuZHJvcGRvd24pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2xsYWJsZSkge1xuICAgICAgICAgICAgICAgIGN0cmwudGV4dENvbnRlbnQgPSBzdW0gKyAnIHZhbHVlcyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkaXNwbGF5ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cblxuICAgIC8vIGhpZGUvc2hvdyB0aGUgZ3JvdXBcbiAgICBlbGZvci5lYWNoKFxuICAgICAgICBtb2RlLnNlbGVjdG9yIHx8ICc6c2NvcGU+b3B0aW9uLDpzY29wZT5vcHRncm91cDpub3QoW2NsYXNzXSknLFxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlZShlbCkgeyBlbC5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheTsgfSxcbiAgICAgICAgdGhpcy5kcm9wZG93blxuICAgICk7XG5cbiAgICAvLyBUT0RPOiBSZXNldCB0aGUgd2lkdGggb2YgdGhpcy5vcHRpb25zIHRvIHRoZSBuYXR1cmFsIHdpZHRoIG9mIHRoaXMuZHJvcGRvd24uIFRvIGRvIHRoaXMsIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBsYXR0ZXIncyBcIndpZHRoOiAxMDAlXCIgZnJvbSB0aGUgQ1NTIGFuZCB0aGVuIHNldCBhbiBleHBsaWNpdCB0aGlzLm9wdGlvbnMuc3R5bGUud2lkdGggYmFzZWQgb24gdGhlIGNvbXB1dGVkIHdpZHRoIG9mIHRoaXMuZHJvcGRvd24uIFRoaXMgaXMgY29tcGxpY2F0ZWQgYnkgdGhlIGZhY3QgdGhhdCBpdCBjYW5ub3QgYmUgZG9uZSBiZWZvcmUgaXQgaXMgaW4gdGhlIERPTS5cbn1cblxuZnVuY3Rpb24gc2xpZGVEb3duKCkge1xuICAgIC8vIHByZXNlcnZlIHRoZSB0ZXh0IGJveCdzIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24sIHdoaWNoIGlzIGFib3V0IHRvIGJlIGxvc3RcbiAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5pbnB1dC5zZWxlY3Rpb25TdGFydDtcbiAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuaW5wdXQuc2VsZWN0aW9uRW5kO1xuXG4gICAgLy8gY2xlYW4gdXAgdGhlIHNlbGVjdCBsaXN0IGZyb20gbGFzdCB1c2FnZVxuICAgIHRoaXMuZHJvcGRvd24uc2VsZWN0ZWRJbmRleCA9IC0xOyAvLyBiZSBraW5kIChyZW1vdmUgcHJldmlvdXMgc2VsZWN0aW9uKVxuICAgIHRoaXMuZHJvcGRvd24uc3R5bGUuc2Nyb2xsVG9wID0gMDsgLy8gcmV3aW5kXG5cbiAgICAvLyBzaG93IHRoZSBkcm9wLWRvd24gc2xpZGUgZG93biBlZmZlY3RcbiAgICB0aGlzLm9wdGlvbnMuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICB2YXIgZHJvcERvd25IZWlnaHQgPSB0aGlzLmRyb3Bkb3duLnNpemUgKiAxNTtcbiAgICB0aGlzLm9wdGlvbnMuc3R5bGUuaGVpZ2h0ID0gMiArIDE1ICsgZHJvcERvd25IZWlnaHQgKyAyICsgJ3B4JzsgLy8gc3RhcnRzIHRoZSBzbGlkZSBkb3duIGVmZmVjdFxuXG4gICAgLy8gd2hpbGUgaW4gZHJvcC1kb3duLCBsaXN0ZW4gZm9yIGNsaWNrcyBpbiB0ZXh0IGJveCB3aGljaCBtZWFucyBhYnBydFxuICAgIHRoaXMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5zbGlkZVVwQm91bmQgPSBzbGlkZVVwLmJpbmQodGhpcykpO1xuXG4gICAgLy8gd2FpdCBmb3IgdHJhbnNpdGlvbiB0byBlbmRcbiAgICB0aGlzLm9wdGlvbnNUcmFuc2l0aW9uLmJlZ2luKCk7XG59XG5cbmZ1bmN0aW9uIHNsaWRlVXAoKSB7XG4gICAgLy8gc3RvcCBsaXN0ZW5pbmcgdG8gaW5wdXQgY2xpY2tzXG4gICAgdGhpcy5pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLnNsaWRlVXBCb3VuZCk7XG5cbiAgICAvLyBzdGFydCB0aGUgc2xpZGUgdXAgZWZmZWN0XG4gICAgdGhpcy5vcHRpb25zLnN0eWxlLmhlaWdodCA9IDA7XG5cbiAgICAvLyBzY2hlZHVsZSB0aGUgaGlkZSB0byBvY2N1ciBhZnRlciB0aGUgc2xpZGUgdXAgZWZmZWN0XG4gICAgdGhpcy5vcHRpb25zVHJhbnNpdGlvbi5iZWdpbihmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICB9KTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbWJvQm94O1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxFZGl0b3IgPSByZXF1aXJlKCcuL0NlbGxFZGl0b3InKTtcblxudmFyIGlzQ2hyb21pdW0gPSB3aW5kb3cuY2hyb21lLFxuICAgIHdpbk5hdiA9IHdpbmRvdy5uYXZpZ2F0b3IsXG4gICAgdmVuZG9yTmFtZSA9IHdpbk5hdi52ZW5kb3IsXG4gICAgaXNPcGVyYSA9IHdpbk5hdi51c2VyQWdlbnQuaW5kZXhPZignT1BSJykgPiAtMSxcbiAgICBpc0lFZWRnZSA9IHdpbk5hdi51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID4gLTEsXG4gICAgaXNJT1NDaHJvbWUgPSB3aW5OYXYudXNlckFnZW50Lm1hdGNoKCdDcmlPUycpLFxuICAgIGlzQ2hyb21lID0gIWlzSU9TQ2hyb21lICYmXG4gICAgICAgIGlzQ2hyb21pdW0gIT09IG51bGwgJiZcbiAgICAgICAgaXNDaHJvbWl1bSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHZlbmRvck5hbWUgPT09ICdHb29nbGUgSW5jLicgJiZcbiAgICAgICAgaXNPcGVyYSA9PSBmYWxzZSAmJiBpc0lFZWRnZSA9PSBmYWxzZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcblxuLyoqXG4gKiBBcyBvZiBzcHJpbmcgMjAxNjpcbiAqIEZ1bmN0aW9ucyB3ZWxsIGluIENocm9tZSBleGNlcHQgbm8gbG9jYWxpemF0aW9uIChkYXksIG1vbnRoIG5hbWVzOyBkYXRlIGZvcm1hdCkuXG4gKiBVbmltcGxlbWVudGVkIGluIFNhZmFyaSwgRmlyZWZveCwgSW50ZXJuZXQgRXhwbG9yZXIuXG4gKiBUaGlzIGlzIGEgXCJzbm1hcnRcIiBjb250cm9sLiBJdCBkZXRlY3RzIENocm9tZTpcbiAqICogSWYgQ2hyb21lLCB1c2VzIGNocm9tZURhdGUgb3ZlcnJpZGVzIGZvcm1hdCB0byB0aGF0IHJlcXVpcmVkIGJ5IHRoZSB2YWx1ZSBhdHRyaWJ1dGUsIHl5eXktbW0tZGQuIChOb3RlIHRoYXQgdGhpcyBpcyBub3QgdGhlIGZvcm1hdCBkaXNwbGF5ZWQgaW4gdGhlIGNvbnRyb2wsIHdoaWNoIGlzIGFsd2F5cyBtbS9kZC95eXl5LilcbiAqICogT3RoZXJ3aXNlIHVzZXMgbG9jYWxpemVkIGRhdGUgZm9ybWF0IF9idXRfIGZhbGxzIGJhY2sgdG8gYSByZWd1bGFyIHRleHQgYm94LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRlID0gQ2VsbEVkaXRvci5leHRlbmQoJ0RhdGUnLCB7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkKSB7XG5cbiAgICAgICAgdmFyIGxvY2FsaXplck5hbWUsXG4gICAgICAgICAgICB1c2VzRGF0ZUlucHV0Q29udHJvbCA9IGlzQ2hyb21lO1xuXG4gICAgICAgIGlmICh1c2VzRGF0ZUlucHV0Q29udHJvbCkge1xuICAgICAgICAgICAgbG9jYWxpemVyTmFtZSA9ICdjaHJvbWVEYXRlJztcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUgPSAnPGlucHV0IHR5cGU9XCJkYXRlXCI+JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvY2FsaXplck5hbWUgPSAnZGF0ZSc7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlID0gJzxpbnB1dCB0eXBlPVwidGV4dFwiPic7XG5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0QWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RDaGFyUGx1c09uZSA9IHRoaXMuZ2V0RWRpdG9yVmFsdWUoKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXRTZWxlY3Rpb25SYW5nZSgwLCBsYXN0Q2hhclBsdXNPbmUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubG9jYWxpemVyID0gZ3JpZC5sb2NhbGl6YXRpb24uZ2V0KGxvY2FsaXplck5hbWUpO1xuICAgIH1cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRGF0ZTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwb3BNZW51ID0gcmVxdWlyZSgncG9wLW1lbnUnKTtcbnZhciBDb25kaXRpb25hbHMgPSByZXF1aXJlKCcuLi9TaGFyZWQnKS5GaWx0ZXJUcmVlLkNvbmRpdGlvbmFscztcblxudmFyIENvbWJvQm94ID0gcmVxdWlyZSgnLi9Db21ib0JveCcpO1xudmFyIHByb3RvdHlwZSA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpLnByb3RvdHlwZTtcblxuXG4vKipcbiAqIFRoZSBzZWxlY3QgbGlzdCBjb25zaXN0cyBvZiB0aGUgZm9sbG93aW5nIHNldHMgb2YgZHJvcC1kb3duIGl0ZW1zOlxuICogKiBgb3BlcmF0b3JzYCAoaWNvbiAqJmx0OyopIFRoZSBwYXJ0aWN1bGFyIHNlbGVjdGlvbiBvZiBvcGVyYXRvcnMgZm9yIHRoaXMgY29sdW1uLiBDb21lcyBmcm9tIHRoZSBmaWx0ZXIgdHJlZS5cbiAqICogYGRpc3RpbmN0VmFsdWVzYCAoaWNvbiAqIyopIExpc3Qgb2YgZGlzdGluY3QgY29sdW1uIHZhbHVlcy4gQ2FsY3VsYXRlZCBmcm9tIGluc3BlY3Rpb24gb2YgY29sdW1uIHZhbHVlcyBvbiBfYW5kXyBvbiBpY29uIGNsaWNrLlxuICogKiBgY29sdW1uTmFtZXNgIChpY29uICpUKikgTGlzdCBvdGhlciBjb2x1bW4gbmFtZXMuIENhbGN1bGF0ZWQgZnJvbSBpbnNwZWN0aW9uIG9mIGNvbHVtbiB2YWx1ZXMgb24gX2FuZF8gb24gaWNvbiBjbGljay5cbiAqXG4gKiBUaGUgY29udHJvbCBhcmVhIHJlZmxlY3RzIHRoZSBgdGhpcy5tb2Rlc2AgYXJyYXkgKGFib3ZlKS4gSXQgaXMgbW9kZWxlZCBieSBhICdtZW51TW9kZXNgIG9iamVjdCwgYSBoYXNoIHdpdGggYm9vbGVhbiBwcm9wZXJ0aWVzIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgZWFjaCBvZiB0aGUgc2V0cyBvZiBtZW51IGl0ZW1zIG91dGxpbmVkIGFib3ZlLiBNaXNzaW5nIHByb3BlcnRpZXMgYXJlIGZhbHN5IGJ5IGltcGxpY2F0aW9uLiBUaGUgc3RhdGUgc2VtYW50aWNzIGFyZTpcbiAqICAgKiBgMWAgb3IgYHRydWVgIG1lYW5zIGFkZHMgQ1NTIGNsYXNzIGBhY3RpdmVgIHRvIGljb24gX2FuZF8gc2hvd3Mgc2V0J3MgaXRlbXMgaW4gZHJvcC1kb3duLlxuICogICAqIGAwYCBvciBgZmFsc2VgIG1lYW5zIHJlbW92ZXMgKENTUyBjbGFzcyBgYWN0aXZlYCBmcm9tIGljb24gX2FuZF8gaGlkZXMgc2V0J3MgaXRlbXMgaW4gZHJvcC1kb3duLlxuICpcbiAqICpQZXJzaXN0aW5nIGNoYW5nZXM6KiBUaGUgb25seSBjaGFuZ2UgdGhpcyBVSSBzdXBwb3J0cyAoYmVzaWRlcyB0aGUgZmlsdGVyIHRleHQgaXRzZWxmKSBpcyB0aGUgbWVudSBtb2RlIHN0YXRlcywgd2hpY2ggYXJlIGV4cGVjdGVkIHRvIGJlIFwic3RpY2t5LlwiIFRoYXQgaXMsIHRoZXkgYXJlIFwicGVyc2lzdGVkXCIgKHdyaXR0ZW4gYmFjaykgdG8gdGhlIGZpbHRlci4gSG93ZXZlciwgdGhlcmUgaXMgYSBwcm9ibGVtOiBXaGVuIHRoZSBjb2x1bW4gZmlsdGVyIGlzIGJsYW5rIGl0IGRvZXNuJ3QgYWN0dWFsbHkgZXhpc3QgeWV0IGluIHRoZSBmaWx0ZXIsIHNvIHRoZXJlIGlzIG5vd2hlcmUgdG8gc2F2ZSBpdC4gVGhlIHNvbHV0aW9uIGlzIHRvIHJlYWQgdGhlIGBtZW51TW9kZXNgIGhhc2ggX2Zyb21fIHRoZSBmaWx0ZXIgdHJlZSBidXQgZG9uJ3QgbW9kaWZ5IGl0IHVudGlsIGVuZCBvZiBlZGl0aW5nLiBSZWFkaW5nIGl0IGZyb20gdGhlIGZpbHRlciB0cmVlIHBpY2tzIHVwIHByZXZpb3VzIHNldHRpbmcgaWYgdGhlcmUgd2FzIGFuIGV4dGFudCBjb2x1bW4gZmlsdGVyIG9yIHRoZSBkZWZhdWx0IGlmIHRoZXJlIHdhcyBub3QuIEJ1dCB0aGVuLCByYXRoZXIgdGhhbiBtb2RpZnlpbmcgdGhpcyBzdHJ1Y3R1cmUgKGJlY2F1c2UgaXQgbWlnaHQgYmUgdGhlIGRlZmF1bHQgYW5kIHdlIGRvbid0IHdhbnQgdG8gb3ZlcndyaXRlIHRoYXQpLCB3ZSBoYW5nIGEgcHJveHkgY29weSBvZmYgdGhlIGJlaGF2aW9yJ3MgY29sdW1uIG9iamVjdCBmb3IgdGhpcyBjb2x1bW4uIFRoaXMgd2lsbCBwZXJzaXN0IGl0IGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGFwcCBzZXNzaW9uLiBBdCBlbmQgb2YgZWRpdGluZywgaWYgYW5kIG9ubHkgaWYgdGhlcmUgaXMgbm93IGEgY29sdW1uIGZpbHRlciAodGV4dCBpcyBub3QgYmxhbmspLCB3ZSBjb3B5IGl0IHRvIHRoZSBjb2x1bW4gZmlsdGVyJ3Mgc3VidHJlZSBub2RlIGluIHRoZSBmaWx0ZXIgdHJlZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEZpbHRlckJveCA9IENvbWJvQm94LmV4dGVuZCgnRmlsdGVyQm94Jywge1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gbG9vayBpbiB0aGUgZmlsdGVyLCB1bmRlciBjb2x1bW4gZmlsdGVycywgZm9yIGEgY29sdW1uIGZpbHRlciBmb3IgdGhpcyBjb2x1bW5cbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLmdyaWQuZ2V0R2xvYmFsRmlsdGVyKCksXG4gICAgICAgICAgICBjb2x1bW5OYW1lID0gdGhpcy5jb2x1bW4ubmFtZSxcbiAgICAgICAgICAgIGNvbHVtbkZpbHRlcnMgPSB0aGlzLmdyaWQuZ2V0R2xvYmFsRmlsdGVyKCkuY29sdW1uRmlsdGVycyxcbiAgICAgICAgICAgIGNvbHVtbkZpbHRlclN1YnRyZWUgPSByb290LmdldENvbHVtbkZpbHRlcihjb2x1bW5OYW1lKSB8fCB7fSxcbiAgICAgICAgICAgIGNvbHVtblNjaGVtYSA9IHJvb3Quc2NoZW1hLmxvb2t1cChjb2x1bW5OYW1lKSB8fCB7fTtcblxuXG4gICAgICAgIC8vIGdldCB0aGUgb3BlcmF0b3IgbGlzdCBmcm9tIHRoZSBub2RlLCBzY2hlbWEsIHR5cGVPcE1hcCwgb3Igcm9vdDpcbiAgICAgICAgLy8gKFRoaXMgbWltaWNzIHRoZSBjb2RlIGluIEZpbHRlckxlYWYuanMncyBgZ2V0T3BNZW51YCBmdW5jdGlvbiBiZWNhdWFzZSB0aGUgbm9kZSBtYXkgbm90IGV4aXN0IHlldC4pXG4gICAgICAgIHRoaXMub3BNZW51ID1cblxuICAgICAgICAgICAgLy8gcHVsbCBvcGVyYXRvciBsaXN0IGZyb20gY29sdW1uIHNjaGVtYSBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIGNvbHVtblNjaGVtYS5vcE1lbnUgfHxcblxuICAgICAgICAgICAgLy8gb3BlcmF0b3IgbGlzdCBmb3IgdGhlIGNvbHVtbidzIHR5cGUgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICByb290LnR5cGVPcE1hcCAmJiByb290LnR5cGVPcE1hcFtjb2x1bW5TY2hlbWEudHlwZSB8fCBjb2x1bW5GaWx0ZXJTdWJ0cmVlLnR5cGVdIHx8XG5cbiAgICAgICAgICAgIC8vIGRlZmF1bHQgb3BlcmF0b3IgbGlzdCAod2hpY2ggaXRzZWxmIGRlZmF1bHRzIHRvIGBDb25kaXRpb25hbHMuZGVmYXVsdE9wTWVudWApXG4gICAgICAgICAgICByb290Lm9wTWVudTtcblxuXG4gICAgICAgIC8vIGdldCB0aGUgY29sdW1uIGZpbHRlcidzIGBtZW51TW9kZXNgIG9iamVjdCAtLSBjb250YWlucyB0aGUgc3RhdGVzIG9mIHRoZSBkcm9wLWRvd24gb3B0aW9uIGljb25zOlxuICAgICAgICB0aGlzLm1lbnVNb2Rlc1NvdXJjZSA9XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IHRyeSBwcm94eSBmcm9tIGxhc3QgdGltZSAoYmVjYXVzZSBlZGl0aW5nIG1heSBoYXZlIGVuZGVkIHdpdGhvdXQgYSBjb2x1bW4gZmlsdGVyIHRvIHB1dCBpbiB0aGUgZmlsdGVyIHRyZWUpXG4gICAgICAgICAgICB0aGlzLmNvbHVtbi5tZW51TW9kZXMgfHxcblxuICAgICAgICAgICAgLy8gRUxTRSB0cnkgY29sdW1uIGZpbHRlcidzIGBtZW51TW9kZXNgIFdIRU4gYXZhaWxhYmxlXG4gICAgICAgICAgICBjb2x1bW5GaWx0ZXJTdWJ0cmVlLm1lbnVNb2RlcyB8fFxuICAgICAgICAgICAgY29sdW1uRmlsdGVyU3VidHJlZS5tZW51TW9kZXMgfHxcblxuICAgICAgICAgICAgLy8gdHJ5IHVzZSBjb2x1bW4gc2NoZW1hJ3MgYG1lbnVNb2Rlc2Agd2hlbiBkZWZpbmVkXG4gICAgICAgICAgICBjb2x1bW5TY2hlbWEubWVudU1vZGVzIHx8XG5cbiAgICAgICAgICAgIC8vIEVMU0UgdHJ5IHRoZSBmaWx0ZXIgZGVmYXVsdCAod2hpY2ggaXRzZWxmIGRlZmF1bHRzIHRvIG9wZXJhdG9ycyBPTiwgb3RoZXJzIE9GRjsgc2VlIGRlZmluaXRpb24gYXQgdG9wIG9mIERlZmF1bHRGaWx0ZXIuanMpXG4gICAgICAgICAgICBjb2x1bW5GaWx0ZXJzLm1lbnVNb2RlcztcblxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlcmUncyBvbmx5IG9uZSBtb2RlIGRlZmluZWQgaGVyZSwgdGhlIGNvbnRyb2wgYXJlYSBwb3J0aW9uIG9mIHRoZSBVSSBpcyBoaWRkZW4uXG4gICAgICovXG4gICAgbW9kZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ29wZXJhdG9ycycsXG4gICAgICAgICAgICBzeW1ib2w6ICc8JyxcbiAgICAgICAgICAgIGFwcGVuZE9wdGlvbnM6IGZ1bmN0aW9uKGRyb3Bkb3duKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkcm9wZG93bi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFyaW91cyAgb3BlcmF0b3Igb3B0aW9ucyBhbmQvb3Igb3B0Z3JvdXBzIHZhcnkgcGVyIGNvbHVtbiBiYXNlZCBvbiBgb3BNZW51YC5cbiAgICAgICAgICAgICAgICAgICAgcG9wTWVudS5idWlsZChkcm9wZG93biwgdGhpcy5vcE1lbnUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiBmdW5jdGlvbihncm91cE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29uZGl0aW9uYWxzLmdyb3Vwc1tncm91cE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21wdDogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBsaXN0IG9mIGNvbmp1bmN0aW9ucyBpcyBhbiBleHRyYSBhbmQgaXMgZm9yIGFsbCBjb2x1bW5zLiBBbGwgb3BlcmF0b3Igb3B0Z3JvdXBzIGFyZSBjbGFzc2xlc3MuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGdyb3VwJyk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwLmxhYmVsID0gJ0Nvbmp1bmN0aW9ucyc7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwLmFwcGVuZENoaWxkKG5ldyBPcHRpb24oJ2FuZCcsICcgYW5kICcpKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXAuYXBwZW5kQ2hpbGQobmV3IE9wdGlvbignb3InLCAnIG9yICcpKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXAuYXBwZW5kQ2hpbGQobmV3IE9wdGlvbignbm9yJywgJyBub3IgJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2NvbHVtbk5hbWVzJyxcbiAgICAgICAgICAgIGxhYmVsOiAnQ29sdW1uIE5hbWVzJyxcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnb3B0Z3JvdXAuc3VibWVudS1jb2x1bW5OYW1lcycsXG4gICAgICAgICAgICBzeW1ib2w6ICdBJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNlZmYnLFxuICAgICAgICAgICAgYXBwZW5kT3B0aW9uczogZnVuY3Rpb24ob3B0Z3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IHRoaXMuZ3JpZC5iZWhhdmlvci5jb2x1bW5zLFxuICAgICAgICAgICAgICAgICAgICB4ID0gdGhpcy5lZGl0UG9pbnQueDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChvcHRncm91cC5maXJzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cC5maXJzdEVsZW1lbnRDaGlsZC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24oY29sdW1uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gY29sdW1uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gbmV3IE9wdGlvbihuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi50aXRsZSA9ICdbJyArIG5hbWUgKyAnXVxcclwiJyArIGNvbHVtbi5oZWFkZXIgKyAnXCInO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXAuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2Rpc3RpbmN0VmFsdWVzJyxcbiAgICAgICAgICAgIGxhYmVsOiAnRGlzdGluY3QgVmFsdWVzJyxcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnb3B0Z3JvdXAuc3VibWVudS1kaXN0aW5jdFZhbHVlcycsXG4gICAgICAgICAgICBzeW1ib2w6ICcjJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmZWYnLFxuICAgICAgICAgICAgYXBwZW5kT3B0aW9uczogQ29tYm9Cb3gucHJvdG90eXBlLm1vZGVzWzBdLmFwcGVuZE9wdGlvbnNcbiAgICAgICAgfVxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0aGUgYG1lbnVNb2Rlc2AgcHJveHkgdG8gdGhlIGZpbHRlciB0cmVlJ3MgY29sdW1uIGZpbHRlciBzdWJ0cmVlIG5vZGUuXG4gICAgICogV2UgbG9vayB1cCB0aGUgbm9kZSBhZ2FpbiBoZXJlIGJlY2F1c2UgaXQgbWlnaHQgYmUgbmV3OyBvciBtYXkgaGF2ZSBiZWVuIGRlbGV0ZWQgJiByZWNyZWF0ZWQgZHVyaW5nIGVkaXRpbmcuXG4gICAgICovXG4gICAgaGlkZUVkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGxvb2sgaW4gdGhlIGZpbHRlciwgdW5kZXIgY29sdW1uIGZpbHRlcnMsIGZvciBhIGNvbHVtbiBmaWx0ZXIgZm9yIHRoaXMgY29sdW1uXG4gICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmdyaWQuZ2V0R2xvYmFsRmlsdGVyKCksXG4gICAgICAgICAgICBjb2x1bW5OYW1lID0gdGhpcy5jb2x1bW4ubmFtZSxcbiAgICAgICAgICAgIGNvbHVtbkZpbHRlclN1YnRyZWUgPSBmaWx0ZXIuZ2V0Q29sdW1uRmlsdGVyKGNvbHVtbk5hbWUpO1xuXG4gICAgICAgIGlmIChjb2x1bW5GaWx0ZXJTdWJ0cmVlKSB7XG4gICAgICAgICAgICAvLyB3cml0ZSBiYWNrIHRvIGZpbHRlci10cmVlIG5vZGUgZm9yIHBlcnNpc3Rpbmcgd2l0aCBnZXRTdGF0ZVxuICAgICAgICAgICAgY29sdW1uRmlsdGVyU3VidHJlZS5tZW51TW9kZXMgPSB0aGlzLm1lbnVNb2RlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29sdW1uLm1lbnVNb2RlcyA9IHRoaXMubWVudU1vZGVzO1xuXG4gICAgICAgIENvbWJvQm94LnByb3RvdHlwZS5oaWRlRWRpdG9yLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIGtleXVwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBwcm90b3R5cGUua2V5dXAuY2FsbCh0aGlzLCBlKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ2ZpbHRlcmluZ01vZGUnKSA9PT0gJ2ltbWVkaWF0ZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVFZGl0b3JWYWx1ZSh0aGlzLmdldEVkaXRvclZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZUVkaXRvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluc2VydFRleHQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gaW5zZXJ0IHRoZSBkcm9wLWRvd25iIHRleHQgYXQgdGhlIGluc2VydGlvbiBwb2ludCBvciBvdmVyIHRoZSBzZWxlY3RlZCB0ZXh0XG4gICAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5pbnB1dC5zZXRSYW5nZVRleHQodGhpcy5kcm9wZG93bi52YWx1ZSwgdGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQsICdlbmQnKTtcblxuICAgICAgICAvLyBjbG9zZSB0aGUgZHJvcC1kb3duXG4gICAgICAgIHRoaXMudG9nZ2xlRHJvcERvd24oKTtcbiAgICB9XG5cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyQm94O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGV4dGZpZWxkID0gcmVxdWlyZSgnLi9UZXh0ZmllbGQnKTtcblxuLyoqXG4gKiBGdW5jdGlvbnMgd2VsbCBpbiBDaHJvbWUsIFNhZmFyaSwgRmlyZWZveCwgYW5kIEludGVybmV0IEV4cGxvcmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBOdW1iZXIgPSBUZXh0ZmllbGQuZXh0ZW5kKCdOdW1iZXInLCB7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemVyID0gZ3JpZC5sb2NhbGl6YXRpb24uZ2V0KCdudW1iZXInKTtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxFZGl0b3IgPSByZXF1aXJlKCcuL0NlbGxFZGl0b3InKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFNsaWRlciA9IENlbGxFZGl0b3IuZXh0ZW5kKCdTbGlkZXInLCB7XG5cbiAgICB0ZW1wbGF0ZTogJzxpbnB1dCB0eXBlPVwicmFuZ2VcIiBsYW5nPVwie3tsb2NhbGV9fVwiIHN0eWxlPVwie3tzdHlsZX19XCI+J1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTbGlkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsRWRpdG9yID0gcmVxdWlyZSgnLi9DZWxsRWRpdG9yLmpzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTcGlubmVyID0gQ2VsbEVkaXRvci5leHRlbmQoJ1NwaW5uZXInLCB7XG5cbiAgICB0ZW1wbGF0ZTogJzxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbGFuZz1cInt7bG9jYWxlfX1cIiBzdHlsZT1cInt7c3R5bGV9fVwiPidcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3Bpbm5lcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxFZGl0b3IgPSByZXF1aXJlKCcuL0NlbGxFZGl0b3IuanMnKTtcbnZhciBMb2NhbGl6YXRpb24gPSByZXF1aXJlKCcuLi9saWIvTG9jYWxpemF0aW9uJyk7XG5cblxuLyoqXG4gKiBBcyBvZiBzcHJpbmcgMjAxNjpcbiAqIEZ1bmN0aW9ucyB3ZWxsIGluIENocm9tZSwgU2FmYXJpLCBGaXJlZm94LCBhbmQgSW50ZXJuZXQgRXhwbG9yZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFRleHRmaWVsZCA9IENlbGxFZGl0b3IuZXh0ZW5kKCdUZXh0ZmllbGQnLCB7XG5cbiAgICB0ZW1wbGF0ZTogJzxpbnB1dCB0eXBlPVwidGV4dFwiIGxhbmc9XCJ7e2xvY2FsZX19XCIgc3R5bGU9XCJ7e3N0eWxlfX1cIj4nLFxuXG4gICAgbG9jYWxpemVyOiBMb2NhbGl6YXRpb24ucHJvdG90eXBlLnN0cmluZyxcblxuICAgIHNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsYXN0Q2hhclBsdXNPbmUgPSB0aGlzLmdldEVkaXRvclZhbHVlKCkubGVuZ3RoO1xuICAgICAgICB0aGlzLmlucHV0LnNldFNlbGVjdGlvblJhbmdlKDAsIGxhc3RDaGFyUGx1c09uZSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dGZpZWxkO1xuIiwiLyoqXG4gKiBAbW9kdWxlIGNlbGxFZGl0b3JzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICogQHBhcmFtIHtib29sZWFufSBbcHJpdmF0ZVJlZ2lzdHJ5PWZhbHNlXSAtIFRoaXMgaW5zdGFuY2Ugd2lsbCB1c2UgYSBwcml2YXRlIHJlZ2lzdHJ5LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENlbGxFZGl0b3JzKGdyaWQsIHByaXZhdGVSZWdpc3RyeSkge1xuICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG5cbiAgICBpZiAocHJpdmF0ZVJlZ2lzdHJ5KSB7XG4gICAgICAgIHRoaXMuZWRpdG9ycyA9IHt9O1xuICAgIH1cblxuICAgIC8vIHByZXJlZ2lzdGVyIHRoZSBzdGFuZGFyZCBjZWxsIGVkaXRvcnNcbiAgICBpZiAocHJpdmF0ZVJlZ2lzdHJ5IHx8ICF0aGlzLmdldCgnY2VsbGVkaXRvcicpKSB7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9Db21ib0JveCcpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9Db2xvcicpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9EYXRlJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0ZpbHRlckJveCcpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9OdW1iZXInKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vU2xpZGVyJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL1NwaW5uZXInKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vVGV4dGZpZWxkJykpO1xuICAgIH1cbn1cblxuQ2VsbEVkaXRvcnMucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDZWxsRWRpdG9ycy5wcm90b3R5cGUuY29uc3RydWN0b3IsIC8vIHByZXNlcnZlIGNvbnN0cnVjdG9yXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBhIGNlbGwgZWRpdG9yIGNvbnN0cnVjdG9yLlxuICAgICAqIEBkZXNjIEFkZHMgYSBjdXN0b20gY2VsbCBlZGl0b3IgY29uc3RydWN0b3IgdG8gdGhlIGBlZGl0b3JzYCBoYXNoIHVzaW5nIHRoZSBwcm92aWRlZCBuYW1lIChvciB0aGUgY2xhc3MgbmFtZSksIGNvbnZlcnRlZCB0byBhbGwgbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqID4gQWxsIG5hdGl2ZSBjZWxsIGVkaXRvcnMgYXJlIFwicHJlcmVnaXN0ZXJlZFwiIGluIGBlZGl0b3JzYC4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gQ2FzZS1pbnNlbnNpdGl2ZSBlZGl0b3Iga2V5LiBJZiBub3QgZ2l2ZW4sIGBZb3VyQ2VsbEVkaXRvci5wcm90b3R5cGUuJCRDTEFTU19OQU1FYCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtZb3VyQ2VsbEVkaXRvci5wcm90b3R5cGUuY29uc3RydWN0b3J9IENvbnN0cnVjdG9yIC0gQSBjb25zdHJ1Y3RvciwgdHlwaWNhbGx5IGV4dGVuZGVkIGZyb20gYENlbGxFZGl0b3JgIChvciBhIGRlc2NlbmRhbnQgdGhlcmVmcm9tKS5cbiAgICAgKlxuICAgICAqID4gTm90ZTogYCQkQ0xBU1NfTkFNRWAgY2FuIGJlIGVhc2lseSBzZXQgdXAgYnkgcHJvdmlkaW5nIGEgc3RyaW5nIGFzIHRoZSAob3B0aW9uYWwpIGZpcnN0IHBhcmFtZXRlciAoYGFsaWFzYCkgaW4geW91ciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZXh0ZW5kLW1lfENlbGxFZGl0b3IuZXh0ZW5kfSBjYWxsLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NlbGxFZGl0b3J9IEEgbmV3bHkgcmVnaXN0ZXJlZCBjb25zdHJ1Y3RvciBleHRlbmRlZCBmcm9tIHtAbGluayBDZWxsRWRpdG9yfS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Y2VsbEVkaXRvcnNcbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKG5hbWUsIENvbnN0cnVjdG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgQ29uc3RydWN0b3IgPSBuYW1lO1xuICAgICAgICAgICAgbmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWUgPSBuYW1lIHx8IENvbnN0cnVjdG9yLnByb3RvdHlwZS4kJENMQVNTX05BTUU7XG4gICAgICAgIG5hbWUgPSBuYW1lICYmIG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5lZGl0b3JzW25hbWVdID0gQ29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgYSBzeW5vbnltIGZvciBhbiBleGlzdGluZyBjZWxsIGVkaXRvciBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3lub255bU5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhpc3RpbmdOYW1lXG4gICAgICogQHJldHVybnMge0NlbGxFZGl0b3J9IFRoZSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgY29uc3RydWN0b3IgdGhpcyBuZXcgc3lub255bSBwb2ludHMgdG8uXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3JzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFkZFN5bm9ueW06IGZ1bmN0aW9uKHN5bm9ueW1OYW1lLCBleGlzdGluZ05hbWUpIHtcbiAgICAgICAgdmFyIGNlbGxFZGl0b3IgPSB0aGlzLmdldChleGlzdGluZ05hbWUpO1xuICAgICAgICByZXR1cm4gKHRoaXMuZWRpdG9yc1tzeW5vbnltTmFtZV0gPSBjZWxsRWRpdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIGEgcmVnaXN0ZXJlZCBlZGl0b3IuXG4gICAgICogQHJldHVybnMge0NlbGxFZGl0b3J9IEEgcmVnaXN0ZXJlZCBjb25zdHJ1Y3RvciBleHRlbmRlZCBmcm9tIHtAbGluayBDZWxsRWRpdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvcnNbbmFtZSAmJiBuYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBMb29rdXAgcmVnaXN0ZXJlZCBjZWxsIGVkaXRvciBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIHRoZXJlb2YuXG4gICAgICogQGRlc2MgTm90ZTogTXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgSHlwZXJncmlkIG9iamVjdCBhcyBjb250ZXh0IVxuICAgICAqIEByZXR1cm5zIHtDZWxsRWRpdG9yfSBOZXcgaW5zdGFuY2Ugb2YgdGhlIG5hbWVkIGNlbGwgZWRpdG9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiBhIHJlZ2lzdGVyZWQgZWRpdG9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9uc10gLSBQcm9wZXJ0aWVzIHRvIGFkZCB0byB0aGUgaW5zdGFudGlhdGVkIGVkaXRvciBwcmltYXJpbHkgZm9yIG11c3RhY2hlJ3MgdXNlLlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9ycy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNlbGxFZGl0b3IsXG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IHRoaXMuZ2V0KG5hbWUpO1xuXG4gICAgICAgIGlmIChDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgaWYgKENvbnN0cnVjdG9yLmFic3RyYWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0F0dGVtcHQgdG8gaW5zdGFudGlhdGUgYW4gXCJhYnN0cmFjdFwiIGNlbGwgZWRpdG9yIGNsYXNzLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsRWRpdG9yID0gbmV3IENvbnN0cnVjdG9yKHRoaXMuZ3JpZCwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2VsbEVkaXRvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNlbGwgZWRpdG9yIHJlZ2lzdHJ5IGNvbnRhaW5pbmcgYWxsIHRoZSBcInByZXJlZ2lzdGVyZWRcIiBjZWxsIGVkaXRvciBjb25zdHJ1Y3RvcnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgZWRpdG9yczoge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VsbEVkaXRvcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQnV0dG9uID0gQ2VsbFJlbmRlcmVyLmV4dGVuZCgnQnV0dG9uJywge1xuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVGhlIGRlZmF1bHQgY2VsbCByZW5kZXJpbmcgZnVuY3Rpb24gZm9yIGEgYnV0dG9uIGNlbGwuXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy54IC0gdGhlIHggc2NyZWVuIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy55IC0gdGhlIHkgc2NyZWVuIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5ib3VuZHMud2lkdGggLSB0aGUgd2lkdGggSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLmJvdW5kcy5oZWlnaHQgLSB0aGUgaGVpZ2h0IEknbSBhbGxvd2VkIHRvIGRyYXcgd2l0aGluXG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHZhbCA9IGNvbmZpZy52YWx1ZTtcbiAgICAgICAgdmFyIGMgPSBjb25maWcueDtcbiAgICAgICAgdmFyIHIgPSBjb25maWcueTtcbiAgICAgICAgdmFyIGJvdW5kcyA9IGNvbmZpZy5ib3VuZHM7XG4gICAgICAgIHZhciB4ID0gYm91bmRzLnggKyAyO1xuICAgICAgICB2YXIgeSA9IGJvdW5kcy55ICsgMjtcbiAgICAgICAgdmFyIHdpZHRoID0gYm91bmRzLndpZHRoIC0gMztcbiAgICAgICAgdmFyIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQgLSAzO1xuICAgICAgICB2YXIgcmFkaXVzID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIGFyY0dyYWRpZW50ID0gZ2MuY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeCwgeSArIGhlaWdodCk7XG4gICAgICAgIGlmIChjb25maWcubW91c2VEb3duKSB7XG4gICAgICAgICAgICBhcmNHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJyNCNUNCRUQnKTtcbiAgICAgICAgICAgIGFyY0dyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzRkNzRlYScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICcjZmZmZmZmJyk7XG4gICAgICAgICAgICBhcmNHcmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJyNhYWFhYWEnKTtcbiAgICAgICAgfVxuICAgICAgICBnYy5maWxsU3R5bGUgPSBhcmNHcmFkaWVudDtcbiAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSAnIzAwMDAwMCc7XG4gICAgICAgIHRoaXMucm91bmRSZWN0KGdjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMsIGFyY0dyYWRpZW50LCB0cnVlKTtcblxuICAgICAgICB2YXIgb3ggPSAod2lkdGggLSBjb25maWcuZ2V0VGV4dFdpZHRoKGdjLCB2YWwpKSAvIDI7XG4gICAgICAgIHZhciBveSA9IChoZWlnaHQgLSBjb25maWcuZ2V0VGV4dEhlaWdodChnYy5mb250KS5kZXNjZW50KSAvIDI7XG5cbiAgICAgICAgaWYgKGdjLnRleHRCYXNlbGluZSAhPT0gJ21pZGRsZScpIHtcbiAgICAgICAgICAgIGdjLnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gJyMwMDAwMDAnO1xuXG4gICAgICAgIGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIGdjLmZpbGxUZXh0KHZhbCwgeCArIG94LCB5ICsgb3kpO1xuXG4gICAgICAgIC8vaWRlbnRpZnkgdGhhdCB3ZSBhcmUgYSBidXR0b25cbiAgICAgICAgY29uZmlnLmJ1dHRvbkNlbGxzW2MgKyAnLCcgKyByXSA9IHRydWU7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQnV0dG9uO1xuXG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuLy4uL2xpYi9CYXNlJyk7XG5cbi8qKiBAY29uc3RydWN0b3JcbiAqIEBkZXNjIEluc3RhbmNlcyBvZiBgQ2VsbFJlbmRlcmVyYCBhcmUgdXNlZCB0byByZW5kZXIgdGhlIDJEIGdyYXBoaWNzIGNvbnRleHQgd2l0aGluIHRoZSBib3VuZCBvZiBhIGNlbGwuIEV4dGVuZCB0aGlzIGJhc2UgY2xhc3MgdG8gaW1wbGVtZW50IHlvdXIgb3duIGNlbGwgcmVuZGVyZXJcbiAqXG4gKlxuICogU2VlIGFsc28ge0B0dXRvcmlhbCBjZWxsLXJlbmRlcmVyfS5cbiAqL1xudmFyIENlbGxSZW5kZXJlciA9IEJhc2UuZXh0ZW5kKCdDZWxsUmVuZGVyZXInLCB7XG4gICAgLyoqXG4gICAgICogQGRlc2MgQW4gZW1wdHkgaW1wbGVtZW50YXRpb24gb2YgYSBjZWxsIHJlbmRlcmVyLCBzZWUgW3RoZSBudWxsIG9iamVjdCBwYXR0ZXJuXShodHRwOi8vYzIuY29tL2NnaS93aWtpP051bGxPYmplY3QpLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnY1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gY29uZmlnLmJvdW5kcyAtIFRoZSBib3VuZGluZyByZWN0IG9mIHRoZSBjZWxsIHRvIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSBjb25maWcueCAtIFRoZSBjZWxsIGNvbHVtbiBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBjb25maWcueSAtIFRoZSBjZWxsIHJvdyBwb3NpdGlvblxuICAgICAqIEBtZW1iZXJPZiBDZWxsUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgQSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2Ygcm91bmRpbmcgYSBjZWxsLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHggc2NyZWVuIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBzY3JlZW4gY29vcmRpbmF0ZSBvZiBteSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCBJJ20gYWxsb3dlZCB0byBkcmF3IHdpdGhpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlsbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJva2VcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJvdW5kUmVjdDogZnVuY3Rpb24oZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cywgZmlsbCwgc3Ryb2tlKSB7XG5cbiAgICAgICAgaWYgKCFzdHJva2UpIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYWRpdXMpIHtcbiAgICAgICAgICAgIHJhZGl1cyA9IDU7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIGdjLm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcbiAgICAgICAgZ2MubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG4gICAgICAgIGdjLnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByYWRpdXMpO1xuICAgICAgICBnYy5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgICAgZ2MucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgICAgIGdjLmxpbmVUbyh4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgZ2MucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgICAgZ2MubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICAgICAgICBnYy5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xuICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICAgIGdjLmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICB9XG59KTtcblxuQ2VsbFJlbmRlcmVyLmFic3RyYWN0ID0gdHJ1ZTsgLy8gZG9uJ3QgaW5zdGFudGlhdGUgZGlyZWN0bHlcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsUmVuZGVyZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRXJyb3JDZWxsID0gQ2VsbFJlbmRlcmVyLmV4dGVuZCgnRXJyb3JDZWxsJywge1xuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgV3JpdGVzIGVycm9yIG1lc3NhZ2UgaW50byBjZWxsLlxuICAgICAqXG4gICAgICogQGRlc2MgVGhpcyBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIGNhbGxlZCBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGdjLnNhdmUoKTtcbiAgICAgKiBnYy5iZWdpblBhdGgoKTtcbiAgICAgKiBnYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAqIGdjLmNsaXAoKTtcbiAgICAgKiBiZWhhdmlvci5nZXRDZWxsUHJvdmlkZXIoKS5yZW5kZXJDZWxsRXJyb3IoZ2MsIG1lc3NhZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAqIGdjLnJlc3RvcmUoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlLCB0aGlzIGZ1bmN0aW9uIHNob3VsZCBjbGVhciB0aGUgY2VsbCBieSBzZXR0aW5nIGBnYy5maWxsU3R5bGVgIGFuZCBjYWxsaW5nIGBnYy5maWxsKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBjb25maWcuYm91bmRzIC0gVGhlIGJvdW5kaW5nIHJlY3Qgb2YgdGhlIGNlbGwgdG8gYmUgcmVuZGVyZWQuXG4gICAgICogQHBhcmFtIGNvbmZpZy54IC0gVGhlIGNlbGwgY29sdW1uIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGNvbmZpZy55IC0gVGhlIGNlbGwgcm93IHBvc2l0aW9uXG4gICAgICogQG1lbWJlck9mIEVycm9yQ2VsbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWludDogZnVuY3Rpb24oZ2MsIGNvbmZpZywgbWVzc2FnZSkge1xuICAgICAgICAvL3ZhciBpbWFnZXMgPSByZXF1aXJlKCcuLi8uLi9pbWFnZXMvaW5kZXgnKTtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGNlbGxcbiAgICAgICAgLy8gKHRoaXMgbWFrZXMgdXNlIG9mIHRoZSByZWN0IHBhdGggZGVmaW5lZCBieSB0aGUgY2FsbGVyKVxuICAgICAgICBnYy5maWxsU3R5bGUgPSAnI0ZGRDUwMCc7XG4gICAgICAgIGdjLmZpbGwoKTtcbiAgICAgICAgLy8gcmVuZGVyIGNlbGwgYm9yZGVyXG4gICAgICAgIC8vZ2Muc3Ryb2tlU3R5bGUgPSBnYy5jcmVhdGVQYXR0ZXJuKGltYWdlcy5jYXV0aW9uLCAncmVwZWF0Jyk7IC8vIENhdXNlcyBFcnJvclxuICAgICAgICBnYy5saW5lV2lkdGggPSA1O1xuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgZ2MubW92ZVRvKHgsIHkpOyAvLyBjYXV0aW9uOiBkbyBub3QgdXNlIHJlY3QoKSBoZXJlIGJlY2F1c2UgQ2hyb21lIGRvZXMgbm90IGNsaXAgaXRzIHN0cm9rZSBwcm9wZXJseVxuICAgICAgICBnYy5saW5lVG8oeCArIHdpZHRoLCB5KTtcbiAgICAgICAgZ2MubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICAgIGdjLmxpbmVUbyh4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgZ2MubGluZVRvKHgsIHkpO1xuICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgLy8gYWRqdXN0IGNsaXAgcmVnaW9uIHRvIHByZXZlbnQgdGV4dCBmcm9tIHJlbmRlcmluZyBvdmVyIHJpZ2h0IGJvcmRlciBzaG91bGQgaXQgb3ZlcmZsb3dcbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIGdjLnJlY3QoeCwgeSwgd2lkdGggLSAyLCBoZWlnaHQpO1xuICAgICAgICBnYy5jbGlwKCk7XG4gICAgICAgIC8vIHJlbmRlciBtZXNzYWdlIHRleHRcbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gJyNBMDAnO1xuICAgICAgICBnYy50ZXh0QWxpZ24gPSAnc3RhcnQnO1xuICAgICAgICBnYy50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgZ2MuZm9udCA9ICdib2xkIDZwdCBcImFyaWFsIG5hcnJvd1wiLCB2ZXJkYW5hLCBnZW5ldmEnO1xuICAgICAgICBnYy5maWxsVGV4dChtZXNzYWdlLCB4ICsgNCwgeSArIGhlaWdodCAvIDIgKyAwLjUpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVycm9yQ2VsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxSZW5kZXJlciA9IHJlcXVpcmUoJy4vQ2VsbFJlbmRlcmVyJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBMYXN0U2VsZWN0aW9uID0gQ2VsbFJlbmRlcmVyLmV4dGVuZCgnTGFzdFNlbGVjdGlvbicsIHtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEEgcmVuZGVyaW5nIG9mIHRoZSBsYXN0IFNlbGVjdGlvbiBNb2RlbFxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnY1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gY29uZmlnLmJvdW5kcyAtIFRoZSBib3VuZGluZyByZWN0IG9mIHRoZSBjZWxsIHRvIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSBjb25maWcueCAtIFRoZSBjZWxsIGNvbHVtbiBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBjb25maWcueSAtIFRoZSBjZWxsIHJvdyBwb3NpdGlvblxuICAgICAqIEBtZW1iZXJPZiBMYXN0U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBhaW50OiBmdW5jdGlvbihnYywgY29uZmlnKSB7XG4gICAgICAgIHZhciB4ID0gY29uZmlnLmJvdW5kcy54LFxuICAgICAgICAgICAgeSA9IGNvbmZpZy5ib3VuZHMueSxcbiAgICAgICAgICAgIHdpZHRoID0gY29uZmlnLmJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbmZpZy5ib3VuZHMuaGVpZ2h0O1xuXG4gICAgICAgIC8vIHZhciBmb2N1c0xpbmVTdGVwID0gIFtcbiAgICAgICAgLy8gICAgIFs1LCA1XSxcbiAgICAgICAgLy8gICAgIFswLCAxLCA1LCA0XSxcbiAgICAgICAgLy8gICAgIFswLCAyLCA1LCAzXSxcbiAgICAgICAgLy8gICAgIFswLCAzLCA1LCAyXSxcbiAgICAgICAgLy8gICAgIFswLCA0LCA1LCAxXSxcbiAgICAgICAgLy8gICAgIFswLCA1LCA1LCAwXSxcbiAgICAgICAgLy8gICAgIFsxLCA1LCA0LCAwXSxcbiAgICAgICAgLy8gICAgIFsyLCA1LCAzLCAwXSxcbiAgICAgICAgLy8gICAgIFszLCA1LCAyLCAwXSxcbiAgICAgICAgLy8gICAgIFs0LCA1LCAxLCAwXVxuICAgICAgICAvLyBdO1xuICAgICAgICBnYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBnYy5maWxsU3R5bGUgPSBjb25maWcuc2VsZWN0aW9uUmVnaW9uT3ZlcmxheUNvbG9yO1xuICAgICAgICBnYy5maWxsKCk7XG4gICAgICAgIGdjLmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGdjLnN0cm9rZVN0eWxlID0gY29uZmlnLnNlbGVjdGlvblJlZ2lvbk91dGxpbmVDb2xvcjtcblxuICAgICAgICAvLyBhbmltYXRlIHRoZSBkYXNoZWQgbGluZSBhIGJpdCBoZXJlIGZvciBmdW5cblxuICAgICAgICBnYy5zdHJva2UoKTtcblxuICAgICAgICAvLyBnYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvL1xuICAgICAgICAvLyBnYy5zdHJva2VTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIC8vYW5pbWF0ZSB0aGUgZGFzaGVkIGxpbmUgYSBiaXQgaGVyZSBmb3IgZnVuXG4gICAgICAgIC8vIGdjLnNldExpbmVEYXNoKGZvY3VzTGluZVN0ZXBbTWF0aC5mbG9vcigxMCAqIChEYXRlLm5vdygpIC8gMzAwICUgMSkpICUgZm9jdXNMaW5lU3RlcC5sZW5ndGhdKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gZ2Muc3Ryb2tlKCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGFzdFNlbGVjdGlvbjtcblxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU2ltcGxlQ2VsbCA9IENlbGxSZW5kZXJlci5leHRlbmQoJ1NpbXBsZUNlbGwnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUaGUgZGVmYXVsdCBjZWxsIHJlbmRlcmluZyBmdW5jdGlvbiBmb3IgcmVuZGVyaW5nIGEgdmFuaWxsYSBjZWxsLlxuICAgICAqIEBkZXNjIEdyZWF0IGNhcmUgaGFzIGJlZW4gdGFrZW4gaW4gY3JhZnRpbmcgdGhpcyBmdW5jdGlvbiBhcyBpdCBuZWVkcyB0byBwZXJmb3JtIGV4dHJlbWVseSBmYXN0LiBSZWFkcyBvbiB0aGUgZ2Mgb2JqZWN0IGFyZSBleHBlbnNpdmUgYnV0IG5vdCBxdWl0ZSBhcyBleHBlbnNpdmUgYXMgd3JpdGVzIHRvIGl0LiBXZSBkbyBvdXIgYmVzdCB0byBhdm9pZCB3cml0ZXMsIHRoZW4gYXZvaWQgcmVhZHMuIENsaXBwaW5nIGJvdW5kcyBhcmUgbm90IHNldCBoZXJlIGFzIHRoaXMgaXMgYWxzbyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uLiBJbnN0ZWFkLCB3ZSB0cnVuY2F0ZSBvdmVyZmxvd2luZyB0ZXh0IGFuZCBjb250ZW50IGJ5IGZpbGxpbmcgYSByZWN0YW5nbGUgd2l0aCBiYWNrZ3JvdW5kIGNvbG9yIGNvbHVtbiBieSBjb2x1bW4gaW5zdGVhZCBvZiBjZWxsIGJ5IGNlbGwuICBUaGlzIGNvbHVtbiBieSBjb2x1bW4gZmlsbCBoYXBwZW5zIGhpZ2hlciB1cCBvbiB0aGUgc3RhY2sgaW4gYSBjYWxsaW5nIGZ1bmN0aW9uIGZyb20gZmluLWh5cGVyZ3JpZC1yZW5kZXJlci4gIFRha2Ugbm90ZSB3ZSBkbyBub3QgZG8gY2VsbCBieSBjZWxsIGJvcmRlciByZW5kZXJlcmluZyBhcyB0aGF0IGlzIGV4cGVuc2l2ZS4gIEluc3RlYWQgd2UgcmVuZGVyIG1hbnkgZmV3ZXIgZ3JpZGxpbmVzIGFmdGVyIGFsbCBjZWxscyBhcmUgcmVuZGVyZWQuXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBjb25maWcuYm91bmRzIC0gVGhlIGJvdW5kaW5nIHJlY3Qgb2YgdGhlIGNlbGwgdG8gYmUgcmVuZGVyZWQuXG4gICAgICogQHBhcmFtIGNvbmZpZy54IC0gVGhlIGNlbGwgY29sdW1uIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGNvbmZpZy55IC0gVGhlIGNlbGwgcm93IHBvc2l0aW9uXG4gICAgICogQG1lbWJlck9mIFNpbXBsZUNlbGwucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHZhbCA9IGNvbmZpZy52YWx1ZSxcbiAgICAgICAgICAgIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgICB3cmFwSGVhZGVycyA9IGNvbmZpZy5oZWFkZXJUZXh0V3JhcHBpbmcsXG4gICAgICAgICAgICBsZWZ0UGFkZGluZyA9IDIsIC8vVE9ETzogZml4IHRoaXNcbiAgICAgICAgICAgIGlzSGVhZGVyID0gY29uZmlnLnkgPT09IDA7XG5cbiAgICAgICAgdmFyIGxlZnRJY29uLCByaWdodEljb24sIGNlbnRlckljb24sIGl4b2Zmc2V0LCBpeW9mZnNldCwgZm9udDtcblxuICAgICAgICAvLyBzZXR0aW5nIGdjIHByb3BlcnRpZXMgYXJlIGV4cGVuc2l2ZSwgbGV0J3Mgbm90IGRvIGl0IG5lZWRsZXNzbHlcblxuICAgICAgICBpZiAodmFsICYmIHZhbC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIGxlZnRJY29uID0gdmFsWzBdO1xuICAgICAgICAgICAgcmlnaHRJY29uID0gdmFsWzJdO1xuICAgICAgICAgICAgdmFsID0gdmFsWzFdO1xuICAgICAgICAgICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmICh2YWwuY29uc3RydWN0b3IubmFtZSA9PT0gJ0hUTUxJbWFnZUVsZW1lbnQnKSB7IC8vIG11c3QgYmUgYW4gaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgY2VudGVySWNvbiA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdEljb24gJiYgbGVmdEljb24ubm9kZU5hbWUgIT09ICdJTUcnKSB7XG4gICAgICAgICAgICAgICAgbGVmdEljb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0SWNvbiAmJiByaWdodEljb24ubm9kZU5hbWUgIT09ICdJTUcnKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRJY29uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjZW50ZXJJY29uICYmIGNlbnRlckljb24ubm9kZU5hbWUgIT09ICdJTUcnKSB7XG4gICAgICAgICAgICAgICAgY2VudGVySWNvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YWwgPSB2YWxPckZ1bmModmFsLCBjb25maWcpO1xuICAgICAgICB2YWwgPSBjb25maWcuZm9ybWF0VmFsdWUodmFsKTtcblxuICAgICAgICBmb250ID0gY29uZmlnLmlzU2VsZWN0ZWQgPyBjb25maWcuZm9yZWdyb3VuZFNlbGVjdGlvbkZvbnQgOiBjb25maWcuZm9udDtcblxuICAgICAgICBpZiAoZ2MuZm9udCAhPT0gZm9udCkge1xuICAgICAgICAgICAgZ2MuZm9udCA9IGZvbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdjLnRleHRBbGlnbiAhPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICBnYy50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdjLnRleHRCYXNlbGluZSAhPT0gJ21pZGRsZScpIHtcbiAgICAgICAgICAgIGdjLnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsbCBiYWNrZ3JvdW5kIG9ubHkgaWYgb3VyIGJnQ29sb3IgaXMgcG9wdWxhdGVkIG9yIHdlIGFyZSBhIHNlbGVjdGVkIGNlbGxcbiAgICAgICAgdmFyIGJhY2tncm91bmRDb2xvciwgaG92ZXIsIGhvdmVyQ29sb3IsIHNlbGVjdENvbG9yLFxuICAgICAgICAgICAgY29sb3JzID0gW107XG5cbiAgICAgICAgaWYgKGNvbmZpZy5pc0NlbGxIb3ZlcmVkICYmIGNvbmZpZy5ob3ZlckNlbGxIaWdobGlnaHQuZW5hYmxlZCkge1xuICAgICAgICAgICAgaG92ZXJDb2xvciA9IGNvbmZpZy5ob3ZlckNlbGxIaWdobGlnaHQuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5pc1Jvd0hvdmVyZWQgJiYgKGhvdmVyID0gY29uZmlnLmhvdmVyUm93SGlnaGxpZ2h0KS5lbmFibGVkKSB7XG4gICAgICAgICAgICBob3ZlckNvbG9yID0gY29uZmlnLmlzR3JpZENvbHVtbiB8fCAhaG92ZXIuaGVhZGVyIHx8IGhvdmVyLmhlYWRlci5iYWNrZ3JvdW5kQ29sb3IgPT09IHVuZGVmaW5lZCA/IGhvdmVyLmJhY2tncm91bmRDb2xvciA6IGhvdmVyLmhlYWRlci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmlzQ29sdW1uSG92ZXJlZCAmJiAoaG92ZXIgPSBjb25maWcuaG92ZXJDb2x1bW5IaWdobGlnaHQpLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGhvdmVyQ29sb3IgPSBjb25maWcuaXNHcmlkUm93IHx8ICFob3Zlci5oZWFkZXIgfHwgaG92ZXIuaGVhZGVyLmJhY2tncm91bmRDb2xvciA9PT0gdW5kZWZpbmVkID8gaG92ZXIuYmFja2dyb3VuZENvbG9yIDogaG92ZXIuaGVhZGVyLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxwaGEoaG92ZXJDb2xvcikgPCAxKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RDb2xvciA9IHZhbE9yRnVuYyhjb25maWcuYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yLCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFscGhhKHNlbGVjdENvbG9yKSA8IDEpIHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSB2YWxPckZ1bmMoY29uZmlnLmJhY2tncm91bmRDb2xvciwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEoYmFja2dyb3VuZENvbG9yKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzLnB1c2goYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0Q29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbG9ycy5wdXNoKHNlbGVjdENvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaG92ZXJDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb2xvcnMucHVzaChob3ZlckNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBsYXllckNvbG9ycyhnYywgY29sb3JzLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyBkcmF3IHRleHRcbiAgICAgICAgdmFyIHRoZUNvbG9yID0gdmFsT3JGdW5jKGNvbmZpZy5pc1NlbGVjdGVkID8gY29uZmlnLmZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA6IGNvbmZpZy5jb2xvciwgY29uZmlnKTtcbiAgICAgICAgaWYgKGdjLmZpbGxTdHlsZSAhPT0gdGhlQ29sb3IpIHtcbiAgICAgICAgICAgIGdjLmZpbGxTdHlsZSA9IHRoZUNvbG9yO1xuICAgICAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSB0aGVDb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0hlYWRlciAmJiB3cmFwSGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJNdWx0aUxpbmVUZXh0KGdjLCBjb25maWcsIHZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclNpbmdsZUxpbmVUZXh0KGdjLCBjb25maWcsIHZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWNvbldpZHRoID0gMDtcbiAgICAgICAgaWYgKGxlZnRJY29uKSB7XG4gICAgICAgICAgICBpeW9mZnNldCA9IE1hdGgucm91bmQoKGhlaWdodCAtIGxlZnRJY29uLmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIGdjLmRyYXdJbWFnZShsZWZ0SWNvbiwgeCArIGxlZnRQYWRkaW5nLCB5ICsgaXlvZmZzZXQpO1xuICAgICAgICAgICAgaWNvbldpZHRoID0gTWF0aC5tYXgobGVmdEljb24ud2lkdGggKyAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmlnaHRJY29uICYmIHdpZHRoID4gMS43NSAqIGhlaWdodCkge1xuICAgICAgICAgICAgaXlvZmZzZXQgPSBNYXRoLnJvdW5kKChoZWlnaHQgLSByaWdodEljb24uaGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0WCA9IHggKyB3aWR0aCAtIHJpZ2h0SWNvbi53aWR0aDtcbiAgICAgICAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxheWVyQ29sb3JzKGdjLCBjb2xvcnMsIHJpZ2h0WCwgeSwgcmlnaHRJY29uLndpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnYy5jbGVhclJlY3QocmlnaHRYLCB5LCByaWdodEljb24ud2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnYy5kcmF3SW1hZ2UocmlnaHRJY29uLCByaWdodFgsIHkgKyBpeW9mZnNldCk7XG4gICAgICAgICAgICBpY29uV2lkdGggPSBNYXRoLm1heChyaWdodEljb24ud2lkdGggKyAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VudGVySWNvbikge1xuICAgICAgICAgICAgaXlvZmZzZXQgPSBNYXRoLnJvdW5kKChoZWlnaHQgLSBjZW50ZXJJY29uLmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIGl4b2Zmc2V0ID0gTWF0aC5yb3VuZCgod2lkdGggLSBjZW50ZXJJY29uLndpZHRoKSAvIDIpO1xuICAgICAgICAgICAgZ2MuZHJhd0ltYWdlKGNlbnRlckljb24sIHggKyB3aWR0aCAtIGl4b2Zmc2V0IC0gY2VudGVySWNvbi53aWR0aCwgeSArIGl5b2Zmc2V0KTtcbiAgICAgICAgICAgIGljb25XaWR0aCA9IE1hdGgubWF4KGNlbnRlckljb24ud2lkdGggKyAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmNlbGxCb3JkZXJUaGlja25lc3MpIHtcbiAgICAgICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgZ2MucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGdjLmxpbmVXaWR0aCA9IGNvbmZpZy5jZWxsQm9yZGVyVGhpY2tuZXNzO1xuICAgICAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSBjb25maWcuY2VsbEJvcmRlclN0eWxlO1xuXG4gICAgICAgICAgICAvLyBhbmltYXRlIHRoZSBkYXNoZWQgbGluZSBhIGJpdCBoZXJlIGZvciBmdW5cblxuICAgICAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcubWluV2lkdGggPSBjb25maWcubWluV2lkdGggKyAyICogKGljb25XaWR0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlbmRlcnMgc2luZ2xlIGxpbmUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc0dyYXBoaWNzQ29udGV4dH0gZ2NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IGNvbmZpZy5ib3VuZHMgLSBUaGUgYm91bmRpbmcgcmVjdCBvZiB0aGUgY2VsbCB0byBiZSByZW5kZXJlZC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbCAtIFRoZSB0ZXh0IHRvIHJlbmRlciBpbiB0aGUgY2VsbC5cbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlQ2VsbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZW5kZXJNdWx0aUxpbmVUZXh0OiBmdW5jdGlvbihnYywgY29uZmlnLCB2YWwpIHtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG4gICAgICAgIHZhciBsaW5lcyA9IGZpdFRleHQoZ2MsIGNvbmZpZywgdmFsLCB3aWR0aCk7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclNpbmdsZUxpbmVUZXh0KGdjLCBjb25maWcsIHNxdWVlemUodmFsKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sSEVkZ2VPZmZzZXQgPSBjb25maWcuY2VsbFBhZGRpbmcsXG4gICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSAwLFxuICAgICAgICAgICAgdmFsaWduT2Zmc2V0ID0gY29uZmlnLnZvZmZzZXQsXG4gICAgICAgICAgICBoYWxpZ24gPSBjb25maWcuaGFsaWduLFxuICAgICAgICAgICAgdGV4dEhlaWdodCA9IGNvbmZpZy5nZXRUZXh0SGVpZ2h0KGNvbmZpZy5mb250KS5oZWlnaHQ7XG5cbiAgICAgICAgc3dpdGNoIChoYWxpZ24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSB3aWR0aCAtIGNvbEhFZGdlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSBjb2xIRWRnZU9mZnNldDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoTWluID0gMCwgdk1pbiA9IE1hdGguY2VpbCh0ZXh0SGVpZ2h0IC8gMik7XG5cbiAgICAgICAgdmFsaWduT2Zmc2V0ICs9IE1hdGguY2VpbCgoaGVpZ2h0IC0gKGxpbmVzLmxlbmd0aCAtIDEpICogdGV4dEhlaWdodCkgLyAyKTtcblxuICAgICAgICBoYWxpZ25PZmZzZXQgPSBNYXRoLm1heChoTWluLCBoYWxpZ25PZmZzZXQpO1xuICAgICAgICB2YWxpZ25PZmZzZXQgPSBNYXRoLm1heCh2TWluLCB2YWxpZ25PZmZzZXQpO1xuXG4gICAgICAgIGdjLnNhdmUoKTsgLy8gZGVmaW5lIGEgY2xpcHBpbmcgcmVnaW9uIGZvciBjZWxsXG4gICAgICAgIGdjLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGdjLmNsaXAoKTtcblxuICAgICAgICBnYy50ZXh0QWxpZ24gPSBoYWxpZ247XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZ2MuZmlsbFRleHQobGluZXNbaV0sIHggKyBoYWxpZ25PZmZzZXQsIHkgKyB2YWxpZ25PZmZzZXQgKyAoaSAqIHRleHRIZWlnaHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdjLnJlc3RvcmUoKTsgLy8gZGlzY2FyZCBjbGlwcGluZyByZWdpb25cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVuZGVycyBzaW5nbGUgbGluZSB0ZXh0LlxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnY1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gY29uZmlnLmJvdW5kcyAtIFRoZSBib3VuZGluZyByZWN0IG9mIHRoZSBjZWxsIHRvIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsIC0gVGhlIHRleHQgdG8gcmVuZGVyIGluIHRoZSBjZWxsLlxuICAgICAqIEBtZW1iZXJPZiBTaW1wbGVDZWxsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlbmRlclNpbmdsZUxpbmVUZXh0OiBmdW5jdGlvbihnYywgY29uZmlnLCB2YWwpIHtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG4gICAgICAgIHZhciBjb2xIRWRnZU9mZnNldCA9IGNvbmZpZy5jZWxsUGFkZGluZyxcbiAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IDAsXG4gICAgICAgICAgICB2YWxpZ25PZmZzZXQgPSBjb25maWcudm9mZnNldCxcbiAgICAgICAgICAgIGhhbGlnbiA9IGNvbmZpZy5oYWxpZ24sXG4gICAgICAgICAgICBpc0NlbGxIb3ZlcmVkID0gY29uZmlnLmlzQ2VsbEhvdmVyZWQsXG4gICAgICAgICAgICBpc0xpbmsgPSBjb25maWcubGluaztcblxuICAgICAgICB2YXIgZm9udE1ldHJpY3MgPSBjb25maWcuZ2V0VGV4dEhlaWdodChjb25maWcuZm9udCk7XG4gICAgICAgIHZhciB0ZXh0V2lkdGggPSBjb25maWcuZ2V0VGV4dFdpZHRoKGdjLCB2YWwpO1xuXG4gICAgICAgIC8vd2UgbXVzdCBzZXQgdGhpcyBpbiBvcmRlciB0byBjb21wdXRlIHRoZSBtaW5pbXVtIHdpZHRoXG4gICAgICAgIC8vZm9yIGNvbHVtbiBhdXRvc2l6aW5nIHB1cnBvc2VzXG4gICAgICAgIGNvbmZpZy5taW5XaWR0aCA9IHRleHRXaWR0aCArICgyICogY29sSEVkZ2VPZmZzZXQpO1xuXG4gICAgICAgIHN3aXRjaCAoaGFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgLy90ZXh0V2lkdGggPSBjb25maWcuZ2V0VGV4dFdpZHRoKGdjLCBjb25maWcudmFsdWUpO1xuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IHdpZHRoIC0gY29sSEVkZ2VPZmZzZXQgLSB0ZXh0V2lkdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIC8vdGV4dFdpZHRoID0gY29uZmlnLmdldFRleHRXaWR0aChnYywgY29uZmlnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSAod2lkdGggLSB0ZXh0V2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IGNvbEhFZGdlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFsaWduT2Zmc2V0ID0gTWF0aC5tYXgoMCwgaGFsaWduT2Zmc2V0KTtcbiAgICAgICAgdmFsaWduT2Zmc2V0ID0gdmFsaWduT2Zmc2V0ICsgTWF0aC5jZWlsKGhlaWdodCAvIDIpO1xuXG4gICAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGdjLmZpbGxUZXh0KHZhbCwgeCArIGhhbGlnbk9mZnNldCwgeSArIHZhbGlnbk9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDZWxsSG92ZXJlZCkge1xuICAgICAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBpZiAoaXNMaW5rKSB7XG4gICAgICAgICAgICAgICAgdW5kZXJsaW5lKGNvbmZpZywgZ2MsIHZhbCwgeCArIGhhbGlnbk9mZnNldCwgeSArIHZhbGlnbk9mZnNldCArIE1hdGguZmxvb3IoZm9udE1ldHJpY3MuaGVpZ2h0IC8gMiksIDEpO1xuICAgICAgICAgICAgICAgIGdjLnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5zdHJpa2VUaHJvdWdoID09PSB0cnVlKSB7XG4gICAgICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIHN0cmlrZVRocm91Z2goY29uZmlnLCBnYywgdmFsLCB4ICsgaGFsaWduT2Zmc2V0LCB5ICsgdmFsaWduT2Zmc2V0ICsgTWF0aC5mbG9vcihmb250TWV0cmljcy5oZWlnaHQgLyAyKSwgMSk7XG4gICAgICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuZnVuY3Rpb24gZml0VGV4dChnYywgY29uZmlnLCBzdHJpbmcsIHdpZHRoKSB7XG4gICAgcmV0dXJuIGZpbmRMaW5lcyhnYywgY29uZmlnLCBzcXVlZXplKHN0cmluZykuc3BsaXQoJyAnKSwgd2lkdGgpO1xufVxuXG5mdW5jdGlvbiBmaW5kTGluZXMoZ2MsIGNvbmZpZywgd29yZHMsIHdpZHRoKSB7XG5cbiAgICBpZiAod29yZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB3b3JkcztcbiAgICB9XG5cbiAgICAvLyBzdGFydGluZyB3aXRoIGp1c3QgdGhlIGZpcnN0IHdvcmTigKZcbiAgICB2YXIgc3RpbGxGaXRzLCBsaW5lID0gW3dvcmRzLnNoaWZ0KCldO1xuICAgIHdoaWxlIChcbiAgICAgICAgLy8gc28gbG9uZSBhcyBsaW5lIHN0aWxsIGZpdHMgd2l0aGluIGN1cnJlbnQgY29sdW1u4oCmXG4gICAgKHN0aWxsRml0cyA9IGNvbmZpZy5nZXRUZXh0V2lkdGgoZ2MsIGxpbmUuam9pbignICcpKSA8IHdpZHRoKVxuICAgIC8vIOKApkFORCB0aGVyZSBhcmUgbW9yZSB3b3JkcyBhdmFpbGFibGXigKZcbiAgICAmJiB3b3Jkcy5sZW5ndGhcbiAgICAgICAgKSB7XG4gICAgICAgIC8vIOKApmFkZCBhbm90aGVyIHdvcmQgdG8gZW5kIG9mIGxpbmUgYW5kIHJldGVzdFxuICAgICAgICBsaW5lLnB1c2god29yZHMuc2hpZnQoKSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgICAhc3RpbGxGaXRzIC8vIGlmIGxpbmUgaXMgbm93IHRvbyBsb25n4oCmXG4gICAgICAgICYmIGxpbmUubGVuZ3RoID4gMSAvLyDigKZBTkQgaXMgbXVsdGlwbGUgd29yZHPigKZcbiAgICApIHtcbiAgICAgICAgd29yZHMudW5zaGlmdChsaW5lLnBvcCgpKTsgLy8g4oCmYmFjayBvZmYgYnkgKGkuZS4sIHJlbW92ZSkgb25lIHdvcmRcbiAgICB9XG5cbiAgICBsaW5lID0gW2xpbmUuam9pbignICcpXTtcblxuICAgIGlmICh3b3Jkcy5sZW5ndGgpIHsgLy8gaWYgdGhlcmUncyBhbnl0aGluZyBsZWZ04oCmXG4gICAgICAgIGxpbmUgPSBsaW5lLmNvbmNhdChmaW5kTGluZXMoZ2MsIGNvbmZpZywgd29yZHMsIHdpZHRoKSk7IC8vIOKApmJyZWFrIGl0IHVwIGFzIHdlbGxcbiAgICB9XG5cbiAgICByZXR1cm4gbGluZTtcbn1cblxuLy8gdHJpbSBzdHJpbmc7IHRoZW4gcmVkdWNlIGFsbCBydW5zIG9mIG11bHRpcGxlIHNwYWNlcyB0byBhIHNpbmdsZSBzcGFjZVxuZnVuY3Rpb24gc3F1ZWV6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gKHN0cmluZyArICcnKS50cmltKCkucmVwbGFjZSgvXFxzXFxzKy9nLCAnICcpO1xufVxuXG5mdW5jdGlvbiBzdHJpa2VUaHJvdWdoKGNvbmZpZywgZ2MsIHRleHQsIHgsIHksIHRoaWNrbmVzcykge1xuICAgIHZhciBmb250TWV0cmljcyA9IGNvbmZpZy5nZXRUZXh0SGVpZ2h0KGNvbmZpZy5mb250KTtcbiAgICB2YXIgd2lkdGggPSBjb25maWcuZ2V0VGV4dFdpZHRoKGdjLCB0ZXh0KTtcbiAgICB5ID0geSAtIChmb250TWV0cmljcy5oZWlnaHQgKiAwLjQpO1xuXG4gICAgc3dpdGNoIChnYy50ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIHggLT0gKHdpZHRoIC8gMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgeCAtPSB3aWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vZ2MuYmVnaW5QYXRoKCk7XG4gICAgZ2MubGluZVdpZHRoID0gdGhpY2tuZXNzO1xuICAgIGdjLm1vdmVUbyh4ICsgMC41LCB5ICsgMC41KTtcbiAgICBnYy5saW5lVG8oeCArIHdpZHRoICsgMC41LCB5ICsgMC41KTtcbn1cblxuZnVuY3Rpb24gdW5kZXJsaW5lKGNvbmZpZywgZ2MsIHRleHQsIHgsIHksIHRoaWNrbmVzcykge1xuICAgIHZhciB3aWR0aCA9IGNvbmZpZy5nZXRUZXh0V2lkdGgoZ2MsIHRleHQpO1xuXG4gICAgc3dpdGNoIChnYy50ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIHggLT0gKHdpZHRoIC8gMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgeCAtPSB3aWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vZ2MuYmVnaW5QYXRoKCk7XG4gICAgZ2MubGluZVdpZHRoID0gdGhpY2tuZXNzO1xuICAgIGdjLm1vdmVUbyh4ICsgMC41LCB5ICsgMC41KTtcbiAgICBnYy5saW5lVG8oeCArIHdpZHRoICsgMC41LCB5ICsgMC41KTtcbn1cblxuZnVuY3Rpb24gbGF5ZXJDb2xvcnMoZ2MsIGNvbG9ycywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICBnYy5maWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsT3JGdW5jKHZmLCBjb25maWcpIHtcbiAgICB2YXIgcmVzdWx0ID0gKHR5cGVvZiB2ZilbMF0gPT09ICdmJyA/IHZmKGNvbmZpZykgOiB2ZjtcbiAgICByZXR1cm4gcmVzdWx0IHx8IHJlc3VsdCA9PT0gMCA/IHJlc3VsdCA6ICcnO1xufVxuXG5mdW5jdGlvbiBhbHBoYShjc3NDb2xvclNwZWMpIHtcbiAgICBpZiAoY3NzQ29sb3JTcGVjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIHNvIG5vdCB2aXNpYmxlOyB0cmVhdCBhcyB0cmFuc3BhcmVudFxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlcyA9IGNzc0NvbG9yU3BlYy5tYXRjaChhbHBoYS5yZWdleCk7XG5cbiAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBhbiBvcGFxdWUgY29sb3IgKGEgY29sb3Igc3BlYyB3aXRoIG5vIGFscGhhIGNoYW5uZWwpXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHZhciBBID0gbWF0Y2hlc1s0XTtcblxuICAgIGlmIChBID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gY3NzQ29sb3JTcGVjIG11c3QgaGF2ZSBiZWVuICd0cmFuc3BhcmVudCdcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIE51bWJlcihBKTtcbn1cblxuYWxwaGEucmVnZXggPSAvXih0cmFuc3BhcmVudHwoKFJHQnxIU0wpQVxcKC4qLFxccyooW1xcZFxcLl0rKVxcKSkpJC9pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUNlbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU2xpZGVyID0gQ2VsbFJlbmRlcmVyLmV4dGVuZCgnU2xpZGVyJywge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBjb25maWcuYm91bmRzIC0gVGhlIGJvdW5kaW5nIHJlY3Qgb2YgdGhlIGNlbGwgdG8gYmUgcmVuZGVyZWQuXG4gICAgICogQHBhcmFtIGNvbmZpZy54IC0gVGhlIGNlbGwgY29sdW1uIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGNvbmZpZy55IC0gVGhlIGNlbGwgcm93IHBvc2l0aW9uXG4gICAgICogQG1lbWJlck9mIFNsaWRlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBFbWVyc29uJ3MgcGFpbnQgZnVuY3Rpb24gZm9yIGEgc2xpZGVyIGJ1dHRvbi4gY3VycmVudGx5IHRoZSB1c2VyIGNhbm5vdCBpbnRlcmFjdCB3aXRoIGl0XG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG4gICAgICAgIGdjLnN0cm9rZVN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuY29uZmlnLnZhbHVlO1xuICAgICAgICB2YXIgcmFkaXVzID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIG9mZnNldCA9IHdpZHRoICogdmFsO1xuICAgICAgICB2YXIgYmdDb2xvciA9IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQgPyB0aGlzLmNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IgOiAnIzMzMzMzMyc7XG4gICAgICAgIHZhciBidG5HcmFkaWVudCA9IGdjLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICBidG5HcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgYmdDb2xvcik7XG4gICAgICAgIGJ0bkdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzY2NjY2NicpO1xuICAgICAgICB2YXIgYXJjR3JhZGllbnQgPSBnYy5jcmVhdGVMaW5lYXJHcmFkaWVudCh4LCB5LCB4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICcjYWFhYWFhJyk7XG4gICAgICAgIGFyY0dyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzc3Nzc3NycpO1xuICAgICAgICBnYy5maWxsU3R5bGUgPSBidG5HcmFkaWVudDtcbiAgICAgICAgdGhpcy5yb3VuZFJlY3QoZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cywgYnRuR3JhZGllbnQpO1xuICAgICAgICBpZiAodmFsIDwgMS4wKSB7XG4gICAgICAgICAgICBnYy5maWxsU3R5bGUgPSBhcmNHcmFkaWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdjLmZpbGxTdHlsZSA9ICcjZWVlZWVlJztcbiAgICAgICAgfVxuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgZ2MuYXJjKHggKyBNYXRoLm1heChvZmZzZXQgLSByYWRpdXMsIHJhZGl1cyksIHkgKyByYWRpdXMsIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICBnYy5maWxsKCk7XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICB0aGlzLmNvbmZpZy5taW5XaWR0aCA9IDEwMDtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTbGlkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU3BhcmtCYXIgPSBDZWxsUmVuZGVyZXIuZXh0ZW5kKCdTcGFya0JhcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIGEgc3BhcmtsaW5lLCBiZWNhdXNlIGl0J3MgYSBiYXJjaGFydCB3ZSd2ZSBjaGFuZ2VkIHRoZSBuYW1lIDspLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnY1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gY29uZmlnLmJvdW5kcyAtIFRoZSBib3VuZGluZyByZWN0IG9mIHRoZSBjZWxsIHRvIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSBjb25maWcueCAtIFRoZSBjZWxsIGNvbHVtbiBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBjb25maWcueSAtIFRoZSBjZWxsIHJvdyBwb3NpdGlvblxuICAgICAqIEBtZW1iZXJPZiBTcGFya0Jhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWludDogZnVuY3Rpb24oZ2MsIGNvbmZpZykge1xuICAgICAgICB2YXIgeCA9IGNvbmZpZy5ib3VuZHMueCxcbiAgICAgICAgICAgIHkgPSBjb25maWcuYm91bmRzLnksXG4gICAgICAgICAgICB3aWR0aCA9IGNvbmZpZy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBjb25maWcuYm91bmRzLmhlaWdodDtcblxuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuY29uZmlnLnZhbHVlO1xuICAgICAgICBpZiAoIXZhbCB8fCAhdmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3VudCA9IHZhbC5sZW5ndGg7XG4gICAgICAgIHZhciBlV2lkdGggPSB3aWR0aCAvIGNvdW50O1xuICAgICAgICB2YXIgZmdDb2xvciA9IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQgPyB0aGlzLmNvbmZpZy5mb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgOiB0aGlzLmNvbmZpZy5jb2xvcjtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmJhY2tncm91bmRDb2xvciB8fCB0aGlzLmNvbmZpZy5pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICBnYy5maWxsU3R5bGUgPSB0aGlzLmNvbmZpZy5pc1NlbGVjdGVkID8gJ2JsdWUnIDogdGhpcy5jb25maWcuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gZmdDb2xvcjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBiYXJoZWlnaHQgPSB2YWxbaV0gLyAxMTAgKiBoZWlnaHQ7XG4gICAgICAgICAgICBnYy5maWxsUmVjdCh4ICsgNSwgeSArIGhlaWdodCAtIGJhcmhlaWdodCwgZVdpZHRoICogMC42NjY2LCBiYXJoZWlnaHQpO1xuICAgICAgICAgICAgeCA9IHggKyBlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIHRoaXMuY29uZmlnLm1pbldpZHRoID0gY291bnQgKiAxMDtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcGFya0JhcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxSZW5kZXJlciA9IHJlcXVpcmUoJy4vQ2VsbFJlbmRlcmVyJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTcGFya0xpbmUgPSBDZWxsUmVuZGVyZXIuZXh0ZW5kKCdTcGFya0xpbmUnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBBIHNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHNwYXJrbGluZS4gIHNlZSBbRWR3YXJkIFR1ZnRlIHNwYXJrbGluZV0oaHR0cDovL3d3dy5lZHdhcmR0dWZ0ZS5jb20vYmJvYXJkL3EtYW5kLWEtZmV0Y2gtbXNnP21zZ19pZD0wMDAxT1IpXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBjb25maWcuYm91bmRzIC0gVGhlIGJvdW5kaW5nIHJlY3Qgb2YgdGhlIGNlbGwgdG8gYmUgcmVuZGVyZWQuXG4gICAgICogQHBhcmFtIGNvbmZpZy54IC0gVGhlIGNlbGwgY29sdW1uIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGNvbmZpZy55IC0gVGhlIGNlbGwgcm93IHBvc2l0aW9uXG4gICAgICogQG1lbWJlck9mIFNwYXJrTGluZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWludDogZnVuY3Rpb24oZ2MsIGNvbmZpZykge1xuICAgICAgICB2YXIgeCA9IGNvbmZpZy5ib3VuZHMueCxcbiAgICAgICAgICAgIHkgPSBjb25maWcuYm91bmRzLnksXG4gICAgICAgICAgICB3aWR0aCA9IGNvbmZpZy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBjb25maWcuYm91bmRzLmhlaWdodDtcblxuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuY29uZmlnLnZhbHVlO1xuICAgICAgICBpZiAoIXZhbCB8fCAhdmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3VudCA9IHZhbC5sZW5ndGg7XG4gICAgICAgIHZhciBlV2lkdGggPSB3aWR0aCAvIGNvdW50O1xuXG4gICAgICAgIHZhciBmZ0NvbG9yID0gdGhpcy5jb25maWcuaXNTZWxlY3RlZCA/IHRoaXMuY29uZmlnLmZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA6IHRoaXMuY29uZmlnLmNvbG9yO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYmFja2dyb3VuZENvbG9yIHx8IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGdjLmZpbGxTdHlsZSA9IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQgPyB0aGlzLmNvbmZpZy5iYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgOiB0aGlzLmNvbmZpZy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICBnYy5maWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBnYy5zdHJva2VTdHlsZSA9IGZnQ29sb3I7XG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IGZnQ29sb3I7XG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgcHJldjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBiYXJoZWlnaHQgPSB2YWxbaV0gLyAxMTAgKiBoZWlnaHQ7XG4gICAgICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gYmFyaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2MubGluZVRvKHggKyA1LCB5ICsgaGVpZ2h0IC0gYmFyaGVpZ2h0KTtcbiAgICAgICAgICAgIGdjLmFyYyh4ICsgNSwgeSArIGhlaWdodCAtIGJhcmhlaWdodCwgMSwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgIHggPSB4ICsgZVdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnLm1pbldpZHRoID0gY291bnQgKiAxMDtcbiAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwYXJrTGluZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxSZW5kZXJlciA9IHJlcXVpcmUoJy4vQ2VsbFJlbmRlcmVyJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBUcmVlQ2VsbCA9IENlbGxSZW5kZXJlci5leHRlbmQoJ1RyZWVDZWxsJywge1xuXG4gICAgLyoqXG4gICAgICogQGRlc2MgQSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgYSB0cmVlIGNlbGwgcmVuZGVyZXIgZm9yIHVzZSBtYWlubHkgd2l0aCB0aGUgcXRyZWUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBjb25maWcuYm91bmRzIC0gVGhlIGJvdW5kaW5nIHJlY3Qgb2YgdGhlIGNlbGwgdG8gYmUgcmVuZGVyZWQuXG4gICAgICogQHBhcmFtIGNvbmZpZy54IC0gVGhlIGNlbGwgY29sdW1uIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGNvbmZpZy55IC0gVGhlIGNlbGwgcm93IHBvc2l0aW9uXG4gICAgICogQG1lbWJlck9mIFRyZWVDZWxsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBhaW50OiBmdW5jdGlvbihnYywgY29uZmlnKSB7XG4gICAgICAgIHZhciB4ID0gY29uZmlnLmJvdW5kcy54LFxuICAgICAgICAgICAgeSA9IGNvbmZpZy5ib3VuZHMueSxcbiAgICAgICAgICAgIHdpZHRoID0gY29uZmlnLmJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbmZpZy5ib3VuZHMuaGVpZ2h0O1xuXG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmNvbmZpZy52YWx1ZS5kYXRhO1xuICAgICAgICB2YXIgaW5kZW50ID0gdGhpcy5jb25maWcudmFsdWUuaW5kZW50O1xuICAgICAgICB2YXIgaWNvbiA9IHRoaXMuY29uZmlnLnZhbHVlLmljb247XG5cbiAgICAgICAgLy9maWxsIGJhY2tncm91bmQgb25seSBpZiBvdXIgYmdDb2xvciBpcyBwb3B1bGF0ZWQgb3Igd2UgYXJlIGEgc2VsZWN0ZWQgY2VsbFxuICAgICAgICBpZiAodGhpcy5jb25maWcuYmFja2dyb3VuZENvbG9yIHx8IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGdjLmZpbGxTdHlsZSA9IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQgPyB0aGlzLmNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IgOiB0aGlzLmNvbmZpZy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICBnYy5maWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdmFsIHx8ICF2YWwubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbGlnbk9mZnNldCA9IE1hdGguY2VpbChoZWlnaHQgLyAyKTtcblxuICAgICAgICBnYy5maWxsU3R5bGUgPSB0aGlzLmNvbmZpZy5pc1NlbGVjdGVkID8gdGhpcy5jb25maWcuYmFja2dyb3VuZENvbG9yIDogdGhpcy5jb25maWcuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBnYy5maWxsVGV4dChpY29uICsgdmFsLCB4ICsgaW5kZW50LCB5ICsgdmFsaWduT2Zmc2V0KTtcblxuICAgICAgICB2YXIgdGV4dFdpZHRoID0gdGhpcy5jb25maWcuZ2V0VGV4dFdpZHRoKGdjLCBpY29uICsgdmFsKTtcbiAgICAgICAgdmFyIG1pbldpZHRoID0geCArIGluZGVudCArIHRleHRXaWR0aCArIDEwO1xuICAgICAgICB0aGlzLmNvbmZpZy5taW5XaWR0aCA9IG1pbldpZHRoO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyZWVDZWxsO1xuIiwiLyoqXG4gKiBAc3VtbWFyeSBBUEkgb2YgY2VsbCByZW5kZXJlciBvYmplY3QgY29uc3RydWN0b3JzLCBwbHVzIHNvbWUgYWNjZXNzIG1ldGhvZHMuXG4gKiBAbW9kdWxlIGNlbGxSZW5kZXJlcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBbcHJpdmF0ZVJlZ2lzdHJ5PWZhbHNlXSAtIFRoaXMgaW5zdGFuY2Ugd2lsbCB1c2UgYSBwcml2YXRlIHJlZ2lzdHJ5LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENlbGxSZW5kZXJlcnMocHJpdmF0ZVJlZ2lzdHJ5KSB7XG4gICAgaWYgKHByaXZhdGVSZWdpc3RyeSkge1xuICAgICAgICB0aGlzLnNpbmdsZXRvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBwcmVyZWdpc3RlciB0aGUgc3RhbmRhcmQgY2VsbCByZW5kZXJlcnNcbiAgICBpZiAocHJpdmF0ZVJlZ2lzdHJ5IHx8ICF0aGlzLmdldCgnZW1wdHljZWxsJykpIHtcbiAgICAgICAgdGhpcy5hZGQoJ0VtcHR5Q2VsbCcsIHJlcXVpcmUoJy4vQ2VsbFJlbmRlcmVyJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0J1dHRvbicpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9TaW1wbGVDZWxsJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL1NsaWRlckNlbGwnKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vU3BhcmtCYXInKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vTGFzdFNlbGVjdGlvbicpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9TcGFya0xpbmUnKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vRXJyb3JDZWxsJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL1RyZWVDZWxsJykpO1xuICAgIH1cbn1cblxuQ2VsbFJlbmRlcmVycy5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENlbGxSZW5kZXJlcnMucHJvdG90eXBlLmNvbnN0cnVjdG9yLCAvLyBwcmVzZXJ2ZSBjb25zdHJ1Y3RvclxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgYW5kIGluc3RhbnRpYXRlIGEgY2VsbCByZW5kZXJlciBzaW5nbGV0b24uXG4gICAgICogQGRlc2MgQWRkcyBhIGN1c3RvbSBjZWxsIHJlbmRlcmVyIHRvIHRoZSBgc2luZ2xldG9uc2AgaGFzaCB1c2luZyB0aGUgcHJvdmlkZWQgbmFtZSAob3IgdGhlIGNsYXNzIG5hbWUpLCBjb252ZXJ0ZWQgdG8gYWxsIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiA+IEFsbCBuYXRpdmUgY2VsbCByZW5kZXJlcnMgYXJlIFwicHJlcmVnaXN0ZXJlZFwiIGluIGBzaW5nbGV0b25zYC4gQWRkIG1vcmUgYnkgY2FsbGluZyBgZ2V0YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gLSBDYXNlLWluc2Vuc2l0aXZlIHJlbmRlcmVyIGtleS4gSWYgbm90IGdpdmVuLCBgWW91ckNlbGxSZW5kZXJlci5wcm90b3R5cGUuJCRDTEFTU19OQU1FYCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDZWxsUmVuZGVyZXJ9IENvbnN0cnVjdG9yIC0gQSBjb25zdHJ1Y3RvciwgdHlwaWNhbGx5IGV4dGVuZGVkIGZyb20gYENlbGxSZW5kZXJlcmAgKG9yIGEgZGVzY2VuZGFudCB0aGVyZWZyb20pLlxuICAgICAqXG4gICAgICogPiBOb3RlOiBgJCRDTEFTU19OQU1FYCBjYW4gYmUgZWFzaWx5IHNldCB1cCBieSBwcm92aWRpbmcgYSBzdHJpbmcgYXMgdGhlIChvcHRpb25hbCkgZmlyc3QgcGFyYW1ldGVyIChgYWxpYXNgKSBpbiB5b3VyIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9leHRlbmQtbWV8Q2VsbEVkaXRvci5leHRlbmR9IGNhbGwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q2VsbFJlbmRlcmVyc30gQSBuZXdseSByZWdpc3RlcmVkIGNvbnN0cnVjdG9yIGV4dGVuZGVkIGZyb20ge0BsaW5rIENlbGxSZW5kZXJlcnN9LlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIENlbGxSZW5kZXJlcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihuYW1lLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yID0gbmFtZTtcbiAgICAgICAgICAgIG5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lID0gbmFtZSB8fCBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuJCRDTEFTU19OQU1FO1xuICAgICAgICBuYW1lID0gbmFtZSAmJiBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiAodGhpcy5zaW5nbGV0b25zW25hbWVdID0gbmV3IENvbnN0cnVjdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgYSBzeW5vbnltIGZvciBhbiBleGlzdGluZyBjZWxsIHJlbmRlcmVyIHNpbmdsZXRvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3lub255bU5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhpc3RpbmdOYW1lXG4gICAgICogQHJldHVybnMge0NlbGxSZW5kZXJlcnN9IFRoZSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgY29uc3RydWN0b3IgdGhpcyBuZXcgc3lub255bSBwb2ludHMgdG8uXG4gICAgICogQG1lbWJlck9mIENlbGxSZW5kZXJlcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgYWRkU3lub255bTogZnVuY3Rpb24oc3lub255bU5hbWUsIGV4aXN0aW5nTmFtZSkge1xuICAgICAgICB2YXIgY2VsbFJlbmRlcmVyID0gdGhpcy5nZXQoZXhpc3RpbmdOYW1lKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLnNpbmdsZXRvbnNbc3lub255bU5hbWVdID0gY2VsbFJlbmRlcmVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSByZWdpc3RlcmVkIGNlbGwgcmVuZGVyZXIgc2luZ2xldG9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge0NlbGxSZW5kZXJlcnN9IEEgcmVnaXN0ZXJlZCBjb25zdHJ1Y3RvciBleHRlbmRlZCBmcm9tIHtAbGluayBDZWxsUmVuZGVyZXJzfS5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFJlbmRlcmVycy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2luZ2xldG9uc1tuYW1lICYmIG5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjZWxsIGVkaXRvciByZWdpc3RyeSBjb250YWluaW5nIGFsbCB0aGUgXCJwcmVyZWdpc3RlcmVkXCIgY2VsbCByZW5kZXJlciBzaW5nbGV0b25zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlck9mIENlbGxSZW5kZXJlcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgc2luZ2xldG9uczoge31cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsUmVuZGVyZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL2xpYi9CYXNlJyk7XG5cbnZhciBBID0gJ0EnLmNoYXJDb2RlQXQoMCk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRhTW9kZWwgPSBCYXNlLmV4dGVuZCgnRGF0YU1vZGVsJywge1xuXG4gICAgbmV4dDogbnVsbCxcblxuICAgIGdyaWQ6IG51bGwsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgfSxcblxuICAgIGNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdyaWQuYmVoYXZpb3IuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBnZXRQcml2YXRlU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBhcHBseVN0YXRlOiBmdW5jdGlvbigpIHtcblxuICAgIH0sXG5cbiAgICBhbHBoYUZvcjogZnVuY3Rpb24oaSkge1xuICAgICAgICAvLyBOYW1lIHRoZSBjb2x1bW4gaGVhZGVycyBpbiBBLCAuLiwgQUEsIEFCLCBBQywgLi4sIEFaIGZvcm1hdFxuICAgICAgICAvLyBxdW90aWVudC9yZW1haW5kZXJcbiAgICAgICAgLy92YXIgcXVvID0gTWF0aC5mbG9vcihjb2wvMjcpO1xuICAgICAgICB2YXIgcXVvID0gTWF0aC5mbG9vcihpIC8gMjYpO1xuICAgICAgICB2YXIgcmVtID0gaSAlIDI2O1xuICAgICAgICB2YXIgY29kZSA9ICcnO1xuICAgICAgICBpZiAocXVvID4gMCkge1xuICAgICAgICAgICAgY29kZSArPSB0aGlzLmFscGhhKHF1byAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGUgKz0gdGhpcy5hbHBoYShyZW0pO1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9LFxuXG4gICAgYWxwaGE6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQSArIGkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlY2xhcmVkUmVuZGVyZXJOYW1lIC0gVGhlIHByb3Bvc2VkIGNlbGwgcmVuZGVyZXIgbmFtZSAoZm9ybSB0aGUgcmVuZGVyIHByb3BlcnRpZXMpLlxuICAgICAqIEByZXR1cm5zIHtDZWxsUmVuZGVyZXJ9XG4gICAgICogQG1lbWJlck9mIERhdGFNb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRDZWxsOiBmdW5jdGlvbihjb25maWcsIGRlY2xhcmVkUmVuZGVyZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuY2VsbFJlbmRlcmVycy5nZXQoZGVjbGFyZWRSZW5kZXJlck5hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbnN0YW50aWF0ZSBhIG5ldyBjZWxsIGVkaXRvci5cbiAgICAgKiBAZGVzYyBUaGUgYXBwbGljYXRpb24gZGV2ZWxvcGVyIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0bzpcbiAgICAgKiAqIEluc3RhbnRpYXRlIGFuZCByZXR1cm4gYW4gYXJiaXRyYXJ5IGNlbGwgZWRpdG9yLiBUaGUgZ2VuZXJpYyBpbXBsZW1lbnRhdGlvbiBoZXJlIHNpbXBseSByZXR1cm5zIHRoZSBkZWNsYXJlZCBjZWxsIGVkaXRvci4gVGhpcyBpcyBgdW5kZWZpbmVkYCB3aGVuIHRoZXJlIHdhcyBubyBzdWNoIGRlY2xhcmF0aW9uLCBvciBpZiB0aGUgbmFtZWQgY2VsbCBlZGl0b3Igd2FzIG5vdCByZWdpc3RlcmVkLlxuICAgICAqICogUmV0dXJuIGB1bmRlZmluZWRgIGZvciBubyBjZWxsIGVkaXRvciBhdCBhbGwuIFRoZSBjZWxsIHdpbGwgbm90IGJlIGVkaXRhYmxlLlxuICAgICAqICogU2V0IHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlIGJ5IHBhc3NpbmcgdGhlbSBpbiB0aGUgYG9wdGlvbnNgIG9iamVjdC4gVGhlc2UgYXJlIGFwcGxpZWQgdG8gdGhlIG5ldyBjZWxsIGVkaXRvciBvYmplY3QgYWZ0ZXIgaW5zdGFudGlhdGlvbiBidXQgYmVmb3JlIHJlbmRlcmluZy5cbiAgICAgKiAqIE1hbmlwdWxhdGUgdGhlIGNlbGwgZWRpdG9yIG9iamVjdCAoaW5jbHVkaW5nIGl0cyBET00gZWxlbWVudHMpIGFmdGVyIHJlbmRlcmluZyBidXQgYmVmb3JlIERPTSBpbnNlcnRpb24uXG4gICAgICpcbiAgICAgKiBPdmVycmlkaW5nIHRoaXMgbWV0aG9kIHdpdGggYSBudWxsIGZ1bmN0aW9uICh0aGF0IGFsd2F5cyByZXR1cm5zIGB1bmRlZmluZWRgKSB3aWxsIGhhdmUgdGhlIGVmZmVjdCBvZiBtYWtpbmcgYWxsIGNlbGxzIHVuZWRpdGFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSBBYnNvbHV0ZSBjb2x1bW4gaW5kZXguIEkuZS4sIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29sdW1uIGluIHRoZSBkYXRhIHNvdXJjZSdzIG9yaWdpbmFsIGBmaWVsZHNgIGFycmF5LCBhcyBlY2hvZWQgaW4gYGJlaGF2aW9yLmFsbENvbHVtbnNbXWAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gUm93IGluZGV4IG9mIHRoZSBkYXRhIHJvdyBpbiB0aGUgY3VycmVudGx5IGZpbHRlcmVkIGFuZCBzb3J0ZWQgbGlzdCBvZiByb3dzLCByZWdhcmRsZXNzIG9mIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbiwgb2Zmc2V0IGJ5IHRoZSBudW1iZXIgb2YgaGVhZGVyIHJvd3MgKGFsbCB0aGUgcm93cyBhYm92ZSB0aGUgZmlyc3QgZGF0YSByb3cgaW5jbHVkaW5nIHRoZSBmaWx0ZXIgcm93KS4gSS5lLiwgYWZ0ZXIgc3VidHJhY3Rpbmcgb3V0IHRoZSBudW1iZXIgb2YgaGVhZGVyIHJvd3MsIHRoaXMgaXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBkYXRhIHJvdyBpbiB0aGUgYGluZGV4YCBhcnJheSBvZiB0aGUgZGF0YSBzb3VyY2UgKGkuZS4sIHRoZSBsYXN0IGRhdGEgc291cmNlIHBpcGVsaW5lKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVjbGFyZWRFZGl0b3JOYW1lIC0gVGhlIHByb3Bvc2VkIGNlbGwgZWRpdG9yIG5hbWUgKGZyb20gdGhlIHJlbmRlciBwcm9wZXJ0aWVzKS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgbmV3IGNlbGwgZWRpdG9yIHByaW1hcmlseSBmb3IgbXVzdGFjaGUncyB1c2UuIEFkZGl0aW9uYWxseSwgYWx3YXlzIGluY2x1ZGVzIHRoZSBmb2xsb3dpbmc6XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZm9ybWF0IC0gVGhlIHZhbHVlIG9mIHRoZSBgZm9ybWF0YCByZW5kZXIgcHJvcC4gTWF5IGJlIGB1bmRlZmluZWRgLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNvbHVtbiAtIEZvciBjb252ZW5pZW5jZSwgdGhlIGNvbHVtbiBvYmplY3QgaW4gYGJlaGF2aW9yLmFsbENvbHVtbnNbXWAgdG8gd2hpY2ggYGNvbHVtbkluZGV4YCByZWZlcnMuXG4gICAgICogQHBhcmFtIHtQb2ludH0gb3B0aW9ucy5lZGl0UG9pbnQgLSBUaGUgZ3JpZCBjb29yZGluYXRlcyBvZiB0aGUgY2VsbCB0byBlZGl0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmVkaXRQb2ludC54IC0gVGhlIGhvcml6b250YWwgbW9kZWwgY29vcmRpbmF0ZSBvZiB0aGUgY2VsbCB0byBlZGl0LiBUaGlzIGlzIHRoZSBncmlkIGNvb3JkaW5hdGUgcmVnYXJkbGVzcyBvZiBob3Jpem9udGFsIHNjcm9sbCBwb3NpdGlvbi4gSS5lLiwgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb2x1bW4gaW4gdGhlIG9yZGVyZWQgbGlzdCBvZiBzZWxlY3RlZCBjb2x1bW5zIChgYmVoYXZpb3IuY29sdW1uc1tdYCkuIChUaGlzIGlzIHRoZSBjb29yZGluYXRlIHJlcXVpcmVkIGJ5IHtAbGluayBIeXBlcmdyaWQjZWRpdEF0fGVkaXRBdH0uKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmVkaXRQb2ludC55IC0gU2FtZSBhcyBgcm93SW5kZXhgLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxDZWxsRWRpdG9yfSBBbiBvYmplY3QgaW5zdGFudGlhdGVkIGZyb20gdGhlIHJlZ2lzdGVyZWQgY2VsbCBlZGl0b3IgY29uc3RydWN0b3IgbmFtZWQgaW4gYGRlY2xhcmVkRWRpdG9yTmFtZWAuIEEgZmFsc3kgcmV0dXJuIG1lYW5zIHRoZSBjZWxsIGlzIG5vdCBlZGl0YWJsZSBiZWNhdXNlIHRoZSBgZGVjbGFyZWRFZGl0b3JOYW1lYCB3YXMgbm90IHJlZ2lzdGVyZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldENlbGxFZGl0b3JBdDogZnVuY3Rpb24oY29sdW1uSW5kZXgsIHJvd0luZGV4LCBkZWNsYXJlZEVkaXRvck5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5jZWxsRWRpdG9ycy5jcmVhdGUoZGVjbGFyZWRFZGl0b3JOYW1lLCBvcHRpb25zKTtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFNb2RlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFuYWx5dGljcyA9IHJlcXVpcmUoJy4uL1NoYXJlZC5qcycpLmFuYWx5dGljcztcbnZhciBEYXRhTW9kZWwgPSByZXF1aXJlKCcuL0RhdGFNb2RlbCcpO1xudmFyIGltYWdlcyA9IHJlcXVpcmUoJy4uLy4uL2ltYWdlcycpO1xuXG52YXIgVVBXQVJEU19CTEFDS19BUlJPVyA9ICdcXHUyNWIyJywgLy8gYWthICfilrInXG4gICAgRE9XTldBUkRTX0JMQUNLX0FSUk9XID0gJ1xcdTI1YmMnOyAvLyBha2EgJ+KWvCdcblxudmFyIG51bGxEYXRhU291cmNlID0ge1xuICAgIGlzTnVsbE9iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgZ2V0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgZ2V0QWdncmVnYXRlVG90YWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgaGFzQWdncmVnYXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGhhc0dyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGdldFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICB2aWV3TWFrZXNTZW5zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIHNldEFnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKCkge30sXG4gICAgc2V0R3JvdXBCeXM6IGZ1bmN0aW9uKCkge30sXG4gICAgZ3JvdXBCeXM6IFtdLFxuXG59O1xuXG4vKipcbiAqIEBuYW1lIGRhdGFNb2RlbHMuSlNPTlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBKU09OID0gRGF0YU1vZGVsLmV4dGVuZCgnZGF0YU1vZGVscy5KU09OJywge1xuXG4gICAgLy9udWxsIG9iamVjdCBwYXR0ZXJuIGZvciB0aGUgc291cmNlIG9iamVjdFxuICAgIHJlc2V0U291cmNlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc291cmNlcyA9IHtcbiAgICAgICAgICAgIHNvdXJjZTogbnVsbERhdGFTb3VyY2UsXG4gICAgICAgICAgICBhZ2dyZWdhdG9yOiBudWxsRGF0YVNvdXJjZSxcbiAgICAgICAgICAgIGdsb2JhbGZpbHRlcjogbnVsbERhdGFTb3VyY2UsXG4gICAgICAgICAgICBzb3J0ZXJjb21wb3NpdGU6IG51bGxEYXRhU291cmNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgdG9wVG90YWxzOiBbXSxcbiAgICBib3R0b21Ub3RhbHM6IFtdLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVzZXRTb3VyY2VzKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWREYXRhID0gW107XG4gICAgfSxcblxuICAgIGNsZWFyU2VsZWN0ZWREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZERhdGEubGVuZ3RoID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNBZ2dyZWdhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlcy5hZ2dyZWdhdG9yLmhhc0FnZ3JlZ2F0ZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzLmFnZ3JlZ2F0b3IuaGFzR3JvdXBzKCk7XG4gICAgfSxcblxuICAgIGdldERhdGFTb3VyY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlO1xuICAgIH0sXG5cbiAgICBnZXRHbG9iYWxGaWx0ZXJEYXRhU291cmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlcy5nbG9iYWxmaWx0ZXI7XG4gICAgfSxcblxuICAgIGdldERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzLnNvdXJjZS5kYXRhO1xuICAgIH0sXG5cbiAgICBnZXRGaWx0ZXJlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZHMgPSB0aGlzLmdldERhdGFTb3VyY2UoKTtcbiAgICAgICAgdmFyIGNvdW50ID0gZHMuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY291bnQ7IHkrKykge1xuICAgICAgICAgICAgcmVzdWx0W3ldID0gZHMuZ2V0Um93KHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBoYXNIaWVyYXJjaHlDb2x1bW4gPSB0aGlzLmhhc0hpZXJhcmNoeUNvbHVtbigpO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGlmIChoYXNIaWVyYXJjaHlDb2x1bW4pIHtcbiAgICAgICAgICAgIGlmICh4ID09PSAtMikge1xuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzQWdncmVnYXRlcygpKSB7XG4gICAgICAgICAgICB4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPCBoZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEhlYWRlclJvd1ZhbHVlKHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgKGhhc0hpZXJhcmNoeUNvbHVtbikge1xuICAgICAgICAgICAgLy8gICAgIHkgKz0gMTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXREYXRhU291cmNlKCkuZ2V0VmFsdWUoeCwgeSAtIGhlYWRlclJvd0NvdW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldERhdGFJbmRleDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhU291cmNlKCkuZ2V0RGF0YUluZGV4KHkgLSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIG5lZ2F0aXZlIHZhbHVlcyByZWZlciB0byBfYm90dG9tIHRvdGFsc18gcm93c1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldEhlYWRlclJvd1ZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEhlYWRlcnMoKVtNYXRoLm1heCh4LCAwKV07XG4gICAgICAgIH0gZWxzZSBpZiAoeSA8IDApIHsgLy8gYm90dG9tIHRvdGFscyByb3dzXG4gICAgICAgICAgICB2YXIgYm90dG9tVG90YWxzID0gdGhpcy5nZXRCb3R0b21Ub3RhbHMoKTtcbiAgICAgICAgICAgIHZhbHVlID0gYm90dG9tVG90YWxzW2JvdHRvbVRvdGFscy5sZW5ndGggKyB5XVt4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpc0ZpbHRlclJvdyA9IHRoaXMuZ3JpZC5pc1Nob3dGaWx0ZXJSb3coKSxcbiAgICAgICAgICAgICAgICBpc0hlYWRlclJvdyA9IHRoaXMuZ3JpZC5pc1Nob3dIZWFkZXJSb3coKSxcbiAgICAgICAgICAgICAgICB0b3BUb3RhbHNPZmZzZXQgPSAoaXNGaWx0ZXJSb3cgPyAxIDogMCkgKyAoaXNIZWFkZXJSb3cgPyAxIDogMCk7XG4gICAgICAgICAgICBpZiAoeSA+PSB0b3BUb3RhbHNPZmZzZXQpIHsgLy8gdG9wIHRvdGFscyByb3dzXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldFRvcFRvdGFscygpW3kgLSB0b3BUb3RhbHNPZmZzZXRdW3hdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0hlYWRlclJvdyAmJiB5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEhlYWRlcnMoKVt4XTtcbiAgICAgICAgICAgICAgICB2YXIgc29ydFN0cmluZyA9IHRoaXMuZ2V0U29ydEltYWdlRm9yQ29sdW1uKHgpO1xuICAgICAgICAgICAgICAgIGlmIChzb3J0U3RyaW5nKSB7IHZhbHVlID0gc29ydFN0cmluZyArIHZhbHVlOyB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBtdXN0IGJlIGZpbHRlciByb3dcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5nZXRHbG9iYWxGaWx0ZXIoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpbHRlciAmJiBmaWx0ZXIuZ2V0Q29sdW1uRmlsdGVyU3RhdGUodGhpcy5nZXRGaWVsZHMoKVt4XSkgfHwgJyc7XG4gICAgICAgICAgICAgICAgdmFyIGljb24gPSBpbWFnZXMuZmlsdGVyKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtudWxsLCB2YWx1ZSwgaWNvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGhhc0hpZXJhcmNoeUNvbHVtbiA9IHRoaXMuaGFzSGllcmFyY2h5Q29sdW1uKCk7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICBpZiAoaGFzSGllcmFyY2h5Q29sdW1uKSB7XG4gICAgICAgICAgICBpZiAoeCA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSkge1xuICAgICAgICAgICAgeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5IDwgaGVhZGVyUm93Q291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGVhZGVyUm93VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nZXREYXRhU291cmNlKCkuc2V0VmFsdWUoeCwgeSAtIGhlYWRlclJvd0NvdW50LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHNldEhlYWRlclJvd1ZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldEhlYWRlcih4LCB5KTsgLy8geSBpcyByZWFsbHkgdGhlIHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzRmlsdGVyUm93ID0gdGhpcy5ncmlkLmlzU2hvd0ZpbHRlclJvdygpO1xuICAgICAgICB2YXIgaXNIZWFkZXJSb3cgPSB0aGlzLmdyaWQuaXNTaG93SGVhZGVyUm93KCk7XG4gICAgICAgIHZhciB0b3BUb3RhbHNPZmZzZXQgPSAoaXNGaWx0ZXJSb3cgPyAxIDogMCkgKyAoaXNIZWFkZXJSb3cgPyAxIDogMCk7XG4gICAgICAgIGlmICh5ID49IHRvcFRvdGFsc09mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5nZXRUb3BUb3RhbHMoKVt5IC0gdG9wVG90YWxzT2Zmc2V0XVt4XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGNhbid0IGNoYW5nZSB0aGUgcm93IG51bWJlcnMgaGVhZGVyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNIZWFkZXJSb3cgJiYgeSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldEhlYWRlcih4LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGaWx0ZXJSb3cpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RmlsdGVyKHgsIHZhbHVlLCB7IGFsZXJ0OiB0cnVlIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldEhlYWRlcih4LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKGNvbEluZGV4KSB7XG4gICAgICAgIC8vYWNjZXNzIGRpcmVjdGx5IGJlY2F1c2Ugd2Ugd2FudCBpdCBvcmRlcmVkXG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdyaWQuYmVoYXZpb3IuZ2V0Q29sdW1uKGNvbEluZGV4KTtcbiAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5nZXRQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNob3dUcmVlID0gdGhpcy5ncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2hvd1RyZWVDb2x1bW4nKSA9PT0gdHJ1ZTtcbiAgICAgICAgdmFyIGhhc0FnZ3JlZ2F0ZXMgPSB0aGlzLmhhc0FnZ3JlZ2F0ZXMoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IChoYXNBZ2dyZWdhdGVzICYmICFzaG93VHJlZSkgPyAtMSA6IDA7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXMuYWdncmVnYXRvci5nZXRDb2x1bW5Db3VudCgpICsgb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmdldERhdGFTb3VyY2UoKS5nZXRSb3dDb3VudCgpO1xuICAgICAgICBjb3VudCArPSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlcy5hZ2dyZWdhdG9yLmdldEhlYWRlcnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBoZWFkZXJzXG4gICAgICovXG4gICAgc2V0SGVhZGVyczogZnVuY3Rpb24oaGVhZGVycykge1xuICAgICAgICB0aGlzLmdldERhdGFTb3VyY2UoKS5zZXRIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkc1xuICAgICAqL1xuICAgIHNldEZpZWxkczogZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgICAgIHRoaXMuZ2V0RGF0YVNvdXJjZSgpLnNldEZpZWxkcyhmaWVsZHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRGaWVsZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhU291cmNlKCkuZ2V0RmllbGRzKCk7XG4gICAgfSxcblxuICAgIC8qKiBAdHlwZWRlZiB7b2JqZWN0fSBkYXRhU291cmNlUGlwZWxpbmVPYmplY3RcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBEYXRhU291cmNlIC0gQSBgaHlwZXItYW5hbHl0aWNzYC1zdHlsZSAgXCJkYXRhIHNvdXJjZVwiIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwcm9wZXJ0eSB7Kn0gW29wdGlvbnNdIC0gV2hlbiBkZWZpbmVkLCBwYXNzZWQgYXMgMm5kIGFyZ3VtZW50IHRvIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGFyZW50XSAtIERlZmluZXMgYSBicmFuY2ggb2ZmIHRoZSBtYWluIHNlcXVlbmNlLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2RhdGFTb3VyY2VQaXBlbGluZU9iamVjdFtdfVxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgcGlwZWxpbmU6IFtcbiAgICAgICAgeyB0eXBlOiAnSlNEYXRhU291cmNlJyB9LFxuICAgICAgICB7IHR5cGU6ICdEYXRhU291cmNlQWdncmVnYXRvcicgfSxcbiAgICAgICAgeyB0eXBlOiAnRGF0YVNvdXJjZUdsb2JhbEZpbHRlcicgfSxcbiAgICAgICAgeyB0eXBlOiAnRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZScgfSxcbiAgICAgICAgeyB0eXBlOiAnRGF0YU5vZGVHcm91cFNvcnRlcicsIHBhcmVudDogJ0RhdGFTb3VyY2VBZ2dyZWdhdG9yJyB9XG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEluc3RhbnRpYXRlcyB0aGUgZGF0YSBzb3VyY2UgcGlwZWxpbmUuXG4gICAgICogQGRlc2MgRWFjaCBuZXcgbGF5ZXIgaXMgY3JlYXRlZCB1c2luZyB0aGUgc3VwcGxpZWQgY29uc3RydWN0b3IgYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91cyBkYXRhIHNvdXJjZSBpbiB0aGUgcGlwZWxpbmUuIEEgcmVmZXJlbmNlIHRvIGVhY2ggbmV3IGxheWVyIGlzIGFkZGVkIHRvIGB0aGlzYCBkYXRhTW9kZWwgYXMgYSBwcm9wZXJ0eSB1c2luZyB0aGUgbGF5ZXIncyBgbmFtZWAuXG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3QgbGF5ZXIgbXVzdCBoYXZlIGEgYEBAQ0xBU1NfTkFNRWAgb2YgYCdEYXRhU291cmNlJ2AuIEhlbmNlLCB0aGUgc3RhcnQgb2YgdGhlIHBpcGVsaW5lIGlzIGB0aGlzLnNvdXJjZWAuIFRoZSBsYXN0IGxheWVyIGlzIGFzc2lnbmVkIHRoZSBzeW5vbnltIGB0aGlzLmRhdGFTb3VyY2VgLlxuICAgICAqXG4gICAgICogQnJhbmNoZXMgYXJlIGNyZWF0ZWQgd2hlbiBhIGxheWVyIHNwZWNpZmllcyBhIG5hbWUgaW4gYHBhcmVudGAuXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gZGF0YVNvdXJjZSAtIEFycmF5IG9mIHVuaWZvcm0gb2JqZWN0cyBjb250YWluaW5nIHRoZSBncmlkIGRhdGEuXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMucmVzZXRTb3VyY2VzKCk7XG5cbiAgICAgICAgdGhpcy5waXBlbGluZS5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZXMsIGxheWVyLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIERhdGFTb3VyY2UgPSBhbmFseXRpY3NbbGF5ZXIudHlwZV07XG5cbiAgICAgICAgICAgIGxheWVyLm5hbWUgPSBsYXllci5uYW1lIHx8IGdldERhdGFTb3VyY2VOYW1lKGxheWVyLnR5cGUpO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgbGF5ZXIubmFtZSAhPT0gJ3NvdXJjZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgcGlwZWxpbmUgdG8gYmVnaW4gd2l0aCBzb3VyY2UuJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxheWVyLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IHRoaXMuZGF0YVNvdXJjZSB8fCBkYXRhU291cmNlOyAvLyB0aXAgb2YgbWFpbiB0cnVuayBvbiBmaXJzdCBkaXZlcnNpb25cbiAgICAgICAgICAgICAgICBkYXRhU291cmNlID0gc291cmNlc1tnZXREYXRhU291cmNlTmFtZShsYXllci5wYXJlbnQpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1BhcmVudCBkYXRhIHNvdXJjZSBub3QgaW4gcGlwZWxpbmUuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGFTb3VyY2UgPSBsYXllci5vcHRpb25zID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG5ldyBEYXRhU291cmNlKGRhdGFTb3VyY2UpXG4gICAgICAgICAgICAgICAgOiBuZXcgRGF0YVNvdXJjZShkYXRhU291cmNlLCBsYXllci5vcHRpb25zKTtcblxuICAgICAgICAgICAgc291cmNlc1tsYXllci5uYW1lXSA9IGRhdGFTb3VyY2U7XG4gICAgICAgIH0uYmluZCh0aGlzLCB0aGlzLnNvdXJjZXMpKTtcblxuICAgICAgICB0aGlzLmRhdGFTb3VyY2UgPSB0aGlzLmRhdGFTb3VyY2UgfHwgZGF0YVNvdXJjZTsgLy8gdGlwIG9mIG1haW4gdHJ1bmsgaWYgbmV2ZXIgYnJhbmNoZWRcblxuICAgICAgICB0aGlzLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxheWVyIHRvIHRoZSBkYXRhIHNvdXJjZSBwaXBlbGluZS5cbiAgICAgKiBAcGFyYW0ge2RhdGFTb3VyY2VQaXBlbGluZU9iamVjdH0gbmV3TGF5ZXIgLSBUaGUgbmV3IHBpcGVsaW5lIGxheWVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVmZXJlbmNlTGF5ZXJdIC0gTmFtZSBvZiBhbiBleGlzdGluZyBwaXBlbGluZSBsYXllciBhZnRlciB3aGljaCB0aGUgbmV3IGxheWVyIHdpbGwgYmUgYWRkZWQuIElmIG5vdCBmb3VuZCAoc3VjaCBhcyBgbnVsbGApLCBpbnNlcnRzIGF0IGJlZ2lubmluZy4gSWYgYHVuZGVmaW5lZGAgb3Igb21pdHRlZCwgYWRkcyB0byBlbmQuXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhZGRQaXBlOiBmdW5jdGlvbihuZXdMYXllciwgcmVmZXJlbmNlTGF5ZXIpIHtcbiAgICAgICAgdmFyIGxheWVySW5kZXg7XG4gICAgICAgIGlmIChyZWZlcmVuY2VMYXllciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VMYXllciA9IHRoaXMucGlwZWxpbmUuZmluZChmdW5jdGlvbihsYXllciwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBsYXllci50eXBlID09PSByZWZlcmVuY2VMYXllcjtcbiAgICAgICAgICAgICAgICBsYXllckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZUxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxheWVySW5kZXggPSB0aGlzLnBpcGVsaW5lLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBpcGVsaW5lLnNwbGljZShsYXllckluZGV4ICsgMSwgMCwgbmV3TGF5ZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSB0b3RhbFJvd3NcbiAgICAgKi9cbiAgICBzZXRUb3BUb3RhbHM6IGZ1bmN0aW9uKHRvdGFsUm93cykge1xuICAgICAgICB0aGlzLnRvcFRvdGFscyA9IHRvdGFsUm93cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fVxuICAgICAqL1xuICAgIGdldFRvcFRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSA/IHRoaXMuZ2V0RGF0YVNvdXJjZSgpLmdldEdyYW5kVG90YWxzKCkgOiB0aGlzLnRvcFRvdGFscztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gdG90YWxSb3dzXG4gICAgICovXG4gICAgc2V0Qm90dG9tVG90YWxzOiBmdW5jdGlvbih0b3RhbFJvd3MpIHtcbiAgICAgICAgdGhpcy5ib3R0b21Ub3RhbHMgPSB0b3RhbFJvd3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0FycmF5PEFycmF5Pn1cbiAgICAgKi9cbiAgICBnZXRCb3R0b21Ub3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNBZ2dyZWdhdGVzKCkgPyB0aGlzLmdldERhdGFTb3VyY2UoKS5nZXRHcmFuZFRvdGFscygpIDogdGhpcy5ib3R0b21Ub3RhbHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGdyb3Vwc1xuICAgICAqL1xuICAgIHNldEdyb3VwczogZnVuY3Rpb24oZ3JvdXBzKSB7XG4gICAgICAgIHRoaXMuc291cmNlcy5hZ2dyZWdhdG9yLnNldEdyb3VwQnlzKGdyb3Vwcyk7XG4gICAgICAgIHRoaXMuYXBwbHlBbmFseXRpY3MoKTtcbiAgICAgICAgdGhpcy5ncmlkLmZpcmVTeW50aGV0aWNHcm91cHNDaGFuZ2VkRXZlbnQodGhpcy5nZXRHcm91cHMoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldEdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5nZXRIZWFkZXJzKCkuc2xpY2UoMCk7XG4gICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldEZpZWxkcygpLnNsaWNlKDApO1xuICAgICAgICB2YXIgZ3JvdXBCeXMgPSB0aGlzLnNvdXJjZXMuYWdncmVnYXRvci5ncm91cEJ5cztcbiAgICAgICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwQnlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBoZWFkZXJzW2dyb3VwQnlzW2ldXTtcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogZ3JvdXBCeXNbaV0sXG4gICAgICAgICAgICAgICAgbGFiZWw6IGZpZWxkLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldEF2YWlsYWJsZUdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5zb3VyY2VzLnNvdXJjZS5nZXRIZWFkZXJzKCkuc2xpY2UoMCk7XG4gICAgICAgIHZhciBncm91cEJ5cyA9IHRoaXMuc291cmNlcy5hZ2dyZWdhdG9yLmdyb3VwQnlzO1xuICAgICAgICB2YXIgZ3JvdXBzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGdyb3VwQnlzLmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gaGVhZGVyc1tpXTtcbiAgICAgICAgICAgICAgICBncm91cHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldEFjdGl2ZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmJlaGF2aW9yLmNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5uYW1lICE9PSAndHJlZSc7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ2dldFZpc2libGVDb2x1bW5zKCknLCAnZ2V0QWN0aXZlQ29sdW1ucygpJywgJzEuMC42JywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0W119XG4gICAgICovXG4gICAgZ2V0SGlkZGVuQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2aXNpYmxlID0gdGhpcy5ncmlkLmJlaGF2aW9yLmNvbHVtbnM7XG4gICAgICAgIHZhciBhbGwgPSB0aGlzLmdyaWQuYmVoYXZpb3IuYWxsQ29sdW1ucztcbiAgICAgICAgdmFyIGhpZGRlbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHZpc2libGUuaW5kZXhPZihhbGxbaV0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGhpZGRlbi5wdXNoKGFsbFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGlkZGVuLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuaGVhZGVyIDwgYi5oZWFkZXI7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGlkZGVuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBhZ2dyZWdhdGlvbnNcbiAgICAgKi9cbiAgICBzZXRBZ2dyZWdhdGVzOiBmdW5jdGlvbihhZ2dyZWdhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VzLmFnZ3JlZ2F0b3Iuc2V0QWdncmVnYXRlcyhhZ2dyZWdhdGlvbnMpO1xuICAgICAgICB0aGlzLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzSGllcmFyY2h5Q29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNob3dUcmVlID0gdGhpcy5ncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2hvd1RyZWVDb2x1bW4nKSA9PT0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQWdncmVnYXRlcygpICYmIHRoaXMuaGFzR3JvdXBzKCkgJiYgc2hvd1RyZWU7XG4gICAgfSxcblxuICAgIHNldFJlbGF0aW9uOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc291cmNlcy50cmVldmlldy5zZXRSZWxhdGlvbihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFwcGx5QW5hbHl0aWNzOiBmdW5jdGlvbihkb250QXBwbHlBZ2dyZWdhdG9yKSB7XG4gICAgICAgIHNlbGVjdGVkRGF0YVJvd3NCYWNraW5nU2VsZWN0ZWRHcmlkUm93cy5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMucGlwZWxpbmUuZm9yRWFjaChmdW5jdGlvbihzb3VyY2VzLCBsYXllcikge1xuICAgICAgICAgICAgdmFyIGRhdGFTb3VyY2UgPSBzb3VyY2VzW2xheWVyLm5hbWVdO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGxheWVyLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdEYXRhU291cmNlQWdncmVnYXRvcic6XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb250QXBwbHlBZ2dyZWdhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhU291cmNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VzLmFnZ3JlZ2F0b3IgJiYgc291cmNlcy5hZ2dyZWdhdG9yLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UgPSBzb3VyY2VzLmdyb3Vwc29ydGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UuY2xlYXJTb3J0cygpO1xuICAgICAgICAgICAgICAgICAgICAodGhpcy5nZXRQcml2YXRlU3RhdGUoKS5zb3J0cyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihzb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhU291cmNlLnNvcnRPbihNYXRoLmFicyhzb3J0KSAtIDEsIE1hdGguc2lnbihzb3J0KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGFTb3VyY2UgJiYgZGF0YVNvdXJjZS5hcHBseSkge1xuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UuYXBwbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMsIHRoaXMuc291cmNlcykpO1xuXG4gICAgICAgIHJlc2VsZWN0R3JpZFJvd3NCYWNrZWRCeVNlbGVjdGVkRGF0YVJvd3MuY2FsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXhcbiAgICAgKiBAcGFyYW0ga2V5c1xuICAgICAqL1xuICAgIHRvZ2dsZVNvcnQ6IGZ1bmN0aW9uKGNvbEluZGV4LCBrZXlzKSB7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50U29ydFN0YXRlKGNvbEluZGV4LCBrZXlzKTtcbiAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcyh0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRlZmVycmVkXG4gICAgICovXG4gICAgdW5Tb3J0Q29sdW1uOiBmdW5jdGlvbihjb2xJbmRleCwgZGVmZXJyZWQpIHtcbiAgICAgICAgY29sSW5kZXgrKzsgLy9oYWNrIHRvIGdldCBhcm91bmQgMCBpbmRleFxuICAgICAgICB2YXIgYWxyZWFkeSA9IHRoaXMuZ2V0Q29sdW1uU29ydFN0YXRlKGNvbEluZGV4KTtcbiAgICAgICAgaWYgKGFscmVhZHkgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDb2x1bW5Tb3J0U3RhdGUoY29sSW5kZXgsIGFscmVhZHkpO1xuICAgICAgICAgICAgaWYgKCFkZWZlcnJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlBbmFseXRpY3ModHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRTb3J0ZWRDb2x1bW5JbmRleGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnNvcnRzICYmIHN0YXRlLnNvcnRzLnNsaWNlKCkgfHwgW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4XG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0ga2V5c1xuICAgICAqL1xuICAgIGluY3JlbWVudFNvcnRTdGF0ZTogZnVuY3Rpb24oY29sSW5kZXgsIGtleXMpIHtcbiAgICAgICAgY29sSW5kZXgrKzsgLy9oYWNrIHRvIGdldCBhcm91bmQgMCBpbmRleFxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgICAgICB2YXIgaGFzQ1RSTCA9IGtleXMuaW5kZXhPZignQ1RSTCcpID4gLTE7XG4gICAgICAgIHN0YXRlLnNvcnRzID0gc3RhdGUuc29ydHMgfHwgW107XG4gICAgICAgIHZhciBhbHJlYWR5ID0gdGhpcy5nZXRDb2x1bW5Tb3J0U3RhdGUoY29sSW5kZXgpO1xuICAgICAgICBpZiAoYWxyZWFkeSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc29ydHNbYWxyZWFkeV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuc29ydHNbYWxyZWFkeV0gPSAtMSAqIHN0YXRlLnNvcnRzW2FscmVhZHldOyAvL2Rlc2NlbmRpbmdcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDb2x1bW5Tb3J0U3RhdGUoY29sSW5kZXgsIGFscmVhZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGhhc0NUUkwgfHwgc3RhdGUuc29ydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5zb3J0cy51bnNoaWZ0KGNvbEluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLnNvcnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBzdGF0ZS5zb3J0cy51bnNoaWZ0KGNvbEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvL01pbm9yIGltcHJvdmVtZW50LCBidXQgdGhpcyBjaGVjayBjYW4gaGFwcGVuIGVhcmxpZXIgYW5kIHRlcm1pbmF0ZSBlYXJsaWVyXG4gICAgICAgIGlmIChzdGF0ZS5zb3J0cy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICBzdGF0ZS5zb3J0cy5sZW5ndGggPSAzO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Tb3J0U3RhdGU6IGZ1bmN0aW9uKGNvbEluZGV4KSB7XG4gICAgICAgIC8vYXNzdW1wdGlvbiBpcyB0aGF0IGNvbEluZGV4IGhhcyBiZWVuIGhhY2tlZCB0byBnZXQgYXJvdW5kIDBcbiAgICAgICAgdmFyIGFscmVhZHksXG4gICAgICAgICAgICBzdGF0ZSA9IHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCk7XG5cbiAgICAgICAgc3RhdGUuc29ydHMgPSBzdGF0ZS5zb3J0cyB8fCBbXTtcblxuICAgICAgICAvL0NoZWNrIGRhdGEgY29sdW1uc1xuICAgICAgICBhbHJlYWR5ID0gc3RhdGUuc29ydHMuaW5kZXhPZihjb2xJbmRleCk7XG5cbiAgICAgICAgLy9DaGVjayBjb2x1bW5zIHdpdGggbmVnYXRpdmUgaW5kaWNlcy4gTWV0YSBjb2x1bW5zPz9cbiAgICAgICAgaWYgKGFscmVhZHkgPT09IC0xKSB7XG4gICAgICAgICAgICBhbHJlYWR5ID0gc3RhdGUuc29ydHMuaW5kZXhPZigtMSAqIGNvbEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxyZWFkeTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc29ydFBvc2l0aW9uXG4gICAgICovXG4gICAgcmVtb3ZlQ29sdW1uU29ydFN0YXRlOiBmdW5jdGlvbihjb2xJbmRleCwgc29ydFBvc2l0aW9uKSB7XG4gICAgICAgIC8vYXNzdW1wdGlvbiBpcyB0aGF0IGNvbEluZGV4IGhhcyBiZWVuIGhhY2tlZCB0byBnZXQgYXJvdW5kIDBcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICAgICAgc3RhdGUuc29ydHMgPSBzdGF0ZS5zb3J0cyB8fCBbXTtcbiAgICAgICAgc3RhdGUuc29ydHMuc3BsaWNlKHNvcnRQb3NpdGlvbiwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICogQHBhcmFtIHJldHVybkFzU3RyaW5nXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U29ydEltYWdlRm9yQ29sdW1uOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICB2YXIgdXAgPSB0cnVlO1xuICAgICAgICB2YXIgc29ydHMgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpLnNvcnRzO1xuICAgICAgICBpZiAoIXNvcnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zaXRpb24gPSBzb3J0cy5pbmRleE9mKGluZGV4KTtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSBzb3J0cy5pbmRleE9mKC0xICogaW5kZXgpO1xuICAgICAgICAgICAgdXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuayA9IHNvcnRzLmxlbmd0aCAtIHBvc2l0aW9uO1xuICAgICAgICB2YXIgYXJyb3cgPSB1cCA/IFVQV0FSRFNfQkxBQ0tfQVJST1cgOiBET1dOV0FSRFNfQkxBQ0tfQVJST1c7XG4gICAgICAgIHJldHVybiByYW5rICsgYXJyb3cgKyAnICc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlZHJpbGxkb3duXG4gICAgICogQHBhcmFtIGNlbGxcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKi9cbiAgICBjZWxsQ2xpY2tlZDogZnVuY3Rpb24oY2VsbCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5zb3VyY2VzLnRyZWV2aWV3ICYmIGV2ZW50LmRhdGFDZWxsLnggPT09IHRoaXMuc291cmNlcy50cmVldmlldy50cmVlQ29sdW1uSW5kZXggfHxcbiAgICAgICAgICAgIHRoaXMuaGFzQWdncmVnYXRlcygpICYmIGV2ZW50LmdyaWRDZWxsLnggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgZXhwYW5kYWJsZSA9IHRoaXMuZ2V0RGF0YVNvdXJjZSgpLmNsaWNrKGV2ZW50LmdyaWRDZWxsLnkgLSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKSk7XG4gICAgICAgICAgICBpZiAoZXhwYW5kYWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlBbmFseXRpY3ModHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICBpZiAoeSA8IGhlYWRlclJvd0NvdW50ICYmICF0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSkge1xuICAgICAgICAgICAgdmFyIHRvcFRvdGFscyA9IHRoaXMuZ2V0VG9wVG90YWxzKCk7XG4gICAgICAgICAgICByZXR1cm4gdG9wVG90YWxzW3kgLSAoaGVhZGVyUm93Q291bnQgLSB0b3BUb3RhbHMubGVuZ3RoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YVNvdXJjZSgpLmdldFJvdyh5IC0gaGVhZGVyUm93Q291bnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBidWlsZFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgY29sQ291bnQgPSB0aGlzLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbXS5jb25jYXQodGhpcy5nZXRGaWVsZHMoKSk7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQWdncmVnYXRlcygpKSB7XG4gICAgICAgICAgICByZXN1bHQudHJlZSA9IHRoaXMuZ2V0VmFsdWUoLTIsIHkpO1xuICAgICAgICAgICAgZmllbGRzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbZmllbGRzW2ldXSA9IHRoaXMuZ2V0VmFsdWUoaSwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0Q29tcHV0ZWRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIHJjZiA9IHRoaXMuZ2V0Um93Q29udGV4dEZ1bmN0aW9uKFt5XSk7XG4gICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldEZpZWxkcygpO1xuICAgICAgICB2YXIgcm93ID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgICAgICByb3dbZmllbGRdID0gcmNmKGZpZWxkKVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE5hbWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlQnlGaWVsZDogZnVuY3Rpb24oZmllbGROYW1lLCB5KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0RmllbGRzKCkuaW5kZXhPZihmaWVsZE5hbWUpO1xuICAgICAgICBpZiAodGhpcy5oYXNBZ2dyZWdhdGVzKCkpIHtcbiAgICAgICAgICAgIHkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhU291cmNlKCkuZ2V0VmFsdWUoaW5kZXgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIGZpbHRlciBhdHRhY2hlZCB0byB0aGUgSHlwZXJncmlkLlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJUcmVlfVxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0R2xvYmFsRmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmFsRmlsdGVyRGF0YVNvdXJjZSgpLmdldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBdHRhY2gvZGV0YWNoIGEgZmlsdGVyIHRvIGEgSHlwZXJncmlkLlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZX0gW2ZpbHRlcl0gLSBUaGUgZmlsdGVyIG9iamVjdC4gSWYgdW5kZWZpbmVkLCBhbnkgYXR0YWNoZWQgZmlsdGVyIGlzIHJlbW92ZWQsIHR1cm5pbmcgZmlsdGVyaW5nIE9GRi5cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldEdsb2JhbEZpbHRlcjogZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuZ2V0R2xvYmFsRmlsdGVyRGF0YVNvdXJjZSgpLnNldChmaWx0ZXIpO1xuICAgICAgICB0aGlzLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNldCB0aGUgY2FzZSBzZW5zaXRpdml0eSBvZiBmaWx0ZXIgdGVzdHMgYWdhaW5zdCBkYXRhLlxuICAgICAqIEBkZXNjIENhc2Ugc2Vuc2l0aXZpdHkgcGVydGFpbnMgdG8gc3RyaW5nIGNvbXBhcmVzIG9ubHkuIFRoaXMgaW5jbHVkZXMgdW50eXBlZCBjb2x1bW5zLCBjb2x1bW5zIHR5cGVkIGFzIHN0cmluZ3MsIHR5cGVkIGNvbHVtbnMgY29udGFpbmluZyBkYXRhIHRoYXQgY2Fubm90IGJlIGNvZXJjZWQgdG8gdHlwZSBvciB3aGVuIHRoZSBmaWx0ZXIgZXhwcmVzc2lvbiBvcGVyYW5kIGNhbm5vdCBiZSBjb2VyY2VkLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBhIHNoYXJlZCBwcm9wZXJ0eSBhbmQgYWZmZWN0cyBhbGwgZ3JpZCBtYW5hZ2VkIGJ5IHRoaXMgaW5zdGFuY2Ugb2YgdGhlIGFwcC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU2Vuc2l0aXZlXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRHbG9iYWxGaWx0ZXJDYXNlU2Vuc2l0aXZpdHk6IGZ1bmN0aW9uKGlzU2Vuc2l0aXZlKSB7XG4gICAgICAgIHRoaXMuZ2V0R2xvYmFsRmlsdGVyKCkuc2V0Q2FzZVNlbnNpdGl2aXR5KGlzU2Vuc2l0aXZlKTtcbiAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSBwYXJ0aWN1bGFyIGNvbHVtbiBmaWx0ZXIncyBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sdW1uTmFtZVxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZUdldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyB7QGxpbmsgRGVmYXVsdEZpbHRlciNnZXRTdGF0ZXxnZXRTdGF0ZX0gbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc3ludGF4PSdDUUwnXSAtIFRoZSBzeW50YXggdG8gdXNlIHRvIGRlc2NyaWJlIHRoZSBmaWx0ZXIgc3RhdGUuIE5vdGUgdGhhdCBgZ2V0RmlsdGVyYCdzIGRlZmF1bHQgc3ludGF4LCBgJ0NRTCdgLCBkaWZmZXJzIGZyb20gdGhlIG90aGVyIGdldCBzdGF0ZSBtZXRob2RzLlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9XG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRGaWx0ZXI6IGZ1bmN0aW9uKGNvbHVtbkluZGV4T3JOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBpc0luZGV4ID0gIWlzTmFOKE51bWJlcihjb2x1bW5JbmRleE9yTmFtZSkpLFxuICAgICAgICAgICAgY29sdW1uTmFtZSA9IGlzSW5kZXggPyB0aGlzLmdldEZpZWxkcygpW2NvbHVtbkluZGV4T3JOYW1lXSA6IGNvbHVtbkluZGV4T3JOYW1lO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEdsb2JhbEZpbHRlcigpLmdldENvbHVtbkZpbHRlclN0YXRlKGNvbHVtbk5hbWUsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZXQgYSBwYXJ0aWN1bGFyIGNvbHVtbiBmaWx0ZXIncyBzdGF0ZS5cbiAgICAgKiBAZGVzYyBBZnRlciBzZXR0aW5nIHRoZSBuZXcgZmlsdGVyIHN0YXRlLCByZWFwcGxpZXMgdGhlIGZpbHRlciB0byB0aGUgZGF0YSBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBjb2x1bW5JbmRleE9yTmFtZSAtIFRoZSBfY29sdW1uIGZpbHRlcl8gdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW3N0YXRlXSAtIEEgZmlsdGVyIHRyZWUgb2JqZWN0IG9yIGEgSlNPTiwgU1FMLCBvciBDUUwgc3ViZXhwcmVzc2lvbiBzdHJpbmcgdGhhdCBkZXNjcmliZXMgdGhlIGEgbmV3IHN0YXRlIGZvciB0aGUgbmFtZWQgY29sdW1uIGZpbHRlci4gVGhlIGV4aXN0aW5nIGNvbHVtbiBmaWx0ZXIgc3ViZXhwcmVzc2lvbiBpcyByZXBsYWNlZCB3aXRoIGEgbmV3IG5vZGUgYmFzZWQgb24gdGhpcyBzdGF0ZS4gSWYgaXQgZG9lcyBub3QgZXhpc3QsIHRoZSBuZXcgc3ViZXhwcmVzc2lvbiBpcyBhZGRlZCB0byB0aGUgY29sdW1uIGZpbHRlcnMgc3VidHJlZSAoYGZpbHRlci5jb2x1bW5GaWx0ZXJzYCkuXG4gICAgICpcbiAgICAgKiBJZiB1bmRlZmluZWQsIHJlbW92ZXMgdGhlIGVudGlyZSBjb2x1bW4gZmlsdGVyIHN1YmV4cHJlc3Npb24gZnJvbSB0aGUgY29sdW1uIGZpbHRlcnMgc3VidHJlZS5cbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWVTZXRTdGF0ZU9wdGlvbnNPYmplY3R9IFtvcHRpb25zXSAtIFBhc3NlZCB0byB0aGUgZmlsdGVyJ3MgW3NldFN0YXRlXXtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9GaWx0ZXJUcmVlLmh0bWwjc2V0U3RhdGV9IG1ldGhvZC4gWW91IG1heSBtaXggaW4gbWVtYmVycyBvZiB0aGUge0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL2dsb2JhbC5odG1sI0ZpbHRlclRyZWVWYWxpZGF0aW9uT3B0aW9uc09iamVjdHxGaWx0ZXJUcmVlVmFsaWRhdGlvbk9wdGlvbnNPYmplY3R9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN5bnRheD0nQ1FMJ10gLSBUaGUgc3ludGF4IHRvIHVzZSB0byBkZXNjcmliZSB0aGUgZmlsdGVyIHN0YXRlLiBOb3RlIHRoYXQgYHNldEZpbHRlcmAncyBkZWZhdWx0IHN5bnRheCwgYCdDUUwnYCwgZGlmZmVycyBmcm9tIHRoZSBvdGhlciBnZXQgc3RhdGUgbWV0aG9kcy5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEVycm9yfHN0cmluZ30gYHVuZGVmaW5lZGAgaW5kaWNhdGVzIHN1Y2Nlc3MuXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRGaWx0ZXI6IGZ1bmN0aW9uKGNvbHVtbkluZGV4T3JOYW1lLCBzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgaXNJbmRleCA9ICFpc05hTihOdW1iZXIoY29sdW1uSW5kZXhPck5hbWUpKSxcbiAgICAgICAgICAgIGNvbHVtbk5hbWUgPSBpc0luZGV4ID8gdGhpcy5nZXRGaWVsZHMoKVtjb2x1bW5JbmRleE9yTmFtZV0gOiBjb2x1bW5JbmRleE9yTmFtZTtcblxuICAgICAgICB0aGlzLmdldEdsb2JhbEZpbHRlcigpLnNldENvbHVtbkZpbHRlclN0YXRlKGNvbHVtbk5hbWUsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ncmlkLmZpcmVTeW50aGV0aWNGaWx0ZXJBcHBsaWVkRXZlbnQoKTtcbiAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWVHZXRTdGF0ZU9wdGlvbnNPYmplY3R9IFtvcHRpb25zXSAtIFBhc3NlZCB0byB0aGUgZmlsdGVyJ3Mge0BsaW5rIERlZmF1bHRGaWx0ZXIjZ2V0U3RhdGV8Z2V0U3RhdGV9IG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyB7RmlsdGVyVHJlZVN0YXRlT2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0RmlsdGVyczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHbG9iYWxGaWx0ZXIoKS5nZXRDb2x1bW5GaWx0ZXJzU3RhdGUob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVN0YXRlT2JqZWN0fSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVNldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyBbc2V0U3RhdGVde0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL0ZpbHRlclRyZWUuaHRtbCNzZXRTdGF0ZX0gbWV0aG9kLiBZb3UgbWF5IG1peCBpbiBtZW1iZXJzIG9mIHRoZSB7QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvZ2xvYmFsLmh0bWwjRmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fEZpbHRlclRyZWVWYWxpZGF0aW9uT3B0aW9uc09iamVjdH1cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEVycm9yfHN0cmluZ30gYHVuZGVmaW5lZGAgaW5kaWNhdGVzIHN1Y2Nlc3MuXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRGaWx0ZXJzOiBmdW5jdGlvbihzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmdldEdsb2JhbEZpbHRlcigpLnNldENvbHVtbkZpbHRlcnNTdGF0ZShzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ3JpZC5maXJlU3ludGhldGljRmlsdGVyQXBwbGllZEV2ZW50KCk7XG4gICAgICAgIHRoaXMuYXBwbHlBbmFseXRpY3MoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlR2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIHtAbGluayBEZWZhdWx0RmlsdGVyI2dldFN0YXRlfGdldFN0YXRlfSBtZXRob2QuXG4gICAgICogQHJldHVybnMge0ZpbHRlclRyZWVTdGF0ZU9iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldFRhYmxlRmlsdGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdsb2JhbEZpbHRlcigpLmdldFRhYmxlRmlsdGVyU3RhdGUob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNldCBhIHRoZSB0YWJsZSBmaWx0ZXIgc3RhdGUuXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9IHN0YXRlXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIFtzZXRTdGF0ZV17QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvRmlsdGVyVHJlZS5odG1sI3NldFN0YXRlfSBtZXRob2QuIFlvdSBtYXkgbWl4IGluIG1lbWJlcnMgb2YgdGhlIHtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9nbG9iYWwuaHRtbCNGaWx0ZXJUcmVlVmFsaWRhdGlvbk9wdGlvbnNPYmplY3R8RmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8RXJyb3J8c3RyaW5nfSBgdW5kZWZpbmVkYCBpbmRpY2F0ZXMgc3VjY2Vzcy5cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldFRhYmxlRmlsdGVyOiBmdW5jdGlvbihzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmdldEdsb2JhbEZpbHRlcigpLnNldFRhYmxlRmlsdGVyU3RhdGUoc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdyaWQuZmlyZVN5bnRoZXRpY0ZpbHRlckFwcGxpZWRFdmVudCgpO1xuICAgICAgICB0aGlzLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgYXBwbHlTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYXBwbHlBbmFseXRpY3MoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0RGF0YShbXSk7XG4gICAgfSxcblxuICAgIGdldFVuZmlsdGVyZWRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzLnNvdXJjZS5nZXRWYWx1ZSh4LCB5KTtcbiAgICB9LFxuXG4gICAgZ2V0VW5maWx0ZXJlZFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlcy5zb3VyY2UuZ2V0Um93Q291bnQoKTtcbiAgICB9XG59KTtcblxuLy8gTE9DQUwgTUVUSE9EUyAtLSB0byBiZSBjYWxsZWQgd2l0aCBgLmNhbGwodGhpc2BcblxuLyoqXG4gKiBBY2N1bXVsYXRlIGFjdHVhbCBkYXRhIHJvdyBvYmplY3RzIGJhY2tpbmcgY3VycmVudCBncmlkIHJvdyBzZWxlY3Rpb25zLlxuICogVGhpcyBjYWxsIHNob3VsZCBiZSBwYWlyZWQgd2l0aCBhIHN1YnNlcXVlbnQgY2FsbCB0byBgcmVzZWxlY3RHcmlkUm93c0JhY2tlZEJ5U2VsZWN0ZWREYXRhUm93c2AuXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gc2VsZWN0ZWREYXRhUm93c0JhY2tpbmdTZWxlY3RlZEdyaWRSb3dzKCkge1xuICAgIHZhciBzZWxlY3RlZERhdGEgPSB0aGlzLnNlbGVjdGVkRGF0YSxcbiAgICAgICAgaGFzUm93U2VsZWN0aW9ucyA9IHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5oYXNSb3dTZWxlY3Rpb25zKCksXG4gICAgICAgIG5lZWRGaWx0ZXJlZERhdGFMaXN0ID0gc2VsZWN0ZWREYXRhLmxlbmd0aCB8fCBoYXNSb3dTZWxlY3Rpb25zO1xuXG4gICAgaWYgKG5lZWRGaWx0ZXJlZERhdGFMaXN0KSB7XG4gICAgICAgIHZhciBmaWx0ZXJlZERhdGEgPSB0aGlzLmdldEZpbHRlcmVkRGF0YSgpO1xuICAgIH1cblxuICAgIC8vIFNURVAgMTogUmVtb3ZlIGFueSBmaWx0ZXJlZCBkYXRhIHJvd3MgZnJvbSB0aGUgcmVjZW50bHkgc2VsZWN0ZWQgbGlzdC5cbiAgICBzZWxlY3RlZERhdGEuZm9yRWFjaChmdW5jdGlvbihkYXRhUm93LCBpbmRleCkge1xuICAgICAgICBpZiAoZmlsdGVyZWREYXRhLmluZGV4T2YoZGF0YVJvdykgPj0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIHNlbGVjdGVkRGF0YVtpbmRleF07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNURVAgMjogQWNjdW11bGF0ZSB0aGUgZGF0YSByb3dzIGJhY2tpbmcgYW55IGN1cnJlbnRseSBzZWxlY3RlZCBncmlkIHJvd3MgaW4gYHRoaXMuc2VsZWN0ZWREYXRhYC5cbiAgICBpZiAoaGFzUm93U2VsZWN0aW9ucykgeyAvLyBhbnkgY3VycmVudCBncmlkIHJvdyBzZWxlY3Rpb25zP1xuICAgICAgICB0aGlzLmdyaWQuZ2V0U2VsZWN0ZWRSb3dzKCkuZm9yRWFjaChmdW5jdGlvbihzZWxlY3RlZFJvd0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YVJvdyA9IGZpbHRlcmVkRGF0YVtzZWxlY3RlZFJvd0luZGV4XTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZERhdGEuaW5kZXhPZihkYXRhUm93KSA8IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZERhdGEucHVzaChkYXRhUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlLWVzdGFibGlzaCBncmlkIHJvdyBzZWxlY3Rpb25zIGJhc2VkIG9uIGFjdHVhbCBkYXRhIHJvdyBvYmplY3RzIGFjY3VtdWxhdGVkIGJ5IGBzZWxlY3RlZERhdGFSb3dzQmFja2luZ1NlbGVjdGVkR3JpZFJvd3NgIHdoaWNoIHNob3VsZCBiZSBjYWxsZWQgZmlyc3QuXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gcmVzZWxlY3RHcmlkUm93c0JhY2tlZEJ5U2VsZWN0ZWREYXRhUm93cygpIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZERhdGEubGVuZ3RoKSB7IC8vIGFueSBkYXRhIHJvdyBvYmplY3RzIGFkZGVkIGZyb20gcHJldmlvdXMgZ3JpZCByb3cgc2VsZWN0aW9ucz9cbiAgICAgICAgdmFyIHNlbGVjdGlvbk1vZGVsID0gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLFxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5ncmlkLmdldEhlYWRlclJvd0NvdW50KCksXG4gICAgICAgICAgICBmaWx0ZXJlZERhdGEgPSB0aGlzLmdldEZpbHRlcmVkRGF0YSgpO1xuXG4gICAgICAgIHNlbGVjdGlvbk1vZGVsLmNsZWFyUm93U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZERhdGEuZm9yRWFjaChmdW5jdGlvbihkYXRhUm93KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBmaWx0ZXJlZERhdGEuaW5kZXhPZihkYXRhUm93KTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwuc2VsZWN0Um93KG9mZnNldCArIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXREYXRhU291cmNlTmFtZShuYW1lKSB7XG4gICAgbmFtZSA9IGFuYWx5dGljc1tuYW1lXS5wcm90b3R5cGUuJCRDTEFTU19OQU1FIHx8IG5hbWU7XG4gICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXkRhdGEoU291cmNlfE5vZGUpLywgJycpLnRvTG93ZXJDYXNlKCkgfHwgJ3NvdXJjZSc7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExSVUNhY2hlID0gcmVxdWlyZSgnbHJ1LWNhY2hlJyk7XG5cblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBsaXN0cyB0aGUgcHJvcGVydGllcyB0aGF0IGNhbiBiZSBzZXQgb24gYSB7QGxpbmsgSHlwZXJncmlkfSBhbG9uZyB3aXRoIHRoZWlyIGRlZmF1bHQgdmFsdWVzLlxuICogRWRpdCB0aGlzIGZpbGUgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICogQG1vZHVsZSBkZWZhdWx0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZvbnQgZm9yIGRhdGEgY2VsbHMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzRm9udH1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBub0RhdGFNZXNzYWdlOiAnbm8gZGF0YSB0byBkaXNwbGF5JyxcblxuXG4gICAgLyoqXG4gICAgICogVGhlIGZvbnQgZm9yIGRhdGEgY2VsbHMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzRm9udH1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmb250OiAnMTNweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBGb250IGNvbG9yIGZvciBkYXRhIGNlbGxzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGNvbG9yIGZvciBkYXRhIGNlbGxzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2IoMjQxLCAyNDEsIDI0MSknLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBzdHlsZSBmb3Igc2VsZWN0ZWQgY2VsbChzKS5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZm9yZWdyb3VuZFNlbGVjdGlvbkZvbnQ6ICdib2xkIDEzcHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBjb2xvciBmb3Igc2VsZWN0ZWQgY2VsbChzKS5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDAsIDAsIDEyOCknLFxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgc29ydE9uSGlkZGVuQ29sdW1uczogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGNvbG9yIGZvciBzZWxlY3RlZCBjZWxsKHMpLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2JhKDE0NywgMTg1LCAyNTUsIDAuNjI1KScsXG5cblxuICAgIC8qKioqKioqKioqIFNFQ1RJT046IENPTFVNTiBIRUFERVIgQ09MT1JTICoqKioqKioqKiovXG5cbiAgICAvLyBJTVBPUlRBTlQgQ0FWRUFUOiBUaGUgY29kZSBpcyBpbmNvbnNpc3RlbnQgcmVnYXJkaW5nIHRoZSB0ZXJtaW5vbG9neS4gSXMgdGhlIFwiY29sdW1uIGhlYWRlclwiIHNlY3Rpb24gX3RoZSByb3dfIG9mIGNlbGxzIGF0IHRoZSB0b3AgKHRoYXQgYWN0IGFzIGhlYWRlcnMgZm9yIGVhY2ggY29sdW1uKSBvciBpcyBpdCBfdGhlIGNvbHVtbl8gb2YgY2VsbHMgKHRoYXQgYWN0IGFzIGhlYWRlcnMgZm9yIGVhY2ggcm93KT8gT2ggbXkuXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NGb250fVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlckZvbnQ6ICcxMnB4IFRhaG9tYSwgR2VuZXZhLCBzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlckNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgc3R5bGUgZm9yIHNlbGVjdGVkIGNvbHVtbnMnIGhlYWRlcnMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Gb250OiAnYm9sZCAxMnB4IFRhaG9tYSwgR2VuZXZhLCBzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlckJhY2tncm91bmRDb2xvcjogJ3JnYigyMjMsIDIyNywgMjMyKScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoODAsIDgwLCA4MCknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiYSgyNTUsIDIyMCwgOTcsIDAuNDUpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlckZvcmVncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJCYWNrZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjU1LCAxODAsIDApJyxcblxuXG4gICAgLyoqKioqKioqKiogU0VDVElPTjogUk9XIEhFQURFUiBDT0xPUlMgKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0ZvbnR9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcm93SGVhZGVyRm9udDogJzEycHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcm93SGVhZGVyQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcm93SGVhZGVyQmFja2dyb3VuZENvbG9yOiAncmdiKDIyMywgMjI3LCAyMzIpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd0hlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYig4MCwgODAsIDgwKScsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHN0eWxlIGZvciBzZWxlY3RlZCByb3dzJyBoZWFkZXJzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDogJ2JvbGQgMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByb3dIZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2JhKDI1NSwgMjIwLCA5NywgMC40NSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcm93SGVhZGVyRm9yZWdyb3VuZFJvd1NlbGVjdGlvbkNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd0hlYWRlckJhY2tncm91bmRSb3dTZWxlY3Rpb25Db2xvcjogJ3JnYigyNTUsIDE4MCwgMCknLFxuXG5cbiAgICAvKioqKioqKioqKiBTRUNUSU9OOiBGSUxURVIgUk9XIENPTE9SUyAqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzRm9udH1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaWx0ZXJGb250OiAnMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaWx0ZXJDb2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaWx0ZXJCYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaWx0ZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZmlsdGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDI1NSwgMjIwLCA5NyknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZmlsdGVyQ2VsbEJvcmRlclN0eWxlOiAncmdiYSgwLDAsMCwwLjgpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaWx0ZXJDZWxsQm9yZGVyVGhpY2tuZXNzOiAwLjQsXG4gICAgLyoqKioqKioqKiogU0VDVElPTjogVFJFRSBDT0xVTU4gQ09MT1JTICoqKioqKioqKiovXG4gICAgLy8gVGhlIFwidHJlZSBjb2x1bW5cIiBjb250YWlucyB0aGUgaGllcmFyY2hpY2FsIGRyaWxsLWRvd24gY29udHJvbHMuXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NGb250fVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRyZWVDb2x1bW5Gb250OiAnMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0cmVlQ29sdW1uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdHJlZUNvbHVtbkJhY2tncm91bmRDb2xvcjogJ3JnYigyMjMsIDIyNywgMjMyKScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0cmVlQ29sdW1uRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRyZWVDb2x1bW5CYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2JhKDI1NSwgMjIwLCA5NywgMC40NSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdHJlZUNvbHVtbkZvcmVncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0cmVlQ29sdW1uQmFja2dyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yOiAncmdiKDI1NSwgMTgwLCAwKScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kQ29sb3IyOiAncmdiKDIwMSwgMjAxLCAyMDEpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB2b2Zmc2V0OiAwLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNjcm9sbGJhckhvdmVyT3ZlcjogJ3Zpc2libGUnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNjcm9sbGJhckhvdmVyT2ZmOiAnaGlkZGVuJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgc2Nyb2xsaW5nRW5hYmxlZDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB2U2Nyb2xsYmFyQ2xhc3NQcmVmaXg6ICcnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGhTY3JvbGxiYXJDbGFzc1ByZWZpeDogJycsXG5cbiAgICAvL3RoZXNlIHVzZWQgdG8gYmUgaW4gdGhlIGNvbnN0YW50cyBlbGVtZW50XG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZml4ZWRSb3dBbGlnbjogJ2NlbnRlcicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZml4ZWRDb2xBbGlnbjogJ2NlbnRlcicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY2VsbFBhZGRpbmc6IDUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdyaWRMaW5lc0g6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdyaWRMaW5lc1Y6IHRydWUsXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBncmlkTGluZXNWT3ZlcmZsb3c6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgbGluZUNvbG9yOiAncmdiKDE5OSwgMTk5LCAxOTkpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBsaW5lV2lkdGg6IDAuNCxcblxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGRlZmF1bHRSb3dIZWlnaHQ6IDE1LFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGRlZmF1bHRDb2x1bW5XaWR0aDogMTAwLFxuXG4gICAgLy9mb3IgaW1tZWRpYXRlIHBhaW50aW5nLCBzZXQgdGhlc2UgdmFsdWVzIHRvIDAsIHRydWUgcmVzcGVjdGl2ZWx5XG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcmVwYWludEludGVydmFsUmF0ZTogNjAsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJlcGFpbnRJbW1lZGlhdGVseTogZmFsc2UsXG5cbiAgICAvL2VuYWJsZSBvciBkaXNhYmxlIGRvdWJsZSBidWZmZXJpbmdcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdXNlQml0QmxpdDogZmFsc2UsXG5cblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdXNlSGlEUEk6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCBbJ2FsdCcsICdlc2MnXVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZWRpdG9yQWN0aXZhdGlvbktleXM6IFsnYWx0JywgJ2VzYyddLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByZWFkT25seTogZmFsc2UsXG5cbiAgICAvLyBpbmhlcml0ZWQgYnkgY2VsbCByZW5kZXJlcnNcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IGBnZXRUZXh0V2lkdGhgXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdldFRleHRXaWR0aDogZ2V0VGV4dFdpZHRoLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgYGdldFRleHRIZWlnaHRgXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdldFRleHRIZWlnaHQ6IGdldFRleHRIZWlnaHQsXG5cblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaXhlZENvbHVtbkNvdW50OiAwLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZpeGVkUm93Q291bnQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgaGVhZGVyQ29sdW1uQ291bnQ6IDAsXG5cblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgc2hvd1Jvd051bWJlcnM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNob3dUcmVlQ29sdW1uOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzaG93SGVhZGVyUm93OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzaG93RmlsdGVyUm93OiB0cnVlLFxuXG5cbiAgICAvKiogQ2xpY2tpbmcgaW4gYSBjZWxsIFwic2VsZWN0c1wiIGl0OyBpdCBpcyBhZGRlZCB0byB0aGUgc2VsZWN0IHJlZ2lvbiBhbmQgcmVwYWludGVkIHdpdGggXCJjZWxsIHNlbGVjdGlvblwiIGNvbG9ycy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNlbGxTZWxlY3Rpb246IHRydWUsXG5cbiAgICAvKiogQ2xpY2tpbmcgaW4gYSByb3cgaGVhZGVyIChsZWZ0bW9zdCBjb2x1bW4pIFwic2VsZWN0c1wiIHRoZSByb3c7IHRoZSBlbnRpcmUgcm93IGlzIGFkZGVkIHRvIHRoZSBzZWxlY3QgcmVnaW9uIGFuZCByZXBhaW50ZWQgd2l0aCBcInJvdyBzZWxlY3Rpb25cIiBjb2xvcnMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5TZWxlY3Rpb246IHRydWUsXG5cbiAgICAvKiogQ2xpY2tpbmcgaW4gYSBjb2x1bW4gaGVhZGVyICh0b3Agcm93KSBcInNlbGVjdHNcIiB0aGUgY29sdW1uOyB0aGUgZW50aXJlIGNvbHVtbiBpcyBhZGRlZCB0byB0aGUgc2VsZWN0IHJlZ2lvbiBhbmQgcmVwYWludGVkIHdpdGggXCJjb2x1bW4gc2VsZWN0aW9uXCIgY29sb3JzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcm93U2VsZWN0aW9uOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzaW5nbGVSb3dTZWxlY3Rpb25Nb2RlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgc2VsZWN0aW9uUmVnaW9uT3ZlcmxheUNvbG9yOiAncmdiYSgwLCAwLCA0OCwgMC4yKScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgc2VsZWN0aW9uUmVnaW9uT3V0bGluZUNvbG9yOiAnYmxhY2snLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5BdXRvc2l6aW5nOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByb3dOdW1iZXJBdXRvc2l6aW5nOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBoZWFkZXJUZXh0V3JhcHBpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByb3dSZXNpemU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBlZGl0YWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZWRpdE9uRG91YmxlQ2xpY2s6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZG91YmxlQ2xpY2tEZWxheTogMzI1LFxuXG4gICAgLyoqXG4gICAgICogR3JpZC1sZXZlbCBwcm9wZXJ0eS5cbiAgICAgKiBXaGVuIHVzZXIgcHJlc3NlcyBhIHByaW50YWJsZSBjaGFyYWN0ZXIga2V5IF9vcl8gQkFDS1NQQUNFIF9vcl8gREVMRVRFOlxuICAgICAqIDEuIEFjdGl2YXRlIGNlbGwgZWRpdG9yIG9uIGN1cnJlbnQgY2VsbCAoaS5lLiwgb3JpZ2luIG9mIG1vc3QgcmVjZW50IHNlbGVjdGlvbikuXG4gICAgICogMi4gSWYgY2VsbCBlZGl0b3IgaXMgYSB0ZXh0IGVkaXRvcjpcbiAgICAgKiAgICAxLiBSZXBsYWNlIGN1cnJlbnQgdmFsdWUgd2l0aCB0aGUgY2hhcmFjdGVyIHRoZSB1c2VyIHR5cGVkOyBvclxuICAgICAqICAgIDIuIENsZWFyIGl0IG9uIEJBQ0tTUEFDRSwgREVMRVRFLCBvciBvdGhlciBpbnZhbGlkIGNoYXJhY3RlciAoX2UuZy5fIHdoZW4gdXNlciB0eXBlcyBhIGxldHRlciBidXQgdGhlIGNlbGwgZWRpdG9yIG9ubHkgYWNjZXB0cyBkaWdpdHMpLlxuICAgICAqXG4gICAgICogPiBJbiBpbnZva2VkLCB1c2VyIGhhcyB0aGUgb3B0aW9uIHRvIGJhY2sgb3V0IGJ5IHByZXNzaW5nIHRoZSBFU0NBUEUga2V5LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBlZGl0T25LZXlkb3duOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjaGVja2JveE9ubHlSb3dTZWxlY3Rpb25zOiBmYWxzZSxcblxuICAgIC8qKiBAc3VtbWFyeSBOYW1lIG9mIGEgZm9ybWF0dGVyIGZvciBjZWxsIHRleHQuXG4gICAgICogVGhlIGRlZmF1bHQgKGB1bmRlZmluZWRgKSBmYWxscyBiYWNrIHRvIGBjb2x1bW4udHlwZWAuXG4gICAgICogVGhlIHZhbHVlIGBudWxsYCBkb2VzIG5vIGZvcm1hdHRpbmcuXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICogQHR5cGUge3VuZGVmaW5lZHxudWxsfHN0cmluZ31cbiAgICAgKiBAdHV0b3JpYWwgbG9jYWxpemF0aW9uXG4gICAgICovXG4gICAgZm9ybWF0OiB1bmRlZmluZWQsXG5cbiAgICAvKiogQHN1bW1hcnkgTmFtZSBvZiBhIGNlbGwgZWRpdG9yIGZyb20gdGhlIHtAbGluayBtb2R1bGU6Y2VsbEVkaXRvcnN8Y2VsbEVkaXRvcnMgQVBJfS4uXG4gICAgICogQGRlc2MgTm90IGVkaXRhYmxlIGlmIG5hbWVkIGVkaXRvciBpcyBkb2VzIG5vdCBleGlzdC5cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAdHlwZSB7dW5kZWZpbmVkfG51bGx8c3RyaW5nfVxuICAgICAqIEB0dXRvcmlhbCBjZWxsLWVkaXRvcnNcbiAgICAgKi9cbiAgICBlZGl0b3I6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgY2VsbCByZW5kZXJlciBmcm9tIHRoZSB7QGxpbmsgbW9kdWxlOmNlbGxSZW5kZXJlcnN8Y2VsbFJlbmRlcmVycyBBUEl9LlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICByZW5kZXJlcjogJ1NpbXBsZUNlbGwnLFxuXG4gICAgLyoqKioqKioqKiogSE9WRVIgQ09MT1JTICoqKioqKioqKiovXG5cbiAgICAvKiogQHR5cGVkZWYgaG92ZXJDb2xvcnNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlbmFibGU9ZmFsc2VdIC0gYGZhbHNlYCBtZWFucyBub3QgaGlsaXRlIG9uIGhvdmVyXG4gICAgICogQHByb3BlcnR5IHtjc3NDb2xvcn0gYmFja2dyb3VuZENvbG9yIC0gY2VsbCwgcm93LCBvciBjb2x1bW4gYmFja2dyb3VuZCBjb2xvci4gQWxwaGEgY2hhbm5lbCB3aWxsIGJlIHJlc3BlY3RlZCBhbmQgaWYgZ2l2ZW4gd2lsbCBiZSBwYWludGVkIG92ZXIgdGhlIGNlbGxzIHByZWRldGVybWluZWQgY29sb3IuXG4gICAgICogQHByb3BlcnR5IHtjc3NDb2xvcn0gW2hlYWRlci5iYWNrZ3JvdW5kQ29sb3I9YmFja2dyb3VuZENvbG9yXSAtIGZvciBjb2x1bW5zIGFuZCByb3dzLCB0aGlzIGlzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBjb2x1bW4gb3Igcm93IFwiaGFuZGxlXCIgKGhlYWRlciByb3dzIG9yIGNvbHVtbnMsIHJlc3BlY3RpdmVseSkuIChOb3QgdXNlZCBmb3IgY2VsbHMuKVxuICAgICAqL1xuXG4gICAgLyoqIE9uIG1vdXNlIGhvdmVyLCB3aGV0aGVyIHRvIHJlcGFpbnQgdGhlIGNlbGwgYmFja2dyb3VuZCBhbmQgaG93LlxuICAgICAqIEB0eXBlIHtob3ZlckNvbG9yc31cbiAgICAgKiBAZGVmYXVsdCAneyBlbmFibGVkOiB0cnVlLCBiYWNrZ3JvdW5kOiByZ2JhKDE2MCwgMTYwLCA0MCwgMC4zMCkgfSdcbiAgICAgKi9cbiAgICBob3ZlckNlbGxIaWdobGlnaHQ6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgxNjAsIDE2MCwgNDAsIDAuNDUpJ1xuICAgIH0sXG5cbiAgICAvKiogT24gbW91c2UgaG92ZXIsIHdoZXRoZXIgdG8gcmVwYWludCB0aGUgcm93IGJhY2tncm91bmQgYW5kIGhvdy5cbiAgICAgKiBAdHlwZSB7aG92ZXJDb2xvcnN9XG4gICAgICogQGRlZmF1bHQgJ3sgZW5hYmxlZDogdHJ1ZSwgYmFja2dyb3VuZDogcmdiYSgxMDAsIDEwMCwgMjUsIDAuMTUpIH0nXG4gICAgICovXG4gICAgaG92ZXJSb3dIaWdobGlnaHQ6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgxMDAsIDEwMCwgMjUsIDAuMzApJ1xuXG4gICAgfSxcblxuICAgIC8qKiBPbiBtb3VzZSBob3Zlciwgd2hldGhlciB0byByZXBhaW50IHRoZSBjb2x1bW4gYmFja2dyb3VuZCBhbmQgaG93LlxuICAgICAqIEB0eXBlIHtob3ZlckNvbG9yc31cbiAgICAgKiBAZGVmYXVsdCAneyBlbmFibGVkOiB0cnVlLCBiYWNrZ3JvdW5kOiByZ2JhKDYwLCA2MCwgMTUsIDAuMTUpIH0nXG4gICAgICovXG4gICAgaG92ZXJDb2x1bW5IaWdobGlnaHQ6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSg2MCwgNjAsIDE1LCAwLjE1KSdcbiAgICB9LFxuXG5cbiAgICAvKiogRGlzcGxheSBjZWxsIGZvbnQgd2l0aCB1bmRlci1zY29yZSBsaW5lIGRyYXduIG92ZXIgaXQuXG4gICAgICogPiBJbXBsZW1lbnRhdGlvbiBvZiBsaW5rcyByaWdodCBub3cgaXMgbm90IGF1dG9tYXRpYzsgeW91IG11c3QgYXR0YWNoIGEgJ2Zpbi1jbGljaycgbGlzdGVuZXIgdG8gdGhlIGh5cGVyZ3JpZCBvYmplY3QsIGV0Yy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxpbms6IGZhbHNlLFxuXG4gICAgLyoqIERpc3BsYXkgY2VsbCBmb250IHdpdGggc3RyaWtlLXRocm91Z2ggbGluZSBkcmF3biBvdmVyIGl0LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3RyaWtlVGhyb3VnaDogZmFsc2UsXG5cbn07XG5cbi8qKiBAdHlwZWRlZiB7c3RyaW5nfSBjc3NDb2xvclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY29sb3JfdmFsdWVcbiAqL1xuLyoqIEB0eXBlZGVmIHtzdHJpbmd9IGNzc0ZvbnRcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnRcbiAqL1xuXG52YXIgdGV4dFdpZHRoQ2FjaGUgPSBuZXcgTFJVQ2FjaGUoMjAwMCk7XG5cbmZ1bmN0aW9uIGdldFRleHRXaWR0aChnYywgc3RyaW5nKSB7XG4gICAgaWYgKHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgc3RyaW5nID0gc3RyaW5nICsgJyc7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciBrZXkgPSBnYy5mb250ICsgc3RyaW5nO1xuICAgIHZhciB3aWR0aCA9IHRleHRXaWR0aENhY2hlLmdldChrZXkpO1xuICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgd2lkdGggPSBnYy5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xuICAgICAgICB0ZXh0V2lkdGhDYWNoZS5zZXQoa2V5LCB3aWR0aCk7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aDtcbn1cblxudmFyIGZvbnREYXRhID0ge307XG5cbmZ1bmN0aW9uIGdldFRleHRIZWlnaHQoZm9udCkge1xuICAgIHZhciByZXN1bHQgPSBmb250RGF0YVtmb250XTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICB0ZXh0LnRleHRDb250ZW50ID0gJ0hnJztcbiAgICAgICAgdGV4dC5zdHlsZS5mb250ID0gZm9udDtcblxuICAgICAgICB2YXIgYmxvY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYmxvY2suc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICBibG9jay5zdHlsZS53aWR0aCA9ICcxcHgnO1xuICAgICAgICBibG9jay5zdHlsZS5oZWlnaHQgPSAnMHB4JztcblxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKGJsb2NrKTtcblxuICAgICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgYmxvY2suc3R5bGUudmVydGljYWxBbGlnbiA9ICdiYXNlbGluZSc7XG5cbiAgICAgICAgICAgIHZhciBibG9ja1JlY3QgPSBibG9jay5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciB0ZXh0UmVjdCA9IHRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgIHJlc3VsdC5hc2NlbnQgPSBibG9ja1JlY3QudG9wIC0gdGV4dFJlY3QudG9wO1xuXG4gICAgICAgICAgICBibG9jay5zdHlsZS52ZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICByZXN1bHQuaGVpZ2h0ID0gYmxvY2tSZWN0LnRvcCAtIHRleHRSZWN0LnRvcDtcblxuICAgICAgICAgICAgcmVzdWx0LmRlc2NlbnQgPSByZXN1bHQuaGVpZ2h0IC0gcmVzdWx0LmFzY2VudDtcblxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuaGVpZ2h0ICE9PSAwKSB7XG4gICAgICAgICAgICBmb250RGF0YVtmb250XSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGlzdERyYWdvbiA9IHJlcXVpcmUoJ2xpc3QtZHJhZ29uJyk7XG5cbnZhciBEaWFsb2cgPSByZXF1aXJlKCcuL0RpYWxvZycpO1xudmFyIHN0eWxlc2hlZXQgPSByZXF1aXJlKCcuLi9saWIvc3R5bGVzaGVldCcpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29sdW1uUGlja2VyID0gRGlhbG9nLmV4dGVuZCgnQ29sdW1uUGlja2VyJywge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE1heSBpbmNsdWRlIGBEaWFsb2dgIG9wdGlvbnMuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZ3JpZCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSBncmlkLmJlaGF2aW9yO1xuXG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG5cbiAgICAgICAgaWYgKGJlaGF2aW9yLmlzQ29sdW1uUmVvcmRlcmFibGUoKSkge1xuICAgICAgICAgICAgLy8gZ3JhYiB0aGUgbGlzdHMgZnJvbSB0aGUgYmVoYXZpb3JcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHcm91cHMgPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdHcm91cHMnLFxuICAgICAgICAgICAgICAgIG1vZGVsczogYmVoYXZpb3IuZ2V0R3JvdXBzKClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuYXZhaWxhYmxlR3JvdXBzID0ge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnQXZhaWxhYmxlIEdyb3VwcycsXG4gICAgICAgICAgICAgICAgbW9kZWxzOiBiZWhhdmlvci5nZXRBdmFpbGFibGVHcm91cHMoKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5pbmFjdGl2ZUNvbHVtbnMgPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdJbmFjdGl2ZSBDb2x1bW5zJyxcbiAgICAgICAgICAgICAgICBtb2RlbHM6IGJlaGF2aW9yLmdldEhpZGRlbkNvbHVtbnMoKS5zb3J0KGNvbXBhcmVCeU5hbWUpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNvbHVtbnMgPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdBY3RpdmUgQ29sdW1ucycsXG4gICAgICAgICAgICAgICAgbW9kZWxzOiBiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW5zKClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuc29ydE9uSGlkZGVuQ29sdW1ucyA9IHRoaXMud2FzU29ydE9uSGlkZGVuQ29sdW1ucyA9IGdyaWQucmVzb2x2ZVByb3BlcnR5KCdzb3J0T25IaWRkZW5Db2x1bW5zJyk7XG5cbiAgICAgICAgICAgIC8vIHBhcnNlICYgYWRkIHRoZSBkcmFnLWFuZC1kcm9wIHN0eWxlc2hlZXQgYWRkZW5kdW1cbiAgICAgICAgICAgIHZhciBzdHlsZXNoZWV0QWRkZW5kdW0gPSBzdHlsZXNoZWV0LmluamVjdCgnbGlzdC1kcmFnb24tYWRkZW5kdW0nKTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIGRyYWctYW5kLWRyb3Agc2V0cyBmcm9tIHRoZSBsaXN0c1xuICAgICAgICAgICAgdmFyIGxpc3RTZXRzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBMaXN0RHJhZ29uKFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdyb3VwcyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdmFpbGFibGVHcm91cHNcbiAgICAgICAgICAgICAgICBdLCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgbGlzdC1kcmFnb24tYmFzZSBzdHlsZXNoZWV0IHJpZ2h0IGJlZm9yZSB0aGUgYWRkZW5kdW1cbiAgICAgICAgICAgICAgICAgICAgY3NzU3R5bGVzaGVldFJlZmVyZW5jZUVsZW1lbnQ6IHN0eWxlc2hlZXRBZGRlbmR1bVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBMaXN0RHJhZ29uKFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmFjdGl2ZUNvbHVtbnMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29sdW1uc1xuICAgICAgICAgICAgICAgIF0sIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2UgbW9kZWxzIGhhdmUgYSBoZWFkZXIgcHJvcGVydHkgYXMgdGhlaXIgbGFiZWxzXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAne2hlYWRlcn0nXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgZHJhZy1hbmQtZHJvcCBzZXRzIHRvIHRoZSBkaWFsb2dcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGxpc3RTZXRzLmZvckVhY2goZnVuY3Rpb24obGlzdFNldCkge1xuICAgICAgICAgICAgICAgIGxpc3RTZXQubW9kZWxMaXN0cy5mb3JFYWNoKGZ1bmN0aW9uKGxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBlbmQobGlzdC5jb250YWluZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvL0xpc3RlbiB0byB0aGUgdmlzaWJsZSBjb2x1bW4gY2hhbmdlc1xuICAgICAgICAgICAgbGlzdFNldHNbMV0ubW9kZWxMaXN0c1sxXS5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xpc3RjaGFuZ2VkJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgZ3JpZC5maXJlU3ludGhldGljT25Db2x1bW5zQ2hhbmdlZEV2ZW50KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5zb3J0T25IaWRkZW5Db2x1bW5zID0gdGhpcy5ncmlkLnJlc29sdmVQcm9wZXJ0eSgnc29ydE9uSGlkZGVuQ29sdW1ucycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZGl2LnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgZGl2LnN0eWxlLm1hcmdpblRvcCA9ICcyZW0nO1xuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9ICdUaGUgc2VsZWN0aW9uIG9mIHZpc2libGUgY29sdW1ucyBpbiB0aGUgZ3JpZCBtYXkgbm90IGJlIGNoYW5nZWQuJztcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKGRpdik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgY2hlY2tib3ggdG8gY29udHJvbCBwYW5lbCBmb3Igc29ydGluZyBvbiBoaWRkZW4gZmllbGRzXG4gICAgICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIGxhYmVsLmlubmVySFRNTCA9ICc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCI+IEFsbG93IHNvcnRpbmcgb24gaGlkZGVuIGNvbHVtbnMnO1xuICAgICAgICBsYWJlbC5zdHlsZS5mb250V2VpZ2h0ID0gJ25vcm1hbCc7XG4gICAgICAgIGxhYmVsLnN0eWxlLm1hcmdpblJpZ2h0ID0gJzJlbSc7XG5cbiAgICAgICAgdmFyIGNoZWNrYm94ID0gbGFiZWwucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHRoaXMuc29ydE9uSGlkZGVuQ29sdW1ucztcbiAgICAgICAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIHNlbGYuc29ydE9uSGlkZGVuQ29sdW1ucyA9IGNoZWNrYm94LmNoZWNrZWQ7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcGFuZWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5oeXBlcmdyaWQtZGlhbG9nLWNvbnRyb2wtcGFuZWwnKTtcbiAgICAgICAgcGFuZWwuaW5zZXJ0QmVmb3JlKGxhYmVsLCBwYW5lbC5maXJzdENoaWxkKTtcblxuICAgICAgICAvLyBhZGQgdGhlIGRpYWxvZyB0byB0aGUgRE9NXG4gICAgICAgIHRoaXMub3BlbihvcHRpb25zLmNvbnRhaW5lcik7XG4gICAgfSxcblxuICAgIG9uQ2xvc2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ29sdW1ucykge1xuICAgICAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5ncmlkLmJlaGF2aW9yLFxuICAgICAgICAgICAgICAgIGNvbHVtbnMgPSBiZWhhdmlvci5jb2x1bW5zLFxuICAgICAgICAgICAgICAgIHRyZWUgPSBjb2x1bW5zWzBdO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBicmVha2luZyBlbmNhcHN1bGF0aW9uOyBzaG91bGQgYmUgdXNpbmcgc2V0dGVycyBhbmQgZ2V0dGVycyBvbiB0aGUgYmVoYXZpb3JcbiAgICAgICAgICAgIGNvbHVtbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmICh0cmVlICYmIHRyZWUubGFiZWwgPT09ICdUcmVlJykge1xuICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaCh0cmVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29sdW1ucy5tb2RlbHMuZm9yRWFjaChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGdyb3VwQnlzID0gdGhpcy5zZWxlY3RlZEdyb3Vwcy5tb2RlbHMubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5pZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmVoYXZpb3IuZGF0YU1vZGVsLnNldEdyb3Vwcyhncm91cEJ5cyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNvcnRPbkhpZGRlbkNvbHVtbnMgIT09IHRoaXMud2FzU29ydE9uSGlkZGVuQ29sdW1ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5hZGRQcm9wZXJ0aWVzKHsgc29ydE9uSGlkZGVuQ29sdW1uczogdGhpcy5zb3J0T25IaWRkZW5Db2x1bW5zIH0pO1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yLnNvcnRDaGFuZ2VkKHRoaXMuaW5hY3RpdmVDb2x1bW5zLm1vZGVscyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJlaGF2aW9yLmNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBjb21wYXJlQnlOYW1lKGEsIGIpIHtcbiAgICBhID0gYS5oZWFkZXIudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpO1xuICAgIGIgPSBiLmhlYWRlci50b1N0cmluZygpLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/ICsxIDogMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtblBpY2tlcjtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhdXRvbWF0ID0gcmVxdWlyZSgnYXV0b21hdCcpO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL2xpYi9CYXNlJyk7XG52YXIgbWFya3VwID0gcmVxdWlyZSgnLi4vLi4vaHRtbCcpO1xudmFyIGltYWdlcyA9IHJlcXVpcmUoJy4uLy4uL2ltYWdlcycpO1xudmFyIGVsZm9yID0gcmVxdWlyZSgnLi4vbGliL2VsZm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgc2VydmljZXMgYSBET00gZWxlbWVudCB1c2VkIGFzIGEgY250YWluZXIgZm9yIGEgZGlhbG9nLiBUaGUgc3RhbmRhcmQgYG1hcmt1cC5kaWFsb2dgIGlzIHNpbXBseSBhIGRpdiB3aXRoIGEgX2NvbnRyb2wgcGFuZWxfIGNvbnRhaW5pbmcgYSBjbG9zZSBib3ggYW5kIGEgc2V0dGluZ3MgZ2VhciBpY29uLlxuICpcbiAqIFlvdSBjYW4gc3VwcGx5IGFuIGFsdGVybmF0aXZlIGRpYWxvZyB0ZW1wbGF0ZS4gVGhlIGludGVyZmFjZSBpczpcbiAqICogQ2xhc3MgbmFtZSBgaHlwZXJncmlkLWRpYWxvZ2AuXG4gKiAqIEF0IGxlYXN0IG9uZSBjaGlsZCBlbGVtZW50LiBDb250ZW50IHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoaXMgZmlyc3QgY2hpbGQuXG4gKiAqIFR5cGljYWxseSBjb250YWlucyBhIGNsb3NlLWJveCBlbGVtZW50IHdpdGggY2xhc3MgbmFtZSBgaHlwZXJncmlkLWRpYWxvZy1jbG9zZWAgYW5kIHBvc3NpYmx5IG90aGVyIGNvbnRyb2xzIHdpdGggY2xhc3MgbmFtZSBgaHlwZXJncmlkLWRpYWxvZy14eHh4YCAod2hlcmUgX3h4eHhfIGlzIGEgdW5pcXVlIG5hbWUgZm9yIHlvdXIgY29udHJvbCkuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEaWFsb2cgPSBCYXNlLmV4dGVuZCgnRGlhbG9nJywge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJhc2ljIGRpYWxvZyBib3ggaW4gYHRoaXMuZWxgLlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSBbb3B0aW9ucy5kaWFsb2dUZW1wbGF0ZV0gLSBBbiBhbHRlcm5hdGUgZGlhbG9nIHRlbXBsYXRlLiBUaGUgbGFzdCBjaGlsZCBlbGVtZW50IG11c3QgYmUgdGhlIFwiY29udHJvbCBwYW5lbC5cIlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2V0dGluZ3M9dHJ1ZV0gLSBDb250cm9sIGJveCBoYXMgc2V0dGluZ3MgaWNvbi4gKFNldHRpbmdzIGljb24gbXVzdCBiZSBpbmNsdWRlZCBpbiB0ZW1wbGF0ZS4gVGhpcyBvcHRpb24gcmVtb3ZlcyBpdC4gVGhhdCBpcywgaWYgZXhwbGljaXRseSBgZmFsc2VgIF9hbmRfIHRoZXJlIGlzIGEgc2V0dGluZ3MgY29udHJvbCwgcmVtb3ZlIGl0LilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBbb3B0aW9ucy5iYWNrZ3JvdW5kSW1hZ2U9aW1hZ2VzLmRpYWxvZy5zcmNdIC0gQSBVUkkgZm9yIGEgYmFja2dyb3VuZCBpbWFnZS4gSWYgZXhwbGljaXRseSBgZmFsc2VgLCBiYWNrZ3JvdW5kIGltYWdlIGlzIHN1cHByZXNzZWQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3Rlcm1pbmF0ZV1cbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBiYWNrZHJvcDsgaXQgaXMgYWJzb2x1dGUtcG9zaXRpb25lZCBhbmQgc3RyZXRjaGVkXG4gICAgICAgIHRoaXMuZWwgPSBhdXRvbWF0LmZpcnN0Q2hpbGQob3B0aW9ucy5kaWFsb2dUZW1wbGF0ZSB8fCBtYXJrdXAuZGlhbG9nLCBvcHRpb25zLmRpYWxvZ1JlcGxhY2VtZW50cyk7XG5cbiAgICAgICAgdGhpcy5vcmlnaW5hbEZpcnN0Q2hpbGQgPSB0aGlzLmVsLmZpcnN0RWxlbWVudENoaWxkO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNldHRpbmdzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuaHlwZXJncmlkLWRpYWxvZy1zZXR0aW5ncycpO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgYmFja2dyb3VuZCBpbWFnZVxuICAgICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kSW1hZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoXFwnJyArIChvcHRpb25zLmJhY2tncm91bmRJbWFnZSB8fCBpbWFnZXMuZGlhbG9nLnNyYykgKyAnXFwnKSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaXN0ZW4gZm9yIGNsaWNrc1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljay5iaW5kKHRoaXMpKTtcblxuICAgICAgICBpZiAob3B0aW9ucy50ZXJtaW5hdGUpIHtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlID0gb3B0aW9ucy50ZXJtaW5hdGU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQWRkcyBET00gYE5vZGVgcyB0byBkaWFsb2cuXG4gICAgICogQGRlc2MgSW5wdXQgY2FuIGJlIG5vZGVzIG9yIGEgdGVtcGxhdGUgZnJvbSB3aGljaCB0byBjcmVhdGUgbm9kZXMuIFRoZSBub2RlcyBhcmUgaW5zZXJ0ZWQgaW50byB0aGUgZGlhbG9nJ3MgRE9NIChgdGhpcy5lbGApLCByaWdodCBiZWZvcmUgdGhlIFwiY29udHJvbCBwYW5lbC5cIlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufE5vZGV8Tm9kZVtdfSBub2RlcyAtIFNlZSBgYXV0b21hdGAuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcmVwbGFjZW1lbnRzXSAtIFNlZSBgYXV0b21hdGAuXG4gICAgICovXG4gICAgYXBwZW5kOiBmdW5jdGlvbihub2RlcywgcmVwbGFjZW1lbnRzLyouLi4qLykge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZXMgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgYXJncy5zcGxpY2UoMSwgMCwgZWwsIHRoaXMub3JpZ2luYWxGaXJzdENoaWxkKTtcbiAgICAgICAgICAgIGF1dG9tYXQuYXBwZW5kLmFwcGx5KG51bGwsIGFyZ3MpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoJ2xlbmd0aCcgaW4gbm9kZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBlbC5pbnNlcnRCZWZvcmUobm9kZXNbaV0sIHRoaXMub3JpZ2luYWxGaXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuaW5zZXJ0QmVmb3JlKG5vZGVzLCB0aGlzLm9yaWdpbmFsRmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGRpYWxvZyBpbnRvIERPTS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtjb250YWluZXJdIC0gSWYgdW5kZWZpbmVkLCBkaWFsb2cgaXMgYXBwZW5kZWQgdG8gYm9keS5cbiAgICAgKlxuICAgICAqIElmIGRlZmluZWQsIGRpYWxvZyBpcyBhcHBlbmRlZCB0byBjb250YWluZXIuIFdoZW4gY29udGFpbmVyIGlzIG5vdCBib2R5LCBpdCB3aWxsIGJlOlxuICAgICAqICMgbWFkZSB2aXNpYmxlIGJlZm9yZSBhcHBlbmQgKGl0IHNob3VsZCBpbml0aWFsbHkgYmUgaGlkZGVuKVxuICAgICAqICMgbWFkZSBoaWRkZW4gYWZ0ZXIgcmVtb3ZlXG4gICAgICovXG4gICAgb3BlbjogZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBlcnJvcjtcblxuICAgICAgICBpZiAoISh0aGlzLm9wZW5lZCB8fCB0aGlzLm9wZW5pbmcgfHwgdGhpcy5jbG9zZWQgfHwgdGhpcy5jbG9zaW5nKSkge1xuICAgICAgICAgICAgZXJyb3IgPSB0aGlzLm9uT3BlbigpO1xuXG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgICAgICAgICAgICAgIHRoaXMub3BlbmluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lci50YWdOYW1lICE9PSAnQk9EWScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBuZXcgZGlhbG9nIG1hcmt1cCBpbnRvIHRoZSBET01cbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2NoZWR1bGUgaXQgZm9yIGEgc2hvdyB0cmFuc2l0aW9uXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgZWwuY2xhc3NMaXN0LmFkZCgnaHlwZXJncmlkLWRpYWxvZy12aXNpYmxlJyk7IH0sIDUwKTtcblxuICAgICAgICAgICAgICAgIC8vIGF0IGVuZCBvZiBzaG93IHRyYW5zaXRpb24sIGhpZGUgYWxsIHRoZSBoeXBlcmdyaWRzIGJlaGluZCBpdCB0byBwcmV2ZW50IGFueSBrZXkvbW91c2UgZXZlbnRzIGZyb20gZ2V0dGluZyB0byB0aGVtXG4gICAgICAgICAgICAgICAgLy8gdG9kbzogcGF1c2UgYWxsIGh5cGVyZ3JpZHMgc28gdGhleSBkb24ndCBzcGluIHVzZWxlc3NseVxuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLmhpZGVBcHBCb3VuZCA9IGhpZGVBcHAuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBkaWFsb2cgZnJvbSBET00uXG4gICAgICovXG4gICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZXJyb3I7XG5cbiAgICAgICAgaWYgKHRoaXMub3BlbmVkICYmICEodGhpcy5jbG9zZWQgfHwgdGhpcy5jbG9zaW5nKSkge1xuICAgICAgICAgICAgZXJyb3IgPSB0aGlzLm9uQ2xvc2UoKTtcblxuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gdW5oaWRlIGFsbCB0aGUgaHlwZXJncmlkcyBiZWhpbmQgdGhlIGRpYWxvZ1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwVmlzaWJsZSgndmlzaWJsZScpO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYSBoaWRlIHRyYW5zaXRpb24gb2YgZGlhbG9nIHJldmVhbGluZyBncmlkcyBiZWhpbmQgaXRcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdoeXBlcmdyaWQtZGlhbG9nLXZpc2libGUnKTtcblxuICAgICAgICAgICAgICAgIC8vIGF0IGVuZCBvZiBoaWRlIHRyYW5zaXRpb24sIHJlbW92ZSBkaWFsb2cgZnJvbSB0aGUgRE9NXG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMucmVtb3ZlRGlhbG9nQm91bmQgPSByZW1vdmVEaWFsb2cuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSxcblxuICAgIGFwcFNlbGVjdG9yOiAnY2FudmFzLmh5cGVyZ3JpZCcsXG4gICAgYXBwVmlzaWJsZTogZnVuY3Rpb24odmlzaWJpbGl0eSkge1xuICAgICAgICBlbGZvci5lYWNoKHRoaXMuYXBwU2VsZWN0b3IsIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG9uT3BlbjogbnVsbFBhdHRlcm4sXG4gICAgb25PcGVuZWQ6IG51bGxQYXR0ZXJuLFxuICAgIG9uQ2xvc2U6IG51bGxQYXR0ZXJuLFxuICAgIG9uQ2xvc2VkOiBudWxsUGF0dGVybixcbiAgICB0ZXJtaW5hdGU6IG51bGxQYXR0ZXJuXG59KTtcblxuZnVuY3Rpb24gbnVsbFBhdHRlcm4oKSB7fVxuXG5mdW5jdGlvbiByZW1vdmVEaWFsb2coZXZ0KSB7XG4gICAgaWYgKGV2dC50YXJnZXQgPT09IHRoaXMuZWwgJiYgZXZ0LnByb3BlcnR5TmFtZSA9PT0gJ29wYWNpdHknKSB7XG4gICAgICAgIGlmICh0aGlzLmVsLnBhcmVudEVsZW1lbnQudGFnTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnBhcmVudEVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmVsO1xuXG4gICAgICAgIHRoaXMub25DbG9zZWQoKTtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGUoKTtcbiAgICAgICAgdGhpcy5jbG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhpZGVBcHAoZXZ0KSB7XG4gICAgaWYgKGV2dC50YXJnZXQgPT09IHRoaXMuZWwgJiYgZXZ0LnByb3BlcnR5TmFtZSA9PT0gJ29wYWNpdHknKSB7XG4gICAgICAgIHRoaXMuYXBwVmlzaWJsZSgnaGlkZGVuJyk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMuaGlkZUFwcEJvdW5kKTtcbiAgICAgICAgdGhpcy5vbk9wZW5lZCgpO1xuICAgICAgICB0aGlzLm9wZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gb25DbGljayhldnQpIHtcbiAgICBpZiAodGhpcykge1xuICAgICAgICBpZiAoZXZ0LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2h5cGVyZ3JpZC1kaWFsb2ctY2xvc2UnKSkge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7IC8vIGlnbm9yZSBocmVmXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChldnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnaHlwZXJncmlkLWRpYWxvZy1zZXR0aW5ncycpKSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsgLy8gaWdub3JlIGhyZWZcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzKSB7IHRoaXMuc2V0dGluZ3MoKTsgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vbkNsaWNrICYmICF0aGlzLm9uQ2xpY2suY2FsbCh0aGlzLCBldnQpICYmIGV2dC50YXJnZXQudGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsgLy8gaWdub3JlIGhyZWYgb2YgaGFuZGxlZCBldmVudFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpOyAvLyB0aGUgY2xpY2sgc3RvcHMgaGVyZSwgaGFuZGxlZCBvciBub3Rcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaWFsb2c7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGFieiA9IHJlcXVpcmUoJ3RhYnonKTtcbnZhciBwb3BNZW51ID0gcmVxdWlyZSgncG9wLW1lbnUnKTtcbnZhciBhdXRvbWF0ID0gcmVxdWlyZSgnYXV0b21hdCcpO1xuXG52YXIgRGlhbG9nID0gcmVxdWlyZSgnLi9EaWFsb2cnKTtcbnZhciBtYXJrdXAgPSByZXF1aXJlKCcuLi8uLi9odG1sJyk7XG52YXIgY29weUlucHV0ID0gcmVxdWlyZSgnLi4vbGliL2NvcHktaW5wdXQnKTtcblxudmFyIHRhYlByb3BlcnRpZXMgPSB7XG4gICAgdGFibGVRQjoge1xuICAgICAgICBpc1RhYmxlRmlsdGVyOiB0cnVlXG4gICAgfSxcbiAgICB0YWJsZVNRTDoge1xuICAgICAgICBpc1RhYmxlRmlsdGVyOiB0cnVlLFxuICAgICAgICBsYW5ndWFnZTogJ1NRTCdcbiAgICB9LFxuICAgIGNvbHVtbnNRQjoge1xuICAgICAgICBpc0NvbHVtbkZpbHRlcjogdHJ1ZVxuICAgIH0sXG4gICAgY29sdW1uc1NRTDoge1xuICAgICAgICBpc0NvbHVtbkZpbHRlcjogdHJ1ZSxcbiAgICAgICAgbGFuZ3VhZ2U6ICdTUUwnXG4gICAgfSxcbiAgICBjb2x1bW5zQ1FMOiB7XG4gICAgICAgIGlzQ29sdW1uRmlsdGVyOiB0cnVlLFxuICAgICAgICBsYW5ndWFnZTogJ0NRTCdcbiAgICB9XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWFuYWdlRmlsdGVycyA9IERpYWxvZy5leHRlbmQoJ01hbmFnZUZpbHRlcnMnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBNYXkgaW5jbHVkZSBgRGlhbG9nYCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtvcHRpb25zLmNvbnRhaW5lcj1kb2N1bWVudC5ib2R5XVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGdyaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBncmlkLmdldEdsb2JhbEZpbHRlcigpO1xuXG4gICAgICAgIHRoaXMuYXBwZW5kKG1hcmt1cC5maWx0ZXJUcmVlcyk7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgZm9sZGVyIHRhYnNcbiAgICAgICAgdmFyIHRhYnogPSB0aGlzLnRhYnogPSBuZXcgVGFieih7XG4gICAgICAgICAgICByb290OiB0aGlzLmVsLFxuICAgICAgICAgICAgb25FbmFibGU6IHJlbmRlckZvbGRlci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgb25EaXNhYmxlOiBzYXZlRm9sZGVycy5iaW5kKHRoaXMsIG51bGwpIC8vIG51bGwgb3B0aW9uc1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3aXJlLXVwIHRoZSBOZXcgQ29sdW1uIGRyb3AtZG93blxuICAgICAgICB2YXIgbmV3Q29sdW1uRHJvcERvd24gPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJyNhZGQtY29sdW1uLWZpbHRlci1zdWJleHByZXNzaW9uJyk7XG4gICAgICAgIG5ld0NvbHVtbkRyb3BEb3duLm9ubW91c2Vkb3duID0gb25OZXdDb2x1bW5Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgbmV3Q29sdW1uRHJvcERvd24ub25jaGFuZ2UgPSBvbk5ld0NvbHVtbkNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIHB1dCB0aGUgdHdvIHN1YnRyZWVzIGluIHRoZSB0d28gcGFuZWxzXG4gICAgICAgIHRhYnouZm9sZGVyKCcjdGFibGVRQicpLmFwcGVuZENoaWxkKHRoaXMuZmlsdGVyLnRhYmxlRmlsdGVyLmVsKTtcbiAgICAgICAgdGFiei5mb2xkZXIoJyNjb2x1bW5zUUInKS5hcHBlbmRDaGlsZCh0aGlzLmZpbHRlci5jb2x1bW5GaWx0ZXJzLmVsKTtcblxuICAgICAgICAvLyBjb3B5IHRoZSBTUUwgbW9yZS1pbmZvIGJsb2NrIGZyb20gdGhlIHRhYmxlIHRvIHRoZSBjb2x1bW5zIHRhYlxuICAgICAgICB2YXIgY29sdW1uU3FsRWwgPSB0YWJ6LmZvbGRlcignI2NvbHVtbnNTUUwnKTtcbiAgICAgICAgdmFyIG1vcmVTcWxJbmZvID0gdGFiei5mb2xkZXIoJyN0YWJsZVNRTCcpLmZpcnN0RWxlbWVudENoaWxkLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgY29sdW1uU3FsRWwuaW5zZXJ0QmVmb3JlKG1vcmVTcWxJbmZvLCBjb2x1bW5TcWxFbC5maXJzdENoaWxkKTtcblxuICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIERPTVxuICAgICAgICB0aGlzLm9wZW4ob3B0aW9ucy5jb250YWluZXIpO1xuXG4gICAgICAgIC8vIGZvbGxvd2luZyBuZWVkZWQgZm9yIHVuY2xlYXIgcmVhc29ucyB0byBnZXQgZHJvcC1kb3duIHRvIGRpc3BsYXkgY29ycmVjdGx5XG4gICAgICAgIG5ld0NvbHVtbkRyb3BEb3duLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgIH0sXG5cbiAgICBvbkNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNhdmVGb2xkZXJzLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIG9uQ2xvc2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5ncmlkLmJlaGF2aW9yO1xuICAgICAgICBiZWhhdmlvci5hcHBseUFuYWx5dGljcygpO1xuICAgICAgICBiZWhhdmlvci5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBjbGljayBoYW5kbGVyczsgY2FsbGVkIGJ5IGN1cnRhaW4ub25jbGljayBpbiBjb250ZXh0XG4gICAgICogQHBhcmFtIGV2dFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIG9uQ2xpY2s6IGZ1bmN0aW9uKGV2dCkgeyAvLyB0byBiZSBjYWxsZWQgd2l0aCBmaWx0ZXIgb2JqZWN0IGFzIHN5bnRheFxuICAgICAgICB2YXIgY3RybCA9IGV2dC50YXJnZXQ7XG5cbiAgICAgICAgaWYgKGN0cmwuY2xhc3NMaXN0LmNvbnRhaW5zKCdtb3JlLWluZm8nKSkge1xuICAgICAgICAgICAgLy8gZmluZCBhbGwgbW9yZS1pbmZvIGxpbmtzIGFuZCB0aGVpciBhZGphY2VudCBibG9ja3MgKGJsb2NrcyBhbHdheXMgZm9sbG93IGxpbmtzKVxuICAgICAgICAgICAgdmFyIGVscyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCgnLm1vcmUtaW5mbycpO1xuXG4gICAgICAgICAgICAvLyBoaWRlIGFsbCBtb3JlLWluZm8gYmxvY2tzIGV4Y2VwdCB0aGUgb25lIGZvbGxvd2luZyB0aGlzIGxpbmsgKHVubGVzcyBpdCdzIGFscmVhZHkgdmlzaWJsZSBpbiB3aGljaCBjYXNlIGhpZGUgaXQgdG9vKS5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZWxzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChlbC50YWdOYW1lID09PSAnQScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZWwgPT09IGN0cmw7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdFtmb3VuZCA/ICd0b2dnbGUnIDogJ3JlbW92ZSddKCdoaWRlLWluZm8nKTtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSBlbHNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZm91bmQgJiYgZWwuc3R5bGUuZGlzcGxheSAhPT0gJ2Jsb2NrJyA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoY3RybC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZpbHRlci1jb3B5JykpIHtcbiAgICAgICAgICAgIHZhciBpc0NvcHlBbGwgPSBjdHJsLmNoaWxkTm9kZXMubGVuZ3RoOyAvLyBjb250YWlucyBcIkFsbFwiXG4gICAgICAgICAgICBpZiAoaXNDb3B5QWxsKSB7XG4gICAgICAgICAgICAgICAgY3RybCA9IHRoaXMudGFiei5mb2xkZXIoY3RybCkucXVlcnlTZWxlY3Rvcihjb3B5SW5wdXQuc2VsZWN0b3JUZXh0Q29udHJvbHMpO1xuICAgICAgICAgICAgICAgIGNvcHlJbnB1dChjdHJsLCB0aGlzLmZpbHRlci5jb2x1bW5GaWx0ZXJzLmdldFN0YXRlKHsgc3ludGF4OiAnU1FMJyB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcHlJbnB1dChjdHJsLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3Rvcihjb3B5SW5wdXQuc2VsZWN0b3JUZXh0Q29udHJvbHMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIG1lYW5zIHVuaGFuZGxlZFxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSB0YWJcbiAqIEBwYXJhbSBmb2xkZXJcbiAqIEBwYXJhbSBbcGFuZWxdIFBhbmVsIHRvIHNhdmUgKGZyb20gdGFiIGNsaWNrKS4gSWYgb21pdHRlZCwgc2F2ZSBib3RoIHBhbmVscyAoZnJvbSBvbmNsb3NlKS5cbiAqIEByZXR1cm5zIHtib29sZWFufHVuZGVmaW5lZHxzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNhdmVGb2xkZXJzKG9wdGlvbnMsIHRhYiwgZm9sZGVyLCBwYW5lbCkge1xuICAgIHJldHVybiAoXG4gICAgICAgICghcGFuZWwgfHwgcGFuZWwuaWQgPT09ICd0YWJsZUZpbHRlclBhbmVsJykgJiYgc2F2ZUZvbGRlci5jYWxsKHRoaXMsIHRoaXMuZmlsdGVyLnRhYmxlRmlsdGVyLCBvcHRpb25zKSB8fFxuICAgICAgICAoIXBhbmVsIHx8IHBhbmVsLmlkID09PSAnY29sdW1uRmlsdGVyc1BhbmVsJykgJiYgc2F2ZUZvbGRlci5jYWxsKHRoaXMsIHRoaXMuZmlsdGVyLmNvbHVtbkZpbHRlcnMsIG9wdGlvbnMpXG4gICAgKTtcbn1cblxuLyoqXG4gKiBAdGhpcyBGaWx0ZXJcbiAqIEBwYXJhbSB7RGVmYXVsdEZpbHRlcn0gc3VidHJlZVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXthbGVydDp0cnVlLGZvY3VzOnRydWV9XSAtIFNpZGUgZWZmZWN0cyBhcyBwZXIgYEZpbHRlclRyZWUucHJvdG90eXBlLmludmFsaWRgJ3MgYG9wdGlvbnNgJyBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfHN0cmluZ30gLSBWYWxpZGF0aW9uIGVycm9yIHRleHQ7IGZhbHN5IG1lYW5zIHZhbGlkIChubyBlcnJvcikuXG4gKi9cbmZ1bmN0aW9uIHNhdmVGb2xkZXIoc3VidHJlZSwgb3B0aW9ucykgeyAvLyB0byBiZSBjYWxsZWQgd2l0aCBmaWx0ZXIgb2JqZWN0IGFzIHN5bnRheFxuICAgIHZhciBpc0NvbHVtbkZpbHRlcnMgPSBzdWJ0cmVlID09PSB0aGlzLmZpbHRlci5jb2x1bW5GaWx0ZXJzLFxuICAgICAgICB0YWJRdWVyeUJ1aWxkZXIgPSB0aGlzLnRhYnoudGFiKGlzQ29sdW1uRmlsdGVycyA/ICcjY29sdW1uc1FCJyA6ICcjdGFibGVRQicpLFxuICAgICAgICB0YWIgPSB0aGlzLnRhYnouZW5hYmxlZFRhYih0YWJRdWVyeUJ1aWxkZXIpLFxuICAgICAgICBmb2xkZXIgPSB0aGlzLnRhYnouZm9sZGVyKHRhYiksXG4gICAgICAgIGlzUXVlcnlCdWlsZGVyID0gdGFiID09PSB0YWJRdWVyeUJ1aWxkZXIsXG4gICAgICAgIGRlZmF1bHRlZE9wdGlvbnMgPSBvcHRpb25zIHx8IHtcbiAgICAgICAgICAgIGFsZXJ0OiB0cnVlLFxuICAgICAgICAgICAgZm9jdXM6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZW5oYW5jZWRPcHRpb25zID0ge1xuICAgICAgICAgICAgYWxlcnQ6IGRlZmF1bHRlZE9wdGlvbnMuYWxlcnQsXG4gICAgICAgICAgICBmb2N1czogZGVmYXVsdGVkT3B0aW9ucy5mb2N1cyAmJiBpc1F1ZXJ5QnVpbGRlclxuICAgICAgICB9LFxuICAgICAgICBlcnJvciwgY3RybDtcblxuICAgIGlmIChpc0NvbHVtbkZpbHRlcnMgfHwgaXNRdWVyeUJ1aWxkZXIpIHtcbiAgICAgICAgZXJyb3IgPSBzdWJ0cmVlLmludmFsaWQoZW5oYW5jZWRPcHRpb25zKTtcbiAgICB9IGVsc2UgeyAvLyB0YWJsZSBmaWx0ZXIgU1FMIHRhYlxuICAgICAgICBjdHJsID0gZm9sZGVyLnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhJyk7XG4gICAgICAgIGVycm9yID0gdGhpcy5maWx0ZXIuc2V0VGFibGVGaWx0ZXJTdGF0ZShjdHJsLnZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3IgJiYgIWlzUXVlcnlCdWlsZGVyKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHZhbGlkYXRpb24gZXJyb3IsIG1vdmUgdGhlIGZvY3VzIGZyb20gdGhlIHF1ZXJ5IGJ1aWxkZXIgY29udHJvbCB0byB0aGUgdGV4dCBib3ggY29udHJvbC5cbiAgICAgICAgaWYgKGlzQ29sdW1uRmlsdGVycykge1xuICAgICAgICAgICAgLy8gV2UncmUgaW4gU1FMIG9yIENRTCB0YWIgc28gZmluZCB0ZXh0IGJveCB0aGF0IGdvZXMgd2l0aCB0aGlzIHN1YmV4cHJlc3Npb24gYW5kIGZvY3VzIG9uIGl0IGluc3RlYWQgb2YgUUIgY29udHJvbC5cbiAgICAgICAgICAgIHZhciBlcnJhbnRDb2x1bW5OYW1lID0gZXJyb3Iubm9kZS5lbC5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykudmFsdWU7XG4gICAgICAgICAgICBjdHJsID0gZm9sZGVyLnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPVwiJyArIGVycmFudENvbHVtbk5hbWUgKyAnXCJdJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3RybCkge1xuICAgICAgICBkZWNvcmF0ZUZpbHRlcklucHV0KGN0cmwsIGVycm9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIGRlY29yYXRlRmlsdGVySW5wdXQoY3RybCwgZXJyb3IpIHtcbiAgICBjdHJsLmNsYXNzTGlzdC50b2dnbGUoJ2ZpbHRlci10cmVlLWVycm9yJywgISFlcnJvcik7XG5cbiAgICBjdHJsLmZvY3VzKCk7XG5cbiAgICAvLyBmaW5kIHRoZSBuZWFyYnkgd2FybmluZyBlbGVtZW50XG4gICAgdmFyIHdhcm5pbmdFbDtcbiAgICBkbyB7XG4gICAgICAgIGN0cmwgPSBjdHJsLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIHdhcm5pbmdFbCA9IGN0cmwucXVlcnlTZWxlY3RvcignLmZpbHRlci10cmVlLXdhcm4nKTtcbiAgICB9IHdoaWxlICghd2FybmluZ0VsKTtcblxuICAgIC8vIHNob3cgb3IgaGlkZSB0aGUgZXJyb3JcbiAgICB3YXJuaW5nRWwuaW5uZXJIVE1MID0gZXJyb3IubWVzc2FnZSB8fCBlcnJvciB8fCAnJztcbn1cblxuZnVuY3Rpb24gb25OZXdDb2x1bW5Nb3VzZURvd24oZXZ0KSB7IC8vIHRvIGJlIGNhbGxlZCB3aXRoIGZpbHRlciBvYmplY3QgYXMgc3ludGF4XG4gICAgaWYgKHNhdmVGb2xkZXIuY2FsbCh0aGlzLCB0aGlzLmZpbHRlci5jb2x1bW5GaWx0ZXJzKSkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsgLy8gZG8gbm90IGRyb3AgZG93blxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIChyZSlidWlsZCB0aGUgZHJvcC1kb3duIGNvbnRlbnRzLCB3aXRoIHNhbWUgcHJvbXB0LCBidXQgZXhjbHVkaW5nIGNvbHVtbnMgd2l0aCBhY3RpdmUgZmlsdGVyIHN1YmV4cHJlc3Npb25zXG4gICAgICAgIHZhciBjdHJsID0gZXZ0LnRhcmdldCxcbiAgICAgICAgICAgIHByb21wdCA9IGN0cmwub3B0aW9uc1swXS50ZXh0LnJlcGxhY2UoJ+KApicsICcnKSwgLy8gdXNlIG9yaWdpbmFsIGJ1dCB3L28gZWxsaXBzaXMgYXMgLmJ1aWxkKCkgYXBwZW5kcyBvbmVcbiAgICAgICAgICAgIGJsYWNrbGlzdCA9IHRoaXMuZmlsdGVyLmNvbHVtbkZpbHRlcnMuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKGNvbHVtbkZpbHRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW5GaWx0ZXIuY2hpbGRyZW4ubGVuZ3RoICYmIGNvbHVtbkZpbHRlci5jaGlsZHJlblswXS5jb2x1bW47XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHQsXG4gICAgICAgICAgICAgICAgYmxhY2tsaXN0OiBibGFja2xpc3RcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcG9wTWVudS5idWlsZChjdHJsLCB0aGlzLmZpbHRlci5yb290LnNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvbk5ld0NvbHVtbkNoYW5nZShldnQpIHtcbiAgICB2YXIgY3RybCA9IGV2dC50YXJnZXQsXG4gICAgICAgIHRhYkNvbHVtblFCID0gdGhpcy50YWJ6LmZvbGRlcignI3RhYmxlUUInKSxcbiAgICAgICAgdGFiID0gdGhpcy50YWJ6LmVuYWJsZWRUYWIodGFiQ29sdW1uUUIucGFyZW50RWxlbWVudCksXG4gICAgICAgIGlzUXVlcnlCdWlsZGVyID0gdGFiID09PSB0YWJDb2x1bW5RQixcbiAgICAgICAgdGFiUHJvcHMgPSB0YWJQcm9wZXJ0aWVzW3RhYi5pZF07XG5cbiAgICB0aGlzLmZpbHRlci5jb2x1bW5GaWx0ZXJzLmFkZCh7XG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICB0eXBlOiAnY29sdW1uRmlsdGVyJyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbIHsgY29sdW1uOiBjdHJsLnZhbHVlIH0gXVxuICAgICAgICB9LFxuICAgICAgICBmb2N1czogaXNRdWVyeUJ1aWxkZXJcbiAgICB9KTtcblxuICAgIGlmICh0YWJQcm9wcy5pc0NvbHVtbkZpbHRlciAmJiB0YWJQcm9wcy5sYW51Z2FnZSkge1xuICAgICAgICByZW5kZXJGb2xkZXIuY2FsbCh0aGlzLCB0YWIpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhbGwgYnV0IHRoZSBwcm9tcHQgb3B0aW9uIChmaXJzdCBjaGlsZClcbiAgICBjdHJsLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgIHdoaWxlIChjdHJsLmxhc3RDaGlsZCAhPT0gY3RybC5maXJzdENoaWxkKSB7XG4gICAgICAgIGN0cmwucmVtb3ZlQ2hpbGQoY3RybC5sYXN0Q2hpbGQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyRm9sZGVyKHRhYikgeyAvLyB0byBiZSBjYWxsZWQgd2l0aCBmaWx0ZXIgb2JqZWN0IGFzIHN5bnRheFxuICAgIHZhciB0YWJQcm9wcyA9IHRhYlByb3BlcnRpZXNbdGFiLmlkXSxcbiAgICAgICAgcXVlcnlMYW5ndWFnZSA9IHRhYlByb3BzLmxhbmd1YWdlO1xuXG4gICAgaWYgKHF1ZXJ5TGFuZ3VhZ2UpIHtcbiAgICAgICAgdmFyIGdsb2JhbEZpbHRlciA9IHRoaXMuZmlsdGVyLFxuICAgICAgICAgICAgZm9sZGVyID0gdGhpcy50YWJ6LmZvbGRlcih0YWIpO1xuXG4gICAgICAgIGlmICh0YWJQcm9wcy5pc1RhYmxlRmlsdGVyKSB7XG5cbiAgICAgICAgICAgIGZvbGRlci5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYScpLnZhbHVlID0gZ2xvYmFsRmlsdGVyLnRhYmxlRmlsdGVyLmdldFN0YXRlKHsgc3ludGF4OiAnU1FMJyB9KTtcblxuICAgICAgICB9IGVsc2UgeyAvLyBjb2x1bW4gZmlsdGVyXG5cbiAgICAgICAgICAgIHZhciBjb2x1bW5GaWx0ZXJzID0gZ2xvYmFsRmlsdGVyLmNvbHVtbkZpbHRlcnMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgZWwgPSBmb2xkZXIubGFzdEVsZW1lbnRDaGlsZCxcbiAgICAgICAgICAgICAgICBtc2dFbCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKSxcbiAgICAgICAgICAgICAgICBsaXN0RWwgPSBlbC5xdWVyeVNlbGVjdG9yKCdvbCcpLFxuICAgICAgICAgICAgICAgIGNvcHlBbGxMaW5rID0gZWwucXVlcnlTZWxlY3RvcignYTpmaXJzdC1vZi10eXBlJyk7XG5cbiAgICAgICAgICAgIG1zZ0VsLmlubmVySFRNTCA9IGFjdGl2ZUZpbHRlcnNNZXNzYWdlKGNvbHVtbkZpbHRlcnMubGVuZ3RoKTtcbiAgICAgICAgICAgIGxpc3RFbC5pbm5lckhUTUwgPSAnJztcblxuICAgICAgICAgICAgLy8gZm9yIGVhY2ggY29sdW1uIGZpbHRlciBzdWJ0cmVlLCBhcHBlbmQgYW4gPGxpPi4uLjwvbGk+IGVsZW1lbnQgY29udGFpbmluZzpcbiAgICAgICAgICAgIC8vIGNvbHVtbiB0aXRsZSwgXCIoY29weSlcIiBsaW5rLCBhbmQgZWRpdGFibGUgdGV4dCBpbnB1dCBib3ggY29udGFpbmluZyB0aGUgc3ViZXhwcmVzc2lvblxuICAgICAgICAgICAgY29sdW1uRmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb25hbCA9IGZpbHRlci5jaGlsZHJlblswXSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGNvbmRpdGlvbmFsLnNjaGVtYVswXSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGNvbmRpdGlvbmFsLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgYWxpYXMgPSBpdGVtLmFsaWFzIHx8IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBmaWx0ZXIuZ2V0U3RhdGUoeyBzeW50YXg6IHF1ZXJ5TGFuZ3VhZ2UgfSksXG4gICAgICAgICAgICAgICAgICAgIGlzTnVsbCA9IGV4cHJlc3Npb24gPT09ICcoTlVMTCBJUyBOVUxMKScgfHwgZXhwcmVzc2lvbiA9PT0gJycsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBpc051bGwgPyAnJyA6IGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGlzTnVsbCA/ICdmaWx0ZXItdHJlZS1lcnJvcicgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgbGkgPSBhdXRvbWF0LmZpcnN0Q2hpbGQobWFya3VwW3F1ZXJ5TGFuZ3VhZ2VdLCBhbGlhcywgbmFtZSwgY29udGVudCwgY2xhc3NOYW1lKTtcblxuICAgICAgICAgICAgICAgIGxpc3RFbC5hcHBlbmRDaGlsZChsaSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZm9sZGVyLm9ua2V5dXAgPSBzZXRDb2x1bW5GaWx0ZXJTdGF0ZS5iaW5kKHRoaXMsIHF1ZXJ5TGFuZ3VhZ2UpO1xuXG4gICAgICAgICAgICBpZiAoY29weUFsbExpbmspIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgXCIoY29weSBhbGwpXCIgbGluaywgaGlkZSBpdCBpZiBvbmx5IDAgb3IgMSBzdWJleHByZXNzaW9uc1xuICAgICAgICAgICAgICAgIGNvcHlBbGxMaW5rLnN0eWxlLmRpc3BsYXkgPSBjb2x1bW5GaWx0ZXJzLmxlbmd0aCA+IDEgPyAnYmxvY2snIDogJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG59XG5cbi8vdmFyIFJFVFVSTl9LRVkgPSAweDBkLCBFU0NBUEVfS0VZID0gMHgxYjtcbi8qKlxuICogQ2FsbGVkIGZyb20ga2V5LXVwIGV2ZW50cyBmcm9tIGAjY29sdW1uU1FMYCBhbmQgYCNjb2x1bW5DUUxgIHRhYnMuXG4gKiBAdGhpcyBGaWx0ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeUxhbmd1YWdlXG4gKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2dFxuICovXG5mdW5jdGlvbiBzZXRDb2x1bW5GaWx0ZXJTdGF0ZShxdWVyeUxhbmd1YWdlLCBldnQpIHtcbiAgICB2YXIgY3RybCA9IGV2dC50YXJnZXQ7XG5cbiAgICAvLyBPbmx5IGhhbmRsZSBpZiBrZXkgd2FzIHByZXNzZWQgaW5zaWRlIGEgdGV4dCBib3guXG4gICAgaWYgKGN0cmwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmaWx0ZXItdGV4dC1ib3gnKSkge1xuICAgICAgICAvL3N3aXRjaCAoZXZ0LmtleUNvZGUpIHtcbiAgICAgICAgLy8gICAgY2FzZSBFU0NBUEVfS0VZOlxuICAgICAgICAvLyAgICAgICAgY3RybC52YWx1ZSA9IG9sZEFyZztcbiAgICAgICAgLy8gICAgY2FzZSBSRVRVUk5fS0VZOiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgIC8vICAgICAgICBjdHJsLmJsdXIoKTtcbiAgICAgICAgLy8gICAgICAgIGJyZWFrO1xuICAgICAgICAvLyAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgZXJyb3IsXG4gICAgICAgICAgICBvcHRpb25zID0geyBzeW50YXg6IHF1ZXJ5TGFuZ3VhZ2UsIGFsZXJ0OiB0cnVlIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVycm9yID0gdGhpcy5maWx0ZXIuc2V0Q29sdW1uRmlsdGVyU3RhdGUoY3RybC5uYW1lLCBjdHJsLnZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29yYXRlRmlsdGVySW5wdXQoY3RybCwgZXJyb3IpO1xuICAgICAgICAvL31cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFjdGl2ZUZpbHRlcnNNZXNzYWdlKG4pIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgc3dpdGNoIChuKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJlc3VsdCA9ICdUaGVyZSBhcmUgbm8gYWN0aXZlIGNvbHVtbiBmaWx0ZXJzLic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmVzdWx0ID0gJ1RoZXJlIGlzIDEgYWN0aXZlIGNvbHVtbiBmaWx0ZXI6JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVzdWx0ID0gJ1RoZXJlIGFyZSAnICsgbiArICcgYWN0aXZlIGNvbHVtbiBmaWx0ZXJzOic7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hbmFnZUZpbHRlcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzLkNvbHVtblBpY2tlciA9IHJlcXVpcmUoJy4vQ29sdW1uUGlja2VyJyk7XG5tb2R1bGUuZXhwb3J0cy5NYW5hZ2VGaWx0ZXJzID0gcmVxdWlyZSgnLi9NYW5hZ2VGaWx0ZXJzJyk7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBOT1RFXG4gKlxuICogV2hhdCB0aGlzIGZpbGUgaXM6XG4gKiAqIFRoaXMgZmlsZSBpcyBicm93c2VyaWZ5J3MgZW50cnkgcG9pbnQuXG4gKiAqIFRoaXMgZmlsZSBjcmVhdGVzIHRoZSBgd2luZG93LmZpbi5IeXBlcmdyaWRgIG9iamVjdC5cbiAqXG4gKiBXaGF0IHRoaXMgZmlsZSBpcyBub3Q6XG4gKiAqIFRoaXMgZmlsZSBpcyBub3QgYSBub2RlIG1vZHVsZTsgaXQgaGFzIG5vIHJlZmVyZW5jZSB0byBgbW9kdWxlLmV4cG9ydHNgIG9yIGBleHBvcnRzYDsgaXQgY2Fubm90IGJlIFwicmVxdWlyZWRcIiBieSBhbnkgb3RoZXIgZmlsZS5cbiAqICogVGhpcyBmaWxlIGlzIGJsYWNrbGlzdGVkIGluIC5ucG1pZ25vcmUgYW5kIGlzIG5vdCBwdWJsaXNoZWQgdG8gbnBtLlxuICpcbiAqIE5vdGU6IFRoZSBucG0gXCJtYWluXCIgZW50cnkgcG9pbnQgKGFzIG5vdGVkIGluIHBhY2thZ2UuanNvbikgaXMgc3JjL0h5cGVyZ3JpZC5qcy5cbiAqL1xuXG52YXIgSHlwZXJncmlkID0gcmVxdWlyZSgnLi9IeXBlcmdyaWQnKTtcblxuLy8gRXhwb3NlIHNvbWUgbmFtZXNwYWNlcyB0byB1c2VycyBvZiB0aGUgaHlwZXJncmlkLmpzIGZpbGUgdGhyb3VnaCBgZmluLkh5cGVyZ3JpZGA6XG5IeXBlcmdyaWQuSlNPTiA9IHJlcXVpcmUoJy4vbGliL2pzb24nKTtcbkh5cGVyZ3JpZC5pbWFnZXMgPSByZXF1aXJlKCcuLi9pbWFnZXMnKTtcbkh5cGVyZ3JpZC5iZWhhdmlvcnMgPSByZXF1aXJlKCcuL2JlaGF2aW9ycycpO1xuSHlwZXJncmlkLmZlYXR1cmVzID0gcmVxdWlyZSgnLi9mZWF0dXJlcycpO1xuSHlwZXJncmlkLmFuYWx5dGljcyA9IHJlcXVpcmUoJy4vU2hhcmVkLmpzJykuYW5hbHl0aWNzO1xuSHlwZXJncmlkLkRlZmF1bHRGaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlci9EZWZhdWx0RmlsdGVyJyk7XG5IeXBlcmdyaWQuQ29sdW1uU2NoZW1hRmFjdG9yeSA9IHJlcXVpcmUoJy4vZmlsdGVyL0NvbHVtblNjaGVtYUZhY3RvcnknKTtcbkh5cGVyZ3JpZC5GaWx0ZXJUcmVlID0gcmVxdWlyZSgnLi9TaGFyZWQnKS5GaWx0ZXJUcmVlO1xuSHlwZXJncmlkLnJlY3Rhbmd1bGFyID0gcmVxdWlyZSgncmVjdGFuZ3VsYXInKTtcblxuLy8gQ3JlYXRlIHRoZSBgZmluYCBhbmQgaW4gcGFydGljdWxhciB0aGUgYGZpbi5IeXBlcmdyaWRgIG9iamVjdHM6XG4od2luZG93LmZpbiA9IHdpbmRvdy5maW4gfHwge30pLkh5cGVyZ3JpZCA9IEh5cGVyZ3JpZDtcblxuLy8gTm90ZSB0aGF0IHdoaWxlIHVzZXJzIG9mIHRoZSBucG0gbW9kdWxlIGNhbiBhbHNvIGFjY2VzcyB0aGUgYWJvdmUgbmFtZXNwYWNlcyB0aHJvdWdoIHRoZSBIeXBlcmdyaWQgb2JqZWN0LCBpbiByZWFsaXR5IHRoZXkgYWxzbyBoYXZlIGFjY2VzcyB0byBhbnkgbmFtZXNwYWNlIHRocm91Z2ggYHJlcXVpcmVgLCBmb3IgZXhhbXBsZTpcbi8vIHZhciBiZWhhdmlvckpTT04gPSByZXF1aXJlKCdmaW4taHlwZXJncmlkL3NyYy9iZWhhdmlvcnMvSlNPTicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ2VsbENsaWNrID0gRmVhdHVyZS5leHRlbmQoJ0NlbGxDbGljaycsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsQ2xpY2sucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZXZlbnQuZ3JpZENlbGwueSA+PSBncmlkLmJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCkgJiZcbiAgICAgICAgICAgIGV2ZW50LmdyaWRDZWxsLnggPj0gZ3JpZC5iZWhhdmlvci5nZXRIZWFkZXJDb2x1bW5Db3VudCgpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZ3JpZC5jZWxsQ2xpY2tlZChldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VsbENsaWNrO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xudmFyIENlbGxFZGl0b3IgPSByZXF1aXJlKCcuLi9jZWxsRWRpdG9ycy9DZWxsRWRpdG9yJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDZWxsRWRpdGluZyA9IEZlYXR1cmUuZXh0ZW5kKCdDZWxsRWRpdGluZycsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdGluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZURvdWJsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNEb3VibGVDbGlja0VkaXRvckFjdGl2YXRpb24gPSBncmlkLnJlc29sdmVQcm9wZXJ0eSgnZWRpdE9uRG91YmxlQ2xpY2snKTtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tBY3RpdmF0ZUVkaXRvcihncmlkLCBldmVudCwgaXNEb3VibGVDbGlja0VkaXRvckFjdGl2YXRpb24pKSB7XG4gICAgICAgICAgICBncmlkLm9uRWRpdG9yQWN0aXZhdGUoZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzRG91YmxlQ2xpY2tFZGl0b3JBY3RpdmF0aW9uID0gZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ2VkaXRPbkRvdWJsZUNsaWNrJyk7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQWN0aXZhdGVFZGl0b3IoZ3JpZCwgZXZlbnQsICFpc0RvdWJsZUNsaWNrRWRpdG9yQWN0aXZhdGlvbikpIHtcbiAgICAgICAgICAgIGdyaWQub25FZGl0b3JBY3RpdmF0ZShldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNoZWNrQWN0aXZhdGVFZGl0b3I6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50LCBpc0RvdWJsZUNsaWNrRWRpdG9yQWN0aXZhdGlvbikge1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBncmlkLmJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBoZWFkZXJDb2x1bW5Db3VudCA9IGdyaWQuYmVoYXZpb3IuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIHZhciBpc0ZpbHRlclJvdyA9IGdyaWQuaXNGaWx0ZXJSb3coZ3JpZENlbGwueSk7XG5cbiAgICAgICAgcmV0dXJuIGlzRG91YmxlQ2xpY2tFZGl0b3JBY3RpdmF0aW9uICYmXG4gICAgICAgICAgICBncmlkQ2VsbC54ID49IGhlYWRlckNvbHVtbkNvdW50ICYmXG4gICAgICAgICAgICAoaXNGaWx0ZXJSb3cgfHwgZ3JpZENlbGwueSA+PSBoZWFkZXJSb3dDb3VudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBtZW1iZXJPZiBLZXlQYWdpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGNoYXIsIGlzVmlzaWJsZUNoYXIsIGlzRGVsZXRlQ2hhciwgY3VycmVudENlbGwsIGVkaXRvcjtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBncmlkLnJlc29sdmVQcm9wZXJ0eSgnZWRpdE9uS2V5ZG93bicpICYmXG4gICAgICAgICAgICAhZ3JpZC5jZWxsRWRpdG9yICYmXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgKGNoYXIgPSBldmVudC5kZXRhaWwuY2hhcikgPT09ICdGMicgfHxcbiAgICAgICAgICAgICAgICAoaXNWaXNpYmxlQ2hhciA9IGNoYXIubGVuZ3RoID09PSAxICYmICEoZXZlbnQuZGV0YWlsLm1ldGEgfHwgZXZlbnQuZGV0YWlsLmN0cmwpKSB8fFxuICAgICAgICAgICAgICAgIChpc0RlbGV0ZUNoYXIgPSBjaGFyID09PSAnREVMRVRFJyB8fCBjaGFyID09PSAnQkFDS1NQQUNFJylcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjdXJyZW50Q2VsbCA9IGdyaWQuc2VsZWN0aW9uTW9kZWwuZ2V0TGFzdFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDZWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBzZXVkb0V2ZW50ID0geyBncmlkQ2VsbDogY3VycmVudENlbGwub3JpZ2luIH07XG4gICAgICAgICAgICAgICAgZWRpdG9yID0gZ3JpZC5vbkVkaXRvckFjdGl2YXRlKHBzZXVkb0V2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yIGluc3RhbmNlb2YgQ2VsbEVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWaXNpYmxlQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldEVkaXRvclZhbHVlKGNoYXIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzRGVsZXRlQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldEVkaXRvclZhbHVlKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBldmVudC5kZXRhaWwucHJpbWl0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlS2V5RG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENlbGxFZGl0aW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ2VsbFNlbGVjdGlvbiA9IEZlYXR1cmUuZXh0ZW5kKCdDZWxsU2VsZWN0aW9uJywge1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fVxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGN1cnJlbnREcmFnOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGNlbGwgY29vcmRpbmF0ZXMgb2YgdGhlIHdoZXJlIHRoZSBtb3VzZSBwb2ludGVyIGlzIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBsYXN0RHJhZ0NlbGw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBhIG1pbGxpc2Vjb25kIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgcHJldmlvdXMgdGltZSBhbiBhdXRvc2Nyb2xsIHN0YXJ0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkxhc3RBdXRvOiAwLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHRpbWUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JBdXRvU3RhcnQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc1JpZ2h0Q2xpY2sgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuaXNSaWdodENsaWNrO1xuICAgICAgICB2YXIgY2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB2YXIgdmlld0NlbGwgPSBldmVudC52aWV3UG9pbnQ7XG4gICAgICAgIHZhciBkeCA9IGNlbGwueDtcbiAgICAgICAgdmFyIGR5ID0gY2VsbC55O1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBncmlkLmJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBoZWFkZXJDb2x1bW5Db3VudCA9IGdyaWQuYmVoYXZpb3IuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgaXNPdXRzaWRlID0gdmlld0NlbGwueCA+PSBjb2x1bW5Db3VudDtcblxuICAgICAgICB2YXIgaXNIZWFkZXIgPSBkeSA8IGhlYWRlclJvd0NvdW50IHx8IGR4IDwgaGVhZGVyQ29sdW1uQ291bnQ7XG5cbiAgICAgICAgaWYgKCFncmlkLmlzQ2VsbFNlbGVjdGlvbigpIHx8IGlzUmlnaHRDbGljayB8fCBpc0hlYWRlciB8fCBpc091dHNpZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICAgICAgLy9pZiB3ZSBhcmUgaW4gdGhlIGZpeGVkIGFyZWEgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAvL2NoZWNrIGJvdGggeCBhbmQgeSB2YWx1ZXMgaW5kZXBlbmRlbnRseVxuICAgICAgICAgICAgaWYgKHZpZXdDZWxsLnggPCBudW1GaXhlZENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICBkeCA9IHZpZXdDZWxsLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2aWV3Q2VsbC55IDwgbnVtRml4ZWRSb3dzKSB7XG4gICAgICAgICAgICAgICAgZHkgPSB2aWV3Q2VsbC55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZENlbGwgPSBncmlkLm5ld1BvaW50KGR4LCBkeSk7XG5cbiAgICAgICAgICAgIHZhciBwcmltRXZlbnQgPSBldmVudC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHZhciBrZXlzID0gcHJpbUV2ZW50LmRldGFpbC5rZXlzO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV4dGVuZFNlbGVjdGlvbihncmlkLCBkQ2VsbCwga2V5cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNSaWdodENsaWNrID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljaztcblxuICAgICAgICBpZiAoIWdyaWQuaXNDZWxsU2VsZWN0aW9uKCkgfHwgaXNSaWdodENsaWNrIHx8ICF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICAgICAgdmFyIGNlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgICAgIHZhciB2aWV3Q2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgICAgIHZhciBkeCA9IGNlbGwueDtcbiAgICAgICAgICAgIHZhciBkeSA9IGNlbGwueTtcblxuICAgICAgICAgICAgLy9pZiB3ZSBhcmUgaW4gdGhlIGZpeGVkIGFyZWEgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAvL2NoZWNrIGJvdGggeCBhbmQgeSB2YWx1ZXMgaW5kZXBlbmRlbnRseVxuICAgICAgICAgICAgaWYgKHZpZXdDZWxsLnggPCBudW1GaXhlZENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICBkeCA9IHZpZXdDZWxsLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2aWV3Q2VsbC55IDwgbnVtRml4ZWRSb3dzKSB7XG4gICAgICAgICAgICAgICAgZHkgPSB2aWV3Q2VsbC55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZENlbGwgPSBncmlkLm5ld1BvaW50KGR4LCBkeSk7XG5cbiAgICAgICAgICAgIHZhciBwcmltRXZlbnQgPSBldmVudC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyYWcgPSBwcmltRXZlbnQuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdGhpcy5sYXN0RHJhZ0NlbGwgPSBkQ2VsbDtcblxuICAgICAgICAgICAgdGhpcy5jaGVja0RyYWdTY3JvbGwoZ3JpZCwgdGhpcy5jdXJyZW50RHJhZyk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb24oZ3JpZCwgZENlbGwsIHByaW1FdmVudC5kZXRhaWwua2V5cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGhhbmRsZXI7XG4gICAgICAgIGlmICgoaGFuZGxlciA9IHRoaXNbJ2hhbmRsZScgKyBldmVudC5kZXRhaWwuY2hhcl0pKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgZ3JpZCwgZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgYSBtb3VzZWRyYWcgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIGdyaWRDZWxsLCBrZXlzKSB7XG5cbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gZ3JpZC5iZWhhdmlvci5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgaGVhZGVyQ29sdW1uQ291bnQgPSBncmlkLmJlaGF2aW9yLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciB4ID0gZ3JpZENlbGwueDtcbiAgICAgICAgdmFyIHkgPSBncmlkQ2VsbC55O1xuICAgICAgICB4ID0gTWF0aC5tYXgoaGVhZGVyQ29sdW1uQ291bnQsIHgpO1xuICAgICAgICB5ID0gTWF0aC5tYXgoaGVhZGVyUm93Q291bnQsIHkpO1xuXG4gICAgICAgIHZhciBwcmV2aW91c0RyYWdFeHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKTtcbiAgICAgICAgdmFyIG1vdXNlRG93biA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG5cbiAgICAgICAgLy92YXIgc2Nyb2xsaW5nTm93ID0gZ3JpZC5pc1Njcm9sbGluZ05vdygpO1xuXG4gICAgICAgIHZhciBuZXdYID0geCAtIG1vdXNlRG93bi54O1xuICAgICAgICB2YXIgbmV3WSA9IHkgLSBtb3VzZURvd24ueTtcblxuICAgICAgICBpZiAocHJldmlvdXNEcmFnRXh0ZW50LnggPT09IG5ld1ggJiYgcHJldmlvdXNEcmFnRXh0ZW50LnkgPT09IG5ld1kpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgZ3JpZC5zZWxlY3QobW91c2VEb3duLngsIG1vdXNlRG93bi55LCBuZXdYLCBuZXdZKTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQobmV3WCwgbmV3WSkpO1xuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGNoZWNrcyB3aGlsZSB3ZXJlIGRyYWdnaW5nIGlmIHdlIGdvIG91dHNpZGUgdGhlIHZpc2libGUgYm91bmRzLCBpZiBzbywga2ljayBvZmYgdGhlIGV4dGVybmFsIGF1dG9zY3JvbGwgY2hlY2sgZnVuY3Rpb24gKGFib3ZlKVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBjaGVja0RyYWdTY3JvbGw6IGZ1bmN0aW9uKGdyaWQsIG1vdXNlKSB7XG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiID0gZ3JpZC5nZXREYXRhQm91bmRzKCk7XG4gICAgICAgIHZhciBpbnNpZGUgPSBiLmNvbnRhaW5zKG1vdXNlKTtcbiAgICAgICAgaWYgKGluc2lkZSkge1xuICAgICAgICAgICAgaWYgKGdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgICAgIGdyaWQuc2V0U2Nyb2xsaW5nTm93KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRHJhZyhncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCB3aGlsZSB3ZSBhcmUgZHJhZ2dpbmcgb3V0c2lkZSBvZiB0aGUgZ3JpZCB2aXNpYmxlIGJvdW5kcywgd2Ugc3Jjcm9sbCBhY2NvcmRpbmdseVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2Nyb2xsRHJhZzogZnVuY3Rpb24oZ3JpZCkge1xuXG4gICAgICAgIGlmICghZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHJhZ1N0YXJ0ZWRJbkhlYWRlckFyZWEgPSBncmlkLmlzTW91c2VEb3duSW5IZWFkZXJBcmVhKCk7XG4gICAgICAgIHZhciBsYXN0RHJhZ0NlbGwgPSB0aGlzLmxhc3REcmFnQ2VsbDtcbiAgICAgICAgdmFyIGIgPSBncmlkLmdldERhdGFCb3VuZHMoKTtcbiAgICAgICAgdmFyIHhPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgeU9mZnNldCA9IDA7XG5cbiAgICAgICAgdmFyIG51bUZpeGVkQ29sdW1ucyA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgbnVtRml4ZWRSb3dzID0gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgdmFyIGRyYWdFbmRJbkZpeGVkQXJlYVggPSBsYXN0RHJhZ0NlbGwueCA8IG51bUZpeGVkQ29sdW1ucztcbiAgICAgICAgdmFyIGRyYWdFbmRJbkZpeGVkQXJlYVkgPSBsYXN0RHJhZ0NlbGwueSA8IG51bUZpeGVkUm93cztcblxuICAgICAgICBpZiAoIWRyYWdTdGFydGVkSW5IZWFkZXJBcmVhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy54IDwgYi5vcmlnaW4ueCkge1xuICAgICAgICAgICAgICAgIHhPZmZzZXQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnkgPCBiLm9yaWdpbi55KSB7XG4gICAgICAgICAgICAgICAgeU9mZnNldCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnggPiBiLm9yaWdpbi54ICsgYi5leHRlbnQueCkge1xuICAgICAgICAgICAgeE9mZnNldCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueSA+IGIub3JpZ2luLnkgKyBiLmV4dGVudC55KSB7XG4gICAgICAgICAgICB5T2Zmc2V0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcmFnQ2VsbE9mZnNldFggPSB4T2Zmc2V0O1xuICAgICAgICB2YXIgZHJhZ0NlbGxPZmZzZXRZID0geU9mZnNldDtcblxuICAgICAgICBpZiAoZHJhZ0VuZEluRml4ZWRBcmVhWCkge1xuICAgICAgICAgICAgZHJhZ0NlbGxPZmZzZXRYID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmFnRW5kSW5GaXhlZEFyZWFZKSB7XG4gICAgICAgICAgICBkcmFnQ2VsbE9mZnNldFkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0RHJhZ0NlbGwgPSBsYXN0RHJhZ0NlbGwucGx1c1hZKGRyYWdDZWxsT2Zmc2V0WCwgZHJhZ0NlbGxPZmZzZXRZKTtcbiAgICAgICAgZ3JpZC5zY3JvbGxCeSh4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uKGdyaWQsIGxhc3REcmFnQ2VsbCwgW10pOyAvLyB1cGRhdGUgdGhlIHNlbGVjdGlvblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnNjcm9sbERyYWcuYmluZCh0aGlzLCBncmlkKSwgMjUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBleHRlbmQgYSBzZWxlY3Rpb24gb3IgY3JlYXRlIG9uZSBpZiB0aGVyZSBpc250IHlldFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyaWRDZWxsIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGV4dGVuZFNlbGVjdGlvbjogZnVuY3Rpb24oZ3JpZCwgZ3JpZENlbGwsIGtleXMpIHtcbiAgICAgICAgdmFyIGhhc0NUUkwgPSBrZXlzLmluZGV4T2YoJ0NUUkwnKSA+PSAwO1xuICAgICAgICB2YXIgaGFzU0hJRlQgPSBrZXlzLmluZGV4T2YoJ1NISUZUJykgPj0gMDtcbiAgICAgICAgLy8gdmFyIHNjcm9sbFRvcCA9IGdyaWQuZ2V0VlNjcm9sbFZhbHVlKCk7XG4gICAgICAgIC8vIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcblxuICAgICAgICAvLyB2YXIgbnVtRml4ZWRDb2x1bW5zID0gMDsvL2dyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICAvLyB2YXIgbnVtRml4ZWRSb3dzID0gMDsvL2dyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgIHZhciBtb3VzZVBvaW50ID0gZ3JpZC5nZXRNb3VzZURvd24oKTtcbiAgICAgICAgdmFyIHggPSBncmlkQ2VsbC54OyAvLyAtIG51bUZpeGVkQ29sdW1ucyArIHNjcm9sbExlZnQ7XG4gICAgICAgIHZhciB5ID0gZ3JpZENlbGwueTsgLy8gLSBudW1GaXhlZFJvd3MgKyBzY3JvbGxUb3A7XG5cbiAgICAgICAgLy93ZXJlIG91dHNpZGUgb2YgdGhlIGdyaWQgZG8gbm90aGluZ1xuICAgICAgICBpZiAoeCA8IDAgfHwgeSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vd2UgaGF2ZSByZXBlYXRlZCBhIGNsaWNrIGluIHRoZSBzYW1lIHNwb3QgZGVzbGVjdCB0aGUgdmFsdWUgZnJvbSBsYXN0IHRpbWVcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaGFzQ1RSTCAmJlxuICAgICAgICAgICAgeCA9PT0gbW91c2VQb2ludC54ICYmXG4gICAgICAgICAgICB5ID09PSBtb3VzZVBvaW50LnlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgZ3JpZC5wb3BNb3VzZURvd24oKTtcbiAgICAgICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXNDVFJMICYmICFoYXNTSElGVCkge1xuICAgICAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNTSElGVCkge1xuICAgICAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGdyaWQuc2VsZWN0KG1vdXNlUG9pbnQueCwgbW91c2VQb2ludC55LCB4IC0gbW91c2VQb2ludC54ICsgMSwgeSAtIG1vdXNlUG9pbnQueSArIDEpO1xuICAgICAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoeCAtIG1vdXNlUG9pbnQueCArIDEsIHkgLSBtb3VzZVBvaW50LnkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyaWQuc2VsZWN0KHgsIHksIDAsIDApO1xuICAgICAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludCh4LCB5KSk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGhhbmRsZURPV05TSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAwLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVVBTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAwLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlRTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAtMSwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgMSwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZURPV046IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIC8va2VlcCB0aGUgYnJvd3NlciB2aWV3cG9ydCBmcm9tIGF1dG8gc2Nyb2xsaW5nIG9uIGtleSBldmVudFxuICAgICAgICBldmVudC5wcmltaXRpdmVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuZ2V0QXV0b1Njcm9sbEFjY2VsZXJhdGlvbigpO1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgMCwgY291bnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVVUDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgLy9rZWVwIHRoZSBicm93c2VyIHZpZXdwb3J0IGZyb20gYXV0byBzY3JvbGxpbmcgb24ga2V5IGV2ZW50XG4gICAgICAgIGV2ZW50LnByaW1pdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5nZXRBdXRvU2Nyb2xsQWNjZWxlcmF0aW9uKCk7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAwLCAtY291bnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVMRUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAtMSwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAxLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSWYgd2UgYXJlIGhvbGRpbmcgZG93biB0aGUgc2FtZSBuYXZpZ2F0aW9uIGtleSwgYWNjZWxlcmF0ZSB0aGUgaW5jcmVtZW50IHdlIHNjcm9sbFxuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxBY2NlbGVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY291bnQgPSAxO1xuICAgICAgICB2YXIgZWxhcHNlZCA9IHRoaXMuZ2V0QXV0b1Njcm9sbER1cmF0aW9uKCkgLyAyMDAwO1xuICAgICAgICBjb3VudCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkICogZWxhcHNlZCkpO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgc3RhcnQgdGltZSB0byByaWdodCBub3cgd2hlbiB3ZSBpbml0aWF0ZSBhbiBhdXRvIHNjcm9sbFxuICAgICAqL1xuICAgIHNldEF1dG9TY3JvbGxTdGFydFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNiQXV0b1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXBkYXRlIHRoZSBhdXRvc2Nyb2xsIHN0YXJ0IHRpbWUgaWYgd2UgaGF2ZW4ndCBhdXRvc2Nyb2xsZWQgd2l0aGluIHRoZSBsYXN0IDUwMG1zIG90aGVyd2lzZSB1cGRhdGUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCB0aW1lXG4gICAgICovXG4gICAgcGluZ0F1dG9TY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyAtIHRoaXMuc2JMYXN0QXV0byA+IDUwMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdXRvU2Nyb2xsU3RhcnRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zYkxhc3RBdXRvID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgYW5zd2VyIGhvdyBsb25nIHdlIGhhdmUgYmVlbiBhdXRvIHNjcm9sbGluZ1xuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxEdXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMuc2JBdXRvU3RhcnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEF1Z21lbnQgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiBleHRlbnQgYnkgKG9mZnNldFgsb2Zmc2V0WSkgYW5kIHNjcm9sbCBpZiBuZWNlc3NhcnkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICovXG4gICAgbW92ZVNoaWZ0U2VsZWN0OiBmdW5jdGlvbihncmlkLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG5cbiAgICAgICAgdmFyIG1heENvbHVtbnMgPSBncmlkLmdldENvbHVtbkNvdW50KCkgLSAxO1xuICAgICAgICB2YXIgbWF4Um93cyA9IGdyaWQuZ2V0Um93Q291bnQoKSAtIDE7XG5cbiAgICAgICAgdmFyIG1heFZpZXdhYmxlQ29sdW1ucyA9IGdyaWQuZ2V0VmlzaWJsZUNvbHVtbnMoKSAtIDE7XG4gICAgICAgIHZhciBtYXhWaWV3YWJsZVJvd3MgPSBncmlkLmdldFZpc2libGVSb3dzKCkgLSAxO1xuXG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgbWF4Q29sdW1ucyA9IE1hdGgubWluKG1heENvbHVtbnMsIG1heFZpZXdhYmxlQ29sdW1ucyk7XG4gICAgICAgICAgICBtYXhSb3dzID0gTWF0aC5taW4obWF4Um93cywgbWF4Vmlld2FibGVSb3dzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcmlnaW4gPSBncmlkLmdldE1vdXNlRG93bigpO1xuICAgICAgICB2YXIgZXh0ZW50ID0gZ3JpZC5nZXREcmFnRXh0ZW50KCk7XG5cbiAgICAgICAgdmFyIG5ld1ggPSBleHRlbnQueCArIG9mZnNldFg7XG4gICAgICAgIHZhciBuZXdZID0gZXh0ZW50LnkgKyBvZmZzZXRZO1xuXG4gICAgICAgIG5ld1ggPSBNYXRoLm1pbihtYXhDb2x1bW5zIC0gb3JpZ2luLngsIE1hdGgubWF4KC1vcmlnaW4ueCwgbmV3WCkpO1xuICAgICAgICBuZXdZID0gTWF0aC5taW4obWF4Um93cyAtIG9yaWdpbi55LCBNYXRoLm1heCgtb3JpZ2luLnksIG5ld1kpKTtcblxuICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuICAgICAgICBncmlkLnNlbGVjdChvcmlnaW4ueCwgb3JpZ2luLnksIG5ld1gsIG5ld1kpO1xuXG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KG5ld1gsIG5ld1kpKTtcblxuICAgICAgICBpZiAoZ3JpZC5pbnN1cmVNb2RlbENvbElzVmlzaWJsZShuZXdYICsgb3JpZ2luLngsIG9mZnNldFgpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxSb3dJc1Zpc2libGUobmV3WSArIG9yaWdpbi55LCBvZmZzZXRZKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVwbGFjZSB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIHdpdGggYSBzaW5nbGUgY2VsbCBzZWxlY3Rpb24gdGhhdCBpcyBtb3ZlZCAob2Zmc2V0WCxvZmZzZXRZKSBmcm9tIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gZXh0ZW50LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqL1xuICAgIG1vdmVTaW5nbGVTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFgsIG9mZnNldFkpIHtcblxuICAgICAgICB2YXIgbWF4Q29sdW1ucyA9IGdyaWQuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG4gICAgICAgIHZhciBtYXhSb3dzID0gZ3JpZC5nZXRSb3dDb3VudCgpIC0gMTtcblxuICAgICAgICB2YXIgbWF4Vmlld2FibGVDb2x1bW5zID0gZ3JpZC5nZXRWaXNpYmxlQ29sdW1uc0NvdW50KCkgLSAxO1xuICAgICAgICB2YXIgbWF4Vmlld2FibGVSb3dzID0gZ3JpZC5nZXRWaXNpYmxlUm93c0NvdW50KCkgLSAxO1xuXG4gICAgICAgIHZhciBtaW5Sb3dzID0gZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgbWluQ29scyA9IGdyaWQuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcblxuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBtYXhWaWV3YWJsZUNvbHVtbnMpO1xuICAgICAgICAgICAgbWF4Um93cyA9IE1hdGgubWluKG1heFJvd3MsIG1heFZpZXdhYmxlUm93cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW91c2VDb3JuZXIgPSBncmlkLmdldE1vdXNlRG93bigpLnBsdXMoZ3JpZC5nZXREcmFnRXh0ZW50KCkpO1xuXG4gICAgICAgIHZhciBuZXdYID0gbW91c2VDb3JuZXIueCArIG9mZnNldFg7XG4gICAgICAgIHZhciBuZXdZID0gbW91c2VDb3JuZXIueSArIG9mZnNldFk7XG5cbiAgICAgICAgbmV3WCA9IE1hdGgubWluKG1heENvbHVtbnMsIE1hdGgubWF4KG1pbkNvbHMsIG5ld1gpKTtcbiAgICAgICAgbmV3WSA9IE1hdGgubWluKG1heFJvd3MsIE1hdGgubWF4KG1pblJvd3MsIG5ld1kpKTtcblxuICAgICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICBncmlkLnNlbGVjdChuZXdYLCBuZXdZLCAwLCAwKTtcbiAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludChuZXdYLCBuZXdZKSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcblxuICAgICAgICBncmlkLnNlbGVjdENlbGxBbmRTY3JvbGxUb01ha2VWaXNpYmxlKG5ld1gsIG5ld1kpO1xuXG4gICAgICAgIC8vIGlmIChncmlkLmluc3VyZU1vZGVsQ29sSXNWaXNpYmxlKG5ld1gsIG9mZnNldFgpKSB7XG4gICAgICAgIC8vICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYgKGdyaWQuaW5zdXJlTW9kZWxSb3dJc1Zpc2libGUobmV3WSwgb2Zmc2V0WSkpIHtcbiAgICAgICAgLy8gICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsU2VsZWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29sdW1uQXV0b3NpemluZyA9IEZlYXR1cmUuZXh0ZW5kKCdDb2x1bW5BdXRvc2l6aW5nJywge1xuXG4gICAgLyoqXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uQXV0b3NpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICAvL3ZhciBoZWFkZXJDb2xDb3VudCA9IGdyaWQuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIGlmIChncmlkQ2VsbC55IDw9IGhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICBncmlkLmF1dG9zaXplQ29sdW1uKGdyaWRDZWxsLngpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uQXV0b3NpemluZztcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyogZ2xvYmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmVhdHVyZSBpcyByZXNwb25zaWJsZSBmb3IgY29sdW1uIGRyYWcgYW5kIGRyb3AgcmVvcmRlcmluZy5cbi8vIFRoaXMgb2JqZWN0IGlzIGEgbWVzcyBhbmQgZGVzcGVyYXRlbHkgbmVlZHMgYSBjb21wbGV0ZSByZXdyaXRlLi4uLi5cblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxudmFyIGNvbHVtbkFuaW1hdGlvblRpbWUgPSAxNTA7XG52YXIgZHJhZ2dlcjtcbnZhciBkcmFnZ2VyQ1RYO1xudmFyIGZsb2F0Q29sdW1uO1xudmFyIGZsb2F0Q29sdW1uQ1RYO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29sdW1uTW92aW5nID0gRmVhdHVyZS5leHRlbmQoJ0NvbHVtbk1vdmluZycsIHtcblxuICAgIC8qKlxuICAgICAqIHF1ZXVlIHVwIHRoZSBhbmltYXRpb25zIHRoYXQgbmVlZCB0byBwbGF5IHNvIHRoZXkgYXJlIGRvbmUgc3luY2hyb25vdXNseVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmbG9hdGVyQW5pbWF0aW9uUXVldWU6IFtdLFxuXG4gICAgLyoqXG4gICAgICogYW0gSSBjdXJyZW50bHkgYXV0byBzY3JvbGxpbmcgcmlnaHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGFtIEkgY3VycmVudGx5IGF1dG8gc2Nyb2xsaW5nIGxlZnRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogaXMgdGhlIGRyYWcgbWVjaGFuaXNtIGN1cnJlbnRseSBlbmFibGVkIChcImFybWVkXCIpXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ0FybWVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGFtIEkgZHJhZ2dpbmcgcmlnaHQgbm93XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGNvbHVtbiBpbmRleCBvZiB0aGUgY3VycmVudGx5IGRyYWdnZWQgY29sdW1uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnQ29sOiAtMSxcblxuICAgIC8qKlxuICAgICAqIGFuIG9mZnNldCB0byBwb3NpdGlvbiB0aGUgZHJhZ2dlZCBpdGVtIGZyb20gdGhlIGN1cnNvclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ09mZnNldDogMCxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdpdmUgbWUgYW4gb3Bwb3J0dW5pdHkgdG8gaW5pdGlhbGl6ZSBzdHVmZiBvbiB0aGUgZ3JpZFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZU9uOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuaXNGbG9hdGluZ05vdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVBbmltYXRpb25TdXBwb3J0KGdyaWQpO1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaW5pdGlhbGl6ZU9uKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGluaXRpYWxpemUgYW5pbWF0aW9uIHN1cHBvcnQgb24gdGhlIGdyaWRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGluaXRpYWxpemVBbmltYXRpb25TdXBwb3J0OiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICghZHJhZ2dlcikge1xuICAgICAgICAgICAgZHJhZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgZHJhZ2dlci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzBweCcpO1xuICAgICAgICAgICAgZHJhZ2dlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcwcHgnKTtcblxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkcmFnZ2VyKTtcbiAgICAgICAgICAgIGRyYWdnZXJDVFggPSBkcmFnZ2VyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmbG9hdENvbHVtbikge1xuICAgICAgICAgICAgZmxvYXRDb2x1bW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGZsb2F0Q29sdW1uLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMHB4Jyk7XG4gICAgICAgICAgICBmbG9hdENvbHVtbi5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcwcHgnKTtcblxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmbG9hdENvbHVtbik7XG4gICAgICAgICAgICBmbG9hdENvbHVtbkNUWCA9IGZsb2F0Q29sdW1uLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBnZXRDYW5EcmFnQ3Vyc29yTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC1ncmFiJztcbiAgICB9LFxuXG4gICAgZ2V0RHJhZ2dpbmdDdXJzb3JOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICctd2Via2l0LWdyYWJiaW5nJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuXG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB2YXIgeDtcbiAgICAgICAgLy92YXIgeTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLmFicyhldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuZHJhZ3N0YXJ0LnggLSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueCk7XG5cbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgMTAgfHwgdGhpcy5pc0ZpeGVkQ29sdW1uKGdyaWQsIGV2ZW50KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNIZWFkZXJSb3coZ3JpZCwgZXZlbnQpICYmIHRoaXMuZHJhZ0FybWVkICYmICF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NvbCA9IGdyaWRDZWxsLng7XG4gICAgICAgICAgICB0aGlzLmRyYWdPZmZzZXQgPSBldmVudC5tb3VzZVBvaW50Lng7XG4gICAgICAgICAgICB0aGlzLmRldGFjaENoYWluKCk7XG4gICAgICAgICAgICB4ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLnggLSB0aGlzLmRyYWdPZmZzZXQ7XG4gICAgICAgICAgICAvL3kgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRHJhZ0NvbHVtbihncmlkLCB4LCB0aGlzLmRyYWdDb2wpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgeCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS54IC0gdGhpcy5kcmFnT2Zmc2V0O1xuICAgICAgICAgICAgLy95ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLnk7XG4gICAgICAgICAgICB0aGlzLmRyYWdDb2x1bW4oZ3JpZCwgeCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAoZ3JpZC5iZWhhdmlvci5pc0NvbHVtblJlb3JkZXJhYmxlKCkgJiYgIXRoaXMuaXNGaXhlZENvbHVtbihncmlkLCBldmVudCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGVhZGVyUm93KGdyaWQsIGV2ZW50KSAmJiBldmVudC5ncmlkQ2VsbC54ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0FybWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMuZ2V0RHJhZ2dpbmdDdXJzb3JOYW1lKCk7XG4gICAgICAgICAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICAvL3ZhciBjb2wgPSBldmVudC5ncmlkQ2VsbC54O1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgLy9kZWxheSBoZXJlIHRvIGdpdmUgb3RoZXIgZXZlbnRzIGEgY2hhbmNlIHRvIGJlIGRyb3BwZWRcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZW5kRHJhZ0NvbHVtbihncmlkKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hDaGFpbigpO1xuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdDb2wgPSAtMTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRyYWdBcm1lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuXG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlTW92ZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcblxuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcgJiYgZXZlbnQubW91c2VQb2ludC55IDwgNSAmJiBldmVudC52aWV3UG9pbnQueSA9PT0gMCAmJiAhdGhpcy5pc0ZpeGVkQ29sdW1uKGdyaWQsIGV2ZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLmdldENhbkRyYWdDdXJzb3JOYW1lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzSGVhZGVyUm93KGdyaWQsIGV2ZW50KSAmJiB0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMuZ2V0RHJhZ2dpbmdDdXJzb3JOYW1lKCk7IC8vbW92ZSc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBpcyB0aGUgbWFpbiBldmVudCBoYW5kbGVyIHRoYXQgbWFuYWdlcyB0aGUgZHJhZ2dpbmcgb2YgdGhlIGNvbHVtblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkcmFnZ2VkVG9UaGVSaWdodCAtIGFyZSB3ZSBtb3ZpbmcgdG8gdGhlIHJpZ2h0XG4gICAgICovXG4gICAgZmxvYXRDb2x1bW5UbzogZnVuY3Rpb24oZ3JpZCwgZHJhZ2dlZFRvVGhlUmlnaHQpIHtcbiAgICAgICAgdGhpcy5mbG9hdGluZ05vdyA9IHRydWU7XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyID0gZ3JpZC5nZXRSZW5kZXJlcigpO1xuICAgICAgICB2YXIgY29sRWRnZXMgPSByZW5kZXJlci5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgIHZhciBmbG9hdGVySW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmZsb2F0ZXIuY29sdW1uSW5kZXg7XG4gICAgICAgIHZhciBkcmFnZ2VySW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXg7XG4gICAgICAgIHZhciBoZHBpcmF0aW8gPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuaGRwaXJhdGlvO1xuXG4gICAgICAgIHZhciBkcmFnZ2VyU3RhcnRYO1xuICAgICAgICB2YXIgZmxvYXRlclN0YXJ0WDtcbiAgICAgICAgdmFyIGZpeGVkQ29sdW1uQ291bnQgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGRyYWdnZXJXaWR0aCA9IGdyaWQuZ2V0Q29sdW1uV2lkdGgoZHJhZ2dlckluZGV4KTtcbiAgICAgICAgdmFyIGZsb2F0ZXJXaWR0aCA9IGdyaWQuZ2V0Q29sdW1uV2lkdGgoZmxvYXRlckluZGV4KTtcblxuICAgICAgICB2YXIgbWF4ID0gZ3JpZC5nZXRWaXNpYmxlQ29sdW1uc0NvdW50KCk7XG5cbiAgICAgICAgdmFyIGRvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgZm9mZnNldCA9IDA7XG5cbiAgICAgICAgaWYgKGRyYWdnZXJJbmRleCA+PSBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICBkb2Zmc2V0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxvYXRlckluZGV4ID49IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIGZvZmZzZXQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyYWdnZWRUb1RoZVJpZ2h0KSB7XG4gICAgICAgICAgICBkcmFnZ2VyU3RhcnRYID0gY29sRWRnZXNbTWF0aC5taW4obWF4LCBkcmFnZ2VySW5kZXggLSBkb2Zmc2V0KV07XG4gICAgICAgICAgICBmbG9hdGVyU3RhcnRYID0gY29sRWRnZXNbTWF0aC5taW4obWF4LCBmbG9hdGVySW5kZXggLSBmb2Zmc2V0KV07XG5cbiAgICAgICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5zdGFydFggPSAoZHJhZ2dlclN0YXJ0WCArIGZsb2F0ZXJXaWR0aCkgKiBoZHBpcmF0aW87XG4gICAgICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmZsb2F0ZXIuc3RhcnRYID0gZHJhZ2dlclN0YXJ0WCAqIGhkcGlyYXRpbztcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxvYXRlclN0YXJ0WCA9IGNvbEVkZ2VzW01hdGgubWluKG1heCwgZmxvYXRlckluZGV4IC0gZm9mZnNldCldO1xuICAgICAgICAgICAgZHJhZ2dlclN0YXJ0WCA9IGZsb2F0ZXJTdGFydFggKyBkcmFnZ2VyV2lkdGg7XG5cbiAgICAgICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5zdGFydFggPSBmbG9hdGVyU3RhcnRYICogaGRwaXJhdGlvO1xuICAgICAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5mbG9hdGVyLnN0YXJ0WCA9IGRyYWdnZXJTdGFydFggKiBoZHBpcmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgZ3JpZC5zd2FwQ29sdW1ucyhkcmFnZ2VySW5kZXgsIGZsb2F0ZXJJbmRleCk7XG4gICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5jb2x1bW5JbmRleCA9IGZsb2F0ZXJJbmRleDtcbiAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5mbG9hdGVyLmNvbHVtbkluZGV4ID0gZHJhZ2dlckluZGV4O1xuXG5cbiAgICAgICAgdGhpcy5mbG9hdGVyQW5pbWF0aW9uUXVldWUudW5zaGlmdCh0aGlzLmRvQ29sdW1uTW92ZUFuaW1hdGlvbihncmlkLCBmbG9hdGVyU3RhcnRYLCBkcmFnZ2VyU3RhcnRYKSk7XG5cbiAgICAgICAgdGhpcy5kb0Zsb2F0ZXJBbmltYXRpb24oZ3JpZCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgbWFuaWZlc3QgdGhlIGNvbHVtbiBkcmFnIGFuZCBkcm9wIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZsb2F0ZXJTdGFydFggLSB0aGUgeCBzdGFydCBjb29yZGluYXRlIG9mIHRoZSBjb2x1bW4gdW5kZXJuZWF0aCB0aGF0IGZsb2F0cyBiZWhpbmQgdGhlIGRyYWdnZWQgY29sdW1uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRyYWdnZXJTdGFydFggLSB0aGUgeCBzdGFydCBjb29yZGluYXRlIG9mIHRoZSBkcmFnZ2VkIGNvbHVtblxuICAgICAqL1xuICAgIGRvQ29sdW1uTW92ZUFuaW1hdGlvbjogZnVuY3Rpb24oZ3JpZCwgZmxvYXRlclN0YXJ0WCwgZHJhZ2dlclN0YXJ0WCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkID0gZmxvYXRDb2x1bW47XG4gICAgICAgICAgICBkLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcbiAgICAgICAgICAgIHNlbGYuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGZsb2F0ZXJTdGFydFggKyAncHgsICcgKyAwICsgJ3B4KScpO1xuXG4gICAgICAgICAgICAvL2Quc3R5bGUud2Via2l0LXdlYmtpdC1UcmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyBmbG9hdGVyU3RhcnRYICsgJ3B4LCAnICsgMCArICdweCknO1xuICAgICAgICAgICAgLy9kLnN0eWxlLndlYmtpdC13ZWJraXQtVHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgZmxvYXRlclN0YXJ0WCArICdweCwgJyArIDAgKyAncHgpJztcblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zaXRpb24nLCAoc2VsZi5pc1dlYmtpdCA/ICctd2Via2l0LScgOiAnJykgKyAndHJhbnNmb3JtICcgKyBjb2x1bW5BbmltYXRpb25UaW1lICsgJ21zIGVhc2UnKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBkcmFnZ2VyU3RhcnRYICsgJ3B4LCAnICsgLTIgKyAncHgpJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICAgICAgLy9uZWVkIHRvIGNoYW5nZSB0aGlzIHRvIGtleSBmcmFtZXNcblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2l0aW9uJywgJycpO1xuICAgICAgICAgICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZmxvYXRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5kb0Zsb2F0ZXJBbmltYXRpb24oZ3JpZCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaXNGbG9hdGluZ05vdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgY29sdW1uQW5pbWF0aW9uVGltZSArIDUwKTtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgbWFuaWZlc3QgdGhlIGZsb2F0ZXIgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBkb0Zsb2F0ZXJBbmltYXRpb246IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxvYXRlckFuaW1hdGlvblF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5mbG9hdGluZ05vdyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuZmxvYXRlckFuaW1hdGlvblF1ZXVlLnBvcCgpO1xuICAgICAgICBhbmltYXRpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgY3JlYXRlIHRoZSBmbG9hdCBjb2x1bW4gYXQgY29sdW1uSW5kZXggdW5kZXJuZWF0aCB0aGUgZHJhZ2dlZCBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgY29sdW1uIHRoYXQgd2lsbCBiZSBmbG9hdGluZ1xuICAgICAqL1xuICAgIGNyZWF0ZUZsb2F0Q29sdW1uOiBmdW5jdGlvbihncmlkLCBjb2x1bW5JbmRleCkge1xuXG4gICAgICAgIHZhciBmaXhlZENvbHVtbkNvdW50ID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcblxuICAgICAgICBpZiAoY29sdW1uSW5kZXggPCBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICBzY3JvbGxMZWZ0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW5kZXJlciA9IGdyaWQuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgdmFyIGNvbHVtbkVkZ2VzID0gcmVuZGVyZXIuZ2V0Q29sdW1uRWRnZXMoKTtcblxuICAgICAgICB2YXIgY29sdW1uV2lkdGggPSBncmlkLmdldENvbHVtbldpZHRoKGNvbHVtbkluZGV4KTtcbiAgICAgICAgdmFyIGNvbEhlaWdodCA9IGdyaWQuZGl2LmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIGQgPSBmbG9hdENvbHVtbjtcbiAgICAgICAgdmFyIHN0eWxlID0gZC5zdHlsZTtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gZ3JpZC5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgc3R5bGUudG9wID0gKGxvY2F0aW9uLnRvcCAtIDIpICsgJ3B4JztcbiAgICAgICAgc3R5bGUubGVmdCA9IGxvY2F0aW9uLmxlZnQgKyAncHgnO1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG5cbiAgICAgICAgdmFyIGhkcGlSYXRpbyA9IGdyaWQuZ2V0SGlEUEkoZmxvYXRDb2x1bW5DVFgpO1xuXG4gICAgICAgIGQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIE1hdGgucm91bmQoY29sdW1uV2lkdGggKiBoZHBpUmF0aW8pICsgJ3B4Jyk7XG4gICAgICAgIGQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBNYXRoLnJvdW5kKGNvbEhlaWdodCAqIGhkcGlSYXRpbykgKyAncHgnKTtcbiAgICAgICAgc3R5bGUuYm94U2hhZG93ID0gJzAgMTBweCAyMHB4IHJnYmEoMCwwLDAsMC4xOSksIDAgNnB4IDZweCByZ2JhKDAsMCwwLDAuMjMpJztcbiAgICAgICAgc3R5bGUud2lkdGggPSBjb2x1bW5XaWR0aCArICdweCc7IC8vTWF0aC5yb3VuZChjb2x1bW5XaWR0aCAvIGhkcGlSYXRpbykgKyAncHgnO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBjb2xIZWlnaHQgKyAncHgnOyAvL01hdGgucm91bmQoY29sSGVpZ2h0IC8gaGRwaVJhdGlvKSArICdweCc7XG4gICAgICAgIHN0eWxlLmJvcmRlclRvcCA9ICcxcHggc29saWQgJyArIHJlbmRlcmVyLnJlc29sdmVQcm9wZXJ0eSgnbGluZUNvbG9yJyk7XG4gICAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9IHJlbmRlcmVyLnJlc29sdmVQcm9wZXJ0eSgnYmFja2dyb3VuZENvbG9yJyk7XG5cbiAgICAgICAgdmFyIHN0YXJ0WCA9IGNvbHVtbkVkZ2VzW2NvbHVtbkluZGV4IC0gc2Nyb2xsTGVmdF07XG4gICAgICAgIHN0YXJ0WCA9IHN0YXJ0WCAqIGhkcGlSYXRpbztcblxuICAgICAgICBmbG9hdENvbHVtbkNUWC5zY2FsZShoZHBpUmF0aW8sIGhkcGlSYXRpbyk7XG5cbiAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5mbG9hdGVyID0ge1xuICAgICAgICAgICAgY29sdW1uSW5kZXg6IGNvbHVtbkluZGV4LFxuICAgICAgICAgICAgY3R4OiBmbG9hdENvbHVtbkNUWCxcbiAgICAgICAgICAgIHN0YXJ0WDogc3RhcnRYLFxuICAgICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjb2xIZWlnaHQsXG4gICAgICAgICAgICBoZHBpcmF0aW86IGhkcGlSYXRpb1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0eWxlLnpJbmRleCA9ICc0JztcbiAgICAgICAgdGhpcy5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgc3RhcnRYICsgJ3B4LCAnICsgLTIgKyAncHgpJyk7XG4gICAgICAgIHN0eWxlLmN1cnNvciA9IHRoaXMuZ2V0RHJhZ2dpbmdDdXJzb3JOYW1lKCk7XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IGZ1bmN0aW9uIGZvciBzZXR0aW5nIGNyb3NzIGJyb3dzZXIgY3NzIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZGVzY3JpcHRvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBhc3NpZ25cbiAgICAgKi9cbiAgICBzZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eTogZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIHZhciB1UHJvcGVydHkgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc3Vic3RyKDEpO1xuICAgICAgICB0aGlzLnNldFByb3AoZWxlbWVudCwgJ3dlYmtpdCcgKyB1UHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wKGVsZW1lbnQsICdNb3onICsgdVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCAnbXMnICsgdVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCAnTycgKyB1UHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgZnVuY3Rpb24gZm9yIHNldHRpbmcgcHJvcGVydGllcyBvbiBIVE1MRWxlbWVudHNcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZGVzY3JpcHRvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBhc3NpZ25cbiAgICAgKi9cbiAgICBzZXRQcm9wOiBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5IGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgY3JlYXRlIHRoZSBkcmFnZ2VkIGNvbHVtbiBhdCBjb2x1bW5JbmRleCBhYm92ZSB0aGUgZmxvYXRlZCBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHN0YXJ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gdGhhdCB3aWxsIGJlIGZsb2F0aW5nXG4gICAgICovXG4gICAgY3JlYXRlRHJhZ0NvbHVtbjogZnVuY3Rpb24oZ3JpZCwgeCwgY29sdW1uSW5kZXgpIHtcblxuICAgICAgICB2YXIgZml4ZWRDb2x1bW5Db3VudCA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG5cbiAgICAgICAgaWYgKGNvbHVtbkluZGV4IDwgZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVuZGVyZXIgPSBncmlkLmdldFJlbmRlcmVyKCk7XG4gICAgICAgIHZhciBjb2x1bW5FZGdlcyA9IHJlbmRlcmVyLmdldENvbHVtbkVkZ2VzKCk7XG4gICAgICAgIHZhciBoZHBpUmF0aW8gPSBncmlkLmdldEhpRFBJKGRyYWdnZXJDVFgpO1xuICAgICAgICB2YXIgY29sdW1uV2lkdGggPSBncmlkLmdldENvbHVtbldpZHRoKGNvbHVtbkluZGV4KTtcbiAgICAgICAgdmFyIGNvbEhlaWdodCA9IGdyaWQuZGl2LmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIGQgPSBkcmFnZ2VyO1xuICAgICAgICB2YXIgbG9jYXRpb24gPSBncmlkLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHN0eWxlID0gZC5zdHlsZTtcblxuICAgICAgICBzdHlsZS50b3AgPSBsb2NhdGlvbi50b3AgKyAncHgnO1xuICAgICAgICBzdHlsZS5sZWZ0ID0gbG9jYXRpb24ubGVmdCArICdweCc7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgc3R5bGUub3BhY2l0eSA9IDAuODU7XG4gICAgICAgIHN0eWxlLmJveFNoYWRvdyA9ICcwIDE5cHggMzhweCByZ2JhKDAsMCwwLDAuMzApLCAwIDE1cHggMTJweCByZ2JhKDAsMCwwLDAuMjIpJztcbiAgICAgICAgLy9zdHlsZS56SW5kZXggPSAxMDA7XG4gICAgICAgIHN0eWxlLmJvcmRlclRvcCA9ICcxcHggc29saWQgJyArIHJlbmRlcmVyLnJlc29sdmVQcm9wZXJ0eSgnbGluZUNvbG9yJyk7XG4gICAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9IGdyaWQucmVuZGVyZXIucmVzb2x2ZVByb3BlcnR5KCdiYWNrZ3JvdW5kQ29sb3InKTtcblxuICAgICAgICBkLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBNYXRoLnJvdW5kKGNvbHVtbldpZHRoICogaGRwaVJhdGlvKSArICdweCcpO1xuICAgICAgICBkLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgTWF0aC5yb3VuZChjb2xIZWlnaHQgKiBoZHBpUmF0aW8pICsgJ3B4Jyk7XG5cbiAgICAgICAgc3R5bGUud2lkdGggPSBjb2x1bW5XaWR0aCArICdweCc7IC8vTWF0aC5yb3VuZChjb2x1bW5XaWR0aCAvIGhkcGlSYXRpbykgKyAncHgnO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBjb2xIZWlnaHQgKyAncHgnOyAvL01hdGgucm91bmQoY29sSGVpZ2h0IC8gaGRwaVJhdGlvKSArICdweCc7XG5cbiAgICAgICAgdmFyIHN0YXJ0WCA9IGNvbHVtbkVkZ2VzW2NvbHVtbkluZGV4IC0gc2Nyb2xsTGVmdF07XG4gICAgICAgIHN0YXJ0WCA9IHN0YXJ0WCAqIGhkcGlSYXRpbztcblxuICAgICAgICBkcmFnZ2VyQ1RYLnNjYWxlKGhkcGlSYXRpbywgaGRwaVJhdGlvKTtcblxuICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIgPSB7XG4gICAgICAgICAgICBjb2x1bW5JbmRleDogY29sdW1uSW5kZXgsXG4gICAgICAgICAgICBzdGFydEluZGV4OiBjb2x1bW5JbmRleCxcbiAgICAgICAgICAgIGN0eDogZHJhZ2dlckNUWCxcbiAgICAgICAgICAgIHN0YXJ0WDogc3RhcnRYLFxuICAgICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjb2xIZWlnaHQsXG4gICAgICAgICAgICBoZHBpcmF0aW86IGhkcGlSYXRpb1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHggKyAncHgsIC01cHgpJyk7XG4gICAgICAgIHN0eWxlLnpJbmRleCA9ICc1JztcbiAgICAgICAgc3R5bGUuY3Vyc29yID0gdGhpcy5nZXREcmFnZ2luZ0N1cnNvck5hbWUoKTtcbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gaXMgdGhlIG1haW4gZHJhZ2dpbmcgbG9naWNcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHN0YXJ0IHBvc2l0aW9uXG4gICAgICovXG4gICAgZHJhZ0NvbHVtbjogZnVuY3Rpb24oZ3JpZCwgeCkge1xuXG4gICAgICAgIC8vVE9ETzogdGhpcyBmdW5jdGlvbiBpcyBvdmVybHkgY29tcGxleCwgcmVmYWN0b3IgdGhpcyBpbiB0byBzb21ldGhpbmcgbW9yZSByZWFzb25hYmxlXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgLy92YXIgcmVuZGVyZXIgPSBncmlkLmdldFJlbmRlcmVyKCk7XG4gICAgICAgIC8vdmFyIGNvbHVtbkVkZ2VzID0gcmVuZGVyZXIuZ2V0Q29sdW1uRWRnZXMoKTtcblxuICAgICAgICB2YXIgYXV0b1Njcm9sbGluZ05vdyA9IHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodCB8fCB0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nTGVmdDtcblxuICAgICAgICB2YXIgaGRwaVJhdGlvID0gZ3JpZC5nZXRIaURQSShkcmFnZ2VyQ1RYKTtcblxuICAgICAgICB2YXIgZHJhZ0NvbHVtbkluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuXG4gICAgICAgIHZhciBtaW5YID0gMDtcbiAgICAgICAgdmFyIG1heFggPSBncmlkLnJlbmRlcmVyLmdldEZpbmFsVmlzYWJsZUNvbHVtbkJvdW5kYXJ5KCk7XG4gICAgICAgIHggPSBNYXRoLm1pbih4LCBtYXhYICsgMTUpO1xuICAgICAgICB4ID0gTWF0aC5tYXgobWluWCAtIDE1LCB4KTtcblxuICAgICAgICAvL2FtIEkgYXQgbXkgbG93ZXIgYm91bmRcbiAgICAgICAgdmFyIGF0TWluID0geCA8IG1pblggJiYgZHJhZ0NvbHVtbkluZGV4ICE9PSAwO1xuXG4gICAgICAgIC8vYW0gSSBhdCBteSB1cHBlciBib3VuZFxuICAgICAgICB2YXIgYXRNYXggPSB4ID4gbWF4WDtcblxuICAgICAgICB2YXIgZCA9IGRyYWdnZXI7XG5cbiAgICAgICAgdGhpcy5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNpdGlvbicsIChzZWxmLmlzV2Via2l0ID8gJy13ZWJraXQtJyA6ICcnKSArICd0cmFuc2Zvcm0gJyArIDAgKyAnbXMgZWFzZSwgYm94LXNoYWRvdyAnICsgY29sdW1uQW5pbWF0aW9uVGltZSArICdtcyBlYXNlJyk7XG5cbiAgICAgICAgdGhpcy5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeCArICdweCwgJyArIC0xMCArICdweCknKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZC5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBvdmVyQ29sID0gZ3JpZC5yZW5kZXJlci5nZXRDb2x1bW5Gcm9tUGl4ZWxYKHggKyAoZC53aWR0aCAvIDIgLyBoZHBpUmF0aW8pKTtcblxuICAgICAgICBpZiAoYXRNaW4pIHtcbiAgICAgICAgICAgIG92ZXJDb2wgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF0TWF4KSB7XG4gICAgICAgICAgICBvdmVyQ29sID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkb0FGbG9hdCA9IGRyYWdDb2x1bW5JbmRleCA+IG92ZXJDb2w7XG4gICAgICAgIGRvQUZsb2F0ID0gZG9BRmxvYXQgfHwgKG92ZXJDb2wgLSBkcmFnQ29sdW1uSW5kZXggPj0gMSk7XG5cbiAgICAgICAgaWYgKGRvQUZsb2F0ICYmICFhdE1heCAmJiAhYXV0b1Njcm9sbGluZ05vdykge1xuICAgICAgICAgICAgdmFyIGRyYWdnZWRUb1RoZVJpZ2h0ID0gZHJhZ0NvbHVtbkluZGV4IDwgb3ZlckNvbDtcbiAgICAgICAgICAgIC8vIGlmIChkcmFnZ2VkVG9UaGVSaWdodCkge1xuICAgICAgICAgICAgLy8gICAgIG92ZXJDb2wgPSBvdmVyQ29sIC0gMTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRmxvYXRpbmdOb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaXNGbG9hdGluZ05vdyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZsb2F0Q29sdW1uKGdyaWQsIG92ZXJDb2wpO1xuICAgICAgICAgICAgdGhpcy5mbG9hdENvbHVtblRvKGdyaWQsIGRyYWdnZWRUb1RoZVJpZ2h0KTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKHggPCBtaW5YIC0gMTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQXV0b1Njcm9sbFRvTGVmdChncmlkLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID4gbWluWCAtIDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vbGV0cyBjaGVjayBmb3IgYXV0b3Njcm9sbCB0byByaWdodCBpZiB3ZXJlIHVwIGFnYWluc3QgaXRcbiAgICAgICAgICAgIGlmIChhdE1heCB8fCB4ID4gbWF4WCArIDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0F1dG9TY3JvbGxUb1JpZ2h0KGdyaWQsIHgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4IDwgbWF4WCArIDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgYXV0b3Njcm9sbCB0byB0aGUgcmlnaHQgaWYgbmVjZXNzYXJ5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBzdGFydCBwb3NpdGlvblxuICAgICAqL1xuICAgIGNoZWNrQXV0b1Njcm9sbFRvUmlnaHQ6IGZ1bmN0aW9uKGdyaWQsIHgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NoZWNrQXV0b1Njcm9sbFRvUmlnaHQoZ3JpZCwgeCk7XG4gICAgfSxcblxuICAgIF9jaGVja0F1dG9TY3JvbGxUb1JpZ2h0OiBmdW5jdGlvbihncmlkLCB4KSB7XG4gICAgICAgIGlmICghdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgICAgICBpZiAoIWdyaWQuZHJhZ2dpbmcgfHwgc2Nyb2xsTGVmdCA+IChncmlkLnNiSFNjcm9sbGVyLnJhbmdlLm1heCAtIDIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRyYWdnZWRJbmRleCA9IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5jb2x1bW5JbmRleDtcbiAgICAgICAgZ3JpZC5zY3JvbGxCeSgxLCAwKTtcbiAgICAgICAgdmFyIG5ld0luZGV4ID0gZHJhZ2dlZEluZGV4ICsgMTtcbiAgICAgICAgY29uc29sZS5sb2cobmV3SW5kZXgsIGRyYWdnZWRJbmRleCk7XG4gICAgICAgIGdyaWQuc3dhcENvbHVtbnMobmV3SW5kZXgsIGRyYWdnZWRJbmRleCk7XG4gICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5jb2x1bW5JbmRleCA9IG5ld0luZGV4O1xuXG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5fY2hlY2tBdXRvU2Nyb2xsVG9SaWdodC5iaW5kKHRoaXMsIGdyaWQsIHgpLCAyNTApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhdXRvc2Nyb2xsIHRvIHRoZSBsZWZ0IGlmIG5lY2Vzc2FyeVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgc3RhcnQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBjaGVja0F1dG9TY3JvbGxUb0xlZnQ6IGZ1bmN0aW9uKGdyaWQsIHgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdMZWZ0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jaGVja0F1dG9TY3JvbGxUb0xlZnQoZ3JpZCwgeCk7XG4gICAgfSxcblxuICAgIF9jaGVja0F1dG9TY3JvbGxUb0xlZnQ6IGZ1bmN0aW9uKGdyaWQsIHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nTGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgICAgICBpZiAoIWdyaWQuZHJhZ2dpbmcgfHwgc2Nyb2xsTGVmdCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHJhZ2dlZEluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuICAgICAgICBncmlkLnN3YXBDb2x1bW5zKGRyYWdnZWRJbmRleCArIHNjcm9sbExlZnQsIGRyYWdnZWRJbmRleCArIHNjcm9sbExlZnQgLSAxKTtcbiAgICAgICAgZ3JpZC5zY3JvbGxCeSgtMSwgMCk7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5fY2hlY2tBdXRvU2Nyb2xsVG9MZWZ0LmJpbmQodGhpcywgZ3JpZCwgeCksIDI1MCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGEgY29sdW1uIGRyYWcgaGFzIGNvbXBsZXRlZCwgdXBkYXRlIGRhdGEgYW5kIGNsZWFudXBcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGVuZERyYWdDb2x1bW46IGZ1bmN0aW9uKGdyaWQpIHtcblxuICAgICAgICB2YXIgZml4ZWRDb2x1bW5Db3VudCA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG5cbiAgICAgICAgdmFyIGNvbHVtbkluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuXG4gICAgICAgIGlmIChjb2x1bW5JbmRleCA8IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyID0gZ3JpZC5nZXRSZW5kZXJlcigpO1xuICAgICAgICB2YXIgY29sdW1uRWRnZXMgPSByZW5kZXJlci5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzdGFydFggPSBjb2x1bW5FZGdlc1tjb2x1bW5JbmRleCAtIHNjcm9sbExlZnRdO1xuICAgICAgICB2YXIgZCA9IGRyYWdnZXI7XG4gICAgICAgIHZhciBjaGFuZ2VkID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLnN0YXJ0SW5kZXggIT09IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5jb2x1bW5JbmRleDtcbiAgICAgICAgc2VsZi5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNpdGlvbicsIChzZWxmLmlzV2Via2l0ID8gJy13ZWJraXQtJyA6ICcnKSArICd0cmFuc2Zvcm0gJyArIGNvbHVtbkFuaW1hdGlvblRpbWUgKyAnbXMgZWFzZSwgYm94LXNoYWRvdyAnICsgY29sdW1uQW5pbWF0aW9uVGltZSArICdtcyBlYXNlJyk7XG4gICAgICAgIHNlbGYuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHN0YXJ0WCArICdweCwgJyArIC0xICsgJ3B4KScpO1xuICAgICAgICBkLnN0eWxlLmJveFNoYWRvdyA9ICcwcHggMHB4IDBweCAjODg4ODg4JztcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyID0gbnVsbDtcbiAgICAgICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICBncmlkLmVuZERyYWdDb2x1bW5Ob3RpZmljYXRpb24oKTsgLy9pbnRlcm5hbCBub3RpZmljYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZCl7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY09uQ29sdW1uc0NoYW5nZWRFdmVudCgpOyAvL3B1YmxpYyBub3RpZmljYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgY29sdW1uQW5pbWF0aW9uVGltZSArIDUwKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzSGVhZGVyUm93OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldmVudC52aWV3UG9pbnQ7XG4gICAgICAgIHZhciBpc0ZpeGVkID0gZ3JpZENlbGwueSA9PT0gMDtcbiAgICAgICAgcmV0dXJuIGlzRml4ZWQ7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5Nb3Zpbmc7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qIGdsb2JhbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29sdW1uUGlja2VyID0gRmVhdHVyZS5leHRlbmQoJ0NvbHVtblBpY2tlcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5QaWNrZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVLZXlVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IGV2ZW50LmRldGFpbC5jaGFyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBrZXlzID0gZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ2VkaXRvckFjdGl2YXRpb25LZXlzJyk7XG4gICAgICAgIGlmIChrZXlzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgIGdyaWQudG9nZ2xlRGlhbG9nKCdDb2x1bW5QaWNrZXInKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtblBpY2tlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENvbHVtblJlc2l6aW5nID0gRmVhdHVyZS5leHRlbmQoJ0NvbHVtblJlc2l6aW5nJywge1xuXG4gICAgLyoqXG4gICAgICogdGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gd2FsbCB3ZXJlIGN1cnJlbnRseSBkcmFnZ2luZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTJcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ0luZGV4OiAtMixcblxuICAgIC8qKlxuICAgICAqIHRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgd2hlcmUgdGhlIGRyYWcgd2FzIGluaXRpYXRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ1N0YXJ0OiAtMSxcblxuICAgIC8qKlxuICAgICAqIHRoZSBzdGFydGluZyB3aWR0aC9oZWlnaHQgb2YgdGhlIHJvdy9jb2x1bW4gd2UgYXJlIGRyYWdnaW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnSW5kZXhTdGFydGluZ1NpemU6IC0xLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdldCB0aGUgbW91c2UgeCx5IGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSB0aGUgbW91c2UgZXZlbnQgdG8gcXVlcnlcbiAgICAgKi9cbiAgICBnZXRNb3VzZVZhbHVlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLng7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnZXQgdGhlIGdyaWQgY2VsbCB4LHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fSBncmlkQ2VsbFxuICAgICAqL1xuICAgIGdldEdyaWRDZWxsVmFsdWU6IGZ1bmN0aW9uKGdyaWRDZWxsKSB7XG4gICAgICAgIHJldHVybiBncmlkQ2VsbC55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSBncmlkcyB4LHkgc2Nyb2xsIHZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGdldFNjcm9sbFZhbHVlOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIHJvdy9jb2x1bW4gb2YgaW50ZXJlc3RcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRBcmVhU2l6ZTogZnVuY3Rpb24oZ3JpZCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0Q29sdW1uV2lkdGgoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIHJvdy9jb2x1bW4gYXQgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB0aGUgd2lkdGgvaGVpZ2h0IHRvIHNldCB0b1xuICAgICAqL1xuICAgIHNldEFyZWFTaXplOiBmdW5jdGlvbihncmlkLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgZ3JpZC5zZXRDb2x1bW5XaWR0aChpbmRleCwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSByZWNlbnRseSByZW5kZXJlZCBhcmVhJ3Mgd2lkdGgvaGVpZ2h0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSByb3cvY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0UHJldmlvdXNBYnNvbHV0ZVNpemU6IGZ1bmN0aW9uKGdyaWQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldFJlbmRlcmVkV2lkdGgoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJucyB0aGUgaW5kZXggb2Ygd2hpY2ggZGl2aWRlciBJJ20gb3ZlclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG92ZXJBcmVhRGl2aWRlcjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQub3ZlckNvbHVtbkRpdmlkZXIoZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgYW0gSSBvdmVyIHRoZSBjb2x1bW4vcm93IGFyZWFcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaXNGaXJzdEZpeGVkT3RoZXJBcmVhOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0ZpcnN0Rml4ZWRSb3coZ3JpZCwgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSBjdXJzb3IgbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q3Vyc29yTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnY29sLXJlc2l6ZSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdJbmRleCA+IC0yKSB7XG4gICAgICAgICAgICAvL3ZhciBmaXhlZEFyZWFDb3VudCA9IHRoaXMuZ2V0Rml4ZWRBcmVhQ291bnQoZ3JpZCk7XG4gICAgICAgICAgICAvL3ZhciBvZmZzZXQgPSB0aGlzLmdldEZpeGVkQXJlYVNpemUoZ3JpZCwgZml4ZWRBcmVhQ291bnQgKyBhcmVhSW5kZXgpO1xuICAgICAgICAgICAgdmFyIG1vdXNlID0gdGhpcy5nZXRNb3VzZVZhbHVlKGV2ZW50KTtcbiAgICAgICAgICAgIHZhciBzY3JvbGxWYWx1ZSA9IHRoaXMuZ2V0U2Nyb2xsVmFsdWUoZ3JpZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnSW5kZXggPCB0aGlzLmdldEZpeGVkQXJlYUNvdW50KGdyaWQpKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVmFsdWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5nZXRQcmV2aW91c0Fic29sdXRlU2l6ZShncmlkLCB0aGlzLmRyYWdJbmRleCAtIHNjcm9sbFZhbHVlKTtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IG1vdXNlIC0gcHJldmlvdXM7XG4gICAgICAgICAgICB0aGlzLnNldEFyZWFTaXplKGdyaWQsIHRoaXMuZHJhZ0luZGV4LCBkaXN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2V0IHRoZSB3aWR0aC9oZWlnaHQgb2YgYSBzcGVjaWZpYyByb3cvY29sdW1uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJlYUluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRTaXplOiBmdW5jdGlvbihncmlkLCBhcmVhSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXJlYVNpemUoZ3JpZCwgYXJlYUluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgZml4ZWQgYXJlYSByb3dzL2NvbHVtbnMgY291bnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZ2V0T3RoZXJGaXhlZEFyZWFDb3VudDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzRW5hYmxlZCA9IHRoaXMuaXNFbmFibGVkKGdyaWQpO1xuICAgICAgICB2YXIgb3ZlckFyZWEgPSB0aGlzLm92ZXJBcmVhRGl2aWRlcihncmlkLCBldmVudCk7XG4gICAgICAgIGlmIChpc0VuYWJsZWQgJiYgb3ZlckFyZWEgPiAtMSAmJiB0aGlzLmlzRmlyc3RGaXhlZE90aGVyQXJlYShncmlkLCBldmVudCkpIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxWYWx1ZSA9IHRoaXMuZ2V0U2Nyb2xsVmFsdWUoZ3JpZCk7XG4gICAgICAgICAgICBpZiAob3ZlckFyZWEgPCB0aGlzLmdldEZpeGVkQXJlYUNvdW50KGdyaWQpKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVmFsdWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmFnSW5kZXggPSBvdmVyQXJlYSAtIDEgKyBzY3JvbGxWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0ID0gdGhpcy5nZXRNb3VzZVZhbHVlKGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0luZGV4U3RhcnRpbmdTaXplID0gMDtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoQ2hhaW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc0VuYWJsZWQgPSB0aGlzLmlzRW5hYmxlZChncmlkKTtcbiAgICAgICAgaWYgKGlzRW5hYmxlZCAmJiB0aGlzLmRyYWdJbmRleCA+IC0yKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRyYWdJbmRleCA9IC0yO1xuXG4gICAgICAgICAgICBldmVudC5wcmltaXRpdmVFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIC8vZGVsYXkgaGVyZSB0byBnaXZlIG90aGVyIGV2ZW50cyBhIGNoYW5jZSB0byBiZSBkcm9wcGVkXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBncmlkLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRyaWVzKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYXR0YWNoQ2hhaW4oKTtcbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnSW5kZXggPiAtMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0ZvckFyZWFSZXNpemVDdXJzb3JDaGFuZ2UoZ3JpZCwgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgZmlsbCB0aGlzIGluXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGNoZWNrRm9yQXJlYVJlc2l6ZUN1cnNvckNoYW5nZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzRW5hYmxlZCA9IHRoaXMuaXNFbmFibGVkKGdyaWQpO1xuICAgICAgICBpZiAoaXNFbmFibGVkICYmIHRoaXMub3ZlckFyZWFEaXZpZGVyKGdyaWQsIGV2ZW50KSA+IC0xICYmIHRoaXMuaXNGaXJzdEZpeGVkT3RoZXJBcmVhKGdyaWQsIGV2ZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLmdldEN1cnNvck5hbWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRGaXhlZEFyZWFDb3VudDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB2YXIgY291bnQgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKSArIChncmlkLmlzU2hvd1Jvd051bWJlcnMoKSA/IDEgOiAwKSArIChncmlkLmhhc0hpZXJhcmNoeUNvbHVtbigpID8gMSA6IDApO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQGRlZmF1bHQgLTJcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc0VuYWJsZWQgPSB0aGlzLmlzRW5hYmxlZChncmlkKTtcbiAgICAgICAgdmFyIGhhc0N1cnNvciA9IHRoaXMub3ZlckFyZWFEaXZpZGVyKGdyaWQsIGV2ZW50KSA+IC0xOyAvL3RoaXMuY3Vyc29yICE9PSBudWxsO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIC8vdmFyIGhlYWRlckNvbENvdW50ID0gZ3JpZC5nZXRIZWFkZXJDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgaWYgKGlzRW5hYmxlZCAmJiBoYXNDdXJzb3IgJiYgKGdyaWRDZWxsLnkgPD0gaGVhZGVyUm93Q291bnQpKSB7XG4gICAgICAgICAgICBncmlkLmF1dG9zaXplQ29sdW1uKGdyaWRDZWxsLnggLSAxKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVEb3VibGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCAtMlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5SZXNpemluZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBFeHRyYSBtc2VjcyB0byBhdm9pZCByYWNlIGNvbmRpdGlvbiB3aXRoIGZpbmNhbnZhcydzIGRvdWJsZSBjbGljayB0aW1lci5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZGVmYXVsdHZhbHVlIDUwXG4gKiBOT1RFOiA1MCBtc2VjcyBzZWVtcyB0byB3b3JrIHdlbGwuIDEwIGFuZCBldmVuIDI1IHByb3ZlZCBpbnN1ZmZpY2llbnQgaW4gQ2hyb21lLlxuICogQHByaXZhdGVcbiAqL1xudmFyIFJBQ0VfVElNRSA9IDUwO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29sdW1uU2VsZWN0aW9uID0gRmVhdHVyZS5leHRlbmQoJ0NvbHVtblNlbGVjdGlvbicsIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjdXJyZW50RHJhZzogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjZWxsIGNvb3JkaW5hdGVzIG9mIHRoZSB3aGVyZSB0aGUgbW91c2UgcG9pbnRlciBpcyBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxhc3REcmFnQ2VsbDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBwcmV2aW91cyB0aW1lIGFuIGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JMYXN0QXV0bzogMCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSB0aW1lIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JBdXRvU3RhcnQ6IDAsXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRvdWJsZUNsaWNrVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRvdWJsZUNsaWNrVGltZXIpOyAvLyBwcmV2ZW50IG1vdXNlRG93biBmcm9tIGNvbnRpbnVpbmdcbiAgICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlRG91YmxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRvdWJsZUNsaWNrVGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoIWdyaWQuaXNDb2x1bW5TZWxlY3Rpb24oKSB8fCBldmVudC5tb3VzZVBvaW50LnkgPCA1KSAmJiB0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzUmlnaHRDbGljayA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5pc1JpZ2h0Q2xpY2s7XG4gICAgICAgIHZhciBjZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIHZhciB2aWV3Q2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgdmFyIGR4ID0gY2VsbC54O1xuICAgICAgICB2YXIgZHkgPSBjZWxsLnk7XG5cbiAgICAgICAgdmFyIGlzSGVhZGVyID0gZ3JpZC5pc1Nob3dIZWFkZXJSb3coKSAmJiBkeSA9PT0gMCAmJiBkeCAhPT0gLTE7XG5cbiAgICAgICAgaWYgKGlzUmlnaHRDbGljayB8fCAhaXNIZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhPTEQgT0ZGIFdISUxFIFdBSVRJTkcgRk9SIERPVUJMRS1DTElDS1xuICAgICAgICAgICAgdGhpcy5kb3VibGVDbGlja1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdWJsZUNsaWNrVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFyIG51bUZpeGVkQ29sdW1ucyA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuXG4gICAgICAgICAgICAgICAgLy9pZiB3ZSBhcmUgaW4gdGhlIGZpeGVkIGFyZWEgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAgICAgLy9jaGVjayBib3RoIHggYW5kIHkgdmFsdWVzIGluZGVwZW5kZW50bHlcbiAgICAgICAgICAgICAgICBpZiAodmlld0NlbGwueCA8IG51bUZpeGVkQ29sdW1ucykge1xuICAgICAgICAgICAgICAgICAgICBkeCA9IHZpZXdDZWxsLng7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRDZWxsID0gZ3JpZC5uZXdQb2ludChkeCwgMCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJpbUV2ZW50ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBwcmltRXZlbnQuZGV0YWlsLmtleXM7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRTZWxlY3Rpb24oZ3JpZCwgZENlbGwsIGtleXMpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCBncmlkLnJlc29sdmVQcm9wZXJ0eSgnZG91YmxlQ2xpY2tEZWxheScpICsgUkFDRV9USU1FKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuXG4gICAgICAgIGlmICgoIWdyaWQuaXNDb2x1bW5TZWxlY3Rpb24oKSB8fCB0aGlzLmlzQ29sdW1uRHJhZ2dpbmcoZ3JpZCkpICYmIHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNSaWdodENsaWNrID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljaztcblxuICAgICAgICBpZiAoaXNSaWdodENsaWNrIHx8ICF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcblxuICAgICAgICAgICAgdmFyIGNlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgICAgIHZhciB2aWV3Q2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgICAgIHZhciBkeCA9IGNlbGwueDtcbiAgICAgICAgICAgIHZhciBkeSA9IGNlbGwueTtcblxuICAgICAgICAgICAgLy9pZiB3ZSBhcmUgaW4gdGhlIGZpeGVkIGFyZWEgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAvL2NoZWNrIGJvdGggeCBhbmQgeSB2YWx1ZXMgaW5kZXBlbmRlbnRseVxuICAgICAgICAgICAgaWYgKHZpZXdDZWxsLnggPCBudW1GaXhlZENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICBkeCA9IHZpZXdDZWxsLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkQ2VsbCA9IGdyaWQubmV3UG9pbnQoZHgsIGR5KTtcblxuICAgICAgICAgICAgdmFyIHByaW1FdmVudCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhZyA9IHByaW1FdmVudC5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB0aGlzLmxhc3REcmFnQ2VsbCA9IGRDZWxsO1xuXG4gICAgICAgICAgICB0aGlzLmNoZWNrRHJhZ1Njcm9sbChncmlkLCB0aGlzLmN1cnJlbnREcmFnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCBkQ2VsbCwgcHJpbUV2ZW50LmRldGFpbC5rZXlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGhhbmRsZXI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGdyaWQuZ2V0TGFzdFNlbGVjdGlvblR5cGUoKSA9PT0gJ2NvbHVtbicgJiZcbiAgICAgICAgICAgIChoYW5kbGVyID0gdGhpc1snaGFuZGxlJyArIGV2ZW50LmRldGFpbC5jaGFyXSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgZ3JpZCwgZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSBhIG1vdXNlZHJhZyBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIGFycmF5IG9mIHRoZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBwcmVzc2VkIGRvd25cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uOiBmdW5jdGlvbihncmlkLCBncmlkQ2VsbCwga2V5cykge1xuICAgICAgICB2YXIgeCA9IGdyaWRDZWxsLng7XG4gICAgICAgIC8vICAgICAgICAgICAgdmFyIHByZXZpb3VzRHJhZ0V4dGVudCA9IGdyaWQuZ2V0RHJhZ0V4dGVudCgpO1xuICAgICAgICB2YXIgbW91c2VEb3duID0gZ3JpZC5nZXRNb3VzZURvd24oKTtcblxuICAgICAgICB2YXIgbmV3WCA9IHggLSBtb3VzZURvd24ueDtcbiAgICAgICAgLy92YXIgbmV3WSA9IHkgLSBtb3VzZURvd24ueTtcblxuICAgICAgICAvLyBpZiAocHJldmlvdXNEcmFnRXh0ZW50LnggPT09IG5ld1ggJiYgcHJldmlvdXNEcmFnRXh0ZW50LnkgPT09IG5ld1kpIHtcbiAgICAgICAgLy8gICAgIHJldHVybjtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50Q29sdW1uU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgZ3JpZC5zZWxlY3RDb2x1bW4obW91c2VEb3duLngsIHgpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludChuZXdYLCAwKSk7XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBjaGVja3Mgd2hpbGUgd2VyZSBkcmFnZ2luZyBpZiB3ZSBnbyBvdXRzaWRlIHRoZSB2aXNpYmxlIGJvdW5kcywgaWYgc28sIGtpY2sgb2ZmIHRoZSBleHRlcm5hbCBhdXRvc2Nyb2xsIGNoZWNrIGZ1bmN0aW9uIChhYm92ZSlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgY2hlY2tEcmFnU2Nyb2xsOiBmdW5jdGlvbihncmlkLCBtb3VzZSkge1xuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYiA9IGdyaWQuZ2V0RGF0YUJvdW5kcygpO1xuICAgICAgICB2YXIgaW5zaWRlID0gYi5jb250YWlucyhtb3VzZSk7XG4gICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgIGlmIChncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3codHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERyYWcoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCB3aGlsZSB3ZSBhcmUgZHJhZ2dpbmcgb3V0c2lkZSBvZiB0aGUgZ3JpZCB2aXNpYmxlIGJvdW5kcywgd2Ugc3Jjcm9sbCBhY2NvcmRpbmdseVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2Nyb2xsRHJhZzogZnVuY3Rpb24oZ3JpZCkge1xuXG4gICAgICAgIGlmICghZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdERyYWdDZWxsID0gdGhpcy5sYXN0RHJhZ0NlbGw7XG4gICAgICAgIHZhciBiID0gZ3JpZC5nZXREYXRhQm91bmRzKCk7XG4gICAgICAgIHZhciB4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIHlPZmZzZXQgPSAwO1xuXG4gICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIG51bUZpeGVkUm93cyA9IGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgIHZhciBkcmFnRW5kSW5GaXhlZEFyZWFYID0gbGFzdERyYWdDZWxsLnggPCBudW1GaXhlZENvbHVtbnM7XG4gICAgICAgIHZhciBkcmFnRW5kSW5GaXhlZEFyZWFZID0gbGFzdERyYWdDZWxsLnkgPCBudW1GaXhlZFJvd3M7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueCA8IGIub3JpZ2luLngpIHtcbiAgICAgICAgICAgIHhPZmZzZXQgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnggPiBiLm9yaWdpbi54ICsgYi5leHRlbnQueCkge1xuICAgICAgICAgICAgeE9mZnNldCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHJhZ0NlbGxPZmZzZXRYID0geE9mZnNldDtcbiAgICAgICAgdmFyIGRyYWdDZWxsT2Zmc2V0WSA9IHlPZmZzZXQ7XG5cbiAgICAgICAgaWYgKGRyYWdFbmRJbkZpeGVkQXJlYVgpIHtcbiAgICAgICAgICAgIGRyYWdDZWxsT2Zmc2V0WCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJhZ0VuZEluRml4ZWRBcmVhWSkge1xuICAgICAgICAgICAgZHJhZ0NlbGxPZmZzZXRZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdERyYWdDZWxsID0gbGFzdERyYWdDZWxsLnBsdXNYWShkcmFnQ2VsbE9mZnNldFgsIGRyYWdDZWxsT2Zmc2V0WSk7XG4gICAgICAgIGdyaWQuc2Nyb2xsQnkoeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCBsYXN0RHJhZ0NlbGwsIFtdKTsgLy8gdXBkYXRlIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5zY3JvbGxEcmFnLmJpbmQodGhpcywgZ3JpZCksIDI1KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBleHRlbmQgYSBzZWxlY3Rpb24gb3IgY3JlYXRlIG9uZSBpZiB0aGVyZSBpc250IHlldFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyaWRDZWxsIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGV4dGVuZFNlbGVjdGlvbjogZnVuY3Rpb24oZ3JpZCwgZ3JpZENlbGwsIGtleXMpIHtcbiAgICAgICAgZ3JpZC5zdG9wRWRpdGluZygpO1xuICAgICAgICAvL3ZhciBoYXNDVFJMID0ga2V5cy5pbmRleE9mKCdDVFJMJykgIT09IC0xO1xuICAgICAgICB2YXIgaGFzU0hJRlQgPSBrZXlzLmluZGV4T2YoJ1NISUZUJykgIT09IC0xO1xuXG4gICAgICAgIC8vIHZhciBzY3JvbGxUb3AgPSBncmlkLmdldFZTY3JvbGxWYWx1ZSgpO1xuICAgICAgICAvLyB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG5cbiAgICAgICAgLy8gdmFyIG51bUZpeGVkQ29sdW1ucyA9IDA7Ly9ncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgLy8gdmFyIG51bUZpeGVkUm93cyA9IDA7Ly9ncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICB2YXIgbW91c2VQb2ludCA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG4gICAgICAgIHZhciB4ID0gZ3JpZENlbGwueDsgLy8gLSBudW1GaXhlZENvbHVtbnMgKyBzY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgeSA9IGdyaWRDZWxsLnk7IC8vIC0gbnVtRml4ZWRSb3dzICsgc2Nyb2xsVG9wO1xuXG4gICAgICAgIC8vd2VyZSBvdXRzaWRlIG9mIHRoZSBncmlkIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHggPCAwIHx8IHkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL3dlIGhhdmUgcmVwZWF0ZWQgYSBjbGljayBpbiB0aGUgc2FtZSBzcG90IGRlc2xlY3QgdGhlIHZhbHVlIGZyb20gbGFzdCB0aW1lXG4gICAgICAgIC8vIGlmIChtb3VzZVBvaW50ICYmIHggPT09IG1vdXNlUG9pbnQueCAmJiB5ID09PSBtb3VzZVBvaW50LnkpIHtcbiAgICAgICAgLy8gICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIC8vICAgICBncmlkLnBvcE1vdXNlRG93bigpO1xuICAgICAgICAvLyAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgIC8vICAgICByZXR1cm47XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBpZiAoIWhhc0NUUkwgJiYgIWhhc1NISUZUKSB7XG4gICAgICAgIC8vICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWYgKGhhc1NISUZUKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbigpO1xuICAgICAgICAgICAgZ3JpZC5zZWxlY3RDb2x1bW4oeCwgbW91c2VQb2ludC54KTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KHggLSBtb3VzZVBvaW50LngsIDApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyaWQudG9nZ2xlU2VsZWN0Q29sdW1uKHgsIGtleXMpO1xuICAgICAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludCh4LCB5KSk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGFuZGxlRE9XTlNISUZUOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVVBTSElGVDogZnVuY3Rpb24oZ3JpZCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlRTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFRTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVET1dOOiBmdW5jdGlvbihncmlkKSB7XG5cbiAgICAgICAgLy8gdmFyIG1vdXNlQ29ybmVyID0gZ3JpZC5nZXRNb3VzZURvd24oKS5wbHVzKGdyaWQuZ2V0RHJhZ0V4dGVudCgpKTtcbiAgICAgICAgLy8gdmFyIG1heFJvd3MgPSBncmlkLmdldFJvd0NvdW50KCkgLSAxO1xuXG4gICAgICAgIC8vIHZhciBuZXdYID0gbW91c2VDb3JuZXIueDtcbiAgICAgICAgLy8gdmFyIG5ld1kgPSBncmlkLmdldEhlYWRlclJvd0NvdW50KCkgKyBncmlkLmdldFZTY3JvbGxWYWx1ZSgpO1xuXG4gICAgICAgIC8vIG5ld1kgPSBNYXRoLm1pbihtYXhSb3dzLCBuZXdZKTtcblxuICAgICAgICAvLyBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAvLyBncmlkLnNlbGVjdChuZXdYLCBuZXdZLCAwLCAwKTtcbiAgICAgICAgLy8gZ3JpZC5zZXRNb3VzZURvd24obmV3IGdyaWQucmVjdGFuZ3VsYXIuUG9pbnQobmV3WCwgbmV3WSkpO1xuICAgICAgICAvLyBncmlkLnNldERyYWdFeHRlbnQobmV3IGdyaWQucmVjdGFuZ3VsYXIuUG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIC8vIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVVQOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTEVGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBJZiB3ZSBhcmUgaG9sZGluZyBkb3duIHRoZSBzYW1lIG5hdmlnYXRpb24ga2V5LCBhY2NlbGVyYXRlIHRoZSBpbmNyZW1lbnQgd2Ugc2Nyb2xsXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbEFjY2VsZXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDE7XG4gICAgICAgIHZhciBlbGFwc2VkID0gdGhpcy5nZXRBdXRvU2Nyb2xsRHVyYXRpb24oKSAvIDIwMDA7XG4gICAgICAgIGNvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihlbGFwc2VkICogZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkKSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIHN0YXJ0IHRpbWUgdG8gcmlnaHQgbm93IHdoZW4gd2UgaW5pdGlhdGUgYW4gYXV0byBzY3JvbGxcbiAgICAgKi9cbiAgICBzZXRBdXRvU2Nyb2xsU3RhcnRUaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zYkF1dG9TdGFydCA9IERhdGUubm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXBkYXRlIHRoZSBhdXRvc2Nyb2xsIHN0YXJ0IHRpbWUgaWYgd2UgaGF2ZW4ndCBhdXRvc2Nyb2xsZWQgd2l0aGluIHRoZSBsYXN0IDUwMG1zIG90aGVyd2lzZSB1cGRhdGUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCB0aW1lXG4gICAgICovXG4gICAgcGluZ0F1dG9TY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyAtIHRoaXMuc2JMYXN0QXV0byA+IDUwMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdXRvU2Nyb2xsU3RhcnRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zYkxhc3RBdXRvID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbnN3ZXIgaG93IGxvbmcgd2UgaGF2ZSBiZWVuIGF1dG8gc2Nyb2xsaW5nXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbER1cmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5zYkF1dG9TdGFydDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBdWdtZW50IHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gZXh0ZW50IGJ5IChvZmZzZXRYLG9mZnNldFkpIGFuZCBzY3JvbGwgaWYgbmVjZXNzYXJ5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqL1xuICAgIG1vdmVTaGlmdFNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgb2Zmc2V0WCkge1xuXG4gICAgICAgIHZhciBtYXhDb2x1bW5zID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMTtcblxuICAgICAgICB2YXIgbWF4Vmlld2FibGVDb2x1bW5zID0gZ3JpZC5nZXRWaXNpYmxlQ29sdW1ucygpIC0gMTtcblxuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBtYXhWaWV3YWJsZUNvbHVtbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9yaWdpbiA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG4gICAgICAgIHZhciBleHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKTtcblxuICAgICAgICB2YXIgbmV3WCA9IGV4dGVudC54ICsgb2Zmc2V0WDtcbiAgICAgICAgLy92YXIgbmV3WSA9IGdyaWQuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucyAtIG9yaWdpbi54LCBNYXRoLm1heCgtb3JpZ2luLngsIG5ld1gpKTtcblxuICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbigpO1xuICAgICAgICBncmlkLnNlbGVjdENvbHVtbihvcmlnaW4ueCwgb3JpZ2luLnggKyBuZXdYKTtcblxuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludChuZXdYLCAwKSk7XG5cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxDb2xJc1Zpc2libGUobmV3WCArIG9yaWdpbi54LCBvZmZzZXRYKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXBsYWNlIHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gd2l0aCBhIHNpbmdsZSBjZWxsIHNlbGVjdGlvbiB0aGF0IGlzIG1vdmVkIChvZmZzZXRYLG9mZnNldFkpIGZyb20gdGhlIHByZXZpb3VzIHNlbGVjdGlvbiBleHRlbnQuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICovXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgb2Zmc2V0WCkge1xuXG4gICAgICAgIHZhciBtYXhDb2x1bW5zID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMTtcblxuICAgICAgICB2YXIgbWF4Vmlld2FibGVDb2x1bW5zID0gZ3JpZC5nZXRWaXNpYmxlQ29sdW1uc0NvdW50KCkgLSAxO1xuXG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgbWF4Q29sdW1ucyA9IE1hdGgubWluKG1heENvbHVtbnMsIG1heFZpZXdhYmxlQ29sdW1ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW91c2VDb3JuZXIgPSBncmlkLmdldE1vdXNlRG93bigpLnBsdXMoZ3JpZC5nZXREcmFnRXh0ZW50KCkpO1xuXG4gICAgICAgIHZhciBuZXdYID0gbW91c2VDb3JuZXIueCArIG9mZnNldFg7XG4gICAgICAgIC8vdmFyIG5ld1kgPSBncmlkLmdldFJvd0NvdW50KCk7XG5cbiAgICAgICAgbmV3WCA9IE1hdGgubWluKG1heENvbHVtbnMsIE1hdGgubWF4KDAsIG5ld1gpKTtcblxuICAgICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICBncmlkLnNlbGVjdENvbHVtbihuZXdYKTtcbiAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludChuZXdYLCAwKSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcblxuICAgICAgICBpZiAoZ3JpZC5pbnN1cmVNb2RlbENvbElzVmlzaWJsZShuZXdYLCBvZmZzZXRYKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG5cbiAgICB9LFxuXG4gICAgaXNDb2x1bW5EcmFnZ2luZzogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB2YXIgZHJhZ2dlciA9IGdyaWQubG9va3VwRmVhdHVyZSgnQ29sdW1uTW92aW5nJyk7XG4gICAgICAgIGlmICghZHJhZ2dlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0FjdGl2YXRlZCA9IGRyYWdnZXIuZHJhZ2dpbmcgJiYgIXRoaXMuZHJhZ2dpbmc7XG4gICAgICAgIHJldHVybiBpc0FjdGl2YXRlZDtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtblNlbGVjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENvbHVtblNvcnRpbmcgPSBGZWF0dXJlLmV4dGVuZCgnQ29sdW1uU29ydGluZycsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5Tb3J0aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICBpZiAoZ3JpZC5pc1Nob3dIZWFkZXJSb3coKSAmJiBncmlkQ2VsbC55ID09PSAwICYmIGdyaWRDZWxsLnggIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5rZXlzO1xuICAgICAgICAgICAgZ3JpZC50b2dnbGVTb3J0KGdyaWRDZWxsLngsIGtleXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU29ydGluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciB5ID0gZXZlbnQuZ3JpZENlbGwueTtcbiAgICAgICAgaWYgKHRoaXMuaXNGaXhlZFJvdyhncmlkLCBldmVudCkgJiYgeSA8IDEpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZU1vdmUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5Tb3J0aW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL2xpYi9CYXNlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZGVzYyBpbnN0YW5jZXMgb2YgZmVhdHVyZXMgYXJlIGNvbm5lY3RlZCB0byBvbmUgYW5vdGhlciB0byBtYWtlIGEgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkgZm9yIGhhbmRsaW5nIGFsbCB0aGUgaW5wdXQgdG8gdGhlIGh5cGVyZ3JpZC5cbiAqL1xudmFyIEZlYXR1cmUgPSBCYXNlLmV4dGVuZCgnRmVhdHVyZScsIHtcblxuICAgIC8qKlxuICAgICAqIHRoZSBuZXh0IGZlYXR1cmUgdG8gYmUgZ2l2ZW4gYSBjaGFuY2UgdG8gaGFuZGxlIGluY29taW5nIGV2ZW50c1xuICAgICAqIEB0eXBlIHtGZWF0dXJlfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBuZXh0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogYSB0ZW1wb3JhcnkgaG9sZGluZyBmaWVsZCBmb3IgbXkgbmV4dCBmZWF0dXJlIHdoZW4gSSdtIGluIGEgZGlzY29ubmVjdGVkIHN0YXRlXG4gICAgICogQHR5cGUge0ZlYXR1cmV9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRldGFjaGVkOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGN1cnNvciBJIHdhbnQgdG8gYmUgZGlzcGxheWVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICovXG4gICAgY3Vyc29yOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGNlbGwgbG9jYXRpb24gd2hlcmUgdGhlIGN1cnNvciBpcyBjdXJyZW50bHlcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGN1cnJlbnRIb3ZlckNlbGw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgbXkgbmV4dCBmaWVsZCwgb3IgaWYgaXQncyBwb3B1bGF0ZWQgZGVsZWdhdGUgdG8gdGhlIGZlYXR1cmUgaW4gbXkgbmV4dCBmaWVsZFxuICAgICAqIEBwYXJhbSB7RmVhdHVyZX0gbmV4dEZlYXR1cmUgLSB0aGlzIGlzIGhvdyB3ZSBidWlsZCB0aGUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKi9cbiAgICBzZXROZXh0OiBmdW5jdGlvbihuZXh0RmVhdHVyZSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuc2V0TmV4dChuZXh0RmVhdHVyZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBuZXh0RmVhdHVyZTtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoZWQgPSBuZXh0RmVhdHVyZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkaXNjb25uZWN0IG15IGNoaWxkXG4gICAgICovXG4gICAgZGV0YWNoQ2hhaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZWF0dGFjaCBteSBjaGlsZCBmcm9tIHRoZSBkZXRhY2hlZCByZWZlcmVuY2VcbiAgICAgKi9cbiAgICBhdHRhY2hDaGFpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHRoaXMuZGV0YWNoZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSBtb3VzZSBtb3ZlIGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRXhpdDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRXhpdChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZUVudGVyOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VFbnRlcihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5VXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVXaGVlbE1vdmVkOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlV2hlZWxNb3ZlZChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUNvbnRleHRNZW51OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ29udGV4dE1lbnUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRvZ2dsZSB0aGUgY29sdW1uIHBpY2tlclxuICAgICAqL1xuXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgeCwgeSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQubW92ZVNpbmdsZVNlbGVjdChncmlkLCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRml4ZWRSb3c6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgdmFyIGlzRml4ZWQgPSBncmlkQ2VsbC55IDwgZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgICAgIHJldHVybiBpc0ZpeGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRmlyc3RGaXhlZFJvdzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICB2YXIgaXNGaXhlZCA9IGdyaWRDZWxsLnkgPCAxO1xuICAgICAgICByZXR1cm4gaXNGaXhlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpeGVkQ29sdW1uOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldmVudC52aWV3UG9pbnQ7XG4gICAgICAgIHZhciBpc0ZpeGVkID0gZ3JpZENlbGwueCA8IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICByZXR1cm4gaXNGaXhlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpcnN0Rml4ZWRDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgdmFyIGVkZ2UgPSBncmlkLmlzU2hvd1Jvd051bWJlcnMoKSA/IDAgOiAxO1xuICAgICAgICB2YXIgaXNGaXhlZCA9IGdyaWRDZWxsLnggPCBlZGdlO1xuICAgICAgICByZXR1cm4gaXNGaXhlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc1RvcExlZnQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc1RvcExlZnQgPSB0aGlzLmlzRml4ZWRSb3coZ3JpZCwgZXZlbnQpICYmIHRoaXMuaXNGaXhlZENvbHVtbihncmlkLCBldmVudCk7XG4gICAgICAgIHJldHVybiBpc1RvcExlZnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgc2V0Q3Vyc29yOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKSB7XG4gICAgICAgICAgICBncmlkLmJlQ3Vyc29yKHRoaXMuY3Vyc29yKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGluaXRpYWxpemVPbjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaW5pdGlhbGl6ZU9uKGdyaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGZWF0dXJlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRmlsdGVycyA9IEZlYXR1cmUuZXh0ZW5kKCdGaWx0ZXJzJywge1xuXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChncmlkLmlzRmlsdGVyUm93KGV2ZW50LmdyaWRDZWxsLnkpKSB7XG4gICAgICAgICAgICBncmlkLm9uRWRpdG9yQWN0aXZhdGUoZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKGdyaWQuaXNGaWx0ZXJSb3coZXZlbnQuZ3JpZENlbGwueSkpIHtcbiAgICAgICAgICAgIGdyaWQub25FZGl0b3JBY3RpdmF0ZShldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG52YXIgY29tbWFuZHMgPSB7XG4gICAgUEFHRURPV046IGZ1bmN0aW9uKGdyaWQpIHsgZ3JpZC5wYWdlRG93bigpOyB9LFxuICAgIFBBR0VVUDogZnVuY3Rpb24oZ3JpZCkgeyBncmlkLnBhZ2VVcCgpOyB9LFxuICAgIFBBR0VMRUZUOiBmdW5jdGlvbihncmlkKSB7IGdyaWQucGFnZUxlZnQoKTsgfSxcbiAgICBQQUdFUklHSFQ6IGZ1bmN0aW9uKGdyaWQpIHsgZ3JpZC5wYWdlUmlnaHQoKTsgfVxufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEtleVBhZ2luZyA9IEZlYXR1cmUuZXh0ZW5kKCdLZXlQYWdpbmcnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAbWVtYmVyT2YgS2V5UGFnaW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGhhbmRsZUtleURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBmdW5jID0gY29tbWFuZHNbZXZlbnQuZGV0YWlsLmNoYXJdO1xuICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgZnVuYyhncmlkKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5UGFnaW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgT25Ib3ZlciA9IEZlYXR1cmUuZXh0ZW5kKCdPbkhvdmVyJywge1xuXG4gICAgLyoqXG4gICAgICogQGRlc2MgSGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBtZW1iZXJPZiBPbkhvdmVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlTW92ZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRIb3ZlckNlbGwgPSBncmlkLmdldEhvdmVyQ2VsbCgpO1xuICAgICAgICBpZiAoIWV2ZW50LmdyaWRDZWxsLmVxdWFscyhjdXJyZW50SG92ZXJDZWxsKSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRIb3ZlckNlbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRXhpdChncmlkLCBjdXJyZW50SG92ZXJDZWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VFbnRlcihncmlkLCBldmVudCk7XG4gICAgICAgICAgICBncmlkLnNldEhvdmVyQ2VsbChldmVudC5ncmlkQ2VsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9uSG92ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb2x1bW5SZXNpemluZyA9IHJlcXVpcmUoJy4vQ29sdW1uUmVzaXppbmcnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFJvd1Jlc2l6aW5nID0gQ29sdW1uUmVzaXppbmcuZXh0ZW5kKCdSb3dSZXNpemluZycsIHtcblxuICAgIC8qKlxuICAgICAqIHRoZSBpbmRleCBvZiB0aGUgcm93L2NvbHVtbiB3ZSBhcmUgZHJhZ2dpbmdcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdBcmVhOiAtMSxcblxuICAgIC8qKlxuICAgICAqIHRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgd2hlcmUgdGhlIGRyYWcgd2FzIGluaXRpYXRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ1N0YXJ0OiAtMSxcblxuICAgIC8qKlxuICAgICAqIHRoZSBzdGFydGluZyB3aWR0aC9oZWlnaHQgb2YgdGhlIHJvdy9jb2x1bW4gd2UgYXJlIGRyYWdnaW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnQXJlYVN0YXJ0aW5nU2l6ZTogLTEsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2V0IHRoZSBtb3VzZSB4LHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIHRoZSBtb3VzZSBldmVudCB0byBxdWVyeVxuICAgICAqL1xuICAgIGdldE1vdXNlVmFsdWU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdldCB0aGUgZ3JpZCBjZWxsIHgseSBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBncmlkQ2VsbFxuICAgICAqL1xuICAgIGdldEdyaWRDZWxsVmFsdWU6IGZ1bmN0aW9uKGdyaWRDZWxsKSB7XG4gICAgICAgIHJldHVybiBncmlkQ2VsbC54O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSBncmlkcyB4LHkgc2Nyb2xsIHZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGdldFNjcm9sbFZhbHVlOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldFZTY3JvbGxWYWx1ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIHJvdy9jb2x1bW4gb2YgaW50ZXJlc3RcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRBcmVhU2l6ZTogZnVuY3Rpb24oZ3JpZCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0Um93SGVpZ2h0KGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSByb3cvY29sdW1uIGF0IGluZGV4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSByb3cvY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdGhlIHdpZHRoL2hlaWdodCB0byBzZXQgdG9cbiAgICAgKi9cbiAgICBzZXRBcmVhU2l6ZTogZnVuY3Rpb24oZ3JpZCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGdyaWQuc2V0Um93SGVpZ2h0KGluZGV4LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm5zIHRoZSBpbmRleCBvZiB3aGljaCBkaXZpZGVyIEknbSBvdmVyXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb3ZlckFyZWFEaXZpZGVyOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5vdmVyUm93RGl2aWRlcihldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbSBJIG92ZXIgdGhlIGNvbHVtbi9yb3cgYXJlYVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpcnN0Rml4ZWRPdGhlckFyZWE6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRmlyc3RGaXhlZENvbHVtbihncmlkLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIGN1cnNvciBuYW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDdXJzb3JOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICdyb3ctcmVzaXplJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgcmVjZW50bHkgcmVuZGVyZWQgYXJlYSdzIHdpZHRoL2hlaWdodFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgcm93L2NvbHVtbiBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqL1xuICAgIGdldFByZXZpb3VzQWJzb2x1dGVTaXplOiBmdW5jdGlvbihncmlkLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRSZW5kZXJlZEhlaWdodChpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIGZpeGVkIGFyZWEgcm93cy9jb2x1bW5zIGNvdW50XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGdldE90aGVyRml4ZWRBcmVhQ291bnQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRGaXhlZEFyZWFDb3VudDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCkgKyBncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCAtMlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuaXNSb3dSZXNpemVhYmxlKCk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3dSZXNpemluZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFJvd1NlbGVjdGlvbiA9IEZlYXR1cmUuZXh0ZW5kKCdSb3dTZWxlY3Rpb24nLCB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGN1cnJlbnREcmFnOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNlbGwgY29vcmRpbmF0ZXMgb2YgdGhlIHdoZXJlIHRoZSBtb3VzZSBwb2ludGVyIGlzIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgbGFzdERyYWdDZWxsOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHByZXZpb3VzIHRpbWUgYW4gYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkxhc3RBdXRvOiAwLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHRpbWUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkF1dG9TdGFydDogMCxcblxuICAgIGRyYWdBcm1lZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdBcm1lZCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnQXJtZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vZ2xvYmFsIHJvdyBzZWxlY3Rpb25cbiAgICAgICAgICAgIGlmIChldmVudC5ncmlkQ2VsbC54ID09PSAtMSAmJiBldmVudC5ncmlkQ2VsbC55ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC50b2dnbGVTZWxlY3RBbGxSb3dzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNSb3dTZWxlY3Rpb25DaGFuZ2VkRXZlbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNSb3dTZWxlY3Rpb25DaGFuZ2VkRXZlbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuXG4gICAgICAgIHZhciBpc1JpZ2h0Q2xpY2sgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuaXNSaWdodENsaWNrO1xuICAgICAgICB2YXIgY2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB2YXIgdmlld0NlbGwgPSBldmVudC52aWV3UG9pbnQ7XG4gICAgICAgIHZhciBkeCA9IGNlbGwueDtcbiAgICAgICAgdmFyIGR5ID0gY2VsbC55O1xuXG5cbiAgICAgICAgdmFyIGlzSGVhZGVyID0gZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCkgJiYgZHggPCAwO1xuXG4gICAgICAgIGlmICghZ3JpZC5pc1Jvd1NlbGVjdGlvbigpIHx8IGlzUmlnaHRDbGljayB8fCAhaXNIZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIG51bUZpeGVkUm93cyA9IGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgICAgICAvL2lmIHdlIGFyZSBpbiB0aGUgZml4ZWQgYXJlYSBkbyBub3QgYXBwbHkgdGhlIHNjcm9sbCB2YWx1ZXNcbiAgICAgICAgICAgIC8vY2hlY2sgYm90aCB4IGFuZCB5IHZhbHVlcyBpbmRlcGVuZGVudGx5XG4gICAgICAgICAgICBpZiAodmlld0NlbGwueSA8IG51bUZpeGVkUm93cykge1xuICAgICAgICAgICAgICAgIGR5ID0gdmlld0NlbGwueTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRDZWxsID0gZ3JpZC5uZXdQb2ludCgwLCBkeSk7XG5cbiAgICAgICAgICAgIHZhciBwcmltRXZlbnQgPSBldmVudC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHZhciBrZXlzID0gcHJpbUV2ZW50LmRldGFpbC5rZXlzO1xuICAgICAgICAgICAgdGhpcy5kcmFnQXJtZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5leHRlbmRTZWxlY3Rpb24oZ3JpZCwgZENlbGwsIGtleXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc1JpZ2h0Q2xpY2sgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuaXNSaWdodENsaWNrO1xuXG4gICAgICAgIGlmICghdGhpcy5kcmFnQXJtZWQgfHwgIWdyaWQuaXNSb3dTZWxlY3Rpb24oKSB8fCBpc1JpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG51bUZpeGVkUm93cyA9IGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgICAgICB2YXIgY2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICAgICAgdmFyIHZpZXdDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICAgICAgLy92YXIgZHggPSBjZWxsLng7XG4gICAgICAgICAgICB2YXIgZHkgPSBjZWxsLnk7XG5cbiAgICAgICAgICAgIC8vaWYgd2UgYXJlIGluIHRoZSBmaXhlZCBhcmVhIGRvIG5vdCBhcHBseSB0aGUgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy9jaGVjayBib3RoIHggYW5kIHkgdmFsdWVzIGluZGVwZW5kZW50bHlcbiAgICAgICAgICAgIGlmICh2aWV3Q2VsbC55IDwgbnVtRml4ZWRSb3dzKSB7XG4gICAgICAgICAgICAgICAgZHkgPSB2aWV3Q2VsbC55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZENlbGwgPSBncmlkLm5ld1BvaW50KDAsIGR5KTtcblxuICAgICAgICAgICAgdmFyIHByaW1FdmVudCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhZyA9IHByaW1FdmVudC5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB0aGlzLmxhc3REcmFnQ2VsbCA9IGRDZWxsO1xuXG4gICAgICAgICAgICB0aGlzLmNoZWNrRHJhZ1Njcm9sbChncmlkLCB0aGlzLmN1cnJlbnREcmFnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCBkQ2VsbCwgcHJpbUV2ZW50LmRldGFpbC5rZXlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGhhbmRsZXI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGdyaWQuZ2V0TGFzdFNlbGVjdGlvblR5cGUoKSA9PT0gJ3JvdycgJiZcbiAgICAgICAgICAgIChoYW5kbGVyID0gdGhpc1snaGFuZGxlJyArIGV2ZW50LmRldGFpbC5jaGFyXSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgZ3JpZCwgZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSBhIG1vdXNlZHJhZyBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIGFycmF5IG9mIHRoZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBwcmVzc2VkIGRvd25cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uOiBmdW5jdGlvbihncmlkLCBncmlkQ2VsbCwga2V5cykge1xuICAgICAgICB2YXIgeSA9IGdyaWRDZWxsLnk7XG4gICAgICAgIC8vICAgICAgICAgICAgdmFyIHByZXZpb3VzRHJhZ0V4dGVudCA9IGdyaWQuZ2V0RHJhZ0V4dGVudCgpO1xuICAgICAgICB2YXIgbW91c2VEb3duID0gZ3JpZC5nZXRNb3VzZURvd24oKTtcblxuICAgICAgICB2YXIgbmV3WSA9IHkgLSBtb3VzZURvd24ueTtcbiAgICAgICAgLy92YXIgbmV3WSA9IHkgLSBtb3VzZURvd24ueTtcblxuICAgICAgICAvLyBpZiAocHJldmlvdXNEcmFnRXh0ZW50LnggPT09IG5ld1ggJiYgcHJldmlvdXNEcmFnRXh0ZW50LnkgPT09IG5ld1kpIHtcbiAgICAgICAgLy8gICAgIHJldHVybjtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50Um93U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgZ3JpZC5zZWxlY3RSb3cobW91c2VEb3duLnksIHkpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCBuZXdZKSk7XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBjaGVja3Mgd2hpbGUgd2VyZSBkcmFnZ2luZyBpZiB3ZSBnbyBvdXRzaWRlIHRoZSB2aXNpYmxlIGJvdW5kcywgaWYgc28sIGtpY2sgb2ZmIHRoZSBleHRlcm5hbCBhdXRvc2Nyb2xsIGNoZWNrIGZ1bmN0aW9uIChhYm92ZSlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgY2hlY2tEcmFnU2Nyb2xsOiBmdW5jdGlvbihncmlkLCBtb3VzZSkge1xuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYiA9IGdyaWQuZ2V0RGF0YUJvdW5kcygpO1xuICAgICAgICB2YXIgaW5zaWRlID0gYi5jb250YWlucyhtb3VzZSk7XG4gICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgIGlmIChncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3codHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERyYWcoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCB3aGlsZSB3ZSBhcmUgZHJhZ2dpbmcgb3V0c2lkZSBvZiB0aGUgZ3JpZCB2aXNpYmxlIGJvdW5kcywgd2Ugc3Jjcm9sbCBhY2NvcmRpbmdseVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2Nyb2xsRHJhZzogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3REcmFnQ2VsbCA9IHRoaXMubGFzdERyYWdDZWxsO1xuICAgICAgICB2YXIgYiA9IGdyaWQuZ2V0RGF0YUJvdW5kcygpO1xuICAgICAgICB2YXIgeE9mZnNldCA9IDA7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gMDtcblxuICAgICAgICB2YXIgbnVtRml4ZWRDb2x1bW5zID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICB2YXIgZHJhZ0VuZEluRml4ZWRBcmVhWCA9IGxhc3REcmFnQ2VsbC54IDwgbnVtRml4ZWRDb2x1bW5zO1xuICAgICAgICB2YXIgZHJhZ0VuZEluRml4ZWRBcmVhWSA9IGxhc3REcmFnQ2VsbC55IDwgbnVtRml4ZWRSb3dzO1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnkgPCBiLm9yaWdpbi55KSB7XG4gICAgICAgICAgICB5T2Zmc2V0ID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy55ID4gYi5vcmlnaW4ueSArIGIuZXh0ZW50LnkpIHtcbiAgICAgICAgICAgIHlPZmZzZXQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRyYWdDZWxsT2Zmc2V0WCA9IHhPZmZzZXQ7XG4gICAgICAgIHZhciBkcmFnQ2VsbE9mZnNldFkgPSB5T2Zmc2V0O1xuXG4gICAgICAgIGlmIChkcmFnRW5kSW5GaXhlZEFyZWFYKSB7XG4gICAgICAgICAgICBkcmFnQ2VsbE9mZnNldFggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyYWdFbmRJbkZpeGVkQXJlYVkpIHtcbiAgICAgICAgICAgIGRyYWdDZWxsT2Zmc2V0WSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3REcmFnQ2VsbCA9IGxhc3REcmFnQ2VsbC5wbHVzWFkoZHJhZ0NlbGxPZmZzZXRYLCBkcmFnQ2VsbE9mZnNldFkpO1xuICAgICAgICBncmlkLnNjcm9sbEJ5KHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb24oZ3JpZCwgbGFzdERyYWdDZWxsLCBbXSk7IC8vIHVwZGF0ZSB0aGUgc2VsZWN0aW9uXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuc2Nyb2xsRHJhZy5iaW5kKHRoaXMsIGdyaWQpLCAyNSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgZXh0ZW5kIGEgc2VsZWN0aW9uIG9yIGNyZWF0ZSBvbmUgaWYgdGhlcmUgaXNudCB5ZXRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmlkQ2VsbCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIGFycmF5IG9mIHRoZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBwcmVzc2VkIGRvd25cbiAgICAgKi9cbiAgICBleHRlbmRTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIGdyaWRDZWxsLCBrZXlzKSB7XG4gICAgICAgIGdyaWQuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgLy92YXIgaGFzQ1RSTCA9IGtleXMuaW5kZXhPZignQ1RSTCcpICE9PSAtMTtcbiAgICAgICAgdmFyIGhhc1NISUZUID0ga2V5cy5pbmRleE9mKCdTSElGVCcpICE9PSAtMTtcblxuICAgICAgICB2YXIgbW91c2VQb2ludCA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG4gICAgICAgIHZhciB4ID0gZ3JpZENlbGwueDsgLy8gLSBudW1GaXhlZENvbHVtbnMgKyBzY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgeSA9IGdyaWRDZWxsLnk7IC8vIC0gbnVtRml4ZWRSb3dzICsgc2Nyb2xsVG9wO1xuXG4gICAgICAgIC8vd2VyZSBvdXRzaWRlIG9mIHRoZSBncmlkIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHggPCAwIHx8IHkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50Um93U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBncmlkLnNlbGVjdFJvdyh5LCBtb3VzZVBvaW50LnkpO1xuICAgICAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgeSAtIG1vdXNlUG9pbnQueSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JpZC50b2dnbGVTZWxlY3RSb3coeSwga2V5cyk7XG4gICAgICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KHgsIHkpKTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcbiAgICAgICAgfVxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBoYW5kbGVET1dOU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVVBTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTEVGVFNISUZUOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFRTSElGVDogZnVuY3Rpb24oZ3JpZCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZURPV046IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVVQOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTEVGVDogZnVuY3Rpb24oZ3JpZCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUOiBmdW5jdGlvbihncmlkKSB7XG5cbiAgICAgICAgdmFyIG1vdXNlQ29ybmVyID0gZ3JpZC5nZXRNb3VzZURvd24oKS5wbHVzKGdyaWQuZ2V0RHJhZ0V4dGVudCgpKTtcbiAgICAgICAgdmFyIG1heENvbHVtbnMgPSBncmlkLmdldENvbHVtbkNvdW50KCkgLSAxO1xuXG4gICAgICAgIHZhciBuZXdYID0gZ3JpZC5nZXRIZWFkZXJDb2x1bW5Db3VudCgpICsgZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgdmFyIG5ld1kgPSBtb3VzZUNvcm5lci55O1xuXG4gICAgICAgIG5ld1ggPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBuZXdYKTtcblxuICAgICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICBncmlkLnNlbGVjdChuZXdYLCBuZXdZLCAwLCAwKTtcbiAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludChuZXdYLCBuZXdZKSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBJZiB3ZSBhcmUgaG9sZGluZyBkb3duIHRoZSBzYW1lIG5hdmlnYXRpb24ga2V5LCBhY2NlbGVyYXRlIHRoZSBpbmNyZW1lbnQgd2Ugc2Nyb2xsXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbEFjY2VsZXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDE7XG4gICAgICAgIHZhciBlbGFwc2VkID0gdGhpcy5nZXRBdXRvU2Nyb2xsRHVyYXRpb24oKSAvIDIwMDA7XG4gICAgICAgIGNvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihlbGFwc2VkICogZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkKSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIHN0YXJ0IHRpbWUgdG8gcmlnaHQgbm93IHdoZW4gd2UgaW5pdGlhdGUgYW4gYXV0byBzY3JvbGxcbiAgICAgKi9cbiAgICBzZXRBdXRvU2Nyb2xsU3RhcnRUaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zYkF1dG9TdGFydCA9IERhdGUubm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXBkYXRlIHRoZSBhdXRvc2Nyb2xsIHN0YXJ0IHRpbWUgaWYgd2UgaGF2ZW4ndCBhdXRvc2Nyb2xsZWQgd2l0aGluIHRoZSBsYXN0IDUwMG1zIG90aGVyd2lzZSB1cGRhdGUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCB0aW1lXG4gICAgICovXG4gICAgcGluZ0F1dG9TY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyAtIHRoaXMuc2JMYXN0QXV0byA+IDUwMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdXRvU2Nyb2xsU3RhcnRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zYkxhc3RBdXRvID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbnN3ZXIgaG93IGxvbmcgd2UgaGF2ZSBiZWVuIGF1dG8gc2Nyb2xsaW5nXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbER1cmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5zYkF1dG9TdGFydDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBdWdtZW50IHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gZXh0ZW50IGJ5IChvZmZzZXRYLG9mZnNldFkpIGFuZCBzY3JvbGwgaWYgbmVjZXNzYXJ5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqL1xuICAgIG1vdmVTaGlmdFNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgb2Zmc2V0WSkge1xuXG4gICAgICAgIHZhciBtYXhSb3dzID0gZ3JpZC5nZXRSb3dDb3VudCgpIC0gMTtcblxuICAgICAgICB2YXIgbWF4Vmlld2FibGVSb3dzID0gZ3JpZC5nZXRWaXNpYmxlUm93cygpIC0gMTtcblxuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIG1heFJvd3MgPSBNYXRoLm1pbihtYXhSb3dzLCBtYXhWaWV3YWJsZVJvd3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9yaWdpbiA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG4gICAgICAgIHZhciBleHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKTtcblxuICAgICAgICB2YXIgbmV3WSA9IGV4dGVudC55ICsgb2Zmc2V0WTtcbiAgICAgICAgLy92YXIgbmV3WSA9IGdyaWQuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICBuZXdZID0gTWF0aC5taW4obWF4Um93cyAtIG9yaWdpbi55LCBNYXRoLm1heCgtb3JpZ2luLnksIG5ld1kpKTtcblxuICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbigpO1xuICAgICAgICBncmlkLnNlbGVjdFJvdyhvcmlnaW4ueSwgb3JpZ2luLnkgKyBuZXdZKTtcblxuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCBuZXdZKSk7XG5cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxSb3dJc1Zpc2libGUobmV3WSArIG9yaWdpbi55LCBvZmZzZXRZKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5maXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50KCk7XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVwbGFjZSB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIHdpdGggYSBzaW5nbGUgY2VsbCBzZWxlY3Rpb24gdGhhdCBpcyBtb3ZlZCAob2Zmc2V0WCxvZmZzZXRZKSBmcm9tIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gZXh0ZW50LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqL1xuICAgIG1vdmVTaW5nbGVTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFkpIHtcblxuICAgICAgICB2YXIgbWF4Um93cyA9IGdyaWQuZ2V0Um93Q291bnQoKSAtIDE7XG5cbiAgICAgICAgdmFyIG1heFZpZXdhYmxlUm93cyA9IGdyaWQuZ2V0VmlzaWJsZVJvd3NDb3VudCgpIC0gMTtcblxuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIG1heFJvd3MgPSBNYXRoLm1pbihtYXhSb3dzLCBtYXhWaWV3YWJsZVJvd3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vdXNlQ29ybmVyID0gZ3JpZC5nZXRNb3VzZURvd24oKS5wbHVzKGdyaWQuZ2V0RHJhZ0V4dGVudCgpKTtcblxuICAgICAgICB2YXIgbmV3WSA9IG1vdXNlQ29ybmVyLnkgKyBvZmZzZXRZO1xuICAgICAgICAvL3ZhciBuZXdZID0gZ3JpZC5nZXRSb3dDb3VudCgpO1xuXG4gICAgICAgIG5ld1kgPSBNYXRoLm1pbihtYXhSb3dzLCBNYXRoLm1heCgwLCBuZXdZKSk7XG5cbiAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgZ3JpZC5zZWxlY3RSb3cobmV3WSk7XG4gICAgICAgIGdyaWQuc2V0TW91c2VEb3duKGdyaWQubmV3UG9pbnQoMCwgbmV3WSkpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG5cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxSb3dJc1Zpc2libGUobmV3WSwgb2Zmc2V0WSkpIHtcbiAgICAgICAgICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY1Jvd1NlbGVjdGlvbkNoYW5nZWRFdmVudCgpO1xuICAgICAgICBncmlkLnJlcGFpbnQoKTtcblxuICAgIH0sXG5cbiAgICBpc1NpbmdsZVJvd1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUm93U2VsZWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgVGh1bWJ3aGVlbFNjcm9sbGluZyA9IEZlYXR1cmUuZXh0ZW5kKCdUaHVtYndoZWVsU2Nyb2xsaW5nJywge1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFRodW1id2hlZWxTY3JvbGxpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVXaGVlbE1vdmVkOiBmdW5jdGlvbihncmlkLCBlKSB7XG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByaW1FdmVudCA9IGUucHJpbWl0aXZlRXZlbnQsXG4gICAgICAgICAgICBkZWx0YVggPSBNYXRoLnNpZ24ocHJpbUV2ZW50LndoZWVsRGVsdGFYIHx8IC1wcmltRXZlbnQuZGVsdGFYKSxcbiAgICAgICAgICAgIGRlbHRhWSA9IE1hdGguc2lnbihwcmltRXZlbnQud2hlZWxEZWx0YVkgfHwgLXByaW1FdmVudC5kZWx0YVkpO1xuXG4gICAgICAgIGlmIChkZWx0YVggfHwgZGVsdGFZKSB7XG4gICAgICAgICAgICBncmlkLnNjcm9sbEJ5KFxuICAgICAgICAgICAgICAgIC1kZWx0YVggfHwgMCwgLy8gMCBpZiBOYU5cbiAgICAgICAgICAgICAgICAtZGVsdGFZIHx8IDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVGh1bWJ3aGVlbFNjcm9sbGluZztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRmVhdHVyZTogcmVxdWlyZSgnLi9GZWF0dXJlJyksIC8vIGFic3RyYWN0IGJhc2UgY2xhc3NcbiAgICBDZWxsQ2xpY2s6IHJlcXVpcmUoJy4vQ2VsbENsaWNrJyksXG4gICAgQ2VsbEVkaXRpbmc6IHJlcXVpcmUoJy4vQ2VsbEVkaXRpbmcnKSxcbiAgICBDZWxsU2VsZWN0aW9uOiByZXF1aXJlKCcuL0NlbGxTZWxlY3Rpb24nKSxcbiAgICBDb2x1bW5BdXRvc2l6aW5nOiByZXF1aXJlKCcuL0NvbHVtbkF1dG9zaXppbmcnKSxcbiAgICBDb2x1bW5Nb3Zpbmc6IHJlcXVpcmUoJy4vQ29sdW1uTW92aW5nJyksXG4gICAgQ29sdW1uUmVzaXppbmc6IHJlcXVpcmUoJy4vQ29sdW1uUmVzaXppbmcnKSxcbiAgICBDb2x1bW5TZWxlY3Rpb246IHJlcXVpcmUoJy4vQ29sdW1uU2VsZWN0aW9uJyksXG4gICAgQ29sdW1uU29ydGluZzogcmVxdWlyZSgnLi9Db2x1bW5Tb3J0aW5nJyksXG4gICAgRmlsdGVyczogcmVxdWlyZSgnLi9GaWx0ZXJzJyksXG4gICAgS2V5UGFnaW5nOiByZXF1aXJlKCcuL0tleVBhZ2luZycpLFxuICAgIE9uSG92ZXI6IHJlcXVpcmUoJy4vT25Ib3ZlcicpLFxuICAgIENvbHVtblBpY2tlcjogcmVxdWlyZSgnLi9Db2x1bW5QaWNrZXInKSxcbiAgICBSb3dSZXNpemluZzogcmVxdWlyZSgnLi9Sb3dSZXNpemluZycpLFxuICAgIFJvd1NlbGVjdGlvbjogcmVxdWlyZSgnLi9Sb3dTZWxlY3Rpb24nKSxcbiAgICBUaHVtYndoZWVsU2Nyb2xsaW5nOiByZXF1aXJlKCcuL1RodW1id2hlZWxTY3JvbGxpbmcnKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBvcE1lbnUgPSByZXF1aXJlKCdwb3AtbWVudScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHN1bW1hcnkgQnVpbGQsIG9yZ2FuaXplLCBhbmQgc29ydCBhIGNvbHVtbiBzY2hlbWEgbGlzdCBmcm9tIGEgbGlzdCBvZiBjb2x1bW5zLlxuICogQGRlc2MgRmlsdGVyVHJlZSByZXF1aXJlcyBhIGNvbHVtbiBzY2hlbWEuIEFzIGEgZmFsbGJhY2sgd2hlbiB5b3UgZG9uJ3QgaGF2ZSBhIGNvbHVtbiBzY2hlbWEgb2YgeW91ciBvd24sIHRoZSBzdHJpbmcgYXJyYXkgcmV0dXJuZWQgYnkgYmVoYXZpb3IuZGF0YU1vZGVsLmdldEZpZWxkcygpIHdvdWxkIHdvcmsgYXMgaXMuIFRoaXMgZmFjdG9yeSBvYmplY3Qgd2lsbCBkbyBhIGxpdHRsZSBiZXR0ZXIgdGhhbiB0aGF0LCB0YWtpbmcgSHlwZXJncmlkJ3MgY29sdW1uIGFycmF5IGFuZCBjcmVhdGluZyBhIG1vcmUgdGV4dHVyZWQgY29sdW1uIHNjaGVtYSwgaW5jbHVkaW5nIGNvbHVtbiBhbGlhc2VzIGFuZCB0eXBlcy5cbiAqXG4gKiBDQVZFQVQ6IFNldCB1cCB0aGUgc2NoZW1hIGNvbXBsZXRlbHkgYmVmb3JlIGluc3RhbnRpYXRpbmcgeW91ciBmaWx0ZXIgc3RhdGUuIEZpbHRlci10cmVlIHVzZXMgdGhlIHNjaGVtYSAoaW4gcGFydCkgdG8gZ2VuZXJhdGUgY29sdW1uIHNlbGVjdGlvbiBkcm9wLWRvd25zIGFzIHBhcnQgb2YgaXRzIFwicXVlcnkgYnVpbGRlclwiIFVJLiBOb3RlIHRoYXQgdGhlIFVJIGlzICpub3QqIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCBpZiB5b3UgY2hhbmdlIHRoZSBzY2hlbWEgbGF0ZXIuXG4gKlxuICogQHBhcmFtIHtDb2x1bW5bXX0gY29sdW1uc1xuICpcbiAqIEBwcm9wZXJ0eSB7bWVudUl0ZW1bXX0gc2NoZW1hIC0gVGhpcyBpcyB0aGUgb3V0cHV0IHByb2R1Y2VkIGJ5IHRoZSBmYWN0b3J5LlxuICovXG5mdW5jdGlvbiBDb2x1bW5TY2hlbWFGYWN0b3J5KGNvbHVtbnMsIGZpbmRPcHRpb25zKSB7XG4gICAgdGhpcy5zY2hlbWEgPSBjb2x1bW5zLm1hcChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGNvbHVtbi5uYW1lLFxuICAgICAgICAgICAgYWxpYXM6IGNvbHVtbi5oZWFkZXIsXG4gICAgICAgICAgICB0eXBlOiBjb2x1bW4uZ2V0VHlwZSgpXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbkNvbHVtblNjaGVtYUZhY3RvcnkucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IENvbHVtblNjaGVtYUZhY3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgLyoqXG4gICAgICogT3JnYW5pemUgc2NoZW1hIGludG8gc3VibWVudXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IGNvbHVtbkdyb3Vwc1JlZ2V4IC0gU2NoZW1hIG5hbWVzIG9yIGFsaWFzZXMgdGhhdCBtYXRjaCB0aGlzIGFyZSBwdXQgaW50byBhIHN1Ym1lbnUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmtleT0nbmFtZSddIC0gTXVzdCBiZSBlaXRoZXIgJ25hbWUnIG9yICdhbGlhcycuXG4gICAgICovXG4gICAgb3JnYW5pemU6IGZ1bmN0aW9uKGNvbHVtbkdyb3Vwc1JlZ2V4LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBrZXkgPSBvcHRpb25zICYmIG9wdGlvbnMua2V5IHx8ICduYW1lJyxcbiAgICAgICAgICAgIHN1Ym1lbnVzID0ge30sXG4gICAgICAgICAgICBtZW51ID0gW107XG5cbiAgICAgICAgdGhpcy5zY2hlbWEuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBpdGVtW2tleV0sXG4gICAgICAgICAgICAgICAgZ3JvdXAgPSB2YWx1ZS5tYXRjaChjb2x1bW5Hcm91cHNSZWdleCk7XG4gICAgICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgICAgICBncm91cCA9IGdyb3VwWzBdO1xuICAgICAgICAgICAgICAgIGlmICghKGdyb3VwIGluIHN1Ym1lbnVzKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJtZW51c1tncm91cF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZ3JvdXAudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1lbnU6IFtdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1Ym1lbnVzW2dyb3VwXS5zdWJtZW51LnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lbnUucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgc3VibWVudU5hbWUgaW4gc3VibWVudXMpIHtcbiAgICAgICAgICAgIG1lbnUucHVzaChzdWJtZW51c1tzdWJtZW51TmFtZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY2hlbWEgPSBtZW51O1xuICAgIH0sXG5cbiAgICBsb29rdXA6IGZ1bmN0aW9uKGZpbmRPcHRpb25zLCB2YWx1ZSkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBwb3BNZW51Lmxvb2t1cC5hcHBseSh0aGlzLnNjaGVtYSwgYXJncyk7XG4gICAgfSxcblxuICAgIHdhbGs6IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHJldHVybiBwb3BNZW51LndhbGsuY2FsbCh0aGlzLnNjaGVtYSwgaXRlcmF0ZWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTb3J0IHRoZSBzY2hlbWEuXG4gICAgICogQGRlc2MgV2FsayB0aGUgbWVudSBzdHJ1Y3R1cmUsIHNvcnRpbmcgZWFjaCBzdWJtZW51IHVudGlsIGZpbmFsbHkgdGhlIHRvcC1sZXZlbCBtZW51IGlzIHNvcnRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ10gLSBBIHN1Ym1lbnUgc29ydCBwcmVmaXg6XG4gICAgICogKiBPbWl0IHRvIGdpdmUgbm8gc3BlY2lhbCB0cmVhdG1lbnQgdG8gc3VibWVudXMuXG4gICAgICogKiBHaXZlIGAnXFx1MDAwMCdgIHRvIHBsYWNlIGFsbCB0aGUgc3VibWVudXMgYXQgdGhlIHRvcCBvZiBlYWNoIGVuY2xvc2luZyBzdWJtZW51LlxuICAgICAqICogR2l2ZSBgJ1xcdWZmZmYnYCB0byBwbGFjZSBhbGwgdGhlIHN1Ym1lbnVzIGF0IHRoZSBib3R0b20gb2YgZWFjaCBlbmNsb3Npbmcgc3VibWVudS5cbiAgICAgKi9cbiAgICBzb3J0OiBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICAgICAgdGhpcy5zY2hlbWEuc29ydChmdW5jdGlvbiByZWN1cnNlKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhLmxhYmVsICYmICFhLnNvcnRlZCkge1xuICAgICAgICAgICAgICAgIGEuc3VibWVudS5zb3J0KHJlY3Vyc2UpO1xuICAgICAgICAgICAgICAgIGEuc29ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEgPSBhLmxhYmVsID8gcHJlZml4ICsgYS5sYWJlbCA6IGEuYWxpYXMgfHwgYS5uYW1lIHx8IGE7XG4gICAgICAgICAgICBiID0gYi5sYWJlbCA/IHByZWZpeCArIGIubGFiZWwgOiBiLmFsaWFzIHx8IGIubmFtZSB8fCBiO1xuICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtblNjaGVtYUZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpO1xuXG52YXIgRmlsdGVyVHJlZSA9IHJlcXVpcmUoJy4uL1NoYXJlZCcpLkZpbHRlclRyZWU7XG52YXIgUGFyc2VyQ1FMID0gcmVxdWlyZSgnLi9wYXJzZXItQ1FMJyk7XG5cbi8vIEFkZCBhIHByb3BlcnR5IGBtZW51TW9kZXNgIHRvIHRoZSB0cmVlLCBkZWZhdWx0aW5nIHRvIGBvcGVyYXRvcnNgIGFzIHRoZSBvbmx5IGFjdGl2ZSBtb2RlXG5GaWx0ZXJUcmVlLk5vZGUub3B0aW9uc1NjaGVtYS5tZW51TW9kZXMgPSB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgICBvcGVyYXRvcnM6IDFcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBxdW90ZSh0ZXh0KSB7XG4gICAgdmFyIHF0ID0gUGFyc2VyQ1FMLnF0O1xuICAgIHJldHVybiBxdCArIHRleHQucmVwbGFjZShuZXcgUmVnRXhwKHF0LCAnZycpLCBxdCArIHF0KSArIHF0O1xufVxuXG52YXIgbGlrZURyZXNzZXMgPSBbXG4gICAgeyByZWdleDogL14oTk9UICk/TElLRSAlKC4rKSUkL2ksIG9wZXJhdG9yOiAnY29udGFpbnMnIH0sXG4gICAgeyByZWdleDogL14oTk9UICk/TElLRSAoLispJSQvaSwgb3BlcmF0b3I6ICdiZWdpbnMnIH0sXG4gICAgeyByZWdleDogL14oTk9UICk/TElLRSAlKC4rKSQvaSwgb3BlcmF0b3I6ICdlbmRzJyB9XG5dO1xudmFyIHJlZ2V4RXNjYXBlZExpa2VQYXR0ZXJuQ2hhcnMgPSAvXFxbKFtfXFxbXFxdJV0pXFxdL2c7IC8vIGNhcHR1cmUgYWxsIF8sIFssIF0sIGFuZCAlIGNoYXJzIGVuY2xvc2VkIGluIFtdXG52YXIgcmVnZXhMaWtlUGF0dGVybkNoYXIgPSAvW19cXFtcXF0lXS87IC8vIGZpbmQgYW55IF8sIFssIF0sIGFuZCAlIGNoYXJzIE5PVCBlbmNsb3NlZCBpbiBbXVxuXG4vLyBjb252ZXJ0IGNlcnRhaW4gTElLRSBleHByZXNzaW9ucyB0byBCRUdJTlMsIEVORFMsIENPTlRBSU5TXG5mdW5jdGlvbiBjb252ZXJ0TGlrZVRvUHNldWRvT3AocmVzdWx0KSB7XG4gICAgbGlrZURyZXNzZXMuZmluZChmdW5jdGlvbihkcmVzcykge1xuICAgICAgICB2YXIgbWF0Y2ggPSByZXN1bHQubWF0Y2goZHJlc3MucmVnZXgpO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgLy8gdW5lc2NhcGUgYWxsIExJS0UgcGF0dGVybiBjaGFycyBlc2NhcGVkIHdpdGggYnJhY2tldHNcbiAgICAgICAgICAgIHZhciBub3QgPSAobWF0Y2hbMV0gfHwgJycpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBkcmVzcy5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICBvcGVyYW5kID0gbWF0Y2hbMl0sXG4gICAgICAgICAgICAgICAgb3BlcmFuZFdpdGhvdXRFc2NhcGVkQ2hhcnMgPSBvcGVyYW5kLnJlcGxhY2UocmVnZXhFc2NhcGVkTGlrZVBhdHRlcm5DaGFycywgJycpO1xuXG4gICAgICAgICAgICAvLyBpZiByZXN1bHQgaGFzIG5vIGFjdHVhIHJlbWFpbmluZyBMSUtFIHBhdHRlcm4gY2hhcnMsIGdvIHdpdGggdGhlIGNvbnZlcnNpb25cbiAgICAgICAgICAgIGlmICghcmVnZXhMaWtlUGF0dGVybkNoYXIudGVzdChvcGVyYW5kV2l0aG91dEVzY2FwZWRDaGFycykpIHtcbiAgICAgICAgICAgICAgICBvcGVyYW5kID0gb3BlcmFuZC5yZXBsYWNlKHJlZ2V4RXNjYXBlZExpa2VQYXR0ZXJuQ2hhcnMsICckMScpOyAvLyB1bmVzY2FwZSB0aGUgZXNjYXBlZCBjaGFyc1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5vdCArIG9wZXJhdG9yICsgJyAnICsgb3BlcmFuZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIGJyZWFrIG91dCBvZiBsb29wXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBjb25kaXRpb25hbHNDUUwgPSBuZXcgRmlsdGVyVHJlZS5Db25kaXRpb25hbHMoKTtcbmNvbmRpdGlvbmFsc0NRTC5tYWtlTElLRSA9IGZ1bmN0aW9uKGJlZywgZW5kLCBvcCwgb3JpZ2luYWxPcCwgYykge1xuICAgIG9wID0gb3JpZ2luYWxPcC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBvcCArICcgJyArIHF1b3RlKGMub3BlcmFuZCk7XG59O1xuY29uZGl0aW9uYWxzQ1FMLm1ha2VJTiA9IGZ1bmN0aW9uKG9wLCBjKSB7XG4gICAgcmV0dXJuIG9wLnRvTG93ZXJDYXNlKCkgKyAnICgnICsgYy5vcGVyYW5kLnJlcGxhY2UoL1xccyosXFxzKi9nLCAnLCAnKSArICcpJztcbn07XG5jb25kaXRpb25hbHNDUUwubWFrZSA9IGZ1bmN0aW9uKG9wLCBjKSB7XG4gICAgdmFyIG51bWVyaWNPcGVyYW5kO1xuICAgIG9wID0gb3AudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoL1xcdy8udGVzdChvcCkpIHsgb3AgKz0gJyAnOyB9XG4gICAgb3AgKz0gYy5nZXRUeXBlKCkgPT09ICdudW1iZXInICYmICFpc05hTihudW1lcmljT3BlcmFuZCA9IE51bWJlcihjLm9wZXJhbmQpKVxuICAgICAgICA/IG51bWVyaWNPcGVyYW5kXG4gICAgICAgIDogcXVvdGUoYy5vcGVyYW5kKTtcbiAgICByZXR1cm4gb3A7XG59O1xuXG4vLyByZXBsYWNlIHRoZSBkZWZhdWx0IGZpbHRlciB0cmVlIHRlcm1pbmFsIG5vZGUgY29uc3RydWN0b3Igd2l0aCBhbiBleHRlbnNpb24gb2Ygc2FtZVxudmFyIEN1c3RvbUZpbHRlckxlYWYgPSBGaWx0ZXJUcmVlLnByb3RvdHlwZS5hZGRFZGl0b3Ioe1xuICAgIGdldFN0YXRlOiBmdW5jdGlvbiBnZXRTdGF0ZShvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgICBzeW50YXggPSBvcHRpb25zICYmIG9wdGlvbnMuc3ludGF4O1xuXG4gICAgICAgIGlmIChzeW50YXggPT09ICdDUUwnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmdldFN5bnRheChjb25kaXRpb25hbHNDUUwpO1xuICAgICAgICAgICAgcmVzdWx0ID0gY29udmVydExpa2VUb1BzZXVkb09wKHJlc3VsdCk7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdE9wID0gdGhpcy5zY2hlbWEubG9va3VwKHRoaXMuY29sdW1uKS5kZWZhdWx0T3AgfHwgdGhpcy5yb290LnBhcnNlckNRTC5kZWZhdWx0T3A7IC8vIG1pbWljcyBsb2dpYyBpbiBwYXJzZXItQ1FMLmpzLCBsaW5lIDExMFxuICAgICAgICAgICAgaWYgKHJlc3VsdC50b1VwcGVyQ2FzZSgpLmluZGV4T2YoZGVmYXVsdE9wKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHIoZGVmYXVsdE9wLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBGaWx0ZXJUcmVlLkxlYWYucHJvdG90eXBlLmdldFN0YXRlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0pO1xuXG5GaWx0ZXJUcmVlLnByb3RvdHlwZS5hZGRFZGl0b3IoJ0NvbHVtbnMnKTtcblxuLy8gQWRkIHNvbWUgbm9kZSB0ZW1wbGF0ZXMgYnkgdXBkYXRpbmcgc2hhcmVkIGluc3RhbmNlIG9mIEZpbHRlck5vZGUncyB0ZW1wbGF0ZXMuIChPSyB0byBtdXRhdGUgc2hhcmVkIGluc3RhbmNlOyBmaWx0ZXItdHJlZSBub3QgYmVpbmcgdXNlZCBmb3IgYW55dGhpbmcgZWxzZSBoZXJlLiBBbHRlcm5hdGl2ZWx5LCB3ZSBjb3VsZCBoYXZlIGluc3RhbnRpYXRlZCBhIG5ldyBUZW1wbGF0ZXMgb2JqZWN0IGZvciBvdXIgRGVmYXVsdEZpbHRlciBwcm90b3R5cGUsIGFsdGhvdWdoIHRoaXMgd291bGQgb25seSBhZmZlY3QgdHJlZSBub2Rlcywgbm90IGxlYWYgbm9kZXMsIGJ1dCB0aGF0IHdvdWxkIGJlIG9rIGluIHRoaXMgY2FzZSBzaW5jZSB0aGUgYWRkaXRpb25zIGJlbG93IGFyZSB0cmVlIG5vZGUgdGVtcGxhdGVzLilcbl8oRmlsdGVyVHJlZS5Ob2RlLnByb3RvdHlwZS50ZW1wbGF0ZXMpLmV4dGVuZE93bih7XG4gICAgY29sdW1uRmlsdGVyOiBbXG4gICAgICAgICc8c3BhbiBjbGFzcz1cImZpbHRlci10cmVlXCI+JyxcbiAgICAgICAgJyAgIDxzdHJvbmc+PHNwYW4+ezJ9IDwvc3Bhbj48L3N0cm9uZz48YnI+JyxcbiAgICAgICAgJyAgIE1hdGNoJyxcbiAgICAgICAgJyAgIDxsYWJlbD48aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJmaWx0ZXItdHJlZS1vcC1jaG9pY2VcIiBuYW1lPVwidHJlZU9wezF9XCIgdmFsdWU9XCJvcC1vclwiPmFueTwvbGFiZWw+JyxcbiAgICAgICAgJyAgIDxsYWJlbD48aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJmaWx0ZXItdHJlZS1vcC1jaG9pY2VcIiBuYW1lPVwidHJlZU9wezF9XCIgdmFsdWU9XCJvcC1hbmRcIj5hbGw8L2xhYmVsPicsXG4gICAgICAgICcgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwiZmlsdGVyLXRyZWUtb3AtY2hvaWNlXCIgbmFtZT1cInRyZWVPcHsxfVwiIHZhbHVlPVwib3Atbm9yXCI+bm9uZTwvbGFiZWw+JyxcbiAgICAgICAgJyAgIG9mIHRoZSBmb2xsb3dpbmc6JyxcbiAgICAgICAgJyAgIDxzZWxlY3Q+JyxcbiAgICAgICAgJyAgICAgICA8b3B0aW9uIHZhbHVlPVwiXCI+TmV3IGV4cHJlc3Npb24maGVsbGlwOzwvb3B0aW9uPicsXG4gICAgICAgICcgICA8L3NlbGVjdD4nLFxuICAgICAgICAnICAgPG9sPjwvb2w+JyxcbiAgICAgICAgJzwvc3Bhbj4nXG4gICAgXVxuICAgICAgICAuam9pbignXFxuJyksXG5cbiAgICBjb2x1bW5GaWx0ZXJzOiBbXG4gICAgICAgICc8c3BhbiBjbGFzcz1cImZpbHRlci10cmVlIGZpbHRlci10cmVlLXR5cGUtY29sdW1uLWZpbHRlcnNcIj4nLFxuICAgICAgICAnICAgTWF0Y2ggPHN0cm9uZz5hbGw8L3N0cm9uZz4gb2YgdGhlIGZvbGxvd2luZyBjb2x1bW4gZmlsdGVyIHN1YmV4cHJlc3Npb25zOicsXG4gICAgICAgICcgICA8b2w+PC9vbD4nLFxuICAgICAgICAnPC9zcGFuPidcbiAgICBdXG4gICAgICAgIC5qb2luKCdcXG4nKVxufSk7XG5cbi8qKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAZGVzYyBUaGlzIGV4dGVuc2lvbiBvZiBGaWx0ZXJUcmVlIGZvcmNlcyBhIHNwZWNpZmljIHRyZWUgc3RydWN0dXJlLlxuICogU2VlIHtAbGluayBtYWtlTmV3Um9vdH0gZm9yIGEgZGVzY3JpcHRpb24uXG4gKlxuICogU2VlIGFsc28ge0B0dXRvcmlhbCBmaWx0ZXItYXBpfS5cbiAqXG4gKiBAcGFyYW0ge0ZpbHRlclRyZWVPcHRpb25zT2JqZWN0fSBvcHRpb25zIC0gWW91IHNob3VsZCBwcm92aWRlIGEgY29sdW1uIHNjaGVtYS4gVGhlIGVhc2llc3QgYXBwcm9hY2ggaXMgdG8gcHJvdmlkZSBhIHNjaGVtYSBmb3IgdGhlIGVudGlyZSBmaWx0ZXIgdHJlZSB0aHJvdWdoIGBvcHRpb25zLnNjaGVtYWAuXG4gKlxuICogQWx0aG91Z2ggbm90IHJlY29tbWVuZGVkLCB0aGUgY29sdW1uIHNjaGVtYSBjYW4gYWxzbyBiZSBlbWJlZGRlZCBpbiB0aGUgc3RhdGUgb2JqZWN0LCBlaXRoZXIgYXQgdGhlIHJvb3QsIGBvcHRpb25zLnN0YXRlLnNjaGVtYWAsIG9yIGZvciBhbnkgZGVzY2VuZGFudCBub2RlLiBGb3IgZXhhbXBsZSwgYSBzZXBhcmF0ZSBzY2hlbWEgY291bGQgYmUgcHJvdmlkZWQgZm9yIGVhY2ggZXhwcmVzc2lvbiBvciBzdWJleHByZXNzaW9uIHRoYXQgbmVlZCB0byByZW5kZXIgY29sdW1uIGxpc3QgZHJvcC1kb3ducy5cbiAqXG4gKiBOT1RFOiBJZiBgb3B0aW9ucy5zdGF0ZWAgaXMgdW5kZWZpbmVkLCBpdCBpcyBkZWZpbmVkIGluIGBwcmVJbml0aWFsaXplKClgIGFzIGEgbmV3IGVtcHR5IHN0YXRlIHNjYWZmb2xkIChzZWUge0BsaW5rIG1ha2VOZXdSb290fSkgd2l0aCB0aGUgdHdvIHRydW5rcyB0byBob2xkIGEgdGFibGUgZmlsdGVyIGFuZCBjb2x1bW4gZmlsdGVycy4gRXhwcmVzc2lvbnMgYW5kIHN1YmV4cHJlc3Npb25zIGNhbiBiZSBhZGRlZCB0byB0aGlzIGVtcHR5IHNjYWZmb2xkIGVpdGhlciBwcm9ncmFtbWF0aWNhbGx5IG9yIHRocm91Z2ggdGhlIFF1ZXJ5IEJ1aWxkZXIgVUkuXG4gKi9cblxudmFyIERlZmF1bHRGaWx0ZXIgPSBGaWx0ZXJUcmVlLmV4dGVuZCgnRGVmYXVsdEZpbHRlcicsIHtcbiAgICBwcmVJbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8vIFNldCB1cCB0aGUgZGVmYXVsdCBcIkh5cGVyZmlsdGVyXCIgcHJvZmlsZSAoc2VlIGZ1bmN0aW9uIGNvbW1lbnRzKVxuICAgICAgICB2YXIgc3RhdGUgPSBvcHRpb25zLnN0YXRlID0gb3B0aW9ucy5zdGF0ZSB8fCB0aGlzLm1ha2VOZXdSb290KCk7XG5cbiAgICAgICAgLy8gVXBvbiBjcmVhdGlvbiBvZiBhICdjb2x1bW5GaWx0ZXInIG5vZGUsIGZvcmNlIHRoZSBzY2hlbWEgdG8gdGhlIG9uZSBjb2x1bW5cbiAgICAgICAgaWYgKChvcHRpb25zLnR5cGUgfHwgc3RhdGUgJiYgc3RhdGUudHlwZSkgPT09ICdjb2x1bW5GaWx0ZXInKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYSA9IFtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmVudC5yb290LnNjaGVtYS5sb29rdXAoc3RhdGUuY2hpbGRyZW5bMF0uY29sdW1uKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbb3B0aW9uc107XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZXh0cmFjdFN1YnRyZWVzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcG9zdEluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IHRoaXMucm9vdCAmJiAhdGhpcy5wYXJzZXJDUUwpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyQ1FMID0gbmV3IFBhcnNlckNRTCh0aGlzLmNvbmRpdGlvbmFscy5vcHMsIHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRPcDogb3B0aW9ucy5kZWZhdWx0Q29sdW1uRmlsdGVyT3BlcmF0b3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NvbHVtbkZpbHRlcicpIHtcbiAgICAgICAgICAgIHRoaXMuZG9udFBlcnNpc3Quc2NoZW1hID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgY29udmVuaWVuY2UgdmFycyB0byByZWZlcmVuY2UgdGhlIDIgcm9vdCBcIkh5cGVyZmlsdGVyXCIgbm9kZXNcbiAgICAgKiBAbWVtYmVyT2YgRGVmYXVsdEZpbHRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBleHRyYWN0U3VidHJlZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcm9vdE5vZGVzID0gdGhpcy5yb290LmNoaWxkcmVuO1xuICAgICAgICB0aGlzLnRhYmxlRmlsdGVyID0gcm9vdE5vZGVzWzBdO1xuICAgICAgICB0aGlzLmNvbHVtbkZpbHRlcnMgPSByb290Tm9kZXNbMV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IE1ha2UgYSBuZXcgZW1wdHkgSHlwZXJncmlkIGZpbHRlciB0cmVlIHN0YXRlIG9iamVjdC5cbiAgICAgKiBAZGVzYyBUaGlzIGZ1bmN0aW9uIG1ha2VzIGEgbmV3IGRlZmF1bHQgc3RhdGUgb2JqZWN0IGFzIHVzZWQgYnkgSHlwZXJncmlkLCBhIHJvb3Qgd2l0aCBleGFjdGx5IHR3byBcInRydW5rcy5cIlxuICAgICAqXG4gICAgICogPiAqKkRlZmluaXRpb246KiogQSAqdHJ1bmsqIGlzIGRlZmluZWQgYXMgYSBjaGlsZCBub2RlIHdpdGggYSB0cnV0aHkgYGtlZXBgIHByb3BlcnR5LCBtYWtpbmcgdGhpcyBub2RlIGltbXVuZSB0byB0aGUgdXN1YWwgcHJ1bmluZyB0aGF0IHdvdWxkIG9jY3VyIHdoZW4gaXQgaGFzIG5vIGNoaWxkIG5vZGVzIG9mIGl0cyBvd24uIFRvIGJlIGEgdHJ1ZSB0cnVuaywgYWxsIGFuY2VzdG9yIG5vZGVzIHRvIGJlIHRydW5rcyBhcyB3ZWxsLiBOb3RlIHRoYXQgdGhlIHJvb3QgaXMgYSBuYXR1cmFsIHRydW5rOyBpdCBkb2VzIG5vdCByZXF1aXJlIGEgYGtlZXBgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhlIHR3byB0cnVua3Mgb2YgdGhlIEh5cGVyZ3JpZCBmaWx0ZXIgYXJlOlxuICAgICAqICogVGhlICoqVGFibGUgRmlsdGVyKiogKGxlZnQgdHJ1bmssIG9yIGBjaGlsZHJlblswXWApLCBhIGhpZXJhcmNoeSBvZiBmaWx0ZXIgZXhwcmVzc2lvbnMgYW5kIHN1YmV4cHJlc3Npb25zLlxuICAgICAqICogVGhlICoqQ29sdW1uIEZpbHRlcnMqKiAocmlnaHQgdHJ1bmssIG9yIGBjaGlsZHJlblsxXWApLCBhIHNlcmllcyBvZiBzdWJleHByZXNzaW9ucywgb25lIHBlciBhY3RpdmUgY29sdW1uIGZpbHRlci4gRWFjaCBzdWJleHByZXNzaW9uIGNvbnRhaW5zIGFueSBudW1iZXIgb2YgZXhwcmVzc2lvbnMgYm91bmQgdG8gdGhhdCBjb2x1bW4gYnV0IG5vIGZ1cnRoZXIgc3ViZXhwcmVzc2lvbnMuXG4gICAgICpcbiAgICAgKiBUaGUgYG9wZXJhdG9yYCBwcm9wZXJ0aWVzIGZvciBhbGwgc3ViZXhwcmVzc2lvbnMgZGVmYXVsdCB0byBgJ29wLWFuZCdgLCB3aGljaCBtZWFuczpcbiAgICAgKiAqIEFsbCB0YWJsZSBmaWx0ZXIgZXhwcmVzc2lvbnMgYW5kIHN1YmV4cHJlc3Npb25zIGFyZSBBTkQnZCB0b2dldGhlci4gKFRoaXMgaXMganVzdCB0aGUgZGVmYXVsdCBhbmQgbWF5IGJlIGNoYW5nZWQgZnJvbSB0aGUgVUkuKVxuICAgICAqICogQWxsIGV4cHJlc3Npb25zIHdpdGhpbiBhIGNvbHVtbiBmaWx0ZXIgc3ViZXhwcmVzc2lvbiBhcmUgQU5EJ2QgdG9nZXRoZXIuIChUaGlzIGlzIGp1c3QgdGhlIGRlZmF1bHQgYW5kIG1heSBiZSBjaGFuZ2VkIGZyb20gdGhlIFVJLilcbiAgICAgKiAqIEFsbCBjb2x1bW4gRmlsdGVycyBzdWJleHByZXNzaW9ucyBhcmUgQU5EJ2QgdG9nZXRoZXIuIChUaGlzIG1heSBub3QgYmUgY2hhbmdlZCBmcm9tIFVJLilcbiAgICAgKiAqIEZpbmFsbHksIHRoZSB0YWJsZSBmaWx0ZXIgYW5kIGNvbHVtbiBmaWx0ZXJzIGFyZSBBTkQnZCB0b2dldGhlci4gKFRoaXMgbWF5IG5vdCBiZSBjaGFuZ2VkIGZyb20gVUkuKVxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH0gQSBwbGFpbiBvYmplY3QgdG8gc2VydmUgYXMgYSBmaWx0ZXItdHJlZSBzdGF0ZSBvYmplY3QgcmVwcmVzZW50aW5nIGEgbmV3IEh5cGVyZ3JpZCBmaWx0ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRGVmYXVsdEZpbHRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtYWtlTmV3Um9vdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy50YWJsZUZpbHRlciA9IHtcbiAgICAgICAgICAgIGtlZXA6IHRydWUsXG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgIC8vIHRhYmxlIGZpbHRlciBleHByZXNzaW9ucyBhbmQgc3ViZXhwcmVzc2lvbnMgZ28gaGVyZVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY29sdW1uRmlsdGVycyA9IHtcbiAgICAgICAgICAgIGtlZXA6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiAnY29sdW1uRmlsdGVycycsXG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgIC8vIHN1YmV4cHJlc3Npb25zIHdpdGggdHlwZSAnY29sdW1uRmlsdGVyJyBnbyBoZXJlLCBvbmUgZm9yIGVhY2ggYWN0aXZlIGNvbHVtbiBmaWx0ZXJcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZmlsdGVyID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICB0aGlzLnRhYmxlRmlsdGVyLFxuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uRmlsdGVyc1xuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgY29sdW1uIGZpbHRlciBzdWJleHByZXNzaW9uIG5vZGUuXG4gICAgICogQGRlc2MgRWFjaCBjb2x1bW4gZmlsdGVyIHN1YmV4cHJlc3Npb24gbm9kZSBpcyBhIGNoaWxkIG5vZGUgb2YgdGhlIGBjb2x1bW5GaWx0ZXJzYCB0cnVuayBvZiB0aGUgSHlwZXJncmlkIGZpbHRlciB0cmVlLlxuICAgICAqIEVhY2ggc3VjaCBub2RlIGNvbnRhaW5zIGFsbCB0aGUgY29sdW1uIGZpbHRlciBleHByZXNzaW9ucyBmb3IgdGhlIG5hbWVkIGNvbHVtbi4gSXQgd2lsbCBuZXZlciBiZSBlbXB0eTsgaWYgdGhlcmUgaXMgbm8gY29sdW1uIGZpbHRlciBmb3IgdGhlIG5hbWVkIGNvbHVtbiwgaXQgd29uJ3QgZXhpc3QgaW4gYGNvbHVtbkZpbHRlcnNgLlxuICAgICAqXG4gICAgICogQ0FVVElPTjogVGhpcyBpcyB0aGUgYWN0dWFsIG5vZGUgb2JqZWN0LiBEbyBub3QgY29uZnVzZSBpdCB3aXRoIHRoZSBjb2x1bW4gZmlsdGVyIF9zdGF0ZV8gb2JqZWN0IChmb3Igd2hpY2ggc2VlIHRoZSB7QGxpbmsgRGVmYXVsdEZpbHRlciNnZXRDb2x1bW5GaWx0ZXJTdGF0ZXxnZXRDb2x1bW5GaWx0ZXJTdGF0ZSgpfSBtZXRob2QpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2x1bW5OYW1lXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxEZWZhdWx0RmlsdGVyfSBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSBjb2x1bW4gZmlsdGVyIGRvZXMgbm90IGV4aXN0LlxuICAgICAqL1xuICAgIGdldENvbHVtbkZpbHRlcjogZnVuY3Rpb24oY29sdW1uTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5GaWx0ZXJzLmNoaWxkcmVuLmZpbmQoZnVuY3Rpb24oY29sdW1uRmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sdW1uRmlsdGVyLmNoaWxkcmVuLmxlbmd0aCAmJiBjb2x1bW5GaWx0ZXIuY2hpbGRyZW5bMF0uY29sdW1uID09PSBjb2x1bW5OYW1lO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlZGVmIHtvYmplY3R9IEZpbHRlclRyZWVHZXRTdGF0ZU9wdGlvbnNPYmplY3RcbiAgICAgKiBTZWUgdGhlIHtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9nbG9iYWwuaHRtbCNGaWx0ZXJUcmVlR2V0U3RhdGVPcHRpb25zT2JqZWN0fHR5cGUgZGVmaW5pdGlvbn0gaW4gdGhlIGZpbHRlci10cmVlIGRvY3VtZW50YXRpb24uXG4gICAgICovXG5cbiAgICAvKiogQHR5cGVkZWYge29iamVjdH0gRmlsdGVyVHJlZVNldFN0YXRlT3B0aW9uc09iamVjdFxuICAgICAqIFNlZSB0aGUge0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL2dsb2JhbC5odG1sI0ZpbHRlclRyZWVTZXRTdGF0ZU9wdGlvbnNPYmplY3R8dHlwZSBkZWZpbml0aW9ufSBpbiB0aGUgZmlsdGVyLXRyZWUgZG9jdW1lbnRhdGlvbi5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCBhIHBhcnRpY3VsYXIgY29sdW1uIGZpbHRlcidzIHN0YXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByYXdDb2x1bW5OYW1lIC0gQ29sdW1uIG5hbWUgZm9yIGNhc2UgYW5kIGFsaWFzIGxvb2t1cC5cbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWVHZXRTdGF0ZU9wdGlvbnNPYmplY3R9IFtvcHRpb25zXSAtIFBhc3NlZCB0byB0aGUgZmlsdGVyJ3Mge0BsaW5rIERlZmF1bHRGaWx0ZXIjZ2V0U3RhdGV8Z2V0U3RhdGV9IG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnN5bnRheD0nQ1FMJ10gLSBUaGUgc3ludGF4IHRvIHVzZSB0byBkZXNjcmliZSB0aGUgZmlsdGVyIHN0YXRlLiBOb3RlIHRoYXQgYGdldEZpbHRlcmAncyBkZWZhdWx0IHN5bnRheCwgYCdDUUwnYCwgZGlmZmVycyBmcm9tIHRoZSBvdGhlciBnZXQgc3RhdGUgbWV0aG9kcy5cbiAgICAgKiBAcmV0dXJucyB7RmlsdGVyVHJlZVN0YXRlT2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBEZWZhdWx0RmlsdGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldENvbHVtbkZpbHRlclN0YXRlOiBmdW5jdGlvbihyYXdDb2x1bW5OYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAgIGNvbHVtblNjaGVtYSA9IHRoaXMuc2NoZW1hLmxvb2t1cChyYXdDb2x1bW5OYW1lKTtcblxuICAgICAgICBpZiAoY29sdW1uU2NoZW1hKSB7XG4gICAgICAgICAgICB2YXIgc3ViZXhwcmVzc2lvbiA9IHRoaXMuZ2V0Q29sdW1uRmlsdGVyKGNvbHVtblNjaGVtYS5uYW1lKTtcblxuICAgICAgICAgICAgaWYgKHN1YmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoIShvcHRpb25zICYmIG9wdGlvbnMuc3ludGF4KSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zeW50YXggPSAnQ1FMJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc3ViZXhwcmVzc2lvbi5nZXRTdGF0ZShvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNldCBhIHBhcnRpY3VsYXIgY29sdW1uIGZpbHRlcidzIHN0YXRlLlxuICAgICAqIEBkZXNjIEFkZHMgQ1FMIHN1cHBvcnQgdG8gdGhpcy5nZXRTdGF0ZSgpLiBUaGlzIGZ1bmN0aW9uIHRocm93cyBwYXJzZXIgZXJyb3JzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbHVtbk5hbWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW3N0YXRlXSAtIEEgZmlsdGVyIHRyZWUgb2JqZWN0IG9yIGEgSlNPTiwgU1FMLCBvciBDUUwgc3ViZXhwcmVzc2lvbiBzdHJpbmcgdGhhdCBkZXNjcmliZXMgdGhlIGEgbmV3IHN0YXRlIGZvciB0aGUgbmFtZWQgY29sdW1uIGZpbHRlci4gVGhlIGV4aXN0aW5nIGNvbHVtbiBmaWx0ZXIgc3ViZXhwcmVzc2lvbiBpcyByZXBsYWNlZCB3aXRoIGEgbmV3IG5vZGUgYmFzZWQgb24gdGhpcyBzdGF0ZS4gSWYgaXQgZG9lcyBub3QgZXhpc3QsIHRoZSBuZXcgc3ViZXhwcmVzc2lvbiBpcyBhZGRlZCB0byB0aGUgY29sdW1uIGZpbHRlcnMgc3VidHJlZSAoYHRoaXMucm9vdC5jb2x1bW5GaWx0ZXJzYCkuXG4gICAgICpcbiAgICAgKiBJZiB1bmRlZmluZWQsIHJlbW92ZXMgdGhlIGVudGlyZSBjb2x1bW4gZmlsdGVyIHN1YmV4cHJlc3Npb24gZnJvbSB0aGUgY29sdW1uIGZpbHRlcnMgc3VidHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByYXdDb2x1bW5OYW1lIC0gQ29sdW1uIG5hbWUgZm9yIGNhc2UgYW5kIGFsaWFzIGxvb2t1cC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVNldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyBbc2V0U3RhdGVde0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL0ZpbHRlclRyZWUuaHRtbCNzZXRTdGF0ZX0gbWV0aG9kLiBZb3UgbWF5IG1peCBpbiBtZW1iZXJzIG9mIHRoZSB7QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvZ2xvYmFsLmh0bWwjRmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fEZpbHRlclRyZWVWYWxpZGF0aW9uT3B0aW9uc09iamVjdH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc3ludGF4PSdDUUwnXSAtIFRoZSBzeW50YXggdG8gdXNlIHRvIGRlc2NyaWJlIHRoZSBmaWx0ZXIgc3RhdGUuIE5vdGUgdGhhdCBgc2V0Q29sdW1uRmlsdGVyU3RhdGVgJ3MgZGVmYXVsdCBzeW50YXgsIGAnQ1FMJ2AsIGRpZmZlcnMgZnJvbSB0aGUgb3RoZXIgZ2V0IHN0YXRlIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRGVmYXVsdEZpbHRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRDb2x1bW5GaWx0ZXJTdGF0ZTogZnVuY3Rpb24ocmF3Q29sdW1uTmFtZSwgc3RhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVycm9yLFxuICAgICAgICAgICAgc3ViZXhwcmVzc2lvbjtcblxuICAgICAgICB2YXIgY29sdW1uTmFtZSA9IHRoaXMuc2NoZW1hLmxvb2t1cChyYXdDb2x1bW5OYW1lKS5uYW1lO1xuXG4gICAgICAgIGlmICghY29sdW1uTmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgJ1Vua25vd24gY29sdW1uIG5hbWUgXCInICsgcmF3Q29sdW1uTmFtZSArICdcIic7XG4gICAgICAgIH1cblxuICAgICAgICBzdWJleHByZXNzaW9uID0gdGhpcy5nZXRDb2x1bW5GaWx0ZXIoY29sdW1uTmFtZSk7XG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gXyh7fSkuZXh0ZW5kKG9wdGlvbnMpOyAvLyBjbG9uZSBpdCBiZWNhdXNlIHdlIG1heSBtdXRhdGUgaXQgYmVsb3dcbiAgICAgICAgICAgIG9wdGlvbnMuc3ludGF4ID0gb3B0aW9ucy5zeW50YXggfHwgJ0NRTCc7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN5bnRheCA9PT0gJ0NRTCcpIHtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHNvbWUgQ1FMIHN0YXRlIHN5bnRheCBpbnRvIGEgZmlsdGVyIHRyZWUgc3RhdGUgb2JqZWN0LlxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIG11c3QgYmUgYXQgbGVhc3Qgb25lIGNvbXBsZXRlIGV4cHJlc3Npb24gb3IgYHN0YXRlYCB3aWxsIGJlY29tZSB1bmRlZmluZWQuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnJvb3QucGFyc2VyQ1FMLnBhcnNlKHN0YXRlLCBjb2x1bW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN5bnRheCA9ICdvYmplY3QnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0RlZmF1bHRGaWx0ZXI6IE5vIGNvbXBsZXRlIGV4cHJlc3Npb24uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZXJyb3IpIHsgLy8gcGFyc2Ugc3VjY2Vzc2Z1bFxuICAgICAgICAgICAgICAgIGlmIChzdWJleHByZXNzaW9uKSB7IC8vIHN1YmV4cHJlc3Npb24gYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBzdWJleHByZXNzaW9uIHJlcHJlc2VudGluZyB0aGlzIGNvbHVtblxuICAgICAgICAgICAgICAgICAgICBzdWJleHByZXNzaW9uLnNldFN0YXRlKHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgYSBuZXcgc3ViZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgdGhpcyBjb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnBhcnNlU3RhdGVTdHJpbmcoc3RhdGUsIG9wdGlvbnMpOyAvLyBiZWNhdXNlIC5hZGQoKSBvbmx5IHRha2VzIG9iamVjdCBzeW50YXhcbiAgICAgICAgICAgICAgICAgICAgc3ViZXhwcmVzc2lvbiA9IHRoaXMuY29sdW1uRmlsdGVycy5hZGQoc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zLnRocm93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlcnJvciA9IHN1YmV4cHJlc3Npb24uaW52YWxpZChvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdWJleHByZXNzaW9uICYmICghc3RhdGUgfHwgZXJyb3IpKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgc3ViZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgdGhpcyBjb2x1bW5cbiAgICAgICAgICAgIHN1YmV4cHJlc3Npb24ucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCBzdGF0ZSBvZiBhbGwgY29sdW1uIGZpbHRlcnMuXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlR2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIHtAbGluayBEZWZhdWx0RmlsdGVyI2dldFN0YXRlfGdldFN0YXRlfSBtZXRob2QuXG4gICAgICogQHJldHVybnMge0ZpbHRlclRyZWVTdGF0ZU9iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgRGVmYXVsdEZpbHRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRDb2x1bW5GaWx0ZXJzU3RhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zeW50YXggPT09ICdDUUwnKSB7XG4gICAgICAgICAgICB0aHJvdyAnVGhlIENRTCBzeW50YXggaXMgaW50ZW5kZWQgZm9yIHVzZSBvbiBhIHNpbmdsZSBjb2x1bW4gZmlsdGVyIG9ubHkuIEl0IGRvZXMgbm90IHN1cHBvcnQgbXVsdGlwbGUgY29sdW1ucyBvciBzdWJleHByZXNzaW9ucy4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuY29sdW1uRmlsdGVycy5nZXRTdGF0ZShvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2V0IHN0YXRlIG9mIGFsbCBjb2x1bW4gZmlsdGVycy5cbiAgICAgKiBAZGVzYyBOb3RlIHRoYXQgdGhlIGNvbHVtbiBmaWx0ZXJzIGltcGxlbWVudGF0aW9uIGRlcGVuZHMgb24gdGhlIG5vZGVzIGhhdmluZyBjZXJ0YWluIG1ldGEtZGF0YTsgeW91IHNob3VsZCBub3QgYmUgY2FsbGluZyB0aGlzIHdpdGhvdXQgdGhlc2UgbWV0YS1kYXRhIGJlaW5nIGluIHBsYWNlLiBTcGVjaWZpY2FsbHkgYHR5cGUgPSAnY29sdW1uRmlsdGVycydgIGFuZCAgYGtlZXAgPSB0cnVlYCBmb3IgdGhlIGNvbHVtbiBmaWx0ZXJzIHN1YnRyZWUgYW5kYHR5cGUgPSAnY29sdW1uRmlsdGVyJ2AgZm9yIGVhY2ggaW5kaXZpZHVhbCBjb2x1bW4gZmlsdGVyIHN1YmV4cHJlc3Npb24uIEluIGFkZGl0aW9uIHRoZSBzdWJ0cmVlIG9wZXJhdG9ycyBzaG91bGQgYWx3YXlzIGJlIGAnb3AtYW5kJ2AuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXRlXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIFtzZXRTdGF0ZV17QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvRmlsdGVyVHJlZS5odG1sI3NldFN0YXRlfSBtZXRob2QuIFlvdSBtYXkgbWl4IGluIG1lbWJlcnMgb2YgdGhlIHtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9nbG9iYWwuaHRtbCNGaWx0ZXJUcmVlVmFsaWRhdGlvbk9wdGlvbnNPYmplY3R8RmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fVxuICAgICAqXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxFcnJvcnxzdHJpbmd9IGB1bmRlZmluZWRgIGluZGljYXRlcyBzdWNjZXNzLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIERlZmF1bHRGaWx0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0Q29sdW1uRmlsdGVyc1N0YXRlOiBmdW5jdGlvbihzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZXJyb3I7XG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QuY29sdW1uRmlsdGVycy5zZXRTdGF0ZShzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBlcnJvciA9IHRoaXMucm9vdC5jb2x1bW5GaWx0ZXJzLmludmFsaWQob3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZUdldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyB7QGxpbmsgRGVmYXVsdEZpbHRlciNnZXRTdGF0ZXxnZXRTdGF0ZX0gbWV0aG9kLlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9XG4gICAgICogQG1lbWJlck9mIERlZmF1bHRGaWx0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0VGFibGVGaWx0ZXJTdGF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnN5bnRheCA9PT0gJ0NRTCcpIHtcbiAgICAgICAgICAgIHRocm93ICdUaGUgQ1FMIHN5bnRheCBpcyBpbnRlbmRlZCBmb3IgdXNlIG9uIGEgc2luZ2xlIGNvbHVtbiBmaWx0ZXIgb25seS4gSXQgZG9lcyBub3Qgc3VwcG9ydCBtdWx0aXBsZSBjb2x1bW5zIG9yIHN1YmV4cHJlc3Npb25zLic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC50YWJsZUZpbHRlci5nZXRTdGF0ZShvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXRlXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIFtzZXRTdGF0ZV17QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvRmlsdGVyVHJlZS5odG1sI3NldFN0YXRlfSBtZXRob2QuIFlvdSBtYXkgbWl4IGluIG1lbWJlcnMgb2YgdGhlIHtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9nbG9iYWwuaHRtbCNGaWx0ZXJUcmVlVmFsaWRhdGlvbk9wdGlvbnNPYmplY3R8RmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8RXJyb3J8c3RyaW5nfSBgdW5kZWZpbmVkYCBpbmRpY2F0ZXMgc3VjY2Vzcy5cbiAgICAgKiBAbWVtYmVyT2YgRGVmYXVsdEZpbHRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRUYWJsZUZpbHRlclN0YXRlOiBmdW5jdGlvbihzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZXJyb3I7XG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QudGFibGVGaWx0ZXIuc2V0U3RhdGUoc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgZXJyb3IgPSB0aGlzLnJvb3QudGFibGVGaWx0ZXIuaW52YWxpZChvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC50YWJsZUZpbHRlci5jaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBUaGUgQ1FMIHN5bnRheCBzaG91bGQgb25seSBiZSByZXF1ZXN0ZWQgZm9yIGEgc3VidHJlZSBjb250YWluaW5nIGhvbW9nZW5lb3VzIGNvbHVtbiBuYW1lcyBhbmQgbm8gc3ViZXhwcmVzc2lvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3ludGF4PSdvYmplY3QnXSAtIElmIGAnQ1FMJ2AsIHdhbGtzIHRoZSB0cmVlLCByZXR1cm5pbmcgYSBzdHJpbmcgc3VpdGFibGUgZm9yIGEgSHlwZXJncmlkIGZpbHRlciBjZWxsLiBBbGwgb3RoZXIgdmFsdWVzIGFyZSBmb3J3YXJkZWQgdG8gdGhlIHByb3RvdHlwZSdzIGBnZXRTdGF0ZWAgbWV0aG9kIGZvciBmdXJ0aGVyIGludGVycHJldGF0aW9uLlxuICAgICAqXG4gICAgICogTk9URTogQ1FMIGlzIG5vdCBpbnRlbmRlZCB0byBiZSB1c2VkIG91dHNpZGUgdGhlIGNvbnRleHQgb2YgYSBgY29sdW1uRmlsdGVyc2Agc3ViZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRGVmYXVsdEZpbHRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRTdGF0ZTogZnVuY3Rpb24gZ2V0U3RhdGUob3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgc3ludGF4ID0gb3B0aW9ucyAmJiBvcHRpb25zLnN5bnRheDtcblxuICAgICAgICBpZiAoc3ludGF4ID09PSAnQ1FMJykge1xuICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5vcGVyYXRvci5zdWJzdHIoMyk7IC8vIHJlbW92ZSB0aGUgJ29wLScgcHJlZml4XG4gICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEN1c3RvbUZpbHRlckxlYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyAnICsgb3BlcmF0b3IgKyAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gY2hpbGQuZ2V0U3RhdGUob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlZmF1bHRGaWx0ZXI6IEV4cGVjdGVkIGEgY29uZGl0aW9uYWwgYnV0IGZvdW5kIGEgc3ViZXhwcmVzc2lvbi4gU3ViZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gQ1FMIChDb2x1bW4gUXVlcnkgTGFuZ3VhZ2UsIHRoZSBmaWx0ZXIgY2VsbCBzeW50YXgpLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBGaWx0ZXJUcmVlLnByb3RvdHlwZS5nZXRTdGF0ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgbG9hZENvbHVtblByb3BlcnRpZXNGcm9tU2NoZW1hOiBmdW5jdGlvbihjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMucm9vdC5zY2hlbWEud2FsayhmdW5jdGlvbihjb2x1bW5TY2hlbWEpIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBjb2x1bW5zLmZpbmQoZnVuY3Rpb24odGhpc0NvbHVtbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQ29sdW1uLm5hbWUgPT09IGNvbHVtblNjaGVtYS5uYW1lIHx8IGNvbHVtblNjaGVtYTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIGNvbHVtbi50eXBlID0gY29sdW1uU2NoZW1hLnR5cGUgfHwgY29sdW1uLnR5cGU7XG4gICAgICAgICAgICAgICAgY29sdW1uLmhlYWRlciA9IGNvbHVtblNjaGVtYS5hbGlhcyB8fCBjb2x1bW4uaGVhZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRGaWx0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpO1xuXG52YXIgUkVHRVhQX0JPT0xTID0gL1xcYihBTkR8T1J8Tk9SKVxcYi9naSxcbiAgICBFWFAgPSAnKC4qPyknLCBCUiA9ICdcXFxcYicsXG4gICAgUFJFRklYID0gJ14nICsgRVhQICsgQlIsXG4gICAgSU5GSVggPSBCUiArIEVYUCArIEJSLFxuICAgIFBPU1RGSVggPSBCUiArIEVYUCArICckJztcblxuZnVuY3Rpb24gUGFyc2VyQ3FsRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5QYXJzZXJDcWxFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5QYXJzZXJDcWxFcnJvci5wcm90b3R5cGUubmFtZSA9ICdQYXJzZXJDcWxFcnJvcic7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHN1bW1hcnkgQ29sdW1uIFF1ZXJ5IExhbmd1YWdlIChDUUwpIHBhcnNlclxuICpcbiAqIEBhdXRob3IgSm9uYXRoYW4gRWl0ZW4gam9uYXRoYW5Ab3BlbmZpbi5jb21cbiAqXG4gKiBAZGVzYyBTZWUge0B0dXRvcmlhbCBDUUx9IGZvciB0aGUgZ3JhbW1hci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0b3JzSGFzaCAtIEhhc2ggb2YgdmFsaWQgb3BlcmF0b3JzLiBFYWNoIGlzIGFuIG9iamVjdCwgdGhlIG9ubHkgcHJvcGVydHkgb2YgaW50ZXJlc3QgYmVpbmcgYGNvbXBsZXhgIHdoaWNoIGlmIHRydXRoeSBtZWFucyBvcGVyYW5kIG1heSBiZSBhIGxpc3Qgb2YgbXVsdGlwbGUgb3BlcmFuZHMuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge21lbnVJdGVtW119IFtvcHRpb25zLnNjaGVtYV0gLSBDb2x1bW4gc2NoZW1hIGZvciBjb2x1bW4gbmFtZS9hbGlhcyB2YWxpZGF0aW9uLiBUaHJvd3MgYW4gZXJyb3IgaWYgbmFtZSBmYWlscyB2YWxpZGF0aW9uIChidXQgc2VlIGByZXNvbHZlQWxpYXNlc2ApLiBPbWl0IHRvIHNraXAgY29sdW1uIG5hbWUgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVmYXVsdE9wPSc9J10gLSBEZWZhdWx0IG9wZXJhdG9yIGZvciBjb2x1bW4gd2hlbiBub3QgZGVmaW5lZCBpbiBjb2x1bW4gc2NoZW1hLlxuICovXG5mdW5jdGlvbiBQYXJzZXJDUUwob3BlcmF0b3JzSGFzaCwgb3B0aW9ucykge1xuICAgIHZhciBvcGVyYXRvcnMgPSBbXTtcblxuICAgIHRoaXMuc2NoZW1hID0gb3B0aW9ucyAmJiBvcHRpb25zLnNjaGVtYTtcbiAgICB0aGlzLmRlZmF1bHRPcCA9IChvcHRpb25zICYmIG9wdGlvbnMuZGVmYXVsdE9wIHx8ICc9JykudG9VcHBlckNhc2UoKTtcblxuICAgIF8ob3BlcmF0b3JzSGFzaCkuZWFjaChmdW5jdGlvbihwcm9wcywgb3ApIHtcbiAgICAgICAgaWYgKG9wICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb3BlcmF0b3JzLnB1c2gob3ApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBQdXQgbGFyZ2VyIG9uZXMgZmlyc3Qgc28gdGhhdCBpbiBjYXNlIGEgc21hbGxlciBvbmUgaXMgYSBzdWJzdHJpbmcgb2YgYSBsYXJnZXIgb25lIChzdWNoIGFzICc8JyBpcyB0byAnPD0nKSwgbGFyZ2VyIG9uZSB3aWxsIGJlIG1hdGNoZWQgZmlyc3QuXG4gICAgb3BlcmF0b3JzID0gb3BlcmF0b3JzLnNvcnQoZGVzY2VuZGluZ0J5TGVuZ3RoKTtcblxuICAgIC8vIEVzY2FwZSBhbGwgc3ltYm9saWMgKG5vbiBhbHBoYSkgb3BlcmF0b3JzLlxuICAgIG9wZXJhdG9ycyA9IG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24ob3ApIHsgcmV0dXJuIC9bXlxcd10vLnRlc3Qob3ApID8gJ1xcXFwnICsgb3Auc3BsaXQoJycpLmpvaW4oJ1xcXFwnKSA6IG9wOyB9KTtcblxuICAgIHZhciBzeW1ib2xpY09wZXJhdG9ycyA9IG9wZXJhdG9ycy5maWx0ZXIoZnVuY3Rpb24ob3ApIHsgcmV0dXJuIG9wWzBdID09PSAnXFxcXCc7IH0pLFxuICAgICAgICBhbHBoYU9wZXJhdG9ycyA9IG9wZXJhdG9ycy5maWx0ZXIoZnVuY3Rpb24ob3ApIHsgcmV0dXJuIG9wWzBdICE9PSAnXFxcXCc7IH0pLmpvaW4oJ3wnKTtcblxuICAgIGlmIChhbHBoYU9wZXJhdG9ycykge1xuICAgICAgICBhbHBoYU9wZXJhdG9ycyA9ICdcXFxcYignICsgYWxwaGFPcGVyYXRvcnMgKyAnKVxcXFxiJztcbiAgICB9XG4gICAgLyoqIEBzdW1tYXJ5IFJlZ2V4IHRvIG1hdGNoIGFueSBvcGVyYXRvci5cbiAgICAgKiBAZGVzYyBNYXRjaGVzIHN5bWJvbGljIG9wZXJhdG9ycyAobWFkZSB1cCBvZiBub24tYWxwaGEgY2hhcmFjdGVycykgb3IgaWRlbnRpZmllciBvcGVyYXRvcnMgKHdvcmQtYm91bmRhcnktaXNvbGF0ZWQgcnVucyBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycykuXG4gICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgKi9cbiAgICB0aGlzLlJFR0VYX09QRVJBVE9SID0gbmV3IFJlZ0V4cChzeW1ib2xpY09wZXJhdG9ycy5jb25jYXQoYWxwaGFPcGVyYXRvcnMpLmpvaW4oJ3wnKSwgJ2lnJyk7XG5cbiAgICBvcGVyYXRvcnMgPSBvcGVyYXRvcnMuam9pbignfCcpIC8vIHBpcGUgdGhlbVxuICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAnXFxcXHMrJyk7IC8vIGFyYml0cmFyeSBzdHJpbmcgb2Ygd2hpdGVzcGFjZSBjaGFycyAtPiB3aGl0ZXNwYWNlIHJlZ2V4IG1hdGNoZXJcblxuICAgIC8qKiBAc3VtbWFyeSBSZWdleCB0byBtYXRjaCBhbiBvcGVyYXRvciArIG9wdGlvbmFsIG9wZXJhdG9yXG4gICAgICogQGRlc2MgVEhlIG9wZXJhdG9yIGlzIG9wdGlvbmFsLiBUaGUgb3BlcmFuZCBtYXkgKG9yIG1heSBub3QpIGJlIGVuY2xvc2VkIGluIHBhcmVudGhlc2VzLlxuICAgICAqIEBkZXNjIE1hdGNoIGxpc3Q6XG4gICAgICogMC4gX2lucHV0IHN0cmluZ19cbiAgICAgKiAxLiBvcGVyYXRvclxuICAgICAqIDIuIG91dGVyIG9wZXJhbmQgKG1heSBpbmNsdWRlIHBhcmVudGhlc2VzKVxuICAgICAqIDMuIGlubmVyIG9wZXJhbmQgd2l0aG91dCBwYXJlbnRoZXNlcyAod2hlbiBhbiBvcGVyYW5kIHdhcyBnaXZlbiB3aXRoIHBhcmVudGhlc2VzKVxuICAgICAqIDQuIGlubmVyIG9wZXJhbmQgKHdoZW4gYW4gb3BlcmFuZCB3YXMgZ2l2ZW4gd2l0aG91dCBwYXJlbnRoZXNlcylcbiAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlck9mIFBhcnNlckNRTC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0aGlzLlJFR0VYX0VYUFJFU1NJT04gPSBuZXcgUmVnRXhwKCdeXFxcXHMqKCcgKyBvcGVyYXRvcnMgKyAnKT9cXFxccyooXFxcXChcXFxccyooLis/KVxcXFxzKlxcXFwpfCguKz8pKVxcXFxzKiQnLCAnaScpO1xuXG4gICAgdGhpcy5SRUdFWF9MSVRFUkFMX1RPS0VOUyA9IG5ldyBSZWdFeHAoJ1xcXFwnICsgUGFyc2VyQ1FMLnF0ICsgJyhcXFxcZCspJyArICdcXFxcJyArIFBhcnNlckNRTC5xdCwgJ2cnKTtcblxufVxuXG4vKiogQHN1bW1hcnkgT3BlcmFuZCBxdW90YXRpb24gbWFyayBjaGFyYWN0ZXIuXG4gKiBAZGVzYyBTaG91bGQgYmUgYSBzaW5nbGUgY2hhcmFjdGVyIChsZW5ndGggPT09IDEpLlxuICogQGRlZmF1bHQgJ1wiJ1xuICogQHR5cGUge3N0cmluZ31cbiAqL1xuUGFyc2VyQ1FMLnF0ID0gJ1wiJztcblxuUGFyc2VyQ1FMLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBQYXJzZXJDUUwucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRXh0cmFjdCB0aGUgYm9vbGVhbiBvcGVyYXRvcnMgZnJvbSBhbiBleHByZXNzaW9uIGNoYWluLlxuICAgICAqIEBkZXNjIFJldHVybnMgbGlzdCBvZiBob21vZ2VuZW91cyBvcGVyYXRvcnMgdHJhbnNmb3JtZWQgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBhbGwgdGhlIGJvb2xlYW4gb3BlcmF0b3JzIGluIHRoZSBjaGFpbiBhcmUgbm90IGlkZW50aWNhbC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3FsXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIGNhcHR1cmVCb29sZWFuczogZnVuY3Rpb24oY3FsKSB7XG4gICAgICAgIHZhciBib29sZWFucyA9IGNxbC5tYXRjaChSRUdFWFBfQk9PTFMpO1xuXG4gICAgICAgIGlmIChib29sZWFucykge1xuICAgICAgICAgICAgdmFyIGhldGVyb2dlbmVvdXNPcGVyYXRvciA9IGJvb2xlYW5zLmZpbmQoZnVuY3Rpb24ob3AsIGkpIHtcbiAgICAgICAgICAgICAgICBib29sZWFuc1tpXSA9IG9wLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvb2xlYW5zW2ldICE9PSBib29sZWFuc1swXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaGV0ZXJvZ2VuZW91c09wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlckNxbEVycm9yKCdFeHBlY3RlZCBob21vZ2VuZW91cyBib29sZWFuIG9wZXJhdG9ycy4gWW91IGNhbm5vdCBtaXggQU5ELCBPUiwgYW5kIE5PUiBvcGVyYXRvcnMgaGVyZSBiZWNhdXNlIHRoZSBvcmRlciBvZiBvcGVyYXRpb25zIGlzIGFtYmlndW91cy4gRXZlcnl0aGluZyBhZnRlciB5b3VyICcgKyBoZXRlcm9nZW5lb3VzT3BlcmF0b3IudG9VcHBlckNhc2UoKSArICcgd2FzIGlnbm9yZWQuIFRpcDogWW91IGNhbiBncm91cCBvcGVyYXRpb25zIHdpdGggc3ViZXhwcmVzc2lvbnMgYnV0IG9ubHkgaW4gdGhlIFF1ZXJ5QnVpbGRlciBvciBieSB1c2luZyBwYXJlbnRoZXNlcyBpbiBTUUwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm9vbGVhbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEJyZWFrIGFuIGV4cHJlc3Npb24gY2hhaW4gaW50byBhIGxpc3Qgb2YgZXhwcmVzc2lvbnMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNxbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGJvb2xlYW5zXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIGNhcHR1cmVFeHByZXNzaW9uczogZnVuY3Rpb24oY3FsLCBib29sZWFucykge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMsIHJlO1xuXG4gICAgICAgIGlmIChib29sZWFucykge1xuICAgICAgICAgICAgcmUgPSBuZXcgUmVnRXhwKFBSRUZJWCArIGJvb2xlYW5zLmpvaW4oSU5GSVgpICsgUE9TVEZJWCwgJ2knKTtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zID0gY3FsLm1hdGNoKHJlKTtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zLnNoaWZ0KCk7IC8vIGRpc2NhcmQgWzBdIChpbnB1dClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zID0gW2NxbF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IE1ha2UgYSBsaXN0IG9mIGNoaWxkcmVuIG91dCBvZiBhIGxpc3Qgb2YgZXhwcmVzc2lvbnMuXG4gICAgICogQGRlc2MgVXNlcyBvbmx5IF9jb21wbGV0ZV8gZXhwcmVzc2lvbnMgKGEgdmFsdWUgT1IgYW4gb3BlcmF0b3IgKyBhIHZhbHVlKS5cbiAgICAgKlxuICAgICAqIElnbm9yZXMgX2luY29tcGxldGVfIGV4cHJlc3Npb25zIChlbXB0eSBzdHJpbmcgT1IgYW4gb3BlcmF0b3IgLSBhIHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2x1bW5OYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZXhwcmVzc2lvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBsaXRlcmFscyAtIGxpc3Qgb2YgbGl0ZXJhbHMgaW5kZXhlZCBieSB0b2tlblxuICAgICAqXG4gICAgICogQHJldHVybnMge2V4cHJlc3Npb25TdGF0ZVtdfSB3aGVyZSBgZXhwcmVzc2lvblN0YXRlYCBpcyBvbmUgb2Y6XG4gICAgICogKiBge2NvbHVtbjogc3RyaW5nLCBvcGVyYXRvcjogc3RyaW5nLCBvcGVyYW5kOiBzdHJpbmd9YFxuICAgICAqICogYHtjb2x1bW46IHN0cmluZywgb3BlcmF0b3I6IHN0cmluZywgb3BlcmFuZDogc3RyaW5nLCBlZGl0b3I6ICdDb2x1bW5zJ31gXG4gICAgICovXG4gICAgbWFrZUNoaWxkcmVuOiBmdW5jdGlvbihjb2x1bW5OYW1lLCBleHByZXNzaW9ucywgbGl0ZXJhbHMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnMucmVkdWNlKGZ1bmN0aW9uKGNoaWxkcmVuLCBleHApIHtcbiAgICAgICAgICAgIGlmIChleHApIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBleHAubWF0Y2goc2VsZi5SRUdFWF9FWFBSRVNTSU9OKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gcGFydHNbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlckxpdGVyYWwgPSBwYXJ0c1syXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyTGl0ZXJhbCA9IHBhcnRzLnNsaWNlKDMpLmZpbmQoZnVuY3Rpb24ocGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBvcCA9IChvcCB8fCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRoZXNpemVkID0gL15cXCguKlxcKSQvLnRlc3Qob3V0ZXJMaXRlcmFsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyT3BlcmF0b3JzID0gaW5uZXJMaXRlcmFsLm1hdGNoKHNlbGYuUkVHRVhfT1BFUkFUT1IpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50aGVzaXplZCAmJiBpbm5lck9wZXJhdG9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wID09PSAnJyAmJiBvdXRlckxpdGVyYWwgPT09IGlubmVyT3BlcmF0b3JzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlckNxbEVycm9yKCdFeHBlY3RlZCBhbiBvcGVyYW5kLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VyQ3FsRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0V4cGVjdGVkIG9wZXJhbmQgYnV0IGZvdW5kIGFkZGl0aW9uYWwgb3BlcmF0b3Iocyk6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyT3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50b1N0cmluZygpIC8vIGNvbnZlcnQgdG8gY29tbWEtc2VwYXJhdGVkIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLywvZywgJywgJykgLy8gYWRkIHNwYWNlcyBhZnRlciB0aGUgY29tbWFzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eKFteLF0rKSwgKFteLF0rKSQvLCAnJDEgYW5kICQyJykgLy8gcmVwbGFjZSBvbmx5IGNvbW1hIHdpdGggXCJhbmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKC4rLC4rKSwgKFteLF0rKSQvLCAnJDEsIGFuZCAkMicpIC8vIGFkZCBcImFuZFwiIGFmdGVyIGxhc3Qgb2Ygc2V2ZXJhbCBjb21tYXNcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvcCA9IG9wIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNjaGVtYSAmJiBzZWxmLnNjaGVtYS5sb29rdXAoY29sdW1uTmFtZSkuZGVmYXVsdE9wIHx8IC8vIGNvbHVtbidzIGRlZmF1bHQgb3BlcmF0b3IgZnJvbSBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGVmYXVsdE9wOyAvLyBncmlkJ3MgZGVmYXVsdCBvcGVyYXRvclxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBvcFxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBzZWxmLnNjaGVtYSAmJiBzZWxmLnNjaGVtYS5sb29rdXAoaW5uZXJMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQub3BlcmFuZCA9IGZpZWxkTmFtZS5uYW1lIHx8IGZpZWxkTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmVkaXRvciA9ICdDb2x1bW5zJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgYW5kIGV4cGFuZCBhbGwgY29sbGFwc2VkIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQub3BlcmFuZCA9IGlubmVyTGl0ZXJhbC5yZXBsYWNlKHNlbGYuUkVHRVhfTElURVJBTF9UT0tFTlMsIGZ1bmN0aW9uKG1hdGNoLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXRlcmFsc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBNYWtlIGEgXCJsb2NrZWRcIiBzdWJleHByZXNzaW9uIGRlZmluaXRpb24gb2JqZWN0IGZyb20gYW4gZXhwcmVzc2lvbiBjaGFpbi5cbiAgICAgKiBAZGVzYyBfTG9ja2VkXyBtZWFucyBpdCBpcyBsb2NrZWQgdG8gYSBzaW5nbGUgZmllbGQuXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZXJlIGlzIG9ubHkgYSBzaW5nbGUgZXhwcmVzc2lvbiBpbiB0aGUgY2hhaW4sIHRoZSBgb3BlcmF0b3JgIGlzIG9taXR0ZWQgKGRlZmF1bHRzIHRvIGAnb3AtYW5kJ2ApLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNxbCAtIEEgY29tcG91bmQgQ1FMIGV4cHJlc3Npb24sIGNvbnNpc3Rpbmcgb2Ygb25lIG9yIG1vcmUgc2ltcGxlIGV4cHJlc3Npb25zIGFsbCBzZXBhcmF0ZWQgYnkgdGhlIHNhbWUgbG9naWNhbCBvcGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sdW1uTmFtZVxuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHx7b3BlcmF0b3I6IHN0cmluZywgY2hpbGRyZW46IHN0cmluZ1tdLCBzY2hlbWE6IHN0cmluZ1tdfX1cbiAgICAgKiBgdW5kZWZpbmVkYCB3aGVuIHRoZXJlIGFyZSBubyBjb21wbGV0ZSBleHByZXNzaW9uc1xuICAgICAqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDUUxcbiAgICAgKi9cbiAgICBwYXJzZTogZnVuY3Rpb24oY3FsLCBjb2x1bW5OYW1lKSB7XG4gICAgICAgIC8vIHJlZHVjZSBhbGwgcnVucyBvZiB3aGl0ZSBzcGFjZSB0byBhIHNpbmdsZSBzcGFjZTsgdGhlbiB0cmltXG4gICAgICAgIGNxbCA9IGNxbC5yZXBsYWNlKC9cXHNcXHMrL2csICcgJykudHJpbSgpO1xuXG4gICAgICAgIHZhciBsaXRlcmFscyA9IFtdO1xuICAgICAgICBjcWwgPSB0b2tlbml6ZUxpdGVyYWxzKGNxbCwgUGFyc2VyQ1FMLnF0LCBsaXRlcmFscyk7XG5cbiAgICAgICAgdmFyIGJvb2xlYW5zID0gdGhpcy5jYXB0dXJlQm9vbGVhbnMoY3FsKSxcbiAgICAgICAgICAgIGV4cHJlc3Npb25zID0gdGhpcy5jYXB0dXJlRXhwcmVzc2lvbnMoY3FsLCBib29sZWFucyksXG4gICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMubWFrZUNoaWxkcmVuKGNvbHVtbk5hbWUsIGV4cHJlc3Npb25zLCBsaXRlcmFscyksXG4gICAgICAgICAgICBvcGVyYXRvciA9IGJvb2xlYW5zICYmIGJvb2xlYW5zWzBdLFxuICAgICAgICAgICAgc3RhdGU7XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbHVtbkZpbHRlcicsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVyYXRvciA9ICdvcC0nICsgb3BlcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZGVzY2VuZGluZ0J5TGVuZ3RoKGEsIGIpIHtcbiAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeSBDb2xsYXBzZSBsaXRlcmFscy5cbiAqIEBkZXNjIEFsbG93cyByZXNlcnZlZCB3b3JkcyB0byBleGlzdCBpbnNpZGUgYSBxdW90ZWQgc3RyaW5nLlxuICogTGl0ZXJhbHMgYXJlIGNvbGxhcHNlZCB0byBhIHF1b3RlZCBudW1lcmljYWwgaW5kZXggaW50byB0aGUgYGxpdGVyYWxzYCBhcnJheS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gcXRcbiAqIEBwYXJhbSB7c3RyaW5nW119IGxpdGVyYWxzIC0gRW1wdHkgYXJyYXkgaW4gd2hpY2ggdG8gcmV0dXJuIGV4dHJhY3RlZCBsaXRlcmFscy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplTGl0ZXJhbHModGV4dCwgcXQsIGxpdGVyYWxzKSB7XG4gICAgbGl0ZXJhbHMubGVuZ3RoID0gMDtcblxuICAgIGZvciAoXG4gICAgICAgIHZhciBpID0gMCwgaiA9IDAsIGssIGlubmVyTGl0ZXJhbDtcbiAgICAgICAgKGogPSB0ZXh0LmluZGV4T2YocXQsIGopKSA+PSAwO1xuICAgICAgICBqID0gaiArIDEgKyAoaSArICcnKS5sZW5ndGggKyAxLCBpKytcbiAgICApIHtcbiAgICAgICAgayA9IGo7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGsgPSB0ZXh0LmluZGV4T2YocXQsIGsgKyAxKTtcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZXJDcWxFcnJvcignUXVvdGF0aW9uIG1hcmtzIG11c3QgYmUgcGFpcmVkOyBuZXN0ZWQgcXVvdGF0aW9uIG1hcmtzIG11c3QgYmUgZG91YmxlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodGV4dFsrK2tdID09PSBxdCk7XG5cbiAgICAgICAgaW5uZXJMaXRlcmFsID0gdGV4dFxuICAgICAgICAgICAgLnNsaWNlKCsraiwgLS1rKSAvLyBleHRyYWN0XG4gICAgICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKHF0ICsgcXQsICdnJyksIHF0KTsgLy8gdW5lc2NhcGUgZXNjYXBlZCBxdW90YXRpb24gbWFya3NcblxuICAgICAgICBsaXRlcmFscy5wdXNoKGlubmVyTGl0ZXJhbCk7XG5cbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyKDAsIGopICsgaSArIHRleHQuc3Vic3RyKGspOyAvLyBjb2xsYXBzZVxuICAgIH1cblxuICAgIHJldHVybiB0ZXh0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlckNRTDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlcHJlY2F0ZWQgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZWQnKTtcbnZhciBCYXNlID0gcmVxdWlyZSgnZXh0ZW5kLW1lJykuQmFzZTtcblxuQmFzZS5wcm90b3R5cGUuZGVwcmVjYXRlZCA9IGRlcHJlY2F0ZWQ7XG5CYXNlLnByb3RvdHlwZS5IeXBlcmdyaWRFcnJvciA9IEh5cGVyZ3JpZEVycm9yO1xuXG5cbmZ1bmN0aW9uIEh5cGVyZ3JpZEVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuSHlwZXJncmlkRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuSHlwZXJncmlkRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSHlwZXJncmlkRXJyb3InO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIEBtb2R1bGUgbG9jYWxpemF0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vQmFzZScpO1xudmFyIGRlcHJlY2F0ZWQgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZWQnKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWZhdWx0TG9jYWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xvY2FsZT1kZWZhdWx0bG9jYWxlXVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBGb3JtYXR0ZXIgPSBCYXNlLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGVmYXVsdExvY2FsZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcblxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmludmFsaWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludmFsaWQgPSBvcHRpb25zLmludmFsaWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBlY3RhdGlvbiA9IG9wdGlvbnMuZXhwZWN0YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBAc3VtbWFyeSBDcmVhdGUgYSBudW1iZXIgbG9jYWxpemVyLlxuICogQGltcGxlbWVudHMgbG9jYWxpemVySW50ZXJmYWNlXG4gKiBAZGVzYyBDcmVhdGUgYW4gb2JqZWN0IGNvbmZvcm1pbmcgdG8ge0BsaW5rIGxvY2FsaXplckludGVyZmFjZX0gZm9yIG51bWJlcnMsIHVzaW5nIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXJGb3JtYXR8SW50bC5OdW1iZXJGb3JtYXR9LlxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRMb2NhbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbG9jYWxlPWRlZmF1bHRMb2NhbGVdIC0gUGFzc2VkIHRvIHRoZSB7QGxpbmsgSW50bC5OdW1iZXJGb3JtYXR8aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyRm9ybWF0fSBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGBJbnRsLk51bWJlckZvcm1hdGAgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFjY2VwdFN0YW5kYXJkRGlnaXRzPWZhbHNlXSAtIEFjY2VwdCBzdGFuZGFyZCBkaWdpdHMgYW5kIGRlY2ltYWwgcG9pbnQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggbG9jYWxpemVkIGRpZ2l0cyBhbmQgZGVjaW1hbCBwb2ludC4gKFRoaXMgb3B0aW9uIGlzIGludGVycHJldGVkIGhlcmU7IGl0IGlzIG5vdCB1c2VkIGJ5IGBJbnRsLk51bWJlckZvcm1hdGAuKVxuICogQGNvbnN0cnVjdG9yXG4gKiBAdHV0b3JpYWwgbG9jYWxpemF0aW9uXG4gKi9cbnZhciBOdW1iZXJGb3JtYXR0ZXIgPSBGb3JtYXR0ZXIuZXh0ZW5kKCdOdW1iZXJGb3JtYXR0ZXInLCB7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGVmYXVsdExvY2FsZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGxvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuZm9ybWF0ID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMubG9jYWxlLCBvcHRpb25zKS5mb3JtYXQ7XG5cbiAgICAgICAgdmFyIG1hcHBlck9wdGlvbnMgPSB7IHVzZUdyb3VwaW5nOiBmYWxzZSB9LFxuICAgICAgICAgICAgbWFwcGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMubG9jYWxlLCBtYXBwZXJPcHRpb25zKS5mb3JtYXQ7XG5cbiAgICAgICAgdGhpcy5kZW1hcHBlciA9IGRlbWFwLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IEEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICAgICAqIEBkZXNjIENvbnRhaW5zIGFsbCBsb2NhbGl6ZWQgZGlnaXRzICsgbG9jYWxpemVkIGRlY2ltYWwgcG9pbnQuXG4gICAgICAgICAqIElmIHdlJ3JlIGFjY2VwdGluZyBzdGFuZGFyZCBkaWdpdHMsIHdpbGwgYWxzbyBjb250YWluIGFsbCB0aGUgc3RhbmRhcmQgZGlnaXRzICsgc3RhbmRhcmQgZGVjaW1hbCBwb2ludCAoaWYgZGlmZmVyZW50IHRoYW4gbG9jYWxpemVkIHZlcnNpb25zKS5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGRlc2MgTG9jYWxpemVkIGRpZ2l0cyBhbmQgZGVjaW1hbCBwb2ludC4gV2lsbCBhbHNvIGluY2x1ZGUgc3RhbmRhcmRpemVkIGRpZ2l0cyBhbmQgZGVjaW1hbCBwb2ludCBpZiBgb3B0aW9ucy5hY2NlcHRTdGFuZGFyZERpZ2l0c2AgaXMgdHJ1dGh5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgaW50ZXJuYWwgdXNlIGJ5IHRoZSB7QGxpbmsgTnVtYmVyRm9ybWF0dGVyI3N0YW5kYXJkaXplfHN0YW5kYXJkaXplfSBtZXRob2QuXG4gICAgICAgICAqIEBtZW1iZXJPZiBOdW1iZXJGb3JtYXR0ZXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcCA9IG1hcHBlcigxMDEyMzQ1Njc4OS41KS5zdWJzdHIoMSwgMTEpOyAvLyBsb2NhbGl6ZWQgJzAxMjM0NTY3ODkuJ1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFjY2VwdFN0YW5kYXJkRGlnaXRzICYmIHRoaXMubWFwICE9PSAnMDEyMzQ1Njc4OS4nKSB7XG4gICAgICAgICAgICB0aGlzLm1hcCArPSAnMDEyMzQ1Njc4OS4nOyAgLy8gc3RhbmRhcmQgJzAxMjM0NTY3ODkuJ1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBzdW1tYXJ5IEEgcmVnZXggdGhhdCB0ZXN0cyBgdHJ1ZWAgb24gZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIuXG4gICAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBkZXNjIFZhbGlkIGNoYXJhY3RlcnMgaW5jbHVkZTpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBMb2NhbGl6ZWQgZGlnaXRzXG4gICAgICAgICAqICogTG9jYWxpemVkIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgICogKiBTdGFuZGFyZCBkaWdpdHMgKHdoZW4gYG9wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHNgIGlzIHRydXRoeSlcbiAgICAgICAgICogKiBTdGFuZGFyZCBkZWNpbWFsIHBvaW50ICh3aGVuIGBvcHRpb25zLmFjY2VwdFN0YW5kYXJkRGlnaXRzYCBpcyB0cnV0aHkpXG4gICAgICAgICAqICogQ29zbWV0aWMgY2hhcmFjdGVycyBhZGRlZCBieSBmb3JtYXR0ZXIgYXMgcGVyIGBvcHRpb25zYCAoZm9yIGh1bWFuLWZyaWVuZGx5IHJlYWRhYmlsaXR5KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQW55IGNoYXJhY3RlcnMgb3V0c2lkZSB0aGlzIHNldCBhcmUgY29uc2lkZXJlZCBpbnZhbGlkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yOyBjb25zdW1lZCBieSB0aGUge0BsaW5rIG1vZHVsZTpsb2NhbGl6YXRpb25+TnVtYmVyRm9ybWF0dGVyI2ludmFsaWR8aW52YWxpZH0gbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUZXN0aW5nIGEgc3RyaW5nIGFnYWluc3QgdGhpcyBwYXR0ZXJuIHlpZWxkcyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIGludmFsaWQgY2hhcmFjdGVyIG9yIGBmYWxzZWAgaWYgYWxsIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgICAgKiBAbWVtYmVyT2YgTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnZhbGlkcyA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnW14nICtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0KDExMTExKS5yZXBsYWNlKHRoaXMubWFwWzFdLCAnJykgKyAvLyB0aG91c2FuZHMgc2VwYXJhdG9yIGlmIGluIHVzZVxuICAgICAgICAgICAgdGhpcy5tYXAgKyAvLyBkaWdpdHMgKyBkZWNpbWFsIHBvaW50XG4gICAgICAgICAgICAnXSdcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IFRlc3RzIGZvciBpbnZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICogQGRlc2MgVGVzdHMgYSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbnVtYmVyIHRoYXQgaXQgY29udGFpbnMgYW55IGludmFsaWQgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIFRoZSBudW1iZXIgbWF5IGJlIHVuZm9ybWF0dGVkIG9yIGl0IG1heSBiZSBmb3JtYXR0ZWQgd2l0aCBhbnkgb2YgdGhlIHBlcm1pdHRlZCBmb3JtYXR0aW5nIGNoYXJhY3RlcnMsIGFzIGltcGxpZWQgYnkgdGhlIGNvbnN0cnVjdG9yJ3MgYG9wdGlvbnNgIChwYXNzZWQgdG8gYEludGwuTnVtYmVyRm9ybWF0YCkuIEFueSBvdGhlciBjaGFyYWN0ZXJzIGFyZSBjb25zaWRlcmVkIGludmFsaWQuXG4gICAgICpcbiAgICAgKiBIb3dldmVyLCBzdGFuZGFyZCBkaWdpdHMgYW5kIHRoZSBzdGFuZGFyZCBkZWNpbWFsIHBvaW50IGFyZSBjb25zaWRlcmVkIHZhbGlkIGlmIHRoZSB2YWx1ZSBvZiBgb3B0aW9ucy5hY2NlcHRTdGFuZGFyZERpZ2l0c2AgYXMgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yIHdhcyB0cnV0aHkuIChPZiBjb3Vyc2UsIHRoZXNlIGFyZSBhbHdheXMgdmFsaWQgZm9yIGxvY2FsZXMgdGhhdCB1c2UgdGhlbS4pXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG86XG4gICAgICogMS4gRmlsdGVyIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgb24gYSBgb25rZXlkb3duYCBldmVudDsgb3JcbiAgICAgKiAyLiBUZXN0IGFuIGVkaXRlZCBzdHJpbmcgcHJpb3IgdG8gY2FsbGluZyB0aGUge0BsaW5rIG1vZHVsZTpsb2NhbGl6YXRpb25+TnVtYmVyRm9ybWF0dGVyI3N0YW5kYXJkaXplfHN0YW5kYXJkaXplfS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgbWV0aG9kIGRvZXMgbm90IGNoZWNrIGdyYW1tYXRpY2FsIHN5bnRheDsgaXQgb25seSBjaGVja3MgZm9yIGludmFsaWQgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBudW1iZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxzdHJpbmd9IEZhbHN5IG1lYW5zIHZhbGlkIHdoaWNoIGluIHRoaXMgY2FzZSBtZWFucyBjb250YWlucyBvbmx5IHZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICogQG1lbWJlck9mIE51bWJlckZvcm1hdHRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbnZhbGlkOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52YWxpZHMudGVzdChudW1iZXIpO1xuICAgIH0sXG5cbiAgICBleHBlY3RhdGlvbjpcbiAgICAgICAgJ0V4cGVjdGVkIGEgbnVtYmVyIHdpdGggb3B0aW9uYWwgY29tbWFzICh0aG91c2FuZHMgZ3JvdXBpbmcgc2VwYXJhdG9yKSwgb3B0aW9uYWwgZGVjaW1hbCBwb2ludCwgYW5kIGFuIG9wdGlvbmFsIGZyYWN0aW9uYWwgcGFydC5cXG4nICtcbiAgICAgICAgJ0NvbW1hIHNlcGFyYXRvcnMgYXJlIHBhcnQgb2YgdGhlIGZvcm1hdCBhbmQgd2lsbCBhbHdheXMgYmUgZGlzcGxheWVkIGZvciB2YWx1ZXMgPj0gMTAwMC5cXG4nICtcbiAgICAgICAgJ0VkaXRlZCB2YWx1ZXMgYXJlIGFsd2F5cyBzYXZlZCBpbiB0aGVpciBlbnRpcmV0eSBldmVuIHRob3VnaCB0aGUgZm9ybWF0dGVkIHZhbHVlIGlzIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuJyxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGw6XG4gICAgICogKiBDb252ZXJ0IGxvY2FsaXplZCBkaWdpdHMgYW5kIGRlY2ltYWwgcG9pbnQgY2hhcmFjdGVycyB0byBzdGFuZGFyZCBkaWdpdHMgYW5kIGRlY2ltYWwgcG9pbnQgY2hhcmFjdGVycy5cbiAgICAgKiAqIFwiQ2xlYW5cIiB0aGUgc3RyaW5nIGJ5IGlnbm9yaW5nIGFsbCBvdGhlciBjaGFyYWN0ZXJzLlxuICAgICAqICogQ29lcmNlIHRoZSBzdHJpbmcgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXR0ZWRMb2NhbGl6ZWROdW1iZXIgLSBNYXkgb3IgbWF5IG5vdCBiZSBmb3JtYXR0ZWQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIHByaW1pdGl2ZS5cbiAgICAgKiBAdGhyb3dzIHtzdHJpbmd9IEludmFsaWQgbnVtYmVyLlxuICAgICAqIEBtZW1iZXJPZiBOdW1iZXJGb3JtYXR0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGZvcm1hdHRlZExvY2FsaXplZE51bWJlcikge1xuICAgICAgICB2YXIgbnVtYmVyID0gTnVtYmVyKFxuICAgICAgICAgICAgZm9ybWF0dGVkTG9jYWxpemVkTnVtYmVyLnNwbGl0KCcnKS5tYXAodGhpcy5kZW1hcHBlcikuam9pbignJylcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNOYU4obnVtYmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgJ0ludmFsaWQgTnVtYmVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGRlbWFwKGMpIHtcbiAgICB2YXIgZCA9IHRoaXMubWFwLmluZGV4T2YoYykgJSAxMTtcbiAgICByZXR1cm4gZCA8IDAgPyAnJyA6IGQgPCAxMCA/IGQgOiAnLic7XG59XG5cbi8qKlxuICogQGltcGxlbWVudHMgbG9jYWxpemVySW50ZXJmYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdExvY2FsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtsb2NhbGU9ZGVmYXVsdGxvY2FsZV0gLSBQYXNzZWQgdG8gdGhlIHtAbGluayBJbnRsLkRhdGVGb3JtYXR8aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZUZvcm1hdH0gY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBgSW50bC5EYXRlRm9ybWF0YCBjb25zdHJ1Y3Rvci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRGF0ZUZvcm1hdHRlciA9IEZvcm1hdHRlci5leHRlbmQoJ0RhdGVGb3JtYXR0ZXInLCB7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGVmYXVsdExvY2FsZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGxvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8qKiBAc3VtbWFyeSBUcmFuc2Zvcm0gYSBkYXRlIG9iamVjdCBpbnRvIGh1bWFuLWZyaWVuZGx5IHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmxvY2FsZSwgb3B0aW9ucykuZm9ybWF0O1xuXG4gICAgICAgIC8vIEdldCBkaWdpdHMgYmVjYXVzZSBtYXkgYmUgY2hpbmVzZSBvciBcInJlYWwgQXJhYmljXCIgbnVtZXJhbHMuXG4gICAgICAgIHZhciB0ZXN0T3B0aW9ucyA9IHsgdXNlR3JvdXBpbmc6IGZhbHNlLCBzdHlsZTogJ2RlY2ltYWwnIH0sXG4gICAgICAgICAgICBsb2NhbGl6ZU51bWJlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLmxvY2FsZSwgdGVzdE9wdGlvbnMpLmZvcm1hdCxcbiAgICAgICAgICAgIGxvY2FsaXplZERpZ2l0cyA9IHRoaXMubG9jYWxpemVkRGlnaXRzID0gbG9jYWxpemVOdW1iZXIoMTAxMjM0NTY3ODkpLnN1YnN0cigxLCAxMCk7IC8vIGFsbCBsb2NhbGl6ZWQgZGlnaXRzIGluIG51bWVyaWNhbCBvcmRlclxuXG4gICAgICAgIHRoaXMuZGlnaXRGb3JtYXR0ZXIgPSBmb3JtYXREaWdpdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRpZ2l0UGFyc2VyID0gcGFyc2VEaWdpdC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIExvY2FsaXplIGEgdGVzdCBkYXRlIHdpdGggdGhlIGRlZmF1bHQgbnVtZXJpYyBwYXJ0cyB0byBmaW5kIG91dCB0aGUgcmVzdWx0aW5nIG9yZGVyIG9mIHRoZXNlIHBhcnRzLlxuICAgICAgICB2YXIgeXkgPSAxOTg3LFxuICAgICAgICAgICAgbW0gPSAxMixcbiAgICAgICAgICAgIGRkID0gMzAsXG4gICAgICAgICAgICBZWSA9IHRoaXMudHJhbnNmb3JtTnVtYmVyKHRoaXMuZGlnaXRGb3JtYXR0ZXIsIHl5KSxcbiAgICAgICAgICAgIE1NID0gdGhpcy50cmFuc2Zvcm1OdW1iZXIodGhpcy5kaWdpdEZvcm1hdHRlciwgbW0pLFxuICAgICAgICAgICAgREQgPSB0aGlzLnRyYW5zZm9ybU51bWJlcih0aGlzLmRpZ2l0Rm9ybWF0dGVyLCBkZCksXG4gICAgICAgICAgICB0ZXN0RGF0ZSA9IG5ldyBEYXRlKHl5LCBtbSAtIDEsIGRkKSxcbiAgICAgICAgICAgIGxvY2FsaXplRGF0ZSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlKS5mb3JtYXQsXG4gICAgICAgICAgICBsb2NhbGl6ZWREYXRlID0gbG9jYWxpemVEYXRlKHRlc3REYXRlKSwgLy8gYWxsIGxvY2FsaXplZCBkaWdpdHMgKyBsb2NhbGl6ZWQgcHVuY3R1YXRpb25cbiAgICAgICAgICAgIG1pc3NpbmdEaWdpdHMgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQodGhpcy5sb2NhbGUpLmZvcm1hdCg0NTYpLFxuICAgICAgICAgICAgbG9jYWxpemVkTnVtYmVyUGF0dGVybiA9IHRoaXMubG9jYWxpemVkTnVtYmVyUGF0dGVybiA9IG5ldyBSZWdFeHAoJ1snICsgbG9jYWxpemVkRGlnaXRzICsgJ10rJywgJ2cnKSxcbiAgICAgICAgICAgIHBhcnRzID0gbG9jYWxpemVkRGF0ZS5tYXRjaChsb2NhbGl6ZWROdW1iZXJQYXR0ZXJuKTtcblxuICAgICAgICB0aGlzLnBhcnRzTWFwID0ge1xuICAgICAgICAgICAgeXk6IHBhcnRzLmluZGV4T2YoWVkpLFxuICAgICAgICAgICAgbW06IHBhcnRzLmluZGV4T2YoTU0pLFxuICAgICAgICAgICAgZGQ6IHBhcnRzLmluZGV4T2YoREQpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHMpIHtcbiAgICAgICAgICAgIG1pc3NpbmdEaWdpdHMgKz0gJzEyMzQ1Njc4OTAnO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBzdW1tYXJ5IEEgcmVnZXggdGhhdCB0ZXN0cyBgdHJ1ZWAgb24gZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIuXG4gICAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBkZXNjIFZhbGlkIGNoYXJhY3RlcnMgaW5jbHVkZTpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBMb2NhbGl6ZWQgZGlnaXRzXG4gICAgICAgICAqICogU3RhbmRhcmQgZGlnaXRzICh3aGVuIGBvcHRpb25zLmFjY2VwdFN0YW5kYXJkRGlnaXRzYCBpcyB0cnV0aHkpXG4gICAgICAgICAqICogTG9jYWxpemVkIHB1bmN0dWF0aW9uIHRvIGRlbGltaXQgZGF0ZSBwYXJ0c1xuICAgICAgICAgKlxuICAgICAgICAgKiBBbnkgY2hhcmFjdGVycyBvdXRzaWRlIHRoaXMgc2V0IGFyZSBjb25zaWRlcmVkIGludmFsaWQuIE5vdGUgdGhhdCB0aGlzIG9ubHkgY3VycmVudGx5IGltcGxlbWVudGVkIHdoZW4gYWxsIHRocmVlIGRhdGUgcGFydHMgYXJlIG51bWVyaWNcbiAgICAgICAgICpcbiAgICAgICAgICogU2V0IGJ5IHRoZSBjb25zdHJ1Y3RvcjsgY29uc3VtZWQgYnkgdGhlIHtAbGluayBOdW1iZXJGb3JtYXR0ZXIjdmFsaWR8dmFsaWR9IG1ldGhvZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGVzdGluZyBhIHN0cmluZyBhZ2FpbnN0IHRoaXMgcGF0dGVybiB5aWVsZHMgYHRydWVgIGlmIGF0IGxlYXN0IG9uZSBpbnZhbGlkIGNoYXJhY3RlciBvciBgZmFsc2VgIGlmIGFsbCBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cbiAgICAgICAgICogQG1lbWJlck9mIERhdGVGb3JtYXR0ZXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmludmFsaWRzID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdbXicgK1xuICAgICAgICAgICAgbG9jYWxpemVkRGF0ZSArXG4gICAgICAgICAgICBtaXNzaW5nRGlnaXRzICtcbiAgICAgICAgICAgICddJ1xuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKiogQHN1bW1hcnkgVGVzdHMgZm9yIGludmFsaWQgY2hhcmFjdGVycy5cbiAgICAgKiBAZGVzYyBUZXN0cyBhIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBudW1iZXIgdGhhdCBpdCBjb250YWlucyBhbnkgaW52YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogVGhlIGRhdGUgaXMgYXNzdW1lZCB0byBjb250YWluIGxvY2FsaXplZCBkaWdpdHMgYW5kIHB1bmN0dWF0aW9uIGFzIHdvdWxkIGJlIHJldHVybmVkIGJ5IGBJbnRsLkRhdGVGb3JtYXRgIHdpdGggdGhlIGdpdmVuIGBsb2NhbGVgIGFuZCBgb3B0aW9uc2AuIEFueSBvdGhlciBjaGFyYWN0ZXJzIGFyZSBjb25zaWRlcmVkIGludmFsaWQuXG4gICAgICpcbiAgICAgKiBIb3dldmVyLCBzdGFuZGFyZCBkaWdpdHMgYW5kIHRoZSBzdGFuZGFyZCBkZWNpbWFsIHBvaW50IGFyZSBhbHNvIGNvbnNpZGVyZWQgdmFsaWQgaWYgdGhlIHZhbHVlIG9mIGBvcHRpb25zLmFjY2VwdFN0YW5kYXJkRGlnaXRzYCBhcyBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3Igd2FzIHRydXRoeS4gKE9mIGNvdXJzZSwgdGhlc2UgYXJlIGFsd2F5cyB2YWxpZCBmb3IgbG9jYWxlcyB0aGF0IHVzZSB0aGVtLilcbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0bzpcbiAgICAgKiAxLiBGaWx0ZXIgb3V0IGludmFsaWQgY2hhcmFjdGVycyBvbiBhIGBvbmtleWRvd25gIGV2ZW50OyBvclxuICAgICAqIDIuIFRlc3QgYW4gZWRpdGVkIHN0cmluZyBwcmlvciB0byBjYWxsaW5nIHRoZSB7QGxpbmsgbW9kdWxlOmxvY2FsaXphdGlvbn5EYXRlRm9ybWF0dGVyI3N0YW5kYXJkaXplfHN0YW5kYXJkaXplfS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgZGF0ZSBmb3JtYXRzIHVzaW5nIGFsbCBudW1lcmljcyAod2hpY2ggaXMgdGhlIGRlZmF1bHQgZm9yIGBJbnRsLkRhdGVGb3JtYXRgKS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgbWV0aG9kIGRvZXMgbm90IGNoZWNrIGdyYW1tYXRpY2FsIHN5bnRheDsgaXQgb25seSBjaGVja3MgZm9yIGludmFsaWQgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBudW1iZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQ29udGFpbnMgb25seSB2YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAqIEBtZW1iZXJPZiBEYXRlRm9ybWF0dGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGludmFsaWQ6IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnZhbGlkcy50ZXN0KG51bWJlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGw6XG4gICAgICogKiBDb252ZXJ0IGxvY2FsaXplZCBkYXRlIHRvIERhdGUgb2JqZWN0LlxuICAgICAqICogXCJDbGVhblwiIHRoZSBzdHJpbmcgYnkgaWdub3JpbmcgYWxsIG90aGVyIGNoYXJhY3RlcnMuXG4gICAgICogKiBDb2VyY2UgdGhlIHN0cmluZyB0byBhIG51bWJlciBwcmltaXRpdmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsaXplZERhdGVcbiAgICAgKiBAcmV0dXJucyB7RGF0ZX1cbiAgICAgKiBAdGhyb3dzIHtzdHJpbmd9IEludmFsaWQgZGF0ZS5cbiAgICAgKiBAbWVtYmVyT2YgRGF0ZUZvcm1hdHRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYXJzZTogZnVuY3Rpb24obG9jYWxpemVkRGF0ZSkge1xuICAgICAgICB2YXIgZGF0ZSxcbiAgICAgICAgICAgIHBhcnRzID0gbG9jYWxpemVkRGF0ZS5tYXRjaCh0aGlzLmxvY2FsaXplZE51bWJlclBhdHRlcm4pO1xuXG4gICAgICAgIGlmIChwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy50cmFuc2Zvcm1OdW1iZXIodGhpcy5kaWdpdFBhcnNlciwgcGFydHNbdGhpcy5wYXJ0c01hcC55eV0pLFxuICAgICAgICAgICAgICAgIG0gPSB0aGlzLnRyYW5zZm9ybU51bWJlcih0aGlzLmRpZ2l0UGFyc2VyLCBwYXJ0c1t0aGlzLnBhcnRzTWFwLm1tXSkgLSAxLFxuICAgICAgICAgICAgICAgIGQgPSB0aGlzLnRyYW5zZm9ybU51bWJlcih0aGlzLmRpZ2l0UGFyc2VyLCBwYXJ0c1t0aGlzLnBhcnRzTWFwLmRkXSk7XG5cbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93ICdJbnZhbGlkIERhdGUnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhIG51bWJlciB0byBvciBmcm9tIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIHdpdGggbG9jYWxpemVkIGRpZ2l0cy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBkaWdpdFRyYW5zZm9ybWVyIC0gQSBmdW5jdGlvbiBib3VuZCB0byBgdGhpc2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyT2YgRGF0ZUZvcm1hdHRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1OdW1iZXI6IGZ1bmN0aW9uKGRpZ2l0VHJhbnNmb3JtZXIsIG51bWJlcikge1xuICAgICAgICByZXR1cm4gbnVtYmVyLnRvU3RyaW5nKCkuc3BsaXQoJycpLm1hcChkaWdpdFRyYW5zZm9ybWVyKS5qb2luKCcnKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gZm9ybWF0RGlnaXQoZCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsaXplZERpZ2l0c1tkXTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEaWdpdChjKSB7XG4gICAgdmFyIGQgPSB0aGlzLmxvY2FsaXplZERpZ2l0cy5pbmRleE9mKGMpO1xuICAgIGlmIChkIDwgMCkgeyBkID0gJyc7IH1cbiAgICByZXR1cm4gZDtcbn1cblxuLyoqXG4gKiBBbGwgbWVtYmVycyBhcmUgbG9jYWxpemVycyAoY29uZm9ybSB0byB7QGxpbmsgbG9jYWxpemVySW50ZXJmYWNlfSkgd2l0aCBleGNlcHRpb24gb2YgYGdldGAsIGBzZXRgLCBhbmQgbG9jYWxpemVyIGNvbnN0cnVjdG9ycyB3aGljaCBhcmUgbmFtZWQgKGJ5IGNvbnZlbnRpb24pIGVuZGluZyBpbiBcIkZvcm1tYXR0ZXJcIi5cbiAqXG4gKiBUaGUgYXBwbGljYXRpb24gZGV2ZWxvcGVyIGlzIGZyZWUgdG8gYWRkIGxvY2FsaXplcnMgYW5kIGxvY2FsaXplciBmYWN0b3J5IG1ldGhvZHMuIFNlZSB0aGUge0BsaW5rIExvY2FsaXphdGlvbiNjb25zdHJ1Y3R8Y29uc3RydWN0fSBjb252ZW5pZW5jZSBtZXRob2Qgd2hpY2ggbWF5IGJlIGhlbHBmdWwgaW4gdGhpcyByZWdhcmQuXG4gKiBAcGFyYW0gbG9jYWxlXG4gKiBAcGFyYW0ge29iamVjdH0gW251bWJlck9wdGlvbnNdXG4gKiBAcGFyYW0ge29iamVjdH0gW2RhdGVPcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIExvY2FsaXphdGlvbihsb2NhbGUsIG51bWJlck9wdGlvbnMsIGRhdGVPcHRpb25zKSB7XG4gICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBudW1iZXJcbiAgICAgKiBAc2VlIFRoZSB7QGxpbmsgTnVtYmVyRm9ybWF0dGVyfE51bWJlckZvcm1hdHRlcn0gY2xhc3NcbiAgICAgKiBAbWVtYmVyT2YgTG9jYWxpemF0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRoaXMuaW50ID0gdGhpcy5mbG9hdCA9IHRoaXMuY29uc3RydWN0KCdudW1iZXInLCBOdW1iZXJGb3JtYXR0ZXIsIG51bWJlck9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHNlZSBUaGUge0BsaW5rIERhdGVGb3JtYXR0ZXJ8RGF0ZUZvcm1hdHRlcn0gY2xhc3NcbiAgICAgKiBAbWVtYmVyT2YgTG9jYWxpemF0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RydWN0KCdkYXRlJywgRGF0ZUZvcm1hdHRlciwgZGF0ZU9wdGlvbnMpO1xufVxuXG5Mb2NhbGl6YXRpb24ucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBMb2NhbGl6YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgLyoqIEBzdW1tYXJ5IENyZWF0ZXMgYSBsb2NhbGl6ZXIgZnJvbSBhIGxvY2FsaXplciBmYWN0b3J5IG9iamVjdCB1c2luZyB0aGUgZGVmYXVsdCBsb2NhbGUuXG4gICAgICogQGRlc2MgUGVyZm9ybXMgdGhlIGZvbGxvd2luZyBhY3Rpb25zOlxuICAgICAqIDEuIEJpbmRzIGBDb25zdHJ1Y3RvcmAgdG8gYGxvY2FsZWAuXG4gICAgICogMi4gQWRkcyB0aGUgbmV3bHkgYm91bmQgY29uc3RydWN0b3IgdG8gdGhpcyBvYmplY3QgKGZvciBmdXR1cmUgcmVmZXJlbmNlKSB3aXRoIHRoZSBrZXkgXCJOYW1lRm9ybWF0dGVyXCIgKHdoZXJlIFwiTmFtZVwiIGlzIHRoZSBsb2NhbGl6ZXIgbmFtZSwgYWxsIGxvd2VyIGNhc2UgYnV0IHdpdGggYW4gaW5pdGlhbCBjYXBpdGFsKS5cbiAgICAgKiAzLiBVc2VzIHRoZSBuZXdseSBib3VuZCBjb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBuZXcgbG9jYWxpemVkIGxvY2FsaXplciB3aXRoIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIDQuIEFkZHMgbmV3IGxvY2FsaXplciB0byB0aGlzIG9iamVjdCB2aWEge0BsaW5rIExvY2FsaXphdGlvbiNhZGR8YWRkfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbGl6ZXJOYW1lXG4gICAgICogQHBhcmFtIHtDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB7ZmFjdG9yeU9wdGlvbnN9XG4gICAgICogQHJldHVybnMge2xvY2FsaXplSW5lcmZhY2V9IFRoZSBuZXcgbG9jYWxpemVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdDogZnVuY3Rpb24obG9jYWxpemVyTmFtZSwgQ29uc3RydWN0b3IsIGZhY3RvcnlPcHRpb25zKSB7XG4gICAgICAgIHZhciBjb25zdHJ1Y3Rvck5hbWUgPSBsb2NhbGl6ZXJOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBsb2NhbGl6ZXJOYW1lLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpICsgJ0Zvcm1hdHRlcicsXG4gICAgICAgICAgICBCb3VuZENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3IuYmluZChudWxsLCB0aGlzLmxvY2FsZSksXG4gICAgICAgICAgICBsb2NhbGl6ZXIgPSBuZXcgQm91bmRDb25zdHJ1Y3RvcihmYWN0b3J5T3B0aW9ucyk7XG5cbiAgICAgICAgdGhpc1tjb25zdHJ1Y3Rvck5hbWVdID0gQm91bmRDb25zdHJ1Y3RvcjtcblxuICAgICAgICByZXR1cm4gdGhpcy5hZGQobG9jYWxpemVyTmFtZSwgbG9jYWxpemVyKTtcbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IFJlZ2lzdGVyIGEgbG9jYWxpemVyLlxuICAgICAqIEBkZXNjIENoZWNrcyB0aGUgcHJvdmlkZWQgbG9jYWxpemVyIHRoYXQgaXQgY29uZm9ybXMgdG8ge0BsaW5rIGxvY2FsaXplckludGVyZmFjZX1cbiAgICAgKiBhbmQgYWRkcyBpdCB0byB0aGUgb2JqZWN0IHVzaW5nIGxvY2FsaXplck5hbWUgYWxsIGxvd2VyIGNhc2UgYXMgdGhlIGtleS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7bG9jYWxpemVySW50ZXJmYWNlfSBsb2NhbGl6ZXJcbiAgICAgKiBAbWVtYmVyT2YgTG9jYWxpemF0aW9uLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtsb2NhbGl6ZUluZXJmYWNlfSBUaGUgcHJvdmlkZWQgbG9jYWxpemVyLlxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24obmFtZSwgbG9jYWxpemVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGxvY2FsaXplciA9IG5hbWU7XG4gICAgICAgICAgICBuYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGxvY2FsaXplciAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBsb2NhbGl6ZXIuZm9ybWF0ICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICB0eXBlb2YgbG9jYWxpemVyLnBhcnNlICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICBsb2NhbGl6ZXIuaW52YWxpZCAmJiB0eXBlb2YgbG9jYWxpemVyLmludmFsaWQgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGxvY2FsaXplci5leHBlY3RhdGlvbiAmJiB0eXBlb2YgbG9jYWxpemVyLmV4cGVjdGF0aW9uICE9PSAnc3RyaW5nJ1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBsb2NhbGl6ZXIgb2JqZWN0IHRvIGNvbmZvcm0gdG8gaW50ZXJmYWNlLic7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lID0gbmFtZSB8fCBsb2NhbGl6ZXIubmFtZTtcbiAgICAgICAgbmFtZSA9IG5hbWUgJiYgbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzW25hbWVdID0gbG9jYWxpemVyO1xuXG4gICAgICAgIHJldHVybiBsb2NhbGl6ZXI7XG4gICAgfSxcbiAgICBkZXByZWNhdGVkOiBkZXByZWNhdGVkLFxuICAgIHNldDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ3NldChuYW1lLCBsb2NhbGl6ZXIpJywgJ2FkZChuYW1lLCBsb2NhbGl6ZXIpJywgJzEuMC42JywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxpemVyTmFtZVxuICAgICAqIEByZXR1cm5zIHtsb2NhbGl6ZXJJbnRlcmZhY2V9XG4gICAgICogQG1lbWJlck9mIExvY2FsaXphdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbbmFtZSAmJiBuYW1lLnRvTG93ZXJDYXNlKCldIHx8IHRoaXMuc3RyaW5nO1xuICAgIH0sXG5cbiAgICAvLy8gIC8vLyAgLy8vICAvLy8gIC8vLyAgICBMT0NBTElaRVJTICAgIC8vLyAgLy8vICAvLy8gIC8vLyAgLy8vXG5cbiAgICAvLyBTcGVjaWFsIGxvY2FsaXplciBmb3IgdXNlIGJ5IENocm9tZSdzIGRhdGUgaW5wdXQgY29udHJvbC5cbiAgICBjaHJvbWVEYXRlOiB7XG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgaWYgKGRhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB5eSA9IGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgbSA9IGRhdGUuZ2V0TW9udGgoKSArIDEsIG1tID0gbSA8IDEwID8gJzAnICsgbSA6IG0sXG4gICAgICAgICAgICAgICAgICAgIGQgPSBkYXRlLmdldERhdGUoKSwgZGQgPSBkIDwgMTAgPyAnMCcgKyBkIDogZDtcblxuICAgICAgICAgICAgICAgIGRhdGUgPSB5eSArICctJyArIG1tICsgJy0nICsgZGQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHZhciBkYXRlLFxuICAgICAgICAgICAgICAgIHBhcnRzID0gc3RyLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBpZiAocGFydHMgJiYgcGFydHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHBhcnRzWzBdLCBwYXJ0c1sxXSAtIDEsIHBhcnRzWzJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBudWxsOiB7XG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzdHJpbmc6IHtcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICsgJyc7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIgKyAnJztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTG9jYWxpemF0aW9uO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG4vKiBnbG9iYWwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG52YXIgaW1hZ2VzID0gcmVxdWlyZSgnLi4vLi4vaW1hZ2VzJyk7XG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAqIEBzZWUgW0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRClcbiAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgZmluLWh5cGVyZ3JpZC1yZW5kZXJlciBpcyB0aGUgY2FudmFzIGVuYWJsZWQgdG9wIGxldmVsIHN1YiBjb21wb25lbnQgdGhhdCBoYW5kbGVzIHRoZSByZW5kZXJlcmluZyBvZiB0aGUgR3JpZC5cbiAqXG4gKiBJdCByZWxpZXMgb24gdHdvIG90aGVyIGV4dGVybmFsIHN1YnByb2plY3RzXG4gKlxuICogMS4gZmluLWNhbnZhczogYSB3cmFwcGVyIHRvIHByb3ZpZGUgYSBzaW1wbGVyIGludGVyZmFjZSB0byB0aGUgSFRNTDUgY2FudmFzIGNvbXBvbmVudFxuICogMi4gcmVjdGFuZ3VsYXI6IGEgc21hbGwgbnBtIG1vZHVsZSBwcm92aWRpbmcgUG9pbnQgYW5kIFJlY3RhbmdsZSBvYmplY3RzXG4gKlxuICogVGhlIGZpbi1oeXBlcmdyaWQtcmVuZGVyZXIgaXMgaW4gYSB1bmlxdWUgcG9zaXRpb24gdG8gcHJvdmlkZSBjcml0aWNhbCBmdW5jdGlvbmFsaXR5IHRvIHRoZSBmaW4taHlwZXJncmlkIGluIGEgaGlnaHRseSBwZXJmb3JtYW50IG1hbm5lci5cbiAqIEJlY2F1c2UgaXQgTVVTVCBpdGVyYXRlIG92ZXIgYWxsIHRoZSB2aXNpYmxlIGNlbGxzIGl0IGNhbiBzdG9yZSB2YXJpb3VzIGJpdHMgb2YgaW5mb3JtYXRpb24gdGhhdCBjYW4gYmUgZW5jYXBzdWxhdGVkIGFzIGEgc2VydmljZSBmb3IgY29uc3VtcHRpb24gYnkgdGhlIGZpbi1oeXBlcmdyaWQgY29tcG9uZW50LlxuICpcbiAqIEluc3RhbmNlcyBvZiB0aGlzIG9iamVjdCBoYXZlIGJhc2ljYWxseSBmb3VyIG1haW4gZnVuY3Rpb25zLlxuICpcbiAqIDEuIHJlbmRlciBmaXhlZCByb3cgaGVhZGVyc1xuICogMi4gcmVuZGVyIGZpeGVkIGNvbCBoZWFkZXJzXG4gKiAzLiByZW5kZXIgbWFpbiBkYXRhIGNlbGxzXG4gKiA0LiByZW5kZXIgZ3JpZCBsaW5lc1xuICpcbiAqIFNhbWUgcGFyYW1ldGVycyBhcyB7QGxpbmsgUmVuZGVyZXIjaW5pdGlhbGl6ZXxpbml0aWFsaXplfSwgd2hpY2ggaXMgY2FsbGVkIGJ5IHRoaXMgY29uc3RydWN0b3IuXG4gKlxuICovXG52YXIgUmVuZGVyZXIgPSBCYXNlLmV4dGVuZCgnUmVuZGVyZXInLCB7XG5cbiAgICAvL3RoZSBzaGFyZWQgc2luZ2xlIGl0ZW0gXCJwb29sZWRcIiBjZWxsIG9iamVjdCBmb3IgZHJhd2luZyBlYWNoIGNlbGxcbiAgICBjZWxsOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICB9LFxuXG4gICAgc2Nyb2xsSGVpZ2h0OiAwLFxuXG4gICAgdmlld0hlaWdodDogMCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ib3VuZHMgPSB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbHVtbkVkZ2VzID0gW107XG4gICAgICAgIHRoaXMuY29sdW1uRWRnZXNJbmRleE1hcCA9IFtdO1xuICAgICAgICB0aGlzLnJlbmRlcmVkQ29sdW1uTWluV2lkdGhzID0gW107XG4gICAgICAgIHRoaXMucm93RWRnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yb3dFZGdlc0luZGV4TWFwID0gW107XG4gICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnMgPSBbXTtcbiAgICAgICAgdGhpcy52aXNpYmxlUm93cyA9IFtdO1xuICAgICAgICB0aGlzLmluc2VydGlvbkJvdW5kcyA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb25zdHJ1Y3RvciBsb2dpY1xuICAgICAqIEBkZXNjIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIHVwb24gaW5zdGFudGlhdGlvbiBvZiB0aGlzIGNsYXNzIG9yIG9mIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgZnJvbSB0aGlzIGNsYXNzLlxuICAgICAqID4gQWxsIGBpbml0aWFsaXplKClgIG1ldGhvZHMgaW4gdGhlIGluaGVyaXRhbmNlIGNoYWluIGFyZSBjYWxsZWQsIGluIHR1cm4sIGVhY2ggd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLCBiZWdpbm5pbmcgd2l0aCB0aGF0IG9mIHRoZSBtb3N0IFwic2VuaW9yXCIgY2xhc3MgdGhyb3VnaCB0aGF0IG9mIHRoZSBjbGFzcyBvZiB0aGUgbmV3IGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9LFxuXG4gICAgLy90aGlzIGZ1bmN0aW9uIGNvbXB1dGVzIHRoZSBncmlkIGNvb3JkaW5hdGVzIHVzZWQgZm9yIGV4dHJlbWVseSBmYXN0IGl0ZXJhdGlvbiBvdmVyXG4gICAgLy9wYWludGluZyB0aGUgZ3JpZCBjZWxscy4gdGhpcyBmdW5jdGlvbiBpcyB2ZXJ5IGZhc3QsIGZvciB0aG91c2FuZCByb3dzIFggMTAwIGNvbHVtbnNcbiAgICAvL29uIGEgbW9kZXN0IG1hY2hpbmUgdGFraW5nIHVzdWFsbHkgMG1zIGFuZCBubyBtb3JlIHRoYXQgMyBtcy5cbiAgICBjb21wdXRlQ2VsbHNCb3VuZHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuZ2V0U2Nyb2xsVG9wKCksXG4gICAgICAgICAgICBzY3JvbGxMZWZ0ID0gdGhpcy5nZXRTY3JvbGxMZWZ0KCksXG5cbiAgICAgICAgICAgIG51bUNvbHVtbnMgPSB0aGlzLmdldENvbHVtbkNvdW50KCksXG4gICAgICAgICAgICBudW1GaXhlZENvbHVtbnMgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKSxcblxuICAgICAgICAgICAgbnVtUm93cyA9IHRoaXMuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgICAgIG51bUZpeGVkUm93cyA9IHRoaXMuZ2V0Rml4ZWRSb3dDb3VudCgpLFxuXG4gICAgICAgICAgICBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuICAgICAgICAgICAgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgICAgIG51bWJlck9mQm90dG9tVG90YWxzUm93cyA9IGdyaWQuYmVoYXZpb3IuZGF0YU1vZGVsLmdldEJvdHRvbVRvdGFscygpLmxlbmd0aCxcbiAgICAgICAgICAgIHZpZXdXaWR0aCA9IGJvdW5kcy53aWR0aCB8fCBncmlkLmNhbnZhcy53aWR0aCwgLy8gaWYgMCwgd2UgbXVzdCBiZSBpbiBib290c3RyYXBcbiAgICAgICAgICAgIHZpZXdIZWlnaHQgPSBib3VuZHMuaGVpZ2h0IC0gbnVtYmVyT2ZCb3R0b21Ub3RhbHNSb3dzICogZ3JpZC5iZWhhdmlvci5nZXREZWZhdWx0Um93SGVpZ2h0KCksXG5cbiAgICAgICAgICAgIGluc2VydGlvbkJvdW5kc0N1cnNvciA9IDAsXG4gICAgICAgICAgICBwcmV2aW91c0luc2VydGlvbkJvdW5kc0N1cnNvclZhbHVlID0gMCxcblxuICAgICAgICAgICAgc3RhcnQgPSAwLFxuICAgICAgICAgICAgeCA9IDAsIHkgPSAwLFxuICAgICAgICAgICAgYywgcixcbiAgICAgICAgICAgIHZ4LCB2eSxcbiAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgICBmaXJzdFZYLCBsYXN0VlgsXG4gICAgICAgICAgICBmaXJzdFZZLCBsYXN0Vlk7XG5cbiAgICAgICAgdGhpcy5nZXRDb2x1bW5FZGdlcygpLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucm93RWRnZXMubGVuZ3RoID0gMDtcblxuICAgICAgICB0aGlzLmNvbHVtbkVkZ2VzWzBdID0gMDtcbiAgICAgICAgdGhpcy5yb3dFZGdlc1swXSA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gMDtcblxuICAgICAgICB0aGlzLnZpc2libGVDb2x1bW5zLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMudmlzaWJsZVJvd3MubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW5FZGdlc0luZGV4TWFwID0gW107XG4gICAgICAgIHRoaXMucm93RWRnZXNJbmRleE1hcCA9IFtdO1xuXG4gICAgICAgIHRoaXMuaW5zZXJ0aW9uQm91bmRzID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCkpIHtcbiAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkVkZ2VzWy0xXSA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjID0gc3RhcnQ7IGMgPCBudW1Db2x1bW5zOyBjKyspIHtcbiAgICAgICAgICAgIHZ4ID0gYztcbiAgICAgICAgICAgIGlmIChjID49IG51bUZpeGVkQ29sdW1ucykge1xuICAgICAgICAgICAgICAgIHZ4ID0gdnggKyBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFZYID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RWWCA9IHZ4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0VlggPSB2eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID4gdmlld1dpZHRoIHx8IG51bUNvbHVtbnMgPD0gdngpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpZHRoID0gZ3JpZC5nZXRDb2x1bW5XaWR0aCh2eCk7XG4gICAgICAgICAgICB4ID0geCArIHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5FZGdlc1tjICsgMV0gPSBNYXRoLnJvdW5kKHgpO1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlQ29sdW1uc1tjXSA9IHZ4O1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5FZGdlc0luZGV4TWFwW3Z4XSA9IGM7XG5cbiAgICAgICAgICAgIGluc2VydGlvbkJvdW5kc0N1cnNvciA9IGluc2VydGlvbkJvdW5kc0N1cnNvciArIE1hdGgucm91bmQod2lkdGggLyAyKSArIHByZXZpb3VzSW5zZXJ0aW9uQm91bmRzQ3Vyc29yVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmluc2VydGlvbkJvdW5kcy5wdXNoKGluc2VydGlvbkJvdW5kc0N1cnNvcik7XG4gICAgICAgICAgICBwcmV2aW91c0luc2VydGlvbkJvdW5kc0N1cnNvclZhbHVlID0gTWF0aC5yb3VuZCh3aWR0aCAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChyID0gMDsgciA8IG51bVJvd3M7IHIrKykge1xuICAgICAgICAgICAgdnkgPSByO1xuICAgICAgICAgICAgaWYgKHIgPj0gbnVtRml4ZWRSb3dzKSB7XG4gICAgICAgICAgICAgICAgdnkgPSB2eSArIHNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RWWSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0VlkgPSB2eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFZZID0gdnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSA+IHZpZXdIZWlnaHQgfHwgbnVtUm93cyA8PSB2eSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVpZ2h0ID0gZ3JpZC5nZXRSb3dIZWlnaHQodnkpO1xuICAgICAgICAgICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnJvd0VkZ2VzW3IgKyAxXSA9IE1hdGgucm91bmQoeSk7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVSb3dzW3JdID0gdnk7XG4gICAgICAgICAgICB0aGlzLnJvd0VkZ2VzSW5kZXhNYXBbdnldID0gcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdIZWlnaHQgPSB2aWV3SGVpZ2h0O1xuICAgICAgICB0aGlzLmRhdGFXaW5kb3cgPSB0aGlzLmdyaWQubmV3UmVjdGFuZ2xlKGZpcnN0VlgsIGZpcnN0VlksIGxhc3RWWCAtIGZpcnN0VlgsIGxhc3RWWSAtIGZpcnN0VlkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge09iamVjdH0gYSBwcm9wZXJ0eSB2YWx1ZSBhdCBhIGtleSwgZGVsZWdhdGVzIHRvIHRoZSBncmlkXG4gICAgICovXG4gICAgcmVzb2x2ZVByb3BlcnR5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5yZXNvbHZlUHJvcGVydHkoa2V5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IE5vdGlmeSB0aGUgZmluLWh5cGVyZ3JpZCBldmVyeXRpbWUgd2UndmUgcmVwYWludGVkLlxuICAgICAqIEBkZXNjIFRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2NcbiAgICAgKi9cbiAgICBwYWludDogZnVuY3Rpb24oZ2MpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0RhdGEoKSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5ncmlkLnJlc29sdmVQcm9wZXJ0eSgnbm9EYXRhTWVzc2FnZScpO1xuICAgICAgICAgICAgICAgIGdjLmZvbnQgPSAnMjBweCBBcmlhbCc7XG4gICAgICAgICAgICAgICAgZ2MuZmlsbFRleHQobWVzc2FnZSwgMjAsIDMwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJHcmlkKGdjKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuZ3JpZFJlbmRlcmVkTm90aWZpY2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ncmlkLmJlaGF2aW9yLmdldERhdGEoKTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gQW5zd2VyIGhvdyBtYW55IHJvd3Mgd2UgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlUm93c0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVJvd3MubGVuZ3RoIC0gMTtcbiAgICB9LFxuXG4gICAgZ2V0VmlzaWJsZVNjcm9sbEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdIZWlnaHQgLSB0aGlzLmdyaWQuZ2V0Rml4ZWRSb3dzSGVpZ2h0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IFJvd3Mgd2UganVzdCByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVSb3dzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gTnVtZXIgb2YgY29sdW1ucyB3ZSBqdXN0IHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlQ29sdW1ucy5sZW5ndGggLSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gQ29sdW1ucyB3ZSBqdXN0IHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZUNvbHVtbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY29sdW1uIGluZGV4IHdobmUgdGhlIG1vdXNlRXZlbnQgY29vcmRpbmF0ZXMgYXJlIG92ZXIgYSBjb2x1bW4gZGl2aWRlci5cbiAgICAgKi9cbiAgICBvdmVyQ29sdW1uRGl2aWRlcjogZnVuY3Rpb24oeCkge1xuICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICB2YXIgd2hpY2hDb2wgPSBlZGdlcy5pbmRleE9mKHggLSAxKTtcbiAgICAgICAgaWYgKHdoaWNoQ29sIDwgMCkge1xuICAgICAgICAgICAgd2hpY2hDb2wgPSBlZGdlcy5pbmRleE9mKHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aGljaENvbCA8IDApIHtcbiAgICAgICAgICAgIHdoaWNoQ29sID0gZWRnZXMuaW5kZXhPZih4IC0gMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdoaWNoQ29sIDwgMCkge1xuICAgICAgICAgICAgd2hpY2hDb2wgPSBlZGdlcy5pbmRleE9mKHggKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hpY2hDb2wgPCAwKSB7XG4gICAgICAgICAgICB3aGljaENvbCA9IGVkZ2VzLmluZGV4T2YoeCAtIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdoaWNoQ29sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJvdyBpbmRleCB3aGVuIHRoZSBtb3VzZUV2ZW50IGNvb3JkaW5hdGVzIGFyZSBvdmVyIGEgcm93IGRpdmlkZXIuXG4gICAgICovXG4gICAgb3ZlclJvd0RpdmlkZXI6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgeSA9IE1hdGgucm91bmQoeSk7XG4gICAgICAgIHZhciB3aGljaCA9IHRoaXMucm93RWRnZXMuaW5kZXhPZih5ICsgMSk7XG4gICAgICAgIGlmICh3aGljaCA8IDApIHtcbiAgICAgICAgICAgIHdoaWNoID0gdGhpcy5yb3dFZGdlcy5pbmRleE9mKHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aGljaCA8IDApIHtcbiAgICAgICAgICAgIHdoaWNoID0gdGhpcy5yb3dFZGdlcy5pbmRleE9mKHkgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2hpY2g7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gQm91bmRpbmcgcmVjdCBvZiB0aGUgZ2l2ZW4gYGNlbGxgLlxuICAgICAqL1xuICAgIGdldEJvdW5kc09mQ2VsbDogZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Qm91bmRzT2ZDZWxsKGNlbGwueCwgY2VsbC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjIC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gciAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IEJvdW5kaW5nIHJlY3Qgb2YgY2VsbCB3aXRoIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBfZ2V0Qm91bmRzT2ZDZWxsOiBmdW5jdGlvbihjLCByKSB7XG4gICAgICAgIHZhciB4T3V0c2lkZSA9IGZhbHNlLFxuICAgICAgICAgICAgeU91dHNpZGUgPSBmYWxzZSxcbiAgICAgICAgICAgIGNlbGwgPSB0aGlzLmNlbGw7XG5cbiAgICAgICAgdmFyIHksIHggPSB0aGlzLmNvbHVtbkVkZ2VzSW5kZXhNYXBbY107XG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHggPSB0aGlzLmNvbHVtbkVkZ2VzSW5kZXhNYXBbYyAtIDFdO1xuICAgICAgICAgICAgeE91dHNpZGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG95LCBveCA9IHRoaXMuY29sdW1uRWRnZXNbeF0sXG4gICAgICAgICAgICBjeSwgY3ggPSB0aGlzLmNvbHVtbkVkZ2VzW3ggKyAxXSxcbiAgICAgICAgICAgIGV5LCBleCA9IGN4IC0gb3g7XG5cbiAgICAgICAgY2VsbC54ID0geE91dHNpZGUgPyBjeCA6IG94O1xuICAgICAgICBjZWxsLndpZHRoID0geE91dHNpZGUgPyAwIDogZXg7XG5cbiAgICAgICAgaWYgKHIgPCAwKSB7IC8vIGJvdHRvbSB0b3RhbHMgcm93c1xuICAgICAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5ncmlkLmJlaGF2aW9yLFxuICAgICAgICAgICAgICAgIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG5cbiAgICAgICAgICAgIGV5ID0gYmVoYXZpb3IuZ2V0RGVmYXVsdFJvd0hlaWdodCgpO1xuICAgICAgICAgICAgb3kgPSBib3VuZHMuaGVpZ2h0ICsgciAqIGV5O1xuICAgICAgICAgICAgY3kgPSBveSArIGV5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeSA9IHRoaXMucm93RWRnZXNJbmRleE1hcFtyXTtcbiAgICAgICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5yb3dFZGdlc0luZGV4TWFwW3IgLSAxXTtcbiAgICAgICAgICAgICAgICB5T3V0c2lkZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG95ID0gdGhpcy5yb3dFZGdlc1t5XTtcbiAgICAgICAgICAgIGN5ID0gdGhpcy5yb3dFZGdlc1t5ICsgMV07XG4gICAgICAgICAgICBleSA9IGN5IC0gb3k7XG4gICAgICAgIH1cblxuICAgICAgICBjZWxsLnkgPSB5T3V0c2lkZSA/IGN5IDogb3k7XG4gICAgICAgIGNlbGwuaGVpZ2h0ID0geU91dHNpZGUgPyAwIDogZXk7XG5cbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbnN3ZXIgdGhlIGNvbHVtbiBpbmRleCB1bmRlciB0aGUgY29vcmRpbmF0ZSBhdCBwaXhlbFhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxYIC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY29sdW1uIGluZGV4IHVuZGVyIHRoZSBjb29yZGluYXRlIGF0IHBpeGVsWC5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Gcm9tUGl4ZWxYOiBmdW5jdGlvbihwaXhlbFgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gMCxcbiAgICAgICAgICAgIGZpeGVkQ29sdW1uQ291bnQgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSB0aGlzLmdyaWQuZ2V0SFNjcm9sbFZhbHVlKCksXG4gICAgICAgICAgICBlZGdlcyA9IHRoaXMuZ2V0Q29sdW1uRWRnZXMoKTtcblxuICAgICAgICBmb3IgKHZhciBjID0gMTsgYyA8IGVkZ2VzLmxlbmd0aCAtIDE7IGMrKykge1xuICAgICAgICAgICAgd2lkdGggPSBlZGdlc1tjXSAtIChlZGdlc1tjXSAtIGVkZ2VzW2MgLSAxXSkgLyAyO1xuICAgICAgICAgICAgaWYgKHBpeGVsWCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPiBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBjICsgc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjID4gZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgYyA9IGMgKyBzY3JvbGxMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjIC0gMTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgQW5zd2VyIHNwZWNpZmljIGRhdGEgY2VsbCBjb29yZGluYXRlcyBnaXZlbiBtb3VzZSBjb29yZGluYXRlcyBpbiBwaXhlbHMuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IENlbGwgY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBnZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuXG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ3JpZC5iZWhhdmlvcjtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICAgIHZhciB4LCB5LCBjLCByO1xuICAgICAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgICAgICB2YXIgY29sdW1uRWRnZXMgPSB0aGlzLmdldENvbHVtbkVkZ2VzKCk7XG4gICAgICAgIHZhciBmaXhlZENvbHVtbkNvdW50ID0gdGhpcy5nZXRGaXhlZENvbHVtbkNvdW50KCk7IC8vICsgZ3JpZFNpemU7XG4gICAgICAgIHZhciBmaXhlZFJvd0NvdW50ID0gdGhpcy5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgLy8gdmFyIGZpeGVkQ29sdW1uQ291bnQgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgLy8gdmFyIGZpeGVkUm93Q291bnQgPSB0aGlzLmdldEZpeGVkUm93Q291bnQoKTtcbiAgICAgICAgdmFyIHNjcm9sbFggPSB0aGlzLmdldFNjcm9sbExlZnQoKTtcbiAgICAgICAgdmFyIHNjcm9sbFkgPSB0aGlzLmdldFNjcm9sbFRvcCgpO1xuXG4gICAgICAgIGZvciAoYyA9IDA7IGMgPCBjb2x1bW5FZGdlcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgd2lkdGggPSBjb2x1bW5FZGdlc1tjXTtcbiAgICAgICAgICAgIGlmIChwb2ludC54IDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB4ID0gTWF0aC5tYXgoMCwgcG9pbnQueCAtIHByZXZpb3VzIC0gMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91cyA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGMtLTtcbiAgICAgICAgcHJldmlvdXMgPSAwO1xuICAgICAgICBmb3IgKHIgPSAwOyByIDwgdGhpcy5yb3dFZGdlcy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5yb3dFZGdlc1tyXTtcbiAgICAgICAgICAgIGlmIChwb2ludC55IDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgubWF4KDAsIHBvaW50LnkgLSBwcmV2aW91cyAtIDIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXMgPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgci0tO1xuICAgICAgICBpZiAocG9pbnQueCA8IDApIHtcbiAgICAgICAgICAgIGMgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnQueSA8IDApIHtcbiAgICAgICAgICAgIHIgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2aWV3UG9pbnQgPSB0aGlzLmdyaWQubmV3UG9pbnQoYywgcik7XG5cbiAgICAgICAgLy9jb21wZW5zYXRlIGlmIHdlIGFyZSBzY3JvbGxlZFxuICAgICAgICBpZiAoYyA+PSBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICBjID0gYyArIHNjcm9sbFg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIgPj0gZml4ZWRSb3dDb3VudCkge1xuICAgICAgICAgICAgciA9IHIgKyBzY3JvbGxZO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYW5zbGF0ZWRJbmRleCA9IC0xO1xuXG4gICAgICAgIHZhciBjb2x1bW4gPSBiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oYyk7XG4gICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZWRJbmRleCA9IGNvbHVtbi5pbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncmlkQ2VsbDogdGhpcy5ncmlkLm5ld1BvaW50KGMsIHIpLFxuICAgICAgICAgICAgbW91c2VQb2ludDogdGhpcy5ncmlkLm5ld1BvaW50KHgsIHkpLFxuICAgICAgICAgICAgdmlld1BvaW50OiB2aWV3UG9pbnQsXG4gICAgICAgICAgICBkYXRhQ2VsbDogdGhpcy5ncmlkLm5ld1BvaW50KHRyYW5zbGF0ZWRJbmRleCwgciksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIGlmIGEgY29sdW1uIGlzIHZpc2libGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4IC0gdGhlIGNvbHVtbiBpbmRleCpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIGNvbHVtbiBpcyBmdWxseSB2aXNpYmxlLlxuICAgICAqL1xuICAgIGlzQ29sdW1uVmlzaWJsZTogZnVuY3Rpb24oY29sSW5kZXgpIHtcbiAgICAgICAgdmFyIGlzVmlzaWJsZSA9IHRoaXMudmlzaWJsZUNvbHVtbnMuaW5kZXhPZihjb2xJbmRleCkgIT09IC0xO1xuICAgICAgICByZXR1cm4gaXNWaXNpYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHdpZHRoIHggY29vcmRpbmF0ZSBvZiB0aGUgbGFzdCByZW5kZXJlZCBjb2x1bW5cbiAgICAgKi9cbiAgICBnZXRGaW5hbFZpc2FibGVDb2x1bW5Cb3VuZGFyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpc01heFggPSB0aGlzLmlzTGFzdENvbHVtblZpc2libGUoKTtcbiAgICAgICAgdmFyIGNob3AgPSBpc01heFggPyAyIDogMTtcbiAgICAgICAgdmFyIGNvbFdhbGwgPSB0aGlzLmdldENvbHVtbkVkZ2VzKClbdGhpcy5nZXRDb2x1bW5FZGdlcygpLmxlbmd0aCAtIGNob3BdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gTWF0aC5taW4oY29sV2FsbCwgdGhpcy5nZXRCb3VuZHMoKS53aWR0aCAtIDIwMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIHZpc2liaWxpdHkgb2YgYSByb3cuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gdGhlIHJvdyBpbmRleFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gcm93IGlzIGZ1bGx5IHZpc2libGUuXG4gICAgICovXG4gICAgaXNSb3dWaXNpYmxlOiBmdW5jdGlvbihyb3dJbmRleCkge1xuICAgICAgICB2YXIgaXNWaXNpYmxlID0gdGhpcy52aXNpYmxlUm93cy5pbmRleE9mKHJvd0luZGV4KSAhPT0gLTE7XG4gICAgICAgIHJldHVybiBpc1Zpc2libGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIGlmIGEgY2VsbCBpcyBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IGNlbGwgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgY2VsbCBjb29yZGluYXRlKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY2VsbCBpcyBmdWxseSB2aXNpYmxlLlxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5pc1NlbGVjdGVkKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgbWFpbiBmb3JraW5nIG9mIHRoZSByZW5kZXJlcmluZyB0YXNrLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqL1xuICAgIHJlbmRlckdyaWQ6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIHRoaXMucGFpbnRDZWxscyhnYyk7XG4gICAgICAgIHRoaXMucGFpbnRHcmlkbGluZXMoZ2MpO1xuICAgICAgICB0aGlzLnJlbmRlck92ZXJyaWRlcyhnYyk7XG4gICAgICAgIHRoaXMucmVuZGVyTGFzdFNlbGVjdGlvbihnYyk7XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICByZW5kZXJMYXN0U2VsZWN0aW9uOiBmdW5jdGlvbihnYykge1xuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyTGFzdFNlbGVjdGlvbihnYyk7XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICBfcmVuZGVyTGFzdFNlbGVjdGlvbjogZnVuY3Rpb24oZ2MpIHtcblxuICAgICAgICAvKlxuXG4gICAgICAgICAgICBDb21wdXRlIHRoZSBCb3VuZHMgb2YgdGhlIExhc3QgU2VsZWN0aW9uIHRoYXQgaXMgdmlzaWJsZVxuXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb25zIHx8IHNlbGVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRMYXN0U2VsZWN0aW9uKCk7XG4gICAgICAgIHZhciBtb3VzZURvd24gPSBzZWxlY3Rpb24ub3JpZ2luO1xuICAgICAgICBpZiAobW91c2VEb3duLnggPT09IC0xKSB7XG4gICAgICAgICAgICAvL25vIHNlbGVjdGVkIGFyZWEsIGxldHMgZXhpdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZpc2libGVDb2x1bW5zID0gdGhpcy5nZXRWaXNpYmxlQ29sdW1ucygpO1xuICAgICAgICB2YXIgdmlzaWJsZVJvd3MgPSB0aGlzLmdldFZpc2libGVSb3dzKCk7XG4gICAgICAgIHZhciBsYXN0VmlzaWJsZUNvbHVtbiA9IHZpc2libGVDb2x1bW5zW3Zpc2libGVDb2x1bW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbGFzdFZpc2libGVSb3cgPSB2aXNpYmxlUm93c1t2aXNpYmxlUm93cy5sZW5ndGggLSAxXTtcblxuICAgICAgICB2YXIgZXh0ZW50ID0gc2VsZWN0aW9uLmV4dGVudDtcblxuICAgICAgICB2YXIgZHBPWCA9IE1hdGgubWluKG1vdXNlRG93bi54LCBtb3VzZURvd24ueCArIGV4dGVudC54KTtcbiAgICAgICAgdmFyIGRwT1kgPSBNYXRoLm1pbihtb3VzZURvd24ueSwgbW91c2VEb3duLnkgKyBleHRlbnQueSk7XG5cbiAgICAgICAgLy9sZXRzIGNoZWNrIGlmIG91ciBzZWxlY3Rpb24gcmVjdGFuZ2xlIGlzIHNjcm9sbGVkIG91dHNpZGUgb2YgdGhlIHZpc2libGUgYXJlYVxuICAgICAgICBpZiAoZHBPWCA+IGxhc3RWaXNpYmxlQ29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vdGhlIHRvcCBvZiBvdXIgcmVjdGFuZ2xlIGlzIGJlbG93IHZpc2libGVcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHBPWSA+IGxhc3RWaXNpYmxlUm93KSB7XG4gICAgICAgICAgICByZXR1cm47IC8vdGhlIGxlZnQgb2Ygb3VyIHJlY3RhbmdsZSBpcyB0byB0aGUgcmlnaHQgb2YgYmVpbmcgdmlzaWJsZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRwRVggPSBNYXRoLm1heChtb3VzZURvd24ueCwgbW91c2VEb3duLnggKyBleHRlbnQueCkgKyAxO1xuICAgICAgICBkcEVYID0gTWF0aC5taW4oZHBFWCwgMSArIGxhc3RWaXNpYmxlQ29sdW1uKTtcblxuICAgICAgICB2YXIgZHBFWSA9IE1hdGgubWF4KG1vdXNlRG93bi55LCBtb3VzZURvd24ueSArIGV4dGVudC55KSArIDE7XG4gICAgICAgIGRwRVkgPSBNYXRoLm1pbihkcEVZLCAxICsgbGFzdFZpc2libGVSb3cpO1xuXG4gICAgICAgIHZhciBvID0gdGhpcy5fZ2V0Qm91bmRzT2ZDZWxsKGRwT1gsIGRwT1kpO1xuICAgICAgICB2YXIgb3ggPSBNYXRoLnJvdW5kKChvLnggPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdyaWQuZ2V0Rml4ZWRDb2x1bW5zV2lkdGgoKSA6IG8ueCk7XG4gICAgICAgIHZhciBveSA9IE1hdGgucm91bmQoKG8ueSA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ3JpZC5nZXRGaXhlZFJvd3NIZWlnaHQoKSA6IG8ueSk7XG4gICAgICAgIC8vIHZhciBvdyA9IG8ud2lkdGg7XG4gICAgICAgIC8vIHZhciBvaCA9IG8uaGVpZ2h0O1xuICAgICAgICB2YXIgZSA9IHRoaXMuX2dldEJvdW5kc09mQ2VsbChkcEVYLCBkcEVZKTtcbiAgICAgICAgdmFyIGV4ID0gTWF0aC5yb3VuZCgoZS54ID09PSB1bmRlZmluZWQpID8gdGhpcy5ncmlkLmdldEZpeGVkQ29sdW1uc1dpZHRoKCkgOiBlLngpO1xuICAgICAgICB2YXIgZXkgPSBNYXRoLnJvdW5kKChlLnkgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdyaWQuZ2V0Rml4ZWRSb3dzSGVpZ2h0KCkgOiBlLnkpO1xuICAgICAgICAvLyB2YXIgZXcgPSBlLndpZHRoO1xuICAgICAgICAvLyB2YXIgZWggPSBlLmhlaWdodDtcbiAgICAgICAgdmFyIHggPSBNYXRoLm1pbihveCwgZXgpO1xuICAgICAgICB2YXIgeSA9IE1hdGgubWluKG95LCBleSk7XG4gICAgICAgIHZhciB3aWR0aCA9IDEgKyBleCAtIG94O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gMSArIGV5IC0gb3k7XG4gICAgICAgIGlmICh4ID09PSBleCkge1xuICAgICAgICAgICAgd2lkdGggPSBveCAtIGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ID09PSBleSkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gb3kgLSBleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGggKiBoZWlnaHQgPCAxKSB7XG4gICAgICAgICAgICAvL2lmIHdlIGFyZSBvbmx5IGEgc2tpbm55IGxpbmUsIGRvbid0IHJlbmRlciBhbnl0aGluZ1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcblxuICAgICAgICAgIFJlbmRlciB0aGUgc2VsZWN0aW9uIG1vZGVsIGFyb3VuZCB0aGUgYm91bmRzXG5cbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIGJvdW5kczoge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3Rpb25SZWdpb25PdmVybGF5Q29sb3I6IHRoaXMuZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3NlbGVjdGlvblJlZ2lvbk92ZXJsYXlDb2xvcicpLFxuICAgICAgICAgICAgc2VsZWN0aW9uUmVnaW9uT3V0bGluZUNvbG9yOiB0aGlzLmdyaWQucmVzb2x2ZVByb3BlcnR5KCdzZWxlY3Rpb25SZWdpb25PdXRsaW5lQ29sb3InKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdyaWQuY2VsbFJlbmRlcmVycy5nZXQoJ2xhc3RzZWxlY3Rpb24nKS5wYWludChnYywgY29uZmlnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGl0ZXJhdGUgdGhlIHJlbmRlcmVyaW5nIG92ZXJyaWRlcyBhbmQgbWFuaWZlc3QgZWFjaFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqL1xuICAgIHJlbmRlck92ZXJyaWRlczogZnVuY3Rpb24oZ2MpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5ncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJyaWRlID0gY2FjaGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJPdmVycmlkZShnYywgb3ZlcnJpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgY29weSBlYWNoIG92ZXJyaWRlcyBzcGVjaWZpZWQgYXJlYSB0byBpdCdzIHRhcmdldCBhbmQgYmxhbmsgb3V0IHRoZSBzb3VyY2UgYXJlYVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqIEBwYXJhbSB7T3ZlcnJpZGVPYmplY3R9IG92ZXJyaWRlIC0gYW4gb2JqZWN0IHdpdGggZGV0YWlscyBjb250YWluIGFuIGFyZWEgYW5kIGEgdGFyZ2V0IGNvbnRleHRcbiAgICAgKi9cbiAgICByZW5kZXJPdmVycmlkZTogZnVuY3Rpb24oZ2MsIG92ZXJyaWRlKSB7XG4gICAgICAgIC8vbGV0cyBibGFuayBvdXQgdGhlIGRyYWcgcm93XG4gICAgICAgIHZhciBoZHBpUmF0aW8gPSBvdmVycmlkZS5oZHBpcmF0aW87XG4gICAgICAgIC8vdmFyIGVkZ2VzID0gdGhpcy5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICB2YXIgc3RhcnRYID0gb3ZlcnJpZGUuc3RhcnRYOyAvL2hkcGlSYXRpbyAqIGVkZ2VzW292ZXJyaWRlLmNvbHVtbkluZGV4XTtcbiAgICAgICAgdmFyIHdpZHRoID0gb3ZlcnJpZGUud2lkdGggKyAxO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gb3ZlcnJpZGUuaGVpZ2h0O1xuICAgICAgICB2YXIgdGFyZ2V0Q1RYID0gb3ZlcnJpZGUuY3R4O1xuICAgICAgICB2YXIgaW1nRGF0YSA9IGdjLmdldEltYWdlRGF0YShzdGFydFgsIDAsIE1hdGgucm91bmQod2lkdGggKiBoZHBpUmF0aW8pLCBNYXRoLnJvdW5kKGhlaWdodCAqIGhkcGlSYXRpbykpO1xuICAgICAgICB0YXJnZXRDVFgucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIDAsIDApO1xuICAgICAgICBnYy5maWxsU3R5bGUgPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnYmFja2dyb3VuZENvbG9yMicpO1xuICAgICAgICBnYy5maWxsUmVjdChNYXRoLnJvdW5kKHN0YXJ0WCAvIGhkcGlSYXRpbyksIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gQ3VycmVudCB2ZXJ0aWNhbCBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0U2Nyb2xsVG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRWU2Nyb2xsVmFsdWUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEN1cnJlbnQgaG9yaXpvbnRhbCBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0U2Nyb2xsTGVmdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgfSxcblxuICAgIGdldENvbHVtbkVkZ2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uRWRnZXM7XG4gICAgfSxcblxuICAgIGdldFJvd0VkZ2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93RWRnZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGxhc3QgY29sIHdhcyByZW5kZXJlZCAoaXMgdmlzaWJsZSlcbiAgICAgKi9cbiAgICBpc0xhc3RDb2x1bW5WaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxhc3RDb2x1bW5JbmRleCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVDb2x1bW5zLmluZGV4T2YobGFzdENvbHVtbkluZGV4KSAhPT0gLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVuZGVyZWQgY29sdW1uIHdpZHRoIGF0IGluZGV4XG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRXaWR0aDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sdW1uRWRnZXMoKVtpbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVuZGVyZWQgcm93IGhlaWdodCBhdCBpbmRleFxuICAgICAqL1xuICAgIGdldFJlbmRlcmVkSGVpZ2h0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dFZGdlc1tpbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7ZmluLWNhbnZhc30gbXkgW2Zpbi1jYW52YXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9zdGV2ZXdpcnRzL2Zpbi1jYW52YXMpXG4gICAgICovXG4gICAgZ2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRDYW52YXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBVc2VyIGlzIGN1cnJlbnRseSBkcmFnZ2luZyBhIGNvbHVtbiBmb3IgcmVvcmRlcmluZy5cbiAgICAgKi9cbiAgICBpc0RyYWdnaW5nQ29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5pc0RyYWdnaW5nQ29sdW1uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcm93IHRvIGdvdG8gZm9yIGEgcGFnZSB1cC5cbiAgICAgKi9cbiAgICBnZXRQYWdlVXBSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgICAgIHNjcm9sbEhlaWdodCA9IHRoaXMuZ2V0VmlzaWJsZVNjcm9sbEhlaWdodCgpLFxuICAgICAgICAgICAgaGVhZGVyUm93cyA9IHRoaXMuZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCksXG4gICAgICAgICAgICB0b3AgPSB0aGlzLmRhdGFXaW5kb3cub3JpZ2luLnkgLSBoZWFkZXJSb3dzLFxuICAgICAgICAgICAgc2NhbkhlaWdodCA9IDA7XG4gICAgICAgIHdoaWxlIChzY2FuSGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIHRvcCA+IC0xKSB7XG4gICAgICAgICAgICBzY2FuSGVpZ2h0ID0gc2NhbkhlaWdodCArIGdyaWQuZ2V0Um93SGVpZ2h0KHRvcCk7XG4gICAgICAgICAgICB0b3AtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wICsgMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByb3cgdG8gZ290byBmb3IgYSBwYWdlIGRvd24uXG4gICAgICovXG4gICAgZ2V0UGFnZURvd25Sb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVhZGVyUm93cyA9IHRoaXMuZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgICAgIHZhciByb3dOdW0gPSB0aGlzLmRhdGFXaW5kb3cuY29ybmVyLnkgLSBoZWFkZXJSb3dzIC0gMTtcbiAgICAgICAgcmV0dXJuIHJvd051bTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygcm93cy5cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0Um93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRGaXhlZENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIHJvd3MuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBoZWFkZXIgcm93cy5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgaGVhZGVyIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBTbWFydCByZW5kZXIgdGhlIGdyaWQuXG4gICAgICogQGRlc2MgUGFpbnQgYWxsIHRoZSBjZWxscyBvZiBhIGdyaWQsIGluY2x1ZGluZyBhbGwgXCJmaXhlZFwiIGNvbHVtbnMgYW5kIHJvd3MuXG4gICAgICogV2Ugc25hcHNob3QgdGhlIGNvbnRleHQgdG8gaW5zdXJlIGFnYWluc3QgaXRzIHBvbGx1dGlvbi5cbiAgICAgKiBgdHJ5Li4uY2F0Y2hgIHN1cnJvdW5kcyBlYWNoIGNlbGwgcGFpbnQgaW4gY2FzZSBhIGNlbGwgZWRpdG9yIHRocm93cyBhbiBlcnJvci5cbiAgICAgKiBUaGUgZXJyb3IgbWVzc2FnZSBpcyBlcnJvci1sb2dnZWQgdG8gY29uc29sZSBBTkQgZGlzcGxheWVkIGluIGNlbGwuXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqL1xuICAgIHBhaW50Q2VsbHM6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIHZhciBtZXNzYWdlLFxuICAgICAgICAgICAgY29uZmlnID0ge30sXG4gICAgICAgICAgICB4LCB5LFxuICAgICAgICAgICAgYywgcixcblxuICAgICAgICAgICAgY29sdW1uRWRnZXMgPSB0aGlzLmdldENvbHVtbkVkZ2VzKCksXG4gICAgICAgICAgICByb3dFZGdlcyA9IHRoaXMucm93RWRnZXMsXG5cbiAgICAgICAgICAgIHZpc2libGVDb2xzID0gdGhpcy5nZXRWaXNpYmxlQ29sdW1ucygpLFxuICAgICAgICAgICAgdmlzaWJsZVJvd3MgPSB0aGlzLmdldFZpc2libGVSb3dzKCksXG5cbiAgICAgICAgICAgIGJlaGF2aW9yID0gdGhpcy5ncmlkLmJlaGF2aW9yLFxuXG4gICAgICAgICAgICBjbGlwWCA9IDAsXG4gICAgICAgICAgICBjbGlwWSA9IDAsXG4gICAgICAgICAgICBjbGlwV2lkdGgsXG4gICAgICAgICAgICBjbGlwSGVpZ2h0ID0gdGhpcy5nZXRCb3VuZHMoKS5oZWlnaHQsXG5cbiAgICAgICAgICAgIGxvb3BTdGFydCA9IHRoaXMuZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCkgPyAtMSA6IDAsXG4gICAgICAgICAgICBsb29wTGVuZ3RoID0gdmlzaWJsZUNvbHMubGVuZ3RoOyAvLyByZWdhcmRsZXNzIG9mIGxvb3BTdGFydCwgZHVlIHRvIGRlZmluaXRpb24gb2YgLmxlbmd0aFxuXG4gICAgICAgIHRoaXMuYnV0dG9uQ2VsbHMgPSB7fTtcblxuICAgICAgICBpZiAobG9vcExlbmd0aCkgeyAvLyB0aGlzIGlmIHByZXZlbnRzIHBhaW50aW5nIGp1c3QgdGhlIGZpeGVkIGNvbHVtbnMgd2hlbiB0aGVyZSBhcmUgbm8gdmlzaWJsZSBjb2x1bW5zXG5cbiAgICAgICAgICAgIC8vIEZvciBlYWNoIGNvbHVtbi4uLlxuICAgICAgICAgICAgZm9yICh4ID0gbG9vcFN0YXJ0OyB4IDwgbG9vcExlbmd0aDsgeCsrLCBjbGlwWCArPSBjbGlwV2lkdGgpIHtcblxuICAgICAgICAgICAgICAgIGMgPSB2aXNpYmxlQ29sc1t4XTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkQ29sdW1uTWluV2lkdGhzW2NdID0gMDtcblxuICAgICAgICAgICAgICAgIGdjLnNhdmUoKTtcblxuICAgICAgICAgICAgICAgIC8vIENsaXAgdG8gdmlzaWJsZSBwb3J0aW9uIG9mIGNvbHVtbiB0byBwcmV2ZW50IG92ZXJmbG93IHRvIHJpZ2h0LiBQcmV2aW91c2x5IHdlIGNsaXBwZWQgdG8gZW50aXJlIHZpc2libGUgZ3JpZCBhbmQgZGVhbHQgd2l0aCBvdmVyZmxvdyBieSBvdmVycGFpbnRpbmcgd2l0aCBuZXh0IGNvbHVtbi4gSG93ZXZlciwgdGhpcyBzdHJhdGVneSBmYWlscyB3aGVuIHRyYW5zcGFyZW50IGJhY2tncm91bmQgKG5vIGJhY2tncm91bmQgY29sb3IpLlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlmIGV4dHJhIGNsaXAoKSBjYWxscyBwZXIgY29sdW1uIGFmZmVjdCBwZXJmb3JtYW5jZSAobm90IHRoZSBjbGlwcGluZyBpdHNlbGYgd2hpY2ggd2FzIGhhcHBlbmluZyBhbnl3YXksIGJ1dCB0aGUgY2xpcCBjYWxscyB3aGljaCBzZXQgdXAgdGhlIGNsaXBwaW5nKSwgdXNlIHByZXZpb3VzIHN0cmF0ZWd5IHdoZW4gdGhlcmUgaXMgYSBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgICAgICAgICAgICAgY2xpcFdpZHRoID0gY29sdW1uRWRnZXNbeCArIDFdIC0gY2xpcFg7XG4gICAgICAgICAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgZ2MucmVjdChjbGlwWCwgY2xpcFksIGNsaXBXaWR0aCwgY2xpcEhlaWdodCk7XG4gICAgICAgICAgICAgICAgZ2MuY2xpcCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggcm93IChvZiBlYWNoIGNvbHVtbikuLi5cbiAgICAgICAgICAgICAgICBmb3IgKHkgPSAwOyB5IDwgdmlzaWJsZVJvd3MubGVuZ3RoOyB5KyspIHtcblxuICAgICAgICAgICAgICAgICAgICByID0gdmlzaWJsZVJvd3NbeV07XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFpbnRDZWxsKGdjLCBjLCByKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAociA9PT0gOSAmJiBjID09PSAyKSB7IHRocm93IEVycm9yKCdTaGUgc2VsbHMgc2VhIHNoZWxscyBieSB0aGUgc2VhIHNob3JlLicpOyB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gZSAmJiAoZS5tZXNzYWdlIHx8IGUpIHx8ICdVbmtub3duIGVycm9yLic7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdHYyA9IGdjLmdjIHx8IGdjLCAvLyBEb24ndCBsb2cgdGhlc2UgY2FudmFzIGNhbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyWSA9IHJvd0VkZ2VzW3ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyckhlaWdodCA9IHJvd0VkZ2VzW3kgKyAxXSAtIGVyclk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0djLnNhdmUoKTsgLy8gZGVmaW5lIGNsaXBwaW5nIHJlZ2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3R2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdHYy5yZWN0KGNsaXBYLCBlcnJZLCBjbGlwV2lkdGgsIGVyckhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdHYy5jbGlwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGVyclksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNsaXBYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGVyckhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNsaXBXaWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5jZWxsUmVuZGVyZXJzLmdldCgnZXJyb3JjZWxsJykucGFpbnQocmF3R2MsIGNvbmZpZywgbWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0djLnJlc3RvcmUoKTsgLy8gZGlzY2FyZCBjbGlwcGluZyByZWdpb25cblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQm90dG9tIHRvdGFscyByb3dzLi4uXG4gICAgICAgICAgICAgICAgZm9yICh5ID0gLWJlaGF2aW9yLmRhdGFNb2RlbC5nZXRCb3R0b21Ub3RhbHMoKS5sZW5ndGg7IHk7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWludENlbGwoZ2MsIGMsIHkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGdjLnJlc3RvcmUoKTsgLy8gUmVtb3ZlIGNvbHVtbidzIGNsaXAgcmVnaW9uIChhbmQgYW55dGhpbmcgZWxzZSByZW5kZXJDZWxsRXJyb3IoKSBtaWdodCBoYXZlIHNldClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNldE51bWJlckNvbHVtbldpZHRoKGdjLCBiZWhhdmlvciwgdGhpcy5ncmlkLmdldFJvd0NvdW50KCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgV2Ugb3B0ZWQgdG8gbm90IHBhaW50IGJvcmRlcnMgZm9yIGVhY2ggY2VsbCBhcyB0aGF0IHdhcyBleHRyZW1lbHkgZXhwZW5zaXZlLiBJbnN0ZWFkIHdlIGRyYXcgZ3JpZGxpbmVzIGhlcmUuIEFsc28gd2UgcmVjb3JkIHRoZSB3aWR0aHMgYW5kIGhlaWdodHMgZm9yIGxhdGVyLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqL1xuICAgIHBhaW50R3JpZGxpbmVzOiBmdW5jdGlvbihnYykge1xuICAgICAgICB2YXIgeCwgeSwgYywgciA9IDA7XG5cbiAgICAgICAgdmFyIGNvbFdpZHRocyA9IHRoaXMuZ2V0Q29sdW1uRWRnZXMoKTtcbiAgICAgICAgdmFyIHJvd0hlaWdodHMgPSB0aGlzLnJvd0VkZ2VzO1xuICAgICAgICB2YXIgdmlld0hlaWdodDtcbiAgICAgICAgdmFyIHZpZXdXaWR0aCA9IGNvbFdpZHRoc1tjb2xXaWR0aHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBkcmF3VGhlbUggPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnZ3JpZExpbmVzSCcpO1xuICAgICAgICB2YXIgZHJhd1RoZW1WT3ZlcmZsb3cgPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnZ3JpZExpbmVzVk92ZXJmbG93Jyk7XG4gICAgICAgIHZhciBkcmF3VGhlbVYgPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnZ3JpZExpbmVzVicpO1xuICAgICAgICB2YXIgbGluZUNvbG9yID0gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2xpbmVDb2xvcicpO1xuICAgICAgICBpZiAoZHJhd1RoZW1WT3ZlcmZsb3cpe1xuICAgICAgICAgICAgdmlld0hlaWdodCA9IHRoaXMuZ2V0Qm91bmRzKCkuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlld0hlaWdodCA9IHJvd0hlaWdodHNbcm93SGVpZ2h0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGlmIChkcmF3VGhlbVYpIHtcbiAgICAgICAgICAgIGZvciAoYyA9IDA7IGMgPCBjb2xXaWR0aHMubGVuZ3RoICsgMTsgYysrKSB7XG4gICAgICAgICAgICAgICAgeCA9IGNvbFdpZHRoc1tjXSArIDAuNTtcbiAgICAgICAgICAgICAgICBnYy5tb3ZlVG8oeCwgMCk7XG4gICAgICAgICAgICAgICAgZ2MubGluZVRvKHgsIHZpZXdIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyYXdUaGVtSCkge1xuICAgICAgICAgICAgZm9yIChyID0gMDsgciA8IHJvd0hlaWdodHMubGVuZ3RoIC0gMTsgcisrKSB7XG4gICAgICAgICAgICAgICAgeSA9IHJvd0hlaWdodHNbcl0gKyAwLjU7XG4gICAgICAgICAgICAgICAgZ2MubW92ZVRvKDAsIHkpO1xuICAgICAgICAgICAgICAgIGdjLmxpbmVUbyh2aWV3V2lkdGgsIHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCb3R0b20gdG90YWxzIHJvd3MuLi5cbiAgICAgICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ3JpZC5iZWhhdmlvcixcbiAgICAgICAgICAgICAgICByb3dIZWlnaHQgPSBiZWhhdmlvci5nZXREZWZhdWx0Um93SGVpZ2h0KCk7XG4gICAgICAgICAgICBmb3IgKHIgPSAtYmVoYXZpb3IuZGF0YU1vZGVsLmdldEJvdHRvbVRvdGFscygpLmxlbmd0aCwgeSA9IHRoaXMuZ2V0Qm91bmRzKCkuaGVpZ2h0OyByOyByKyspIHtcbiAgICAgICAgICAgICAgICB5IC09IHJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICBnYy5tb3ZlVG8oMCwgeSk7XG4gICAgICAgICAgICAgICAgZ2MubGluZVRvKHZpZXdXaWR0aCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnYy5jbG9zZVBhdGgoKTtcblxuICAgICAgICBnYy5zdHJva2VTdHlsZSA9IGxpbmVDb2xvcjtcbiAgICAgICAgZ2MubGluZVdpZHRoID0gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2xpbmVXaWR0aCcpO1xuICAgICAgICBnYy5zdHJva2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKi9cbiAgICBwYWludENlbGw6IGZ1bmN0aW9uKGdjLCB4LCB5KSB7XG4gICAgICAgIGdjLm1vdmVUbygwLCAwKTtcblxuICAgICAgICB2YXIgYyA9IHRoaXMuZ2V0VmlzaWJsZUNvbHVtbnMoKVt4XSxcbiAgICAgICAgICAgIHIgPSB0aGlzLmdldFZpc2libGVSb3dzKClbeV07XG5cbiAgICAgICAgaWYgKGMpIHsgLy9zb21ldGhpbmcgaXMgYmVpbmcgdmlld2VkIGF0IGF0IHRoZSBtb21lbnQgKG90aGVyd2lzZSByZXR1cm5zIHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuX3BhaW50Q2VsbChnYywgYywgcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3BhaW50Q2VsbDogZnVuY3Rpb24oZ2MsIGMsIHIpIHtcblxuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgICAgIGJlaGF2aW9yID0gZ3JpZC5iZWhhdmlvcixcbiAgICAgICAgICAgIGJhc2VQcm9wZXJ0aWVzID0gYmVoYXZpb3IuZ2V0Q29sdW1uUHJvcGVydGllcyhjKTtcblxuICAgICAgICBpZiAoYmFzZVByb3BlcnRpZXMuaXNOdWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sdW1uUHJvcGVydGllcyA9IGJhc2VQcm9wZXJ0aWVzLFxuXG4gICAgICAgICAgICBoZWFkZXJSb3dDb3VudCA9IGJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCksXG4gICAgICAgICAgICBpc0dyaWRSb3cgPSByID49IGhlYWRlclJvd0NvdW50LFxuICAgICAgICAgICAgaXNGb290ZXJSb3cgPSByIDwgMCxcbiAgICAgICAgICAgIGlzSGVhZGVyUm93ID0gIWlzR3JpZFJvdyAmJiAhaXNGb290ZXJSb3csXG4gICAgICAgICAgICBpc0ZpbHRlclJvdyA9IGdyaWQuaXNGaWx0ZXJSb3cociksXG5cbiAgICAgICAgICAgIGhlYWRlckNvbHVtbkNvdW50ID0gYmVoYXZpb3IuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgIGlzR3JpZENvbHVtbiA9IGMgPj0gaGVhZGVyQ29sdW1uQ291bnQsXG4gICAgICAgICAgICBpc1Nob3dSb3dOdW1iZXJzID0gZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCksXG4gICAgICAgICAgICBpc0hpZXJhcmNoeUNvbHVtbiA9IGdyaWQuaXNIaWVyYXJjaHlDb2x1bW4oYyksXG5cbiAgICAgICAgICAgIGlzUm93U2VsZWN0ZWQgPSBncmlkLmlzUm93U2VsZWN0ZWQociksXG4gICAgICAgICAgICBpc0NvbHVtblNlbGVjdGVkID0gZ3JpZC5pc0NvbHVtblNlbGVjdGVkKGMpLFxuICAgICAgICAgICAgaXNDZWxsU2VsZWN0ZWQgPSBncmlkLmlzQ2VsbFNlbGVjdGVkKGMsIHIpLFxuICAgICAgICAgICAgaXNDZWxsU2VsZWN0ZWRJbkNvbHVtbiA9IGdyaWQuaXNDZWxsU2VsZWN0ZWRJbkNvbHVtbihjKSxcbiAgICAgICAgICAgIGlzQ2VsbFNlbGVjdGVkSW5Sb3cgPSBncmlkLmlzQ2VsbFNlbGVjdGVkSW5Sb3cociksXG4gICAgICAgICAgICBhcmVBbGxSb3dzU2VsZWN0ZWQgPSBncmlkLmFyZUFsbFJvd3NTZWxlY3RlZCgpLFxuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXM7XG5cbiAgICAgICAgaWYgKChpc1Nob3dSb3dOdW1iZXJzICYmIGMgPT09IC0xKSB8fCBpc0hpZXJhcmNoeUNvbHVtbikge1xuICAgICAgICAgICAgaWYgKGlzUm93U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoYmFzZVByb3BlcnRpZXMucm93SGVhZGVyUm93U2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcy5pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm9wZXJ0aWVzLnJvd0hlYWRlcik7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNTZWxlY3RlZCA9IGlzQ2VsbFNlbGVjdGVkSW5Sb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcy5pc1VzZXJEYXRhQXJlYSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzSGVhZGVyUm93IHx8IGlzRm9vdGVyUm93KSB7XG4gICAgICAgICAgICBpZiAoaXNGaWx0ZXJSb3cpIHtcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoYmFzZVByb3BlcnRpZXMuZmlsdGVyUHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NvbHVtblNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm9wZXJ0aWVzLmNvbHVtbkhlYWRlckNvbHVtblNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvcGVydGllcy5jb2x1bW5IZWFkZXIpO1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzU2VsZWN0ZWQgPSBpc0NlbGxTZWxlY3RlZEluQ29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNVc2VyRGF0YUFyZWEgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0hpZXJhcmNoeUNvbHVtbikge1xuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm9wZXJ0aWVzLnJvd0hlYWRlcik7XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcy5pc1NlbGVjdGVkID0gaXNDZWxsU2VsZWN0ZWRJblJvdztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvcGVydGllcyk7XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcy5pc1NlbGVjdGVkID0gaXNDZWxsU2VsZWN0ZWQgfHwgaXNSb3dTZWxlY3RlZCB8fCBpc0NvbHVtblNlbGVjdGVkO1xuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNVc2VyRGF0YUFyZWEgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvd051bSA9IHIgLSBoZWFkZXJSb3dDb3VudCArIDE7XG5cbiAgICAgICAgaWYgKGMgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAociA9PT0gMCkgeyAvLyBoZWFkZXIgcm93IGdldHMgXCJtYXN0ZXJcIiBjaGVja2JveFxuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLnZhbHVlID0gW2ltYWdlcy5jaGVja2JveChhcmVBbGxSb3dzU2VsZWN0ZWQpLCAnJywgbnVsbF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRmlsdGVyUm93KSB7IC8vIG5vIGNoZWNrYm94IGJ1dCBzaG93IGZpbHRlciBpY29uXG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMudmFsdWUgPSBbaW1hZ2VzLmZpbHRlcihmYWxzZSksICcnLCBudWxsXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNIZWFkZXJSb3cgfHwgaXNGb290ZXJSb3cpIHsgLy8gbm8gY2hlY2tib3ggb24gXCJ0b3RhbHNcIiByb3dzXG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMudmFsdWUgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMudmFsdWUgPSBbaW1hZ2VzLmNoZWNrYm94KGlzUm93U2VsZWN0ZWQpLCByb3dOdW0sIG51bGxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaGFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLnZhbHVlID0gZ3JpZC5nZXRWYWx1ZShjLCByKTtcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmhhbGlnbiA9IGdyaWQuZ2V0Q29sdW1uQWxpZ25tZW50KGMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNHcmlkQ29sdW1uID0gaXNHcmlkQ29sdW1uO1xuICAgICAgICBjZWxsUHJvcGVydGllcy5pc0dyaWRSb3cgPSBpc0dyaWRSb3c7XG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzQ29sdW1uSG92ZXJlZCA9IGdyaWQuaXNDb2x1bW5Ib3ZlcmVkKGMpICYmIGlzR3JpZENvbHVtbjtcbiAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNSb3dIb3ZlcmVkID0gZ3JpZC5pc1Jvd0hvdmVyZWQocikgJiYgaXNHcmlkUm93O1xuICAgICAgICBjZWxsUHJvcGVydGllcy5pc0NlbGxIb3ZlcmVkID0gZ3JpZC5pc0hvdmVyZWQoYywgcikgJiYgaXNHcmlkQ29sdW1uICYmIGlzR3JpZFJvdztcbiAgICAgICAgY2VsbFByb3BlcnRpZXMuYm91bmRzID0gdGhpcy5fZ2V0Qm91bmRzT2ZDZWxsKGMsIHIpO1xuICAgICAgICBjZWxsUHJvcGVydGllcy5pc0NlbGxTZWxlY3RlZCA9IGlzQ2VsbFNlbGVjdGVkO1xuICAgICAgICBjZWxsUHJvcGVydGllcy5pc1Jvd1NlbGVjdGVkID0gaXNSb3dTZWxlY3RlZDtcbiAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNDb2x1bW5TZWxlY3RlZCA9IGlzQ29sdW1uU2VsZWN0ZWQ7XG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzSW5DdXJyZW50U2VsZWN0aW9uUmVjdGFuZ2xlID0gZ3JpZC5pc0luQ3VycmVudFNlbGVjdGlvblJlY3RhbmdsZShjLCByKTtcblxuICAgICAgICBpZiAoZ3JpZC5tb3VzZURvd25TdGF0ZSkge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gZ3JpZC5tb3VzZURvd25TdGF0ZS5ncmlkQ2VsbDtcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLm1vdXNlRG93biA9IHBvaW50LnggPT09IGMgJiYgcG9pbnQueSA9PT0gcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLnggPSBjO1xuICAgICAgICBjZWxsUHJvcGVydGllcy55ID0gcjtcblxuICAgICAgICBiZWhhdmlvci5jZWxsUHJvcGVydGllc1ByZVBhaW50Tm90aWZpY2F0aW9uKGNlbGxQcm9wZXJ0aWVzKTtcblxuICAgICAgICB2YXIgY2VsbCA9IGJlaGF2aW9yLmdldENlbGxSZW5kZXJlcihjZWxsUHJvcGVydGllcywgYywgcik7XG4gICAgICAgIHZhciBjb2x1bW4gPSBiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oYyk7XG5cbiAgICAgICAgLy9kZWNsYXJhdGl2ZSBjZWxsIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKGlzR3JpZFJvdykge1xuICAgICAgICAgICAgdmFyIG92ZXJyaWRlcyA9IGJlaGF2aW9yLmdldENlbGxQcm9wZXJ0aWVzKGNvbHVtbi5pbmRleCwgcik7XG4gICAgICAgICAgICBfKGNlbGxQcm9wZXJ0aWVzKS5leHRlbmRPd24ob3ZlcnJpZGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYWxsb3cgdGhlIHJlbmRlcmVyIHRvIGlkZW50aWZ5IGl0c2VsZiBpZiBpdCdzIGEgYnV0dG9uXG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmJ1dHRvbkNlbGxzID0gdGhpcy5idXR0b25DZWxscztcblxuICAgICAgICBjZWxsUHJvcGVydGllcy5mb3JtYXRWYWx1ZSA9IGdyaWQuZ2V0Rm9ybWF0dGVyKGNlbGxQcm9wZXJ0aWVzLmlzVXNlckRhdGFBcmVhICYmIGNlbGxQcm9wZXJ0aWVzLmZvcm1hdCk7XG4gICAgICAgIGNlbGwucGFpbnQoZ2MsIGNlbGxQcm9wZXJ0aWVzKTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVkQ29sdW1uTWluV2lkdGhzW2NdID0gTWF0aC5tYXgoY2VsbFByb3BlcnRpZXMubWluV2lkdGggfHwgMCwgdGhpcy5yZW5kZXJlZENvbHVtbk1pbldpZHRoc1tjXSk7XG4gICAgICAgIGNvbHVtblByb3BlcnRpZXMucHJlZmVycmVkV2lkdGggPSB0aGlzLnJlbmRlcmVkQ29sdW1uTWluV2lkdGhzW2NdO1xuICAgIH0sXG5cbiAgICBpc1ZpZXdhYmxlQnV0dG9uOiBmdW5jdGlvbihjLCByKSB7XG4gICAgICAgIHZhciBrZXkgPSBjICsgJywnICsgcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnV0dG9uQ2VsbHNba2V5XSA9PT0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgZ2V0Um93TnVtYmVyc1dpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbEVkZ2VzID0gdGhpcy5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICBpZiAoY29sRWRnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sRWRnZXNbMF07XG4gICAgfSxcblxuICAgIHN0YXJ0QW5pbWF0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBhbmltYXRlKCkge1xuICAgICAgICAgICAgc2VsZi5hbmltYXRlKCk7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBhbmltYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuZ2V0Q2FudmFzKCkuY2FudmFzQ1RYO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMucmVuZGVyTGFzdFNlbGVjdGlvbihjdHgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kcztcbiAgICB9LFxuXG4gICAgc2V0Qm91bmRzOiBmdW5jdGlvbihib3VuZHMpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJvdW5kcyA9IGJvdW5kcyk7XG4gICAgfVxuXG59KTtcblxuZnVuY3Rpb24gc2V0TnVtYmVyQ29sdW1uV2lkdGgoZ2MsIGJlaGF2aW9yLCBtYXhSb3cpIHtcbiAgICB2YXIgY29sdW1uUHJvcGVydGllcyA9IGJlaGF2aW9yLmdldENvbHVtblByb3BlcnRpZXMoLTEpLFxuICAgICAgICBjZWxsUHJvcGVydGllcyA9IGNvbHVtblByb3BlcnRpZXMucm93SGVhZGVyLFxuICAgICAgICBpY29uID0gaW1hZ2VzLmNoZWNrZWQ7XG5cbiAgICBnYy5mb250ID0gY2VsbFByb3BlcnRpZXMuZm9udDtcblxuICAgIGNvbHVtblByb3BlcnRpZXMucHJlZmVycmVkV2lkdGggPSBpY29uLndpZHRoICsgNyArIGNlbGxQcm9wZXJ0aWVzLmdldFRleHRXaWR0aChnYywgbWF4Um93ICsgMSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBSYW5nZVNlbGVjdGlvbk1vZGVsID0gcmVxdWlyZSgnc3BhcnNlLWJvb2xlYW4tYXJyYXknKTtcblxuLyoqXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZGVzYyBXZSByZXByZXNlbnQgc2VsZWN0aW9ucyBhcyBhIGxpc3Qgb2YgcmVjdGFuZ2xlcyBiZWNhdXNlIGxhcmdlIGFyZWFzIGNhbiBiZSByZXByZXNlbnRlZCBhbmQgdGVzdGVkIGFnYWluc3QgcXVpY2tseSB3aXRoIGEgbWluaW1hbCBhbW91bnQgb2YgbWVtb3J5IHVzYWdlLiBBbHNvIHdlIG5lZWQgdG8gbWFpbnRhaW4gdGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzIGZsYXR0ZW5lZCBjb3VudGVyIHBhcnRzIHNvIHdlIGNhbiB0ZXN0IGZvciBzaW5nbGUgZGltZW5zaW9uIGNvbnRhaW5zLiBUaGlzIGlzIGhvdyB3ZSBrbm93IHRvIGhpZ2hsaWdodCB0aGUgZml4ZWQgcmVnaW9ucyBvbiB0aGUgZWRnZXMgb2YgdGhlIGdyaWQuXG4gKi9cblxuZnVuY3Rpb24gU2VsZWN0aW9uTW9kZWwoZ3JpZCkge1xuXG4gICAgdGhpcy5ncmlkID0gZ3JpZDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHNlbGVjdGlvbnNcbiAgICAgKiBAdHlwZSB7UmVjdGFuZ2xlW119XG4gICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzLlxuICAgICAqIEBkZXNjIENyZWF0ZWQgYXMgYW4gZW1wdHkgYXJyYXkgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgU2VsZWN0aW9uTW9kZWx8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0aGlzLnNlbGVjdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGZsYXR0ZW5lZFhcbiAgICAgKiBAdHlwZSB7UmVjdGFuZ2xlW119XG4gICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzIGZsYXR0ZW5lZCBpbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24gKG5vIHdpZHRoKS5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIGFzIGFuIGVtcHR5IGFycmF5IHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFNlbGVjdGlvbk1vZGVsfGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5mbGF0dGVuZWRYID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBmbGF0dGVuZWRZXG4gICAgICogQHR5cGUge1JlY3RhbmdsZVtdfVxuICAgICAqIEBzdW1tYXJ5IFRoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlcyBmbGF0dGVuZWQgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbiAobm8gaGVpZ2h0KS5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIGFzIGFuIGVtcHR5IGFycmF5IHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFNlbGVjdGlvbk1vZGVsfGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5mbGF0dGVuZWRZID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSByb3dTZWxlY3Rpb25Nb2RlbFxuICAgICAqIEB0eXBlIHtSYW5nZVNlbGVjdGlvbk1vZGVsfVxuICAgICAqIEBzdW1tYXJ5IFRoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlcy5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIGFzIGEgbmV3IFJhbmdlU2VsZWN0aW9uTW9kZWwgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgU2VsZWN0aW9uTW9kZWx8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsID0gbmV3IFJhbmdlU2VsZWN0aW9uTW9kZWwoKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGNvbHVtblNlbGVjdGlvbk1vZGVsXG4gICAgICogQHR5cGUge1JhbmdlU2VsZWN0aW9uTW9kZWx9XG4gICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzLlxuICAgICAqIEBkZXNjIENyZWF0ZWQgYXMgYSBuZXcgUmFuZ2VTZWxlY3Rpb25Nb2RlbCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBTZWxlY3Rpb25Nb2RlbHxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwgPSBuZXcgUmFuZ2VTZWxlY3Rpb25Nb2RlbCgpO1xuXG4gICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgnJyk7XG59XG5cblNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuY29uc3RydWN0b3IsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgYWxsUm93c1NlbGVjdGVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRMYXN0U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbHMgPSB0aGlzLnNlbGVjdGlvbnM7XG4gICAgICAgIHZhciBzZWwgPSBzZWxzW3NlbHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiBzZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRMYXN0U2VsZWN0aW9uVHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RTZWxlY3Rpb25UeXBlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdHlwZVxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRMYXN0U2VsZWN0aW9uVHlwZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UeXBlID0gdHlwZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBTZWxlY3QgdGhlIHJlZ2lvbiBkZXNjcmliZWQgYnkgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG94IC0gb3JpZ2luIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveSAtIG9yaWdpbiB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXggLSBleHRlbnQgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV5IC0gZXh0ZW50IHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IC0gd2hldGhlciB0byBmaXJlIHNlbGVjdGlvbiBjaGFuZ2VkIGV2ZW50XG4gICAgICovXG4gICAgc2VsZWN0OiBmdW5jdGlvbihveCwgb3ksIGV4LCBleSwgc2lsZW50KSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmdyaWQubmV3UmVjdGFuZ2xlKG94LCBveSwgZXgsIGV5KTtcbiAgICAgICAgbmV3U2VsZWN0aW9uLmZpcnN0U2VsZWN0ZWRDZWxsID0gdGhpcy5ncmlkLm5ld1BvaW50KG94LCBveSk7IC8vQ2FjaGUgdGhlIGZpcnN0IHNlbGVjdGVkIGNlbGwgYmVmb3JlIGl0IGdldHMgbm9ybWFsaXplZCB0byB0b3AtbGVmdCBvcmlnaW5cbiAgICAgICAgbmV3U2VsZWN0aW9uLmxhc3RTZWxlY3RlZENlbGwgPSAoXG4gICAgICAgICAgICAobmV3U2VsZWN0aW9uLmZpcnN0U2VsZWN0ZWRDZWxsLnggPT09IG5ld1NlbGVjdGlvbi5vcmlnaW4ueCAmJiBuZXdTZWxlY3Rpb24uZmlyc3RTZWxlY3RlZENlbGwueSA9PT0gbmV3U2VsZWN0aW9uLm9yaWdpbi55KVxuICAgICAgICAgICAgP1xuICAgICAgICAgICAgICAgIG5ld1NlbGVjdGlvbi5jb3JuZXJcbiAgICAgICAgICAgICAgICA6XG4gICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uLm9yaWdpblxuICAgICAgICApO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbnMucHVzaChuZXdTZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLmZsYXR0ZW5lZFgucHVzaChuZXdTZWxlY3Rpb24uZmxhdHRlblhBdCgwKSk7XG4gICAgICAgIHRoaXMuZmxhdHRlbmVkWS5wdXNoKG5ld1NlbGVjdGlvbi5mbGF0dGVuWUF0KDApKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgnY2VsbCcpO1xuICAgICAgICBpZiAoIXNpbGVudCkge3RoaXMuZ3JpZC5zZWxlY3Rpb25DaGFuZ2VkKCk7fVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG94IC0gb3JpZ2luIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveSAtIG9yaWdpbiB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXggLSBleHRlbnQgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV5IC0gZXh0ZW50IHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIHRvZ2dsZVNlbGVjdDogZnVuY3Rpb24ob3gsIG95LCBleCwgZXkpIHtcblxuICAgICAgICB2YXIgc2VsZWN0ZWQsIGluZGV4O1xuXG4gICAgICAgIHNlbGVjdGVkID0gdGhpcy5zZWxlY3Rpb25zLmZpbmQoZnVuY3Rpb24oc2VsZWN0aW9uLCBpZHgpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaWR4O1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24ub3JpZ2luLnggPT09IG94ICYmIHNlbGVjdGlvbi5vcmlnaW4ueSA9PT0gb3kgJiZcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uZXh0ZW50LnggPT09IGV4ICYmIHNlbGVjdGlvbi5leHRlbnQueSA9PT0gZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLmZsYXR0ZW5lZFguc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuZmxhdHRlbmVkWS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLnNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KG94LCBveSwgZXgsIGV5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVtb3ZlIHRoZSBsYXN0IHNlbGVjdGlvbiB0aGF0IHdhcyBjcmVhdGVkLlxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbjogZnVuY3Rpb24oZG9udENsZWFyUm93U2VsZWN0aW9ucykge1xuICAgICAgICBkb250Q2xlYXJSb3dTZWxlY3Rpb25zID0gZG9udENsZWFyUm93U2VsZWN0aW9ucyA9PT0gdHJ1ZTtcbiAgICAgICAgaWYgKCFkb250Q2xlYXJSb3dTZWxlY3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFsbFJvd3NTZWxlY3RlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9ucy5sZW5ndGgpIHsgLS10aGlzLnNlbGVjdGlvbnMubGVuZ3RoOyB9XG4gICAgICAgIGlmICh0aGlzLmZsYXR0ZW5lZFgubGVuZ3RoKSB7IC0tdGhpcy5mbGF0dGVuZWRYLmxlbmd0aDsgfVxuICAgICAgICBpZiAodGhpcy5mbGF0dGVuZWRZLmxlbmd0aCkgeyAtLXRoaXMuZmxhdHRlbmVkWS5sZW5ndGg7IH1cbiAgICAgICAgLy90aGlzLmdldEdyaWQoKS5zZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjbGVhck1vc3RSZWNlbnRDb2x1bW5TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdjb2x1bW4nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucm93U2VsZWN0aW9uTW9kZWwuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ3JvdycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXJSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ3JvdycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlcmUgYXJlIGFjdGl2ZSBzZWxlY3Rpb24ocykuXG4gICAgICovXG4gICAgaGFzU2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbnMubGVuZ3RoICE9PSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUm93U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5pc0VtcHR5KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDb2x1bW5TZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFNlbGVjdGlvbiBjb3ZlcnMgYSBzcGVjaWZpYyBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZEluUm93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NlbGxTZWxlY3RlZCh0aGlzLmZsYXR0ZW5lZFgsIDAsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgU2VsZWN0aW9uIGNvdmVycyBhIHNwZWNpZmljIHJvdy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqL1xuICAgIGlzQ2VsbFNlbGVjdGVkSW5Db2x1bW46IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2VsbFNlbGVjdGVkKHRoaXMuZmxhdHRlbmVkWSwgeCwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTZWxlY3Rpb24gcXVlcnkgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjZWxsIGlzIHNlbGVjdGVkIChwYXJ0IG9mIGFuIGFjdGl2ZSBzZWxlY3Rpb24pLlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlW119IHNlbGVjdGlvbnMgLSBTZWxlY3Rpb24gcmVjdGFuZ2xlcyB0byBzZWFyY2ggdGhyb3VnaC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5pc0NvbHVtblNlbGVjdGVkKHgpIHx8XG4gICAgICAgICAgICB0aGlzLmlzUm93U2VsZWN0ZWQoeSkgfHxcbiAgICAgICAgICAgIHRoaXMuX2lzQ2VsbFNlbGVjdGVkKHRoaXMuc2VsZWN0aW9ucywgeCwgeSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDZWxsU2VsZWN0ZWQodGhpcy5zZWxlY3Rpb25zLCB4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25zXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQ2VsbFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3Rpb25zLCB4LCB5KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuICEhc2VsZWN0aW9ucy5maW5kKGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYucmVjdGFuZ2xlQ29udGFpbnMoc2VsZWN0aW9uLCB4LCB5KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBlbXB0eSBvdXQgYWxsIG91ciBzdGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKGRvbnRDbGVhclJvd1NlbGVjdGlvbnMpIHtcbiAgICAgICAgZG9udENsZWFyUm93U2VsZWN0aW9ucyA9IGRvbnRDbGVhclJvd1NlbGVjdGlvbnMgPT09IHRydWU7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9ucy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmZsYXR0ZW5lZFgubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5mbGF0dGVuZWRZLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgICAgaWYgKCFkb250Q2xlYXJSb3dTZWxlY3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFsbFJvd3NTZWxlY3RlZChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy90aGlzLmdldEdyaWQoKS5zZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ggLSBvcmlnaW4geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG95IC0gb3JpZ2luIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleCAtIGV4dGVudCB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXkgLSBleHRlbnQgeSBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNSZWN0YW5nbGVTZWxlY3RlZDogZnVuY3Rpb24ob3gsIG95LCBleCwgZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zZWxlY3Rpb25zLmZpbmQoZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5vcmlnaW4ueCA9PT0gb3ggJiYgc2VsZWN0aW9uLm9yaWdpbi55ID09PSBveSAmJlxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5leHRlbnQueCA9PT0gZXggJiYgc2VsZWN0aW9uLmV4dGVudC55ID09PSBleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGlzQ29sdW1uU2VsZWN0ZWQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuaXNTZWxlY3RlZCh4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW58Kn1cbiAgICAgKi9cbiAgICBpc1Jvd1NlbGVjdGVkOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbFJvd3NTZWxlY3RlZCB8fCB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmlzU2VsZWN0ZWQoeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geDFcbiAgICAgKiBAcGFyYW0geDJcbiAgICAgKi9cbiAgICBzZWxlY3RDb2x1bW46IGZ1bmN0aW9uKHgxLCB4Mikge1xuICAgICAgICB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLnNlbGVjdCh4MSwgeDIpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdjb2x1bW4nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNlbGVjdEFsbFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuc2V0QWxsUm93c1NlbGVjdGVkKHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgICBzZXRBbGxSb3dzU2VsZWN0ZWQ6IGZ1bmN0aW9uKGlzSXQpIHtcbiAgICAgICAgdGhpcy5hbGxSb3dzU2VsZWN0ZWQgPSBpc0l0O1xuICAgIH0sXG5cbiAgICBhcmVBbGxSb3dzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxSb3dzU2VsZWN0ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geTFcbiAgICAgKiBAcGFyYW0geTJcbiAgICAgKi9cbiAgICBzZWxlY3RSb3c6IGZ1bmN0aW9uKHkxLCB5Mikge1xuICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLnNlbGVjdCh5MSwgeTIpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdyb3cnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4MVxuICAgICAqIEBwYXJhbSB4MlxuICAgICAqL1xuICAgIGRlc2VsZWN0Q29sdW1uOiBmdW5jdGlvbih4MSwgeDIpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdCh4MSwgeDIpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdjb2x1bW4nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB5MVxuICAgICAqIEBwYXJhbSB5MlxuICAgICAqL1xuICAgIGRlc2VsZWN0Um93OiBmdW5jdGlvbih5MSwgeTIpIHtcbiAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdCh5MSwgeTIpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdyb3cnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmFyZUFsbFJvd3NTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyUm93cyA9IHRoaXMuZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gdGhpcy5ncmlkLmdldFJvd0NvdW50KCkgLSBoZWFkZXJSb3dzO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShyb3dDb3VudCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBpICsgaGVhZGVyUm93cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm93U2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp8QXJyYXkuQXJyYXkubnVtYmVyfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgICBpc0NvbHVtbk9yUm93U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuaXNFbXB0eSgpIHx8ICF0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRGbGF0dGVuZWRZczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIHNldCA9IHt9O1xuICAgICAgICB0aGlzLnNlbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB0b3AgPSBzZWxlY3Rpb24ub3JpZ2luLnk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHNlbGVjdGlvbi5leHRlbnQueSArIDE7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHNpemU7IHIrKykge1xuICAgICAgICAgICAgICAgIHZhciB0aSA9IHIgKyB0b3A7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXRbdGldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRpKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0W3RpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0LnNvcnQoZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHggLSB5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKi9cbiAgICBzZWxlY3RSb3dzRnJvbUNlbGxzOiBmdW5jdGlvbihvZmZzZXQsIGRvbnRDbGVhclJvd1NlbGVjdGlvbnMpIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICAgIGRvbnRDbGVhclJvd1NlbGVjdGlvbnMgPSBkb250Q2xlYXJSb3dTZWxlY3Rpb25zID09PSB0cnVlO1xuXG4gICAgICAgIHZhciBzbSA9IHRoaXMucm93U2VsZWN0aW9uTW9kZWw7XG5cbiAgICAgICAgaWYgKCFkb250Q2xlYXJSb3dTZWxlY3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFsbFJvd3NTZWxlY3RlZChmYWxzZSk7XG4gICAgICAgICAgICBzbS5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdG9wID0gc2VsZWN0aW9uLm9yaWdpbi55LFxuICAgICAgICAgICAgICAgIGV4dGVudCA9IHNlbGVjdGlvbi5leHRlbnQueTtcbiAgICAgICAgICAgIHRvcCArPSBvZmZzZXQ7XG4gICAgICAgICAgICBzbS5zZWxlY3QodG9wLCB0b3AgKyBleHRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKi9cbiAgICBzZWxlY3RDb2x1bW5zRnJvbUNlbGxzOiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgICAgdmFyIHNtID0gdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbDtcbiAgICAgICAgc20uY2xlYXIoKTtcblxuICAgICAgICB0aGlzLnNlbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gc2VsZWN0aW9uLm9yaWdpbi54LFxuICAgICAgICAgICAgICAgIGV4dGVudCA9IHNlbGVjdGlvbi5leHRlbnQueDtcbiAgICAgICAgICAgIGxlZnQgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgc20uc2VsZWN0KGxlZnQsIGxlZnQgKyBleHRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBpc0luQ3VycmVudFNlbGVjdGlvblJlY3RhbmdsZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgbGFzdCA9IHRoaXMuc2VsZWN0aW9uc1t0aGlzLnNlbGVjdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiBsYXN0ICYmIHRoaXMucmVjdGFuZ2xlQ29udGFpbnMobGFzdCwgeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gcmVjdFxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICByZWN0YW5nbGVDb250YWluczogZnVuY3Rpb24ocmVjdCwgeCwgeSkgeyAvL1RPRE86IGV4cGxvcmUgd2h5IHRoaXMgd29ya3MgYW5kIGNvbnRhaW5zIG9uIHJlY3RhbmdsdWxhciBkb2VzIG5vdFxuICAgICAgICB2YXIgbWluWCA9IHJlY3Qub3JpZ2luLng7XG4gICAgICAgIHZhciBtaW5ZID0gcmVjdC5vcmlnaW4ueTtcbiAgICAgICAgdmFyIG1heFggPSBtaW5YICsgcmVjdC5leHRlbnQueDtcbiAgICAgICAgdmFyIG1heFkgPSBtaW5ZICsgcmVjdC5leHRlbnQueTtcblxuICAgICAgICBpZiAocmVjdC5leHRlbnQueCA8IDApIHtcbiAgICAgICAgICAgIG1pblggPSBtYXhYO1xuICAgICAgICAgICAgbWF4WCA9IHJlY3Qub3JpZ2luLng7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjdC5leHRlbnQueSA8IDApIHtcbiAgICAgICAgICAgIG1pblkgPSBtYXhZO1xuICAgICAgICAgICAgbWF4WSA9IHJlY3Qub3JpZ2luLnk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID1cbiAgICAgICAgICAgIHggPj0gbWluWCAmJlxuICAgICAgICAgICAgeSA+PSBtaW5ZICYmXG4gICAgICAgICAgICB4IDw9IG1heFggJiZcbiAgICAgICAgICAgIHkgPD0gbWF4WTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0aW9uTW9kZWw7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbY29udGFpbmluZ0VsPWRvY3VtZW50XVxuICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXg9JyddXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NlcGFyYXRvcj0nJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3VmZml4PScnXVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3RyYW5zZm9ybWVyPW11bHRpTGluZVRyaW1dIC0gRnVuY3Rpb24gdG8gdHJhbnNmb3JtIGVhY2ggaW5wdXQgY29udHJvbCdzIHRleHQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBbGwoY29udGFpbmluZ0VsLCBwcmVmaXgsIHNlcGFyYXRvciwgc3VmZml4LCB0cmFuc2Zvcm1lcikge1xuICAgIHZhciB0ZXh0cyA9IFtdLCBsYXN0VGV4dEVsLCB0ZXh0O1xuXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbCgoY29udGFpbmluZ0VsIHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKGNvcHlBbGwuc2VsZWN0b3IpLCBmdW5jdGlvbih0ZXh0RWwpIHtcbiAgICAgICAgdGV4dCA9ICh0cmFuc2Zvcm1lciB8fCBtdWx0aUxpbmVUcmltKSh0ZXh0RWwudmFsdWUpO1xuICAgICAgICBpZiAodGV4dCkgeyB0ZXh0cy5wdXNoKHRleHQpOyB9XG4gICAgICAgIGxhc3RUZXh0RWwgPSB0ZXh0RWw7XG4gICAgfSk7XG5cbiAgICBpZiAobGFzdFRleHRFbCkge1xuICAgICAgICBjb3B5KGxhc3RUZXh0RWwsIChwcmVmaXggfHwgJycpICsgdGV4dHMuam9pbihzZXBhcmF0b3IgfHwgJycpICsgKHN1ZmZpeCB8fCAnJykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiAxLiBUcmltIHRoZSB0ZXh0IGluIHRoZSBnaXZlbiBpbnB1dCBlbGVtZW50XG4gKiAyLiBzZWxlY3QgaXRcbiAqIDMuIGNvcHkgaXQgdG8gdGhlIGNsaXBib2FyZFxuICogNC4gZGVzZWxlY3QgaXRcbiAqIDUuIHJldHVybiBpdFxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MVGV4dEFyZWFFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0PWVsLnZhbHVlXSAtIFRleHQgdG8gY29weS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8c3RyaW5nfSBUcmltbWVkIHRleHQgaW4gZWxlbWVudCBvciB1bmRlZmluZWQgaWYgdW5hYmxlIHRvIGNvcHkuXG4gKi9cbmZ1bmN0aW9uIGNvcHkoZWwsIHRleHQpIHtcbiAgICB2YXIgcmVzdWx0LCB0ZXh0V2FzO1xuXG4gICAgaWYgKHRleHQpIHtcbiAgICAgICAgdGV4dFdhcyA9IGVsLnZhbHVlO1xuICAgICAgICBlbC52YWx1ZSA9IHRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGVsLnZhbHVlO1xuICAgIH1cblxuICAgIGVsLnZhbHVlID0gbXVsdGlMaW5lVHJpbSh0ZXh0KTtcblxuICAgIHRyeSB7XG4gICAgICAgIGVsLnNlbGVjdCgpO1xuICAgICAgICByZXN1bHQgPSBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodGV4dFdhcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbC52YWx1ZSA9IHRleHRXYXM7XG4gICAgICAgIH1cbiAgICAgICAgZWwuYmx1cigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtdWx0aUxpbmVUcmltKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9eXFxzKiguKj8pXFxzKiQvLCAnJDEnKTtcbn1cblxuY29weS5hbGwgPSBjb3B5QWxsO1xuY29weS5tdWx0aUxpbmVUcmltID0gbXVsdGlMaW5lVHJpbTtcbmNvcHkuc2VsZWN0b3JUZXh0Q29udHJvbHMgPSAnaW5wdXQ6bm90KFt0eXBlXSksIGlucHV0W3R5cGU9dGV4dF0sIHRleHRhcmVhJztcblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBjb25zb2xlLndhcm4gcG9seWZpbGwgYXMgbmVlZGVkXG4vLyB1c2VkIGZvciBkZXByZWNhdGlvbiB3YXJuaW5nc1xuaWYgKCFjb25zb2xlLndhcm4pIHtcbiAgICBjb25zb2xlLndhcm4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgWydXQVJOSU5HOiddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcbn1cblxudmFyIHdhcm5lZCA9IHt9O1xuXG52YXIgcmVnZXhJc01ldGhvZCA9IC9cXCkkLztcblxuLyoqXG4gKiBVc2VyIGlzIHdhcm5lZCBhbmQgbmV3IHByb3BlcnR5IGlzIHJldHVybmVkIG9yIG5ldyBtZXRob2QgaXMgY2FsbGVkIGFuZCB0aGUgcmVzdWx0IGlzIHJldHVybmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgLSBEZXByZWNhdGVkIG1ldGhvZCBuYW1lIHdpdGggcGFyZW50aGVzZXMgKHJlcXVpcmVkKSBjb250YWluaW5nIGFyZ3VtZW50IGxpc3QgKG9wdGlvbmFsKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkb3RQcm9wcyAtIERvdC1zZXBhcmF0ZWQgbmV3IHByb3BlcnR5IG5hbWUgdG8gaW52b2tlIG9yIG1ldGhvZCBuYW1lIHRvIGNhbGwuIE1ldGhvZCBuYW1lcyBhcmUgaW5kaWNhdGVkIGJ5IGluY2x1ZGluZyBwYXJlbnRoZXNlcyB3aXRoIG9wdGlvbmFsIGFyZ3VtZW50IGxpc3QuIFRoZSBhcmd1bWVudHMgaW4gZWFjaCBsaXN0IGFyZSBkcmF3biBmcm9tIHRoZSBhcmd1bWVudHMgcHJlc2VudGVkIGluIHRoZSBgbWV0aG9kTmFtZWAgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHNpbmNlIC0gVmVyc2lvbiBpbiB3aGljaCB0aGUgbmFtZSB3YXMgZGVwcmVjYXRlZC5cbiAqIEBwYXJhbSB7QXJndW1lbnRzfEFycmF5fSBbYXJnc10gLSBBY3R1YWwgYXJndW1lbnRzLiBPbmx5IG5lZWRlZCB3aGVuIGFyZ3VtZW50cyBhcmUgbGlzdGVkIGluIGBtZXRob2ROYW1lYC4gVGhlIG9yZGVyIG9mIHRoZSBhcmd1bWVudHMgbXVzdCBtYXRjaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbm90ZXNdIC0gTm90ZXMgdG8gYWRkIHRvIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJuIHZhbHVlIG9mIG5ldyBwcm9wZXJ0eSBvciBtZXRob2QgY2FsbC5cbiAqL1xudmFyIGRlcHJlY2F0ZWQgPSBmdW5jdGlvbihtZXRob2ROYW1lLCBkb3RQcm9wcywgc2luY2UsIGFyZ3MsIG5vdGVzKSB7XG4gICAgaWYgKCFyZWdleElzTWV0aG9kLnRlc3QobWV0aG9kTmFtZSkpIHtcbiAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIG1ldGhvZCBuYW1lIHRvIGhhdmUgcGFyZW50aGVzZXMuJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGBhcmdzYCBvbWl0dGVkXG4gICAgICAgIG5vdGVzID0gYXJncztcbiAgICAgICAgYXJncyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgY2hhaW4gPSBkb3RQcm9wcy5zcGxpdCgnLicpLFxuICAgICAgICBmb3JtYWxBcmdMaXN0ID0gYXJnTGlzdChtZXRob2ROYW1lKSxcbiAgICAgICAgcmVzdWx0ID0gdGhpcztcblxuICAgIGlmICghKG1ldGhvZE5hbWUgaW4gd2FybmVkKSkge1xuICAgICAgICB3YXJuZWRbbWV0aG9kTmFtZV0gPSBkZXByZWNhdGVkLndhcm5pbmdzO1xuICAgIH1cbiAgICBpZiAod2FybmVkW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIHZhciBtZW1iZXJUeXBlID0gcmVnZXhJc01ldGhvZC50ZXN0KGRvdFByb3BzKSA/ICdtZXRob2QnIDogJ3Byb3BlcnR5JztcbiAgICAgICAgdmFyIHdhcm5pbmcgPSAnVGhlIC4nICsgbWV0aG9kTmFtZSArICcoKSBtZXRob2QgaXMgZGVwcmVjYXRlZCBhcyBvZiB2JyArIHNpbmNlICtcbiAgICAgICAgICAgICcgaW4gZmF2b3Igb2YgdGhlIC4nICsgY2hhaW4uam9pbignLicpICsgJyAnICsgbWVtYmVyVHlwZSArICcuJyArXG4gICAgICAgICAgICAnIChXaWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4pJztcblxuICAgICAgICBpZiAobm90ZXMpIHtcbiAgICAgICAgICAgIHdhcm5pbmcgKz0gJyAnICsgbm90ZXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG5cbiAgICAgICAgLS13YXJuZWRbbWV0aG9kTmFtZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwVG9Gb3JtYWxBcmcoYXJnTmFtZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBmb3JtYWxBcmdMaXN0LmluZGV4T2YoYXJnTmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93ICdBY3R1YWwgYXJnIFwiJyArIGFyZ05hbWUgKyAnXCIgbm90IGZvdW5kIGluIGZvcm1hbCBhcmcgbGlzdCAnICsgZm9ybWFsQXJnTGlzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1tpbmRleF07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxhc3QgPSBjaGFpbi5sZW5ndGggLSAxOyBpIDw9IGxhc3Q7ICsraSkge1xuICAgICAgICB2YXIgbGluayA9IGNoYWluW2ldLFxuICAgICAgICAgICAgYWN0dWFsQXJnTGlzdCA9IHJlZ2V4SXNNZXRob2QudGVzdChsaW5rKSA/IGFyZ0xpc3QobGluaykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhY3R1YWxBcmdzID0gW107XG5cbiAgICAgICAgaWYgKGFjdHVhbEFyZ0xpc3QpIHtcbiAgICAgICAgICAgIGFjdHVhbEFyZ3MgPSBhY3R1YWxBcmdMaXN0Lm1hcChtYXBUb0Zvcm1hbEFyZyk7XG4gICAgICAgICAgICBsaW5rID0gbGluay5tYXRjaCgvKFxcdyspLylbMV07XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRbbGlua10uYXBwbHkocmVzdWx0LCBhY3R1YWxBcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFtsaW5rXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5kZXByZWNhdGVkLndhcm5pbmdzID0gNTsgLy8ganVzdCBlbm91Z2ggdG8gYmUgYW5ub3lpbmdcblxuZnVuY3Rpb24gYXJnTGlzdChzKSB7XG4gICAgcmV0dXJuIHMubWF0Y2goL15cXHcrXFwoKC4qKVxcKSQvKVsxXS5tYXRjaCgvKFxcdyspL2cpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZWQ7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqIEBtb2R1bGUgZWZmZWN0cyAqL1xuXG4vKiogQHR5cGVkZWYge2Z1bmN0aW9ufSBlZmZlY3RGdW5jdGlvblxuICogQGRlc2MgRWxlbWVudCB0byBwZXJmb3JtIHRyYW5zaXRpb25zIHVwb24gaXMgYG9wdGlvbnMuZWxgIGlmIGRlZmluZWQgb3IgYHRoaXMuZWxgLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW29wdGlvbnMuZWw9dGhpcy5lbF1cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXSBGdW5jdGlvbiB0byBjYWxsIGF0IGNvbmNsdXNpb24gb2YgdHJhbnNpdGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZHVyYXRpb249JzAuMDY1cyddIC0gRHVyYXRpb24gb2YgZWFjaCB0cmFuc2l0aW9uLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnN0eWxlcz1kZWZhdWx0R2xvd2VyU3R5bGVzXSAtIEhhc2ggb2YgQ1NTIHN0eWxlcyBhbmQgdmFsdWVzIHRvIHRyYW5zaXRpb24uIChGb3Ige0BsaW5rIGVmZmVjdHN+Z2xvd2VyfGdsb3dlcn0gb25seS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2hha2UgZWxlbWVudCBiYWNrIGFuZCBmb3VydGggYSBmZXcgdGltZXMgYXMgaWYgdG8gc2F5LCBcIk5vcGUhXCJcbiAqIEB0eXBlIHtlZmZlY3RGdW5jdGlvbn1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6ZWZmZWN0c1xuICovXG5leHBvcnRzLnNoYWtlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMsXG4gICAgICAgIGVsID0gb3B0aW9ucy5lbCB8fCBjb250ZXh0LmVsLFxuICAgICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgJzAuMDY1cycsXG4gICAgICAgIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCksXG4gICAgICAgIHRyYW5zaXRpb25zID0gY29tcHV0ZWRTdHlsZS50cmFuc2l0aW9uLnNwbGl0KCcsJyksXG4gICAgICAgIHBvc2l0aW9uID0gY29tcHV0ZWRTdHlsZS5wb3NpdGlvbixcbiAgICAgICAgeCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUubGVmdCksXG4gICAgICAgIGR4ID0gLTMsXG4gICAgICAgIHNoYWtlcyA9IDY7XG5cbiAgICB0cmFuc2l0aW9ucy5wdXNoKCdsZWZ0ICcgKyBkdXJhdGlvbik7XG4gICAgZWwuc3R5bGUudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25zLmpvaW4oJywnKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc2hha2VyKTtcbiAgICBzaGFrZXIoKTtcbiAgICBmdW5jdGlvbiBzaGFrZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudCB8fCBldmVudC5wcm9wZXJ0eU5hbWUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgZWwuc3R5bGUubGVmdCA9IHggKyBkeCArICdweCc7XG4gICAgICAgICAgICBpZiAoIXNoYWtlcy0tKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHNoYWtlcik7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25zLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2suY2FsbChjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkeCA9IHNoYWtlcyA/IC1keCA6IDA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZGVmYXVsdEdsb3dlclN0eWxlcyA9IHtcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6ICd5ZWxsb3cnLFxuICAgICdib3gtc2hhZG93JzogJzAgMCAxMHB4IHJlZCdcbn07XG5cbi8qKlxuICogVHJhbnNpdGlvbiBzdHlsZXMgb24gZWxlbWVudCBmb3IgYSBtb21lbnQgYW5kIHJldmVydCBhcyBpZiB0byBzYXksIFwiV2hvYSEuXCJcbiAqIEB0eXBlIHtlZmZlY3RGdW5jdGlvbn1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6ZWZmZWN0c1xuICovXG5leHBvcnRzLmdsb3dlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMsXG4gICAgICAgIGVsID0gb3B0aW9ucy5lbCB8fCBjb250ZXh0LmVsLFxuICAgICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgJzAuMjVzJyxcbiAgICAgICAgc3R5bGVzID0gb3B0aW9ucy5zdHlsZXMgfHwgZGVmYXVsdEdsb3dlclN0eWxlcyxcbiAgICAgICAgdmFsdWVzID0gc3R5bGVzLmxlbmd0aCxcbiAgICAgICAgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKSxcbiAgICAgICAgc3R5bGVXYXMgPSB7fSxcbiAgICAgICAgdHJhbnNpdGlvbiA9IGNvbXB1dGVkU3R5bGUudHJhbnNpdGlvbixcbiAgICAgICAgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uLnNwbGl0KCcsJyk7XG5cbiAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgc3R5bGVXYXNbc3R5bGVdID0ge1xuICAgICAgICAgICAgc3R5bGU6IGNvbXB1dGVkU3R5bGVbc3R5bGVdLFxuICAgICAgICAgICAgdW5kbzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB0cmFuc2l0aW9ucy5wdXNoKHN0eWxlICsgJyAnICsgZHVyYXRpb24pO1xuICAgIH0pO1xuXG4gICAgZWwuc3R5bGUudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25zLmpvaW4oJywnKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZ2xvd2VyKTtcbiAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgZWwuc3R5bGVbc3R5bGVdID0gc3R5bGVzW3N0eWxlXTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGdsb3dlcihldmVudCkge1xuICAgICAgICB2YXIgd2FzID0gc3R5bGVXYXNbZXZlbnQucHJvcGVydHlOYW1lXTtcbiAgICAgICAgaWYgKHdhcy51bmRvKSB7XG4gICAgICAgICAgICBlbC5zdHlsZVtldmVudC5wcm9wZXJ0eU5hbWVdID0gd2FzLnN0eWxlO1xuICAgICAgICAgICAgd2FzLnVuZG8gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghLS12YWx1ZXMpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBnbG93ZXIpO1xuICAgICAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2suY2FsbChjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cy5lYWNoID0gZnVuY3Rpb24oc2VsZWN0b3IsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoKGNvbnRleHQgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLCBpdGVyYXRlZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5maW5kID0gZnVuY3Rpb24oc2VsZWN0b3IsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwoKGNvbnRleHQgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLCBpdGVyYXRlZSk7XG59O1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEhUVFBfU1RBVEVfRE9ORSA9IDQsXG4gICAgSFRUUF9TVEFUVVNfT0sgPSAyMDA7XG5cbm1vZHVsZS5leHBvcnRzLmdldCA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaHR0cFJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIGh0dHBSZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG5cbiAgICBodHRwUmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaHR0cFJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gSFRUUF9TVEFURV9ET05FICYmXG4gICAgICAgICAgICBodHRwUmVxdWVzdC5zdGF0dXMgPT09IEhUVFBfU1RBVFVTX09LXG4gICAgICAgICkge1xuICAgICAgICAgICAgY2FsbGJhY2soSlNPTi5wYXJzZShodHRwUmVxdWVzdC5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBodHRwUmVxdWVzdC5zZW5kKG51bGwpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuTWF0aC5zaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uKHgpIHtcbiAgICB4ID0gK3g7IC8vIGNvbnZlcnQgdG8gYSBudW1iZXJcbiAgICBpZiAoeCA9PT0gMCB8fCBpc05hTih4KSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgcmV0dXJuIHggPiAwID8gMSA6IC0xO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gUXVldWVsZXNzKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG59XG5cblF1ZXVlbGVzcy5wcm90b3R5cGUuYmVnaW4gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IHRydWU7XG5cbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uIGVuZCh0cmFuc0V2ZW50KSB7XG4gICAgICAgIHNlbGYuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZW5kKTtcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdHJhbnNFdmVudCwgc2VsZik7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUXVldWVsZXNzO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGF1dG9tYXQgPSByZXF1aXJlKCdhdXRvbWF0Jyk7XG5cbnZhciBjc3MgPSByZXF1aXJlKCcuLi8uLi9jc3MnKTtcblxuLy8gbm90ZSB0aGUgcG9zaXRpb24gb2YgdGhlICBmaXJzdCBcIm5hdHVyYWxcIiBzdHlsZXNoZWV0LiBXZSB3aWxsIGluc2VydCBvdXIgc3R5bGVzaGVldHMgYmVmb3JlIHRoaXMgbm9kZS5cbnZhciBoZWFkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpO1xudmFyIHJlZk5vZGUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChoZWFkLmNoaWxkcmVuKS5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkLnRhZ05hbWUgPT09ICdTVFlMRScgfHxcbiAgICAgICAgY2hpbGQudGFnTmFtZSA9PT0gJ0xJTksnICYmXG4gICAgICAgIGNoaWxkLmdldEF0dHJpYnV0ZSgncmVsJykgPT09ICdzdHlsZXNoZWV0JyAmJlxuICAgICAgICBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ3RleHQvY3NzJztcbn0pO1xuXG5leHBvcnRzLnByZWZpeCA9ICdpbmplY3RlZC1zdHlsZXNoZWV0LSc7XG5cbmV4cG9ydHMuaW5qZWN0ID0gZnVuY3Rpb24oaWQsIHJlcGxhY2VtZW50cykge1xuICAgIHZhciBzdHlsZXNoZWV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycgKyB0aGlzLnByZWZpeCArIGlkKTtcblxuICAgIGlmICghc3R5bGVzaGVldCkge1xuICAgICAgICBzdHlsZXNoZWV0ID0gY3NzW2lkXTtcbiAgICAgICAgc3R5bGVzaGVldCA9ICc8c3R5bGU+XFxuJyArIHN0eWxlc2hlZXQgKyAnXFxuPC9zdHlsZT5cXG4nO1xuICAgICAgICB2YXIgYXJncyA9IFtzdHlsZXNoZWV0LCBoZWFkLCByZWZOb2RlXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIHN0eWxlc2hlZXQgPSBhdXRvbWF0LmFwcGVuZC5hcHBseShudWxsLCBhcmdzKVswXTtcbiAgICAgICAgc3R5bGVzaGVldC5pZCA9IHRoaXMucHJlZml4ICsgaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlc2hlZXQ7XG59O1xuIl19
